import {
  require_jsx_runtime
} from "./chunk-JSFYXNFF.js";
import {
  require_react
} from "./chunk-GOVGMW3W.js";
import {
  __commonJS
} from "./chunk-LNEMQRCO.js";

// node_modules/rxjs/dist/cjs/internal/util/isFunction.js
var require_isFunction = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/isFunction.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isFunction = void 0;
    function isFunction(value) {
      return typeof value === "function";
    }
    exports.isFunction = isFunction;
  }
});

// node_modules/rxjs/dist/cjs/internal/util/createErrorClass.js
var require_createErrorClass = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/createErrorClass.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createErrorClass = void 0;
    function createErrorClass(createImpl) {
      var _super = function(instance) {
        Error.call(instance);
        instance.stack = new Error().stack;
      };
      var ctorFunc = createImpl(_super);
      ctorFunc.prototype = Object.create(Error.prototype);
      ctorFunc.prototype.constructor = ctorFunc;
      return ctorFunc;
    }
    exports.createErrorClass = createErrorClass;
  }
});

// node_modules/rxjs/dist/cjs/internal/util/UnsubscriptionError.js
var require_UnsubscriptionError = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/UnsubscriptionError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UnsubscriptionError = void 0;
    var createErrorClass_1 = require_createErrorClass();
    exports.UnsubscriptionError = createErrorClass_1.createErrorClass(function(_super) {
      return function UnsubscriptionErrorImpl(errors) {
        _super(this);
        this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function(err, i) {
          return i + 1 + ") " + err.toString();
        }).join("\n  ") : "";
        this.name = "UnsubscriptionError";
        this.errors = errors;
      };
    });
  }
});

// node_modules/rxjs/dist/cjs/internal/util/arrRemove.js
var require_arrRemove = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/arrRemove.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.arrRemove = void 0;
    function arrRemove(arr, item) {
      if (arr) {
        var index = arr.indexOf(item);
        0 <= index && arr.splice(index, 1);
      }
    }
    exports.arrRemove = arrRemove;
  }
});

// node_modules/rxjs/dist/cjs/internal/Subscription.js
var require_Subscription = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/Subscription.js"(exports) {
    "use strict";
    var __values = exports && exports.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = void 0;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    var __read = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray2 = exports && exports.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isSubscription = exports.EMPTY_SUBSCRIPTION = exports.Subscription = void 0;
    var isFunction_1 = require_isFunction();
    var UnsubscriptionError_1 = require_UnsubscriptionError();
    var arrRemove_1 = require_arrRemove();
    var Subscription = function() {
      function Subscription2(initialTeardown) {
        this.initialTeardown = initialTeardown;
        this.closed = false;
        this._parentage = null;
        this._finalizers = null;
      }
      Subscription2.prototype.unsubscribe = function() {
        var e_1, _a, e_2, _b;
        var errors;
        if (!this.closed) {
          this.closed = true;
          var _parentage = this._parentage;
          if (_parentage) {
            this._parentage = null;
            if (Array.isArray(_parentage)) {
              try {
                for (var _parentage_1 = __values(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {
                  var parent_1 = _parentage_1_1.value;
                  parent_1.remove(this);
                }
              } catch (e_1_1) {
                e_1 = { error: e_1_1 };
              } finally {
                try {
                  if (_parentage_1_1 && !_parentage_1_1.done && (_a = _parentage_1.return))
                    _a.call(_parentage_1);
                } finally {
                  if (e_1)
                    throw e_1.error;
                }
              }
            } else {
              _parentage.remove(this);
            }
          }
          var initialFinalizer = this.initialTeardown;
          if (isFunction_1.isFunction(initialFinalizer)) {
            try {
              initialFinalizer();
            } catch (e) {
              errors = e instanceof UnsubscriptionError_1.UnsubscriptionError ? e.errors : [e];
            }
          }
          var _finalizers = this._finalizers;
          if (_finalizers) {
            this._finalizers = null;
            try {
              for (var _finalizers_1 = __values(_finalizers), _finalizers_1_1 = _finalizers_1.next(); !_finalizers_1_1.done; _finalizers_1_1 = _finalizers_1.next()) {
                var finalizer = _finalizers_1_1.value;
                try {
                  execFinalizer(finalizer);
                } catch (err) {
                  errors = errors !== null && errors !== void 0 ? errors : [];
                  if (err instanceof UnsubscriptionError_1.UnsubscriptionError) {
                    errors = __spreadArray2(__spreadArray2([], __read(errors)), __read(err.errors));
                  } else {
                    errors.push(err);
                  }
                }
              }
            } catch (e_2_1) {
              e_2 = { error: e_2_1 };
            } finally {
              try {
                if (_finalizers_1_1 && !_finalizers_1_1.done && (_b = _finalizers_1.return))
                  _b.call(_finalizers_1);
              } finally {
                if (e_2)
                  throw e_2.error;
              }
            }
          }
          if (errors) {
            throw new UnsubscriptionError_1.UnsubscriptionError(errors);
          }
        }
      };
      Subscription2.prototype.add = function(teardown) {
        var _a;
        if (teardown && teardown !== this) {
          if (this.closed) {
            execFinalizer(teardown);
          } else {
            if (teardown instanceof Subscription2) {
              if (teardown.closed || teardown._hasParent(this)) {
                return;
              }
              teardown._addParent(this);
            }
            (this._finalizers = (_a = this._finalizers) !== null && _a !== void 0 ? _a : []).push(teardown);
          }
        }
      };
      Subscription2.prototype._hasParent = function(parent) {
        var _parentage = this._parentage;
        return _parentage === parent || Array.isArray(_parentage) && _parentage.includes(parent);
      };
      Subscription2.prototype._addParent = function(parent) {
        var _parentage = this._parentage;
        this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
      };
      Subscription2.prototype._removeParent = function(parent) {
        var _parentage = this._parentage;
        if (_parentage === parent) {
          this._parentage = null;
        } else if (Array.isArray(_parentage)) {
          arrRemove_1.arrRemove(_parentage, parent);
        }
      };
      Subscription2.prototype.remove = function(teardown) {
        var _finalizers = this._finalizers;
        _finalizers && arrRemove_1.arrRemove(_finalizers, teardown);
        if (teardown instanceof Subscription2) {
          teardown._removeParent(this);
        }
      };
      Subscription2.EMPTY = function() {
        var empty = new Subscription2();
        empty.closed = true;
        return empty;
      }();
      return Subscription2;
    }();
    exports.Subscription = Subscription;
    exports.EMPTY_SUBSCRIPTION = Subscription.EMPTY;
    function isSubscription(value) {
      return value instanceof Subscription || value && "closed" in value && isFunction_1.isFunction(value.remove) && isFunction_1.isFunction(value.add) && isFunction_1.isFunction(value.unsubscribe);
    }
    exports.isSubscription = isSubscription;
    function execFinalizer(finalizer) {
      if (isFunction_1.isFunction(finalizer)) {
        finalizer();
      } else {
        finalizer.unsubscribe();
      }
    }
  }
});

// node_modules/rxjs/dist/cjs/internal/config.js
var require_config = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/config.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.config = void 0;
    exports.config = {
      onUnhandledError: null,
      onStoppedNotification: null,
      Promise: void 0,
      useDeprecatedSynchronousErrorHandling: false,
      useDeprecatedNextContext: false
    };
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/timeoutProvider.js
var require_timeoutProvider = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/timeoutProvider.js"(exports) {
    "use strict";
    var __read = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray2 = exports && exports.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.timeoutProvider = void 0;
    exports.timeoutProvider = {
      setTimeout: function(handler, timeout) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
          args[_i - 2] = arguments[_i];
        }
        var delegate = exports.timeoutProvider.delegate;
        if (delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) {
          return delegate.setTimeout.apply(delegate, __spreadArray2([handler, timeout], __read(args)));
        }
        return setTimeout.apply(void 0, __spreadArray2([handler, timeout], __read(args)));
      },
      clearTimeout: function(handle) {
        var delegate = exports.timeoutProvider.delegate;
        return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);
      },
      delegate: void 0
    };
  }
});

// node_modules/rxjs/dist/cjs/internal/util/reportUnhandledError.js
var require_reportUnhandledError = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/reportUnhandledError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.reportUnhandledError = void 0;
    var config_1 = require_config();
    var timeoutProvider_1 = require_timeoutProvider();
    function reportUnhandledError(err) {
      timeoutProvider_1.timeoutProvider.setTimeout(function() {
        var onUnhandledError = config_1.config.onUnhandledError;
        if (onUnhandledError) {
          onUnhandledError(err);
        } else {
          throw err;
        }
      });
    }
    exports.reportUnhandledError = reportUnhandledError;
  }
});

// node_modules/rxjs/dist/cjs/internal/util/noop.js
var require_noop = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/noop.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.noop = void 0;
    function noop() {
    }
    exports.noop = noop;
  }
});

// node_modules/rxjs/dist/cjs/internal/NotificationFactories.js
var require_NotificationFactories = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/NotificationFactories.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createNotification = exports.nextNotification = exports.errorNotification = exports.COMPLETE_NOTIFICATION = void 0;
    exports.COMPLETE_NOTIFICATION = function() {
      return createNotification("C", void 0, void 0);
    }();
    function errorNotification(error) {
      return createNotification("E", void 0, error);
    }
    exports.errorNotification = errorNotification;
    function nextNotification(value) {
      return createNotification("N", value, void 0);
    }
    exports.nextNotification = nextNotification;
    function createNotification(kind, value, error) {
      return {
        kind,
        value,
        error
      };
    }
    exports.createNotification = createNotification;
  }
});

// node_modules/rxjs/dist/cjs/internal/util/errorContext.js
var require_errorContext = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/errorContext.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.captureError = exports.errorContext = void 0;
    var config_1 = require_config();
    var context = null;
    function errorContext(cb) {
      if (config_1.config.useDeprecatedSynchronousErrorHandling) {
        var isRoot = !context;
        if (isRoot) {
          context = { errorThrown: false, error: null };
        }
        cb();
        if (isRoot) {
          var _a = context, errorThrown = _a.errorThrown, error = _a.error;
          context = null;
          if (errorThrown) {
            throw error;
          }
        }
      } else {
        cb();
      }
    }
    exports.errorContext = errorContext;
    function captureError(err) {
      if (config_1.config.useDeprecatedSynchronousErrorHandling && context) {
        context.errorThrown = true;
        context.error = err;
      }
    }
    exports.captureError = captureError;
  }
});

// node_modules/rxjs/dist/cjs/internal/Subscriber.js
var require_Subscriber = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/Subscriber.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EMPTY_OBSERVER = exports.SafeSubscriber = exports.Subscriber = void 0;
    var isFunction_1 = require_isFunction();
    var Subscription_1 = require_Subscription();
    var config_1 = require_config();
    var reportUnhandledError_1 = require_reportUnhandledError();
    var noop_1 = require_noop();
    var NotificationFactories_1 = require_NotificationFactories();
    var timeoutProvider_1 = require_timeoutProvider();
    var errorContext_1 = require_errorContext();
    var Subscriber = function(_super) {
      __extends(Subscriber2, _super);
      function Subscriber2(destination) {
        var _this = _super.call(this) || this;
        _this.isStopped = false;
        if (destination) {
          _this.destination = destination;
          if (Subscription_1.isSubscription(destination)) {
            destination.add(_this);
          }
        } else {
          _this.destination = exports.EMPTY_OBSERVER;
        }
        return _this;
      }
      Subscriber2.create = function(next, error, complete) {
        return new SafeSubscriber(next, error, complete);
      };
      Subscriber2.prototype.next = function(value) {
        if (this.isStopped) {
          handleStoppedNotification(NotificationFactories_1.nextNotification(value), this);
        } else {
          this._next(value);
        }
      };
      Subscriber2.prototype.error = function(err) {
        if (this.isStopped) {
          handleStoppedNotification(NotificationFactories_1.errorNotification(err), this);
        } else {
          this.isStopped = true;
          this._error(err);
        }
      };
      Subscriber2.prototype.complete = function() {
        if (this.isStopped) {
          handleStoppedNotification(NotificationFactories_1.COMPLETE_NOTIFICATION, this);
        } else {
          this.isStopped = true;
          this._complete();
        }
      };
      Subscriber2.prototype.unsubscribe = function() {
        if (!this.closed) {
          this.isStopped = true;
          _super.prototype.unsubscribe.call(this);
          this.destination = null;
        }
      };
      Subscriber2.prototype._next = function(value) {
        this.destination.next(value);
      };
      Subscriber2.prototype._error = function(err) {
        try {
          this.destination.error(err);
        } finally {
          this.unsubscribe();
        }
      };
      Subscriber2.prototype._complete = function() {
        try {
          this.destination.complete();
        } finally {
          this.unsubscribe();
        }
      };
      return Subscriber2;
    }(Subscription_1.Subscription);
    exports.Subscriber = Subscriber;
    var _bind = Function.prototype.bind;
    function bind(fn, thisArg) {
      return _bind.call(fn, thisArg);
    }
    var ConsumerObserver = function() {
      function ConsumerObserver2(partialObserver) {
        this.partialObserver = partialObserver;
      }
      ConsumerObserver2.prototype.next = function(value) {
        var partialObserver = this.partialObserver;
        if (partialObserver.next) {
          try {
            partialObserver.next(value);
          } catch (error) {
            handleUnhandledError(error);
          }
        }
      };
      ConsumerObserver2.prototype.error = function(err) {
        var partialObserver = this.partialObserver;
        if (partialObserver.error) {
          try {
            partialObserver.error(err);
          } catch (error) {
            handleUnhandledError(error);
          }
        } else {
          handleUnhandledError(err);
        }
      };
      ConsumerObserver2.prototype.complete = function() {
        var partialObserver = this.partialObserver;
        if (partialObserver.complete) {
          try {
            partialObserver.complete();
          } catch (error) {
            handleUnhandledError(error);
          }
        }
      };
      return ConsumerObserver2;
    }();
    var SafeSubscriber = function(_super) {
      __extends(SafeSubscriber2, _super);
      function SafeSubscriber2(observerOrNext, error, complete) {
        var _this = _super.call(this) || this;
        var partialObserver;
        if (isFunction_1.isFunction(observerOrNext) || !observerOrNext) {
          partialObserver = {
            next: observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : void 0,
            error: error !== null && error !== void 0 ? error : void 0,
            complete: complete !== null && complete !== void 0 ? complete : void 0
          };
        } else {
          var context_1;
          if (_this && config_1.config.useDeprecatedNextContext) {
            context_1 = Object.create(observerOrNext);
            context_1.unsubscribe = function() {
              return _this.unsubscribe();
            };
            partialObserver = {
              next: observerOrNext.next && bind(observerOrNext.next, context_1),
              error: observerOrNext.error && bind(observerOrNext.error, context_1),
              complete: observerOrNext.complete && bind(observerOrNext.complete, context_1)
            };
          } else {
            partialObserver = observerOrNext;
          }
        }
        _this.destination = new ConsumerObserver(partialObserver);
        return _this;
      }
      return SafeSubscriber2;
    }(Subscriber);
    exports.SafeSubscriber = SafeSubscriber;
    function handleUnhandledError(error) {
      if (config_1.config.useDeprecatedSynchronousErrorHandling) {
        errorContext_1.captureError(error);
      } else {
        reportUnhandledError_1.reportUnhandledError(error);
      }
    }
    function defaultErrorHandler(err) {
      throw err;
    }
    function handleStoppedNotification(notification, subscriber) {
      var onStoppedNotification = config_1.config.onStoppedNotification;
      onStoppedNotification && timeoutProvider_1.timeoutProvider.setTimeout(function() {
        return onStoppedNotification(notification, subscriber);
      });
    }
    exports.EMPTY_OBSERVER = {
      closed: true,
      next: noop_1.noop,
      error: defaultErrorHandler,
      complete: noop_1.noop
    };
  }
});

// node_modules/rxjs/dist/cjs/internal/symbol/observable.js
var require_observable = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/symbol/observable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.observable = void 0;
    exports.observable = function() {
      return typeof Symbol === "function" && Symbol.observable || "@@observable";
    }();
  }
});

// node_modules/rxjs/dist/cjs/internal/util/identity.js
var require_identity = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/identity.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.identity = void 0;
    function identity(x) {
      return x;
    }
    exports.identity = identity;
  }
});

// node_modules/rxjs/dist/cjs/internal/util/pipe.js
var require_pipe = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/pipe.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.pipeFromArray = exports.pipe = void 0;
    var identity_1 = require_identity();
    function pipe() {
      var fns = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        fns[_i] = arguments[_i];
      }
      return pipeFromArray(fns);
    }
    exports.pipe = pipe;
    function pipeFromArray(fns) {
      if (fns.length === 0) {
        return identity_1.identity;
      }
      if (fns.length === 1) {
        return fns[0];
      }
      return function piped(input) {
        return fns.reduce(function(prev, fn) {
          return fn(prev);
        }, input);
      };
    }
    exports.pipeFromArray = pipeFromArray;
  }
});

// node_modules/rxjs/dist/cjs/internal/Observable.js
var require_Observable = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/Observable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Observable = void 0;
    var Subscriber_1 = require_Subscriber();
    var Subscription_1 = require_Subscription();
    var observable_1 = require_observable();
    var pipe_1 = require_pipe();
    var config_1 = require_config();
    var isFunction_1 = require_isFunction();
    var errorContext_1 = require_errorContext();
    var Observable = function() {
      function Observable2(subscribe) {
        if (subscribe) {
          this._subscribe = subscribe;
        }
      }
      Observable2.prototype.lift = function(operator) {
        var observable = new Observable2();
        observable.source = this;
        observable.operator = operator;
        return observable;
      };
      Observable2.prototype.subscribe = function(observerOrNext, error, complete) {
        var _this = this;
        var subscriber = isSubscriber(observerOrNext) ? observerOrNext : new Subscriber_1.SafeSubscriber(observerOrNext, error, complete);
        errorContext_1.errorContext(function() {
          var _a = _this, operator = _a.operator, source = _a.source;
          subscriber.add(operator ? operator.call(subscriber, source) : source ? _this._subscribe(subscriber) : _this._trySubscribe(subscriber));
        });
        return subscriber;
      };
      Observable2.prototype._trySubscribe = function(sink) {
        try {
          return this._subscribe(sink);
        } catch (err) {
          sink.error(err);
        }
      };
      Observable2.prototype.forEach = function(next, promiseCtor) {
        var _this = this;
        promiseCtor = getPromiseCtor(promiseCtor);
        return new promiseCtor(function(resolve, reject) {
          var subscriber = new Subscriber_1.SafeSubscriber({
            next: function(value) {
              try {
                next(value);
              } catch (err) {
                reject(err);
                subscriber.unsubscribe();
              }
            },
            error: reject,
            complete: resolve
          });
          _this.subscribe(subscriber);
        });
      };
      Observable2.prototype._subscribe = function(subscriber) {
        var _a;
        return (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber);
      };
      Observable2.prototype[observable_1.observable] = function() {
        return this;
      };
      Observable2.prototype.pipe = function() {
        var operations = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          operations[_i] = arguments[_i];
        }
        return pipe_1.pipeFromArray(operations)(this);
      };
      Observable2.prototype.toPromise = function(promiseCtor) {
        var _this = this;
        promiseCtor = getPromiseCtor(promiseCtor);
        return new promiseCtor(function(resolve, reject) {
          var value;
          _this.subscribe(function(x) {
            return value = x;
          }, function(err) {
            return reject(err);
          }, function() {
            return resolve(value);
          });
        });
      };
      Observable2.create = function(subscribe) {
        return new Observable2(subscribe);
      };
      return Observable2;
    }();
    exports.Observable = Observable;
    function getPromiseCtor(promiseCtor) {
      var _a;
      return (_a = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config_1.config.Promise) !== null && _a !== void 0 ? _a : Promise;
    }
    function isObserver(value) {
      return value && isFunction_1.isFunction(value.next) && isFunction_1.isFunction(value.error) && isFunction_1.isFunction(value.complete);
    }
    function isSubscriber(value) {
      return value && value instanceof Subscriber_1.Subscriber || isObserver(value) && Subscription_1.isSubscription(value);
    }
  }
});

// node_modules/rxjs/dist/cjs/internal/util/lift.js
var require_lift = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/lift.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.operate = exports.hasLift = void 0;
    var isFunction_1 = require_isFunction();
    function hasLift(source) {
      return isFunction_1.isFunction(source === null || source === void 0 ? void 0 : source.lift);
    }
    exports.hasLift = hasLift;
    function operate(init) {
      return function(source) {
        if (hasLift(source)) {
          return source.lift(function(liftedSource) {
            try {
              return init(liftedSource, this);
            } catch (err) {
              this.error(err);
            }
          });
        }
        throw new TypeError("Unable to lift unknown Observable type");
      };
    }
    exports.operate = operate;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/OperatorSubscriber.js
var require_OperatorSubscriber = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/OperatorSubscriber.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OperatorSubscriber = exports.createOperatorSubscriber = void 0;
    var Subscriber_1 = require_Subscriber();
    function createOperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {
      return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);
    }
    exports.createOperatorSubscriber = createOperatorSubscriber;
    var OperatorSubscriber = function(_super) {
      __extends(OperatorSubscriber2, _super);
      function OperatorSubscriber2(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {
        var _this = _super.call(this, destination) || this;
        _this.onFinalize = onFinalize;
        _this.shouldUnsubscribe = shouldUnsubscribe;
        _this._next = onNext ? function(value) {
          try {
            onNext(value);
          } catch (err) {
            destination.error(err);
          }
        } : _super.prototype._next;
        _this._error = onError ? function(err) {
          try {
            onError(err);
          } catch (err2) {
            destination.error(err2);
          } finally {
            this.unsubscribe();
          }
        } : _super.prototype._error;
        _this._complete = onComplete ? function() {
          try {
            onComplete();
          } catch (err) {
            destination.error(err);
          } finally {
            this.unsubscribe();
          }
        } : _super.prototype._complete;
        return _this;
      }
      OperatorSubscriber2.prototype.unsubscribe = function() {
        var _a;
        if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
          var closed_1 = this.closed;
          _super.prototype.unsubscribe.call(this);
          !closed_1 && ((_a = this.onFinalize) === null || _a === void 0 ? void 0 : _a.call(this));
        }
      };
      return OperatorSubscriber2;
    }(Subscriber_1.Subscriber);
    exports.OperatorSubscriber = OperatorSubscriber;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/refCount.js
var require_refCount = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/refCount.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.refCount = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function refCount() {
      return lift_1.operate(function(source, subscriber) {
        var connection = null;
        source._refCount++;
        var refCounter = OperatorSubscriber_1.createOperatorSubscriber(subscriber, void 0, void 0, void 0, function() {
          if (!source || source._refCount <= 0 || 0 < --source._refCount) {
            connection = null;
            return;
          }
          var sharedConnection = source._connection;
          var conn = connection;
          connection = null;
          if (sharedConnection && (!conn || sharedConnection === conn)) {
            sharedConnection.unsubscribe();
          }
          subscriber.unsubscribe();
        });
        source.subscribe(refCounter);
        if (!refCounter.closed) {
          connection = source.connect();
        }
      });
    }
    exports.refCount = refCount;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/ConnectableObservable.js
var require_ConnectableObservable = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/ConnectableObservable.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ConnectableObservable = void 0;
    var Observable_1 = require_Observable();
    var Subscription_1 = require_Subscription();
    var refCount_1 = require_refCount();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var lift_1 = require_lift();
    var ConnectableObservable = function(_super) {
      __extends(ConnectableObservable2, _super);
      function ConnectableObservable2(source, subjectFactory) {
        var _this = _super.call(this) || this;
        _this.source = source;
        _this.subjectFactory = subjectFactory;
        _this._subject = null;
        _this._refCount = 0;
        _this._connection = null;
        if (lift_1.hasLift(source)) {
          _this.lift = source.lift;
        }
        return _this;
      }
      ConnectableObservable2.prototype._subscribe = function(subscriber) {
        return this.getSubject().subscribe(subscriber);
      };
      ConnectableObservable2.prototype.getSubject = function() {
        var subject = this._subject;
        if (!subject || subject.isStopped) {
          this._subject = this.subjectFactory();
        }
        return this._subject;
      };
      ConnectableObservable2.prototype._teardown = function() {
        this._refCount = 0;
        var _connection = this._connection;
        this._subject = this._connection = null;
        _connection === null || _connection === void 0 ? void 0 : _connection.unsubscribe();
      };
      ConnectableObservable2.prototype.connect = function() {
        var _this = this;
        var connection = this._connection;
        if (!connection) {
          connection = this._connection = new Subscription_1.Subscription();
          var subject_1 = this.getSubject();
          connection.add(this.source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subject_1, void 0, function() {
            _this._teardown();
            subject_1.complete();
          }, function(err) {
            _this._teardown();
            subject_1.error(err);
          }, function() {
            return _this._teardown();
          })));
          if (connection.closed) {
            this._connection = null;
            connection = Subscription_1.Subscription.EMPTY;
          }
        }
        return connection;
      };
      ConnectableObservable2.prototype.refCount = function() {
        return refCount_1.refCount()(this);
      };
      return ConnectableObservable2;
    }(Observable_1.Observable);
    exports.ConnectableObservable = ConnectableObservable;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/performanceTimestampProvider.js
var require_performanceTimestampProvider = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/performanceTimestampProvider.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.performanceTimestampProvider = void 0;
    exports.performanceTimestampProvider = {
      now: function() {
        return (exports.performanceTimestampProvider.delegate || performance).now();
      },
      delegate: void 0
    };
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/animationFrameProvider.js
var require_animationFrameProvider = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/animationFrameProvider.js"(exports) {
    "use strict";
    var __read = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray2 = exports && exports.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.animationFrameProvider = void 0;
    var Subscription_1 = require_Subscription();
    exports.animationFrameProvider = {
      schedule: function(callback) {
        var request = requestAnimationFrame;
        var cancel = cancelAnimationFrame;
        var delegate = exports.animationFrameProvider.delegate;
        if (delegate) {
          request = delegate.requestAnimationFrame;
          cancel = delegate.cancelAnimationFrame;
        }
        var handle = request(function(timestamp) {
          cancel = void 0;
          callback(timestamp);
        });
        return new Subscription_1.Subscription(function() {
          return cancel === null || cancel === void 0 ? void 0 : cancel(handle);
        });
      },
      requestAnimationFrame: function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var delegate = exports.animationFrameProvider.delegate;
        return ((delegate === null || delegate === void 0 ? void 0 : delegate.requestAnimationFrame) || requestAnimationFrame).apply(void 0, __spreadArray2([], __read(args)));
      },
      cancelAnimationFrame: function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var delegate = exports.animationFrameProvider.delegate;
        return ((delegate === null || delegate === void 0 ? void 0 : delegate.cancelAnimationFrame) || cancelAnimationFrame).apply(void 0, __spreadArray2([], __read(args)));
      },
      delegate: void 0
    };
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/dom/animationFrames.js
var require_animationFrames = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/dom/animationFrames.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.animationFrames = void 0;
    var Observable_1 = require_Observable();
    var performanceTimestampProvider_1 = require_performanceTimestampProvider();
    var animationFrameProvider_1 = require_animationFrameProvider();
    function animationFrames(timestampProvider) {
      return timestampProvider ? animationFramesFactory(timestampProvider) : DEFAULT_ANIMATION_FRAMES;
    }
    exports.animationFrames = animationFrames;
    function animationFramesFactory(timestampProvider) {
      return new Observable_1.Observable(function(subscriber) {
        var provider = timestampProvider || performanceTimestampProvider_1.performanceTimestampProvider;
        var start = provider.now();
        var id = 0;
        var run = function() {
          if (!subscriber.closed) {
            id = animationFrameProvider_1.animationFrameProvider.requestAnimationFrame(function(timestamp) {
              id = 0;
              var now = provider.now();
              subscriber.next({
                timestamp: timestampProvider ? now : timestamp,
                elapsed: now - start
              });
              run();
            });
          }
        };
        run();
        return function() {
          if (id) {
            animationFrameProvider_1.animationFrameProvider.cancelAnimationFrame(id);
          }
        };
      });
    }
    var DEFAULT_ANIMATION_FRAMES = animationFramesFactory();
  }
});

// node_modules/rxjs/dist/cjs/internal/util/ObjectUnsubscribedError.js
var require_ObjectUnsubscribedError = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/ObjectUnsubscribedError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ObjectUnsubscribedError = void 0;
    var createErrorClass_1 = require_createErrorClass();
    exports.ObjectUnsubscribedError = createErrorClass_1.createErrorClass(function(_super) {
      return function ObjectUnsubscribedErrorImpl() {
        _super(this);
        this.name = "ObjectUnsubscribedError";
        this.message = "object unsubscribed";
      };
    });
  }
});

// node_modules/rxjs/dist/cjs/internal/Subject.js
var require_Subject = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/Subject.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __values = exports && exports.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = void 0;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AnonymousSubject = exports.Subject = void 0;
    var Observable_1 = require_Observable();
    var Subscription_1 = require_Subscription();
    var ObjectUnsubscribedError_1 = require_ObjectUnsubscribedError();
    var arrRemove_1 = require_arrRemove();
    var errorContext_1 = require_errorContext();
    var Subject = function(_super) {
      __extends(Subject2, _super);
      function Subject2() {
        var _this = _super.call(this) || this;
        _this.closed = false;
        _this.currentObservers = null;
        _this.observers = [];
        _this.isStopped = false;
        _this.hasError = false;
        _this.thrownError = null;
        return _this;
      }
      Subject2.prototype.lift = function(operator) {
        var subject = new AnonymousSubject(this, this);
        subject.operator = operator;
        return subject;
      };
      Subject2.prototype._throwIfClosed = function() {
        if (this.closed) {
          throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
      };
      Subject2.prototype.next = function(value) {
        var _this = this;
        errorContext_1.errorContext(function() {
          var e_1, _a;
          _this._throwIfClosed();
          if (!_this.isStopped) {
            if (!_this.currentObservers) {
              _this.currentObservers = Array.from(_this.observers);
            }
            try {
              for (var _b = __values(_this.currentObservers), _c = _b.next(); !_c.done; _c = _b.next()) {
                var observer = _c.value;
                observer.next(value);
              }
            } catch (e_1_1) {
              e_1 = { error: e_1_1 };
            } finally {
              try {
                if (_c && !_c.done && (_a = _b.return))
                  _a.call(_b);
              } finally {
                if (e_1)
                  throw e_1.error;
              }
            }
          }
        });
      };
      Subject2.prototype.error = function(err) {
        var _this = this;
        errorContext_1.errorContext(function() {
          _this._throwIfClosed();
          if (!_this.isStopped) {
            _this.hasError = _this.isStopped = true;
            _this.thrownError = err;
            var observers = _this.observers;
            while (observers.length) {
              observers.shift().error(err);
            }
          }
        });
      };
      Subject2.prototype.complete = function() {
        var _this = this;
        errorContext_1.errorContext(function() {
          _this._throwIfClosed();
          if (!_this.isStopped) {
            _this.isStopped = true;
            var observers = _this.observers;
            while (observers.length) {
              observers.shift().complete();
            }
          }
        });
      };
      Subject2.prototype.unsubscribe = function() {
        this.isStopped = this.closed = true;
        this.observers = this.currentObservers = null;
      };
      Object.defineProperty(Subject2.prototype, "observed", {
        get: function() {
          var _a;
          return ((_a = this.observers) === null || _a === void 0 ? void 0 : _a.length) > 0;
        },
        enumerable: false,
        configurable: true
      });
      Subject2.prototype._trySubscribe = function(subscriber) {
        this._throwIfClosed();
        return _super.prototype._trySubscribe.call(this, subscriber);
      };
      Subject2.prototype._subscribe = function(subscriber) {
        this._throwIfClosed();
        this._checkFinalizedStatuses(subscriber);
        return this._innerSubscribe(subscriber);
      };
      Subject2.prototype._innerSubscribe = function(subscriber) {
        var _this = this;
        var _a = this, hasError = _a.hasError, isStopped = _a.isStopped, observers = _a.observers;
        if (hasError || isStopped) {
          return Subscription_1.EMPTY_SUBSCRIPTION;
        }
        this.currentObservers = null;
        observers.push(subscriber);
        return new Subscription_1.Subscription(function() {
          _this.currentObservers = null;
          arrRemove_1.arrRemove(observers, subscriber);
        });
      };
      Subject2.prototype._checkFinalizedStatuses = function(subscriber) {
        var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, isStopped = _a.isStopped;
        if (hasError) {
          subscriber.error(thrownError);
        } else if (isStopped) {
          subscriber.complete();
        }
      };
      Subject2.prototype.asObservable = function() {
        var observable = new Observable_1.Observable();
        observable.source = this;
        return observable;
      };
      Subject2.create = function(destination, source) {
        return new AnonymousSubject(destination, source);
      };
      return Subject2;
    }(Observable_1.Observable);
    exports.Subject = Subject;
    var AnonymousSubject = function(_super) {
      __extends(AnonymousSubject2, _super);
      function AnonymousSubject2(destination, source) {
        var _this = _super.call(this) || this;
        _this.destination = destination;
        _this.source = source;
        return _this;
      }
      AnonymousSubject2.prototype.next = function(value) {
        var _a, _b;
        (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.next) === null || _b === void 0 ? void 0 : _b.call(_a, value);
      };
      AnonymousSubject2.prototype.error = function(err) {
        var _a, _b;
        (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.call(_a, err);
      };
      AnonymousSubject2.prototype.complete = function() {
        var _a, _b;
        (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.complete) === null || _b === void 0 ? void 0 : _b.call(_a);
      };
      AnonymousSubject2.prototype._subscribe = function(subscriber) {
        var _a, _b;
        return (_b = (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber)) !== null && _b !== void 0 ? _b : Subscription_1.EMPTY_SUBSCRIPTION;
      };
      return AnonymousSubject2;
    }(Subject);
    exports.AnonymousSubject = AnonymousSubject;
  }
});

// node_modules/rxjs/dist/cjs/internal/BehaviorSubject.js
var require_BehaviorSubject = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/BehaviorSubject.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BehaviorSubject = void 0;
    var Subject_1 = require_Subject();
    var BehaviorSubject = function(_super) {
      __extends(BehaviorSubject2, _super);
      function BehaviorSubject2(_value) {
        var _this = _super.call(this) || this;
        _this._value = _value;
        return _this;
      }
      Object.defineProperty(BehaviorSubject2.prototype, "value", {
        get: function() {
          return this.getValue();
        },
        enumerable: false,
        configurable: true
      });
      BehaviorSubject2.prototype._subscribe = function(subscriber) {
        var subscription = _super.prototype._subscribe.call(this, subscriber);
        !subscription.closed && subscriber.next(this._value);
        return subscription;
      };
      BehaviorSubject2.prototype.getValue = function() {
        var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, _value = _a._value;
        if (hasError) {
          throw thrownError;
        }
        this._throwIfClosed();
        return _value;
      };
      BehaviorSubject2.prototype.next = function(value) {
        _super.prototype.next.call(this, this._value = value);
      };
      return BehaviorSubject2;
    }(Subject_1.Subject);
    exports.BehaviorSubject = BehaviorSubject;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/dateTimestampProvider.js
var require_dateTimestampProvider = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/dateTimestampProvider.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.dateTimestampProvider = void 0;
    exports.dateTimestampProvider = {
      now: function() {
        return (exports.dateTimestampProvider.delegate || Date).now();
      },
      delegate: void 0
    };
  }
});

// node_modules/rxjs/dist/cjs/internal/ReplaySubject.js
var require_ReplaySubject = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/ReplaySubject.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ReplaySubject = void 0;
    var Subject_1 = require_Subject();
    var dateTimestampProvider_1 = require_dateTimestampProvider();
    var ReplaySubject = function(_super) {
      __extends(ReplaySubject2, _super);
      function ReplaySubject2(_bufferSize, _windowTime, _timestampProvider) {
        if (_bufferSize === void 0) {
          _bufferSize = Infinity;
        }
        if (_windowTime === void 0) {
          _windowTime = Infinity;
        }
        if (_timestampProvider === void 0) {
          _timestampProvider = dateTimestampProvider_1.dateTimestampProvider;
        }
        var _this = _super.call(this) || this;
        _this._bufferSize = _bufferSize;
        _this._windowTime = _windowTime;
        _this._timestampProvider = _timestampProvider;
        _this._buffer = [];
        _this._infiniteTimeWindow = true;
        _this._infiniteTimeWindow = _windowTime === Infinity;
        _this._bufferSize = Math.max(1, _bufferSize);
        _this._windowTime = Math.max(1, _windowTime);
        return _this;
      }
      ReplaySubject2.prototype.next = function(value) {
        var _a = this, isStopped = _a.isStopped, _buffer = _a._buffer, _infiniteTimeWindow = _a._infiniteTimeWindow, _timestampProvider = _a._timestampProvider, _windowTime = _a._windowTime;
        if (!isStopped) {
          _buffer.push(value);
          !_infiniteTimeWindow && _buffer.push(_timestampProvider.now() + _windowTime);
        }
        this._trimBuffer();
        _super.prototype.next.call(this, value);
      };
      ReplaySubject2.prototype._subscribe = function(subscriber) {
        this._throwIfClosed();
        this._trimBuffer();
        var subscription = this._innerSubscribe(subscriber);
        var _a = this, _infiniteTimeWindow = _a._infiniteTimeWindow, _buffer = _a._buffer;
        var copy = _buffer.slice();
        for (var i = 0; i < copy.length && !subscriber.closed; i += _infiniteTimeWindow ? 1 : 2) {
          subscriber.next(copy[i]);
        }
        this._checkFinalizedStatuses(subscriber);
        return subscription;
      };
      ReplaySubject2.prototype._trimBuffer = function() {
        var _a = this, _bufferSize = _a._bufferSize, _timestampProvider = _a._timestampProvider, _buffer = _a._buffer, _infiniteTimeWindow = _a._infiniteTimeWindow;
        var adjustedBufferSize = (_infiniteTimeWindow ? 1 : 2) * _bufferSize;
        _bufferSize < Infinity && adjustedBufferSize < _buffer.length && _buffer.splice(0, _buffer.length - adjustedBufferSize);
        if (!_infiniteTimeWindow) {
          var now = _timestampProvider.now();
          var last = 0;
          for (var i = 1; i < _buffer.length && _buffer[i] <= now; i += 2) {
            last = i;
          }
          last && _buffer.splice(0, last + 1);
        }
      };
      return ReplaySubject2;
    }(Subject_1.Subject);
    exports.ReplaySubject = ReplaySubject;
  }
});

// node_modules/rxjs/dist/cjs/internal/AsyncSubject.js
var require_AsyncSubject = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/AsyncSubject.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AsyncSubject = void 0;
    var Subject_1 = require_Subject();
    var AsyncSubject = function(_super) {
      __extends(AsyncSubject2, _super);
      function AsyncSubject2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._value = null;
        _this._hasValue = false;
        _this._isComplete = false;
        return _this;
      }
      AsyncSubject2.prototype._checkFinalizedStatuses = function(subscriber) {
        var _a = this, hasError = _a.hasError, _hasValue = _a._hasValue, _value = _a._value, thrownError = _a.thrownError, isStopped = _a.isStopped, _isComplete = _a._isComplete;
        if (hasError) {
          subscriber.error(thrownError);
        } else if (isStopped || _isComplete) {
          _hasValue && subscriber.next(_value);
          subscriber.complete();
        }
      };
      AsyncSubject2.prototype.next = function(value) {
        if (!this.isStopped) {
          this._value = value;
          this._hasValue = true;
        }
      };
      AsyncSubject2.prototype.complete = function() {
        var _a = this, _hasValue = _a._hasValue, _value = _a._value, _isComplete = _a._isComplete;
        if (!_isComplete) {
          this._isComplete = true;
          _hasValue && _super.prototype.next.call(this, _value);
          _super.prototype.complete.call(this);
        }
      };
      return AsyncSubject2;
    }(Subject_1.Subject);
    exports.AsyncSubject = AsyncSubject;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/Action.js
var require_Action = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/Action.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Action = void 0;
    var Subscription_1 = require_Subscription();
    var Action = function(_super) {
      __extends(Action2, _super);
      function Action2(scheduler, work) {
        return _super.call(this) || this;
      }
      Action2.prototype.schedule = function(state, delay) {
        if (delay === void 0) {
          delay = 0;
        }
        return this;
      };
      return Action2;
    }(Subscription_1.Subscription);
    exports.Action = Action;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/intervalProvider.js
var require_intervalProvider = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/intervalProvider.js"(exports) {
    "use strict";
    var __read = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray2 = exports && exports.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.intervalProvider = void 0;
    exports.intervalProvider = {
      setInterval: function(handler, timeout) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
          args[_i - 2] = arguments[_i];
        }
        var delegate = exports.intervalProvider.delegate;
        if (delegate === null || delegate === void 0 ? void 0 : delegate.setInterval) {
          return delegate.setInterval.apply(delegate, __spreadArray2([handler, timeout], __read(args)));
        }
        return setInterval.apply(void 0, __spreadArray2([handler, timeout], __read(args)));
      },
      clearInterval: function(handle) {
        var delegate = exports.intervalProvider.delegate;
        return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearInterval) || clearInterval)(handle);
      },
      delegate: void 0
    };
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/AsyncAction.js
var require_AsyncAction = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/AsyncAction.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AsyncAction = void 0;
    var Action_1 = require_Action();
    var intervalProvider_1 = require_intervalProvider();
    var arrRemove_1 = require_arrRemove();
    var AsyncAction = function(_super) {
      __extends(AsyncAction2, _super);
      function AsyncAction2(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        _this.pending = false;
        return _this;
      }
      AsyncAction2.prototype.schedule = function(state, delay) {
        var _a;
        if (delay === void 0) {
          delay = 0;
        }
        if (this.closed) {
          return this;
        }
        this.state = state;
        var id = this.id;
        var scheduler = this.scheduler;
        if (id != null) {
          this.id = this.recycleAsyncId(scheduler, id, delay);
        }
        this.pending = true;
        this.delay = delay;
        this.id = (_a = this.id) !== null && _a !== void 0 ? _a : this.requestAsyncId(scheduler, this.id, delay);
        return this;
      };
      AsyncAction2.prototype.requestAsyncId = function(scheduler, _id, delay) {
        if (delay === void 0) {
          delay = 0;
        }
        return intervalProvider_1.intervalProvider.setInterval(scheduler.flush.bind(scheduler, this), delay);
      };
      AsyncAction2.prototype.recycleAsyncId = function(_scheduler, id, delay) {
        if (delay === void 0) {
          delay = 0;
        }
        if (delay != null && this.delay === delay && this.pending === false) {
          return id;
        }
        if (id != null) {
          intervalProvider_1.intervalProvider.clearInterval(id);
        }
        return void 0;
      };
      AsyncAction2.prototype.execute = function(state, delay) {
        if (this.closed) {
          return new Error("executing a cancelled action");
        }
        this.pending = false;
        var error = this._execute(state, delay);
        if (error) {
          return error;
        } else if (this.pending === false && this.id != null) {
          this.id = this.recycleAsyncId(this.scheduler, this.id, null);
        }
      };
      AsyncAction2.prototype._execute = function(state, _delay) {
        var errored = false;
        var errorValue;
        try {
          this.work(state);
        } catch (e) {
          errored = true;
          errorValue = e ? e : new Error("Scheduled action threw falsy error");
        }
        if (errored) {
          this.unsubscribe();
          return errorValue;
        }
      };
      AsyncAction2.prototype.unsubscribe = function() {
        if (!this.closed) {
          var _a = this, id = _a.id, scheduler = _a.scheduler;
          var actions = scheduler.actions;
          this.work = this.state = this.scheduler = null;
          this.pending = false;
          arrRemove_1.arrRemove(actions, this);
          if (id != null) {
            this.id = this.recycleAsyncId(scheduler, id, null);
          }
          this.delay = null;
          _super.prototype.unsubscribe.call(this);
        }
      };
      return AsyncAction2;
    }(Action_1.Action);
    exports.AsyncAction = AsyncAction;
  }
});

// node_modules/rxjs/dist/cjs/internal/util/Immediate.js
var require_Immediate = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/Immediate.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TestTools = exports.Immediate = void 0;
    var nextHandle = 1;
    var resolved;
    var activeHandles = {};
    function findAndClearHandle(handle) {
      if (handle in activeHandles) {
        delete activeHandles[handle];
        return true;
      }
      return false;
    }
    exports.Immediate = {
      setImmediate: function(cb) {
        var handle = nextHandle++;
        activeHandles[handle] = true;
        if (!resolved) {
          resolved = Promise.resolve();
        }
        resolved.then(function() {
          return findAndClearHandle(handle) && cb();
        });
        return handle;
      },
      clearImmediate: function(handle) {
        findAndClearHandle(handle);
      }
    };
    exports.TestTools = {
      pending: function() {
        return Object.keys(activeHandles).length;
      }
    };
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/immediateProvider.js
var require_immediateProvider = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/immediateProvider.js"(exports) {
    "use strict";
    var __read = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray2 = exports && exports.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.immediateProvider = void 0;
    var Immediate_1 = require_Immediate();
    var setImmediate = Immediate_1.Immediate.setImmediate;
    var clearImmediate = Immediate_1.Immediate.clearImmediate;
    exports.immediateProvider = {
      setImmediate: function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var delegate = exports.immediateProvider.delegate;
        return ((delegate === null || delegate === void 0 ? void 0 : delegate.setImmediate) || setImmediate).apply(void 0, __spreadArray2([], __read(args)));
      },
      clearImmediate: function(handle) {
        var delegate = exports.immediateProvider.delegate;
        return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearImmediate) || clearImmediate)(handle);
      },
      delegate: void 0
    };
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/AsapAction.js
var require_AsapAction = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/AsapAction.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AsapAction = void 0;
    var AsyncAction_1 = require_AsyncAction();
    var immediateProvider_1 = require_immediateProvider();
    var AsapAction = function(_super) {
      __extends(AsapAction2, _super);
      function AsapAction2(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        return _this;
      }
      AsapAction2.prototype.requestAsyncId = function(scheduler, id, delay) {
        if (delay === void 0) {
          delay = 0;
        }
        if (delay !== null && delay > 0) {
          return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
        }
        scheduler.actions.push(this);
        return scheduler._scheduled || (scheduler._scheduled = immediateProvider_1.immediateProvider.setImmediate(scheduler.flush.bind(scheduler, void 0)));
      };
      AsapAction2.prototype.recycleAsyncId = function(scheduler, id, delay) {
        var _a;
        if (delay === void 0) {
          delay = 0;
        }
        if (delay != null ? delay > 0 : this.delay > 0) {
          return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
        }
        var actions = scheduler.actions;
        if (id != null && ((_a = actions[actions.length - 1]) === null || _a === void 0 ? void 0 : _a.id) !== id) {
          immediateProvider_1.immediateProvider.clearImmediate(id);
          if (scheduler._scheduled === id) {
            scheduler._scheduled = void 0;
          }
        }
        return void 0;
      };
      return AsapAction2;
    }(AsyncAction_1.AsyncAction);
    exports.AsapAction = AsapAction;
  }
});

// node_modules/rxjs/dist/cjs/internal/Scheduler.js
var require_Scheduler = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/Scheduler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Scheduler = void 0;
    var dateTimestampProvider_1 = require_dateTimestampProvider();
    var Scheduler = function() {
      function Scheduler2(schedulerActionCtor, now) {
        if (now === void 0) {
          now = Scheduler2.now;
        }
        this.schedulerActionCtor = schedulerActionCtor;
        this.now = now;
      }
      Scheduler2.prototype.schedule = function(work, delay, state) {
        if (delay === void 0) {
          delay = 0;
        }
        return new this.schedulerActionCtor(this, work).schedule(state, delay);
      };
      Scheduler2.now = dateTimestampProvider_1.dateTimestampProvider.now;
      return Scheduler2;
    }();
    exports.Scheduler = Scheduler;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/AsyncScheduler.js
var require_AsyncScheduler = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/AsyncScheduler.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AsyncScheduler = void 0;
    var Scheduler_1 = require_Scheduler();
    var AsyncScheduler = function(_super) {
      __extends(AsyncScheduler2, _super);
      function AsyncScheduler2(SchedulerAction, now) {
        if (now === void 0) {
          now = Scheduler_1.Scheduler.now;
        }
        var _this = _super.call(this, SchedulerAction, now) || this;
        _this.actions = [];
        _this._active = false;
        return _this;
      }
      AsyncScheduler2.prototype.flush = function(action) {
        var actions = this.actions;
        if (this._active) {
          actions.push(action);
          return;
        }
        var error;
        this._active = true;
        do {
          if (error = action.execute(action.state, action.delay)) {
            break;
          }
        } while (action = actions.shift());
        this._active = false;
        if (error) {
          while (action = actions.shift()) {
            action.unsubscribe();
          }
          throw error;
        }
      };
      return AsyncScheduler2;
    }(Scheduler_1.Scheduler);
    exports.AsyncScheduler = AsyncScheduler;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/AsapScheduler.js
var require_AsapScheduler = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/AsapScheduler.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AsapScheduler = void 0;
    var AsyncScheduler_1 = require_AsyncScheduler();
    var AsapScheduler = function(_super) {
      __extends(AsapScheduler2, _super);
      function AsapScheduler2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      AsapScheduler2.prototype.flush = function(action) {
        this._active = true;
        var flushId = this._scheduled;
        this._scheduled = void 0;
        var actions = this.actions;
        var error;
        action = action || actions.shift();
        do {
          if (error = action.execute(action.state, action.delay)) {
            break;
          }
        } while ((action = actions[0]) && action.id === flushId && actions.shift());
        this._active = false;
        if (error) {
          while ((action = actions[0]) && action.id === flushId && actions.shift()) {
            action.unsubscribe();
          }
          throw error;
        }
      };
      return AsapScheduler2;
    }(AsyncScheduler_1.AsyncScheduler);
    exports.AsapScheduler = AsapScheduler;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/asap.js
var require_asap = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/asap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.asap = exports.asapScheduler = void 0;
    var AsapAction_1 = require_AsapAction();
    var AsapScheduler_1 = require_AsapScheduler();
    exports.asapScheduler = new AsapScheduler_1.AsapScheduler(AsapAction_1.AsapAction);
    exports.asap = exports.asapScheduler;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/async.js
var require_async = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/async.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.async = exports.asyncScheduler = void 0;
    var AsyncAction_1 = require_AsyncAction();
    var AsyncScheduler_1 = require_AsyncScheduler();
    exports.asyncScheduler = new AsyncScheduler_1.AsyncScheduler(AsyncAction_1.AsyncAction);
    exports.async = exports.asyncScheduler;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/QueueAction.js
var require_QueueAction = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/QueueAction.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.QueueAction = void 0;
    var AsyncAction_1 = require_AsyncAction();
    var QueueAction = function(_super) {
      __extends(QueueAction2, _super);
      function QueueAction2(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        return _this;
      }
      QueueAction2.prototype.schedule = function(state, delay) {
        if (delay === void 0) {
          delay = 0;
        }
        if (delay > 0) {
          return _super.prototype.schedule.call(this, state, delay);
        }
        this.delay = delay;
        this.state = state;
        this.scheduler.flush(this);
        return this;
      };
      QueueAction2.prototype.execute = function(state, delay) {
        return delay > 0 || this.closed ? _super.prototype.execute.call(this, state, delay) : this._execute(state, delay);
      };
      QueueAction2.prototype.requestAsyncId = function(scheduler, id, delay) {
        if (delay === void 0) {
          delay = 0;
        }
        if (delay != null && delay > 0 || delay == null && this.delay > 0) {
          return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
        }
        scheduler.flush(this);
        return 0;
      };
      return QueueAction2;
    }(AsyncAction_1.AsyncAction);
    exports.QueueAction = QueueAction;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/QueueScheduler.js
var require_QueueScheduler = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/QueueScheduler.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.QueueScheduler = void 0;
    var AsyncScheduler_1 = require_AsyncScheduler();
    var QueueScheduler = function(_super) {
      __extends(QueueScheduler2, _super);
      function QueueScheduler2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      return QueueScheduler2;
    }(AsyncScheduler_1.AsyncScheduler);
    exports.QueueScheduler = QueueScheduler;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/queue.js
var require_queue = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/queue.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.queue = exports.queueScheduler = void 0;
    var QueueAction_1 = require_QueueAction();
    var QueueScheduler_1 = require_QueueScheduler();
    exports.queueScheduler = new QueueScheduler_1.QueueScheduler(QueueAction_1.QueueAction);
    exports.queue = exports.queueScheduler;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/AnimationFrameAction.js
var require_AnimationFrameAction = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/AnimationFrameAction.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AnimationFrameAction = void 0;
    var AsyncAction_1 = require_AsyncAction();
    var animationFrameProvider_1 = require_animationFrameProvider();
    var AnimationFrameAction = function(_super) {
      __extends(AnimationFrameAction2, _super);
      function AnimationFrameAction2(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        return _this;
      }
      AnimationFrameAction2.prototype.requestAsyncId = function(scheduler, id, delay) {
        if (delay === void 0) {
          delay = 0;
        }
        if (delay !== null && delay > 0) {
          return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
        }
        scheduler.actions.push(this);
        return scheduler._scheduled || (scheduler._scheduled = animationFrameProvider_1.animationFrameProvider.requestAnimationFrame(function() {
          return scheduler.flush(void 0);
        }));
      };
      AnimationFrameAction2.prototype.recycleAsyncId = function(scheduler, id, delay) {
        var _a;
        if (delay === void 0) {
          delay = 0;
        }
        if (delay != null ? delay > 0 : this.delay > 0) {
          return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
        }
        var actions = scheduler.actions;
        if (id != null && ((_a = actions[actions.length - 1]) === null || _a === void 0 ? void 0 : _a.id) !== id) {
          animationFrameProvider_1.animationFrameProvider.cancelAnimationFrame(id);
          scheduler._scheduled = void 0;
        }
        return void 0;
      };
      return AnimationFrameAction2;
    }(AsyncAction_1.AsyncAction);
    exports.AnimationFrameAction = AnimationFrameAction;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/AnimationFrameScheduler.js
var require_AnimationFrameScheduler = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/AnimationFrameScheduler.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AnimationFrameScheduler = void 0;
    var AsyncScheduler_1 = require_AsyncScheduler();
    var AnimationFrameScheduler = function(_super) {
      __extends(AnimationFrameScheduler2, _super);
      function AnimationFrameScheduler2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      AnimationFrameScheduler2.prototype.flush = function(action) {
        this._active = true;
        var flushId = this._scheduled;
        this._scheduled = void 0;
        var actions = this.actions;
        var error;
        action = action || actions.shift();
        do {
          if (error = action.execute(action.state, action.delay)) {
            break;
          }
        } while ((action = actions[0]) && action.id === flushId && actions.shift());
        this._active = false;
        if (error) {
          while ((action = actions[0]) && action.id === flushId && actions.shift()) {
            action.unsubscribe();
          }
          throw error;
        }
      };
      return AnimationFrameScheduler2;
    }(AsyncScheduler_1.AsyncScheduler);
    exports.AnimationFrameScheduler = AnimationFrameScheduler;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/animationFrame.js
var require_animationFrame = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/animationFrame.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.animationFrame = exports.animationFrameScheduler = void 0;
    var AnimationFrameAction_1 = require_AnimationFrameAction();
    var AnimationFrameScheduler_1 = require_AnimationFrameScheduler();
    exports.animationFrameScheduler = new AnimationFrameScheduler_1.AnimationFrameScheduler(AnimationFrameAction_1.AnimationFrameAction);
    exports.animationFrame = exports.animationFrameScheduler;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduler/VirtualTimeScheduler.js
var require_VirtualTimeScheduler = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduler/VirtualTimeScheduler.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.VirtualAction = exports.VirtualTimeScheduler = void 0;
    var AsyncAction_1 = require_AsyncAction();
    var Subscription_1 = require_Subscription();
    var AsyncScheduler_1 = require_AsyncScheduler();
    var VirtualTimeScheduler = function(_super) {
      __extends(VirtualTimeScheduler2, _super);
      function VirtualTimeScheduler2(schedulerActionCtor, maxFrames) {
        if (schedulerActionCtor === void 0) {
          schedulerActionCtor = VirtualAction;
        }
        if (maxFrames === void 0) {
          maxFrames = Infinity;
        }
        var _this = _super.call(this, schedulerActionCtor, function() {
          return _this.frame;
        }) || this;
        _this.maxFrames = maxFrames;
        _this.frame = 0;
        _this.index = -1;
        return _this;
      }
      VirtualTimeScheduler2.prototype.flush = function() {
        var _a = this, actions = _a.actions, maxFrames = _a.maxFrames;
        var error;
        var action;
        while ((action = actions[0]) && action.delay <= maxFrames) {
          actions.shift();
          this.frame = action.delay;
          if (error = action.execute(action.state, action.delay)) {
            break;
          }
        }
        if (error) {
          while (action = actions.shift()) {
            action.unsubscribe();
          }
          throw error;
        }
      };
      VirtualTimeScheduler2.frameTimeFactor = 10;
      return VirtualTimeScheduler2;
    }(AsyncScheduler_1.AsyncScheduler);
    exports.VirtualTimeScheduler = VirtualTimeScheduler;
    var VirtualAction = function(_super) {
      __extends(VirtualAction2, _super);
      function VirtualAction2(scheduler, work, index) {
        if (index === void 0) {
          index = scheduler.index += 1;
        }
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        _this.index = index;
        _this.active = true;
        _this.index = scheduler.index = index;
        return _this;
      }
      VirtualAction2.prototype.schedule = function(state, delay) {
        if (delay === void 0) {
          delay = 0;
        }
        if (Number.isFinite(delay)) {
          if (!this.id) {
            return _super.prototype.schedule.call(this, state, delay);
          }
          this.active = false;
          var action = new VirtualAction2(this.scheduler, this.work);
          this.add(action);
          return action.schedule(state, delay);
        } else {
          return Subscription_1.Subscription.EMPTY;
        }
      };
      VirtualAction2.prototype.requestAsyncId = function(scheduler, id, delay) {
        if (delay === void 0) {
          delay = 0;
        }
        this.delay = scheduler.frame + delay;
        var actions = scheduler.actions;
        actions.push(this);
        actions.sort(VirtualAction2.sortActions);
        return 1;
      };
      VirtualAction2.prototype.recycleAsyncId = function(scheduler, id, delay) {
        if (delay === void 0) {
          delay = 0;
        }
        return void 0;
      };
      VirtualAction2.prototype._execute = function(state, delay) {
        if (this.active === true) {
          return _super.prototype._execute.call(this, state, delay);
        }
      };
      VirtualAction2.sortActions = function(a, b) {
        if (a.delay === b.delay) {
          if (a.index === b.index) {
            return 0;
          } else if (a.index > b.index) {
            return 1;
          } else {
            return -1;
          }
        } else if (a.delay > b.delay) {
          return 1;
        } else {
          return -1;
        }
      };
      return VirtualAction2;
    }(AsyncAction_1.AsyncAction);
    exports.VirtualAction = VirtualAction;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/empty.js
var require_empty = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/empty.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.empty = exports.EMPTY = void 0;
    var Observable_1 = require_Observable();
    exports.EMPTY = new Observable_1.Observable(function(subscriber) {
      return subscriber.complete();
    });
    function empty(scheduler) {
      return scheduler ? emptyScheduled(scheduler) : exports.EMPTY;
    }
    exports.empty = empty;
    function emptyScheduled(scheduler) {
      return new Observable_1.Observable(function(subscriber) {
        return scheduler.schedule(function() {
          return subscriber.complete();
        });
      });
    }
  }
});

// node_modules/rxjs/dist/cjs/internal/util/isScheduler.js
var require_isScheduler = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/isScheduler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isScheduler = void 0;
    var isFunction_1 = require_isFunction();
    function isScheduler(value) {
      return value && isFunction_1.isFunction(value.schedule);
    }
    exports.isScheduler = isScheduler;
  }
});

// node_modules/rxjs/dist/cjs/internal/util/args.js
var require_args = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/args.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.popNumber = exports.popScheduler = exports.popResultSelector = void 0;
    var isFunction_1 = require_isFunction();
    var isScheduler_1 = require_isScheduler();
    function last(arr) {
      return arr[arr.length - 1];
    }
    function popResultSelector(args) {
      return isFunction_1.isFunction(last(args)) ? args.pop() : void 0;
    }
    exports.popResultSelector = popResultSelector;
    function popScheduler(args) {
      return isScheduler_1.isScheduler(last(args)) ? args.pop() : void 0;
    }
    exports.popScheduler = popScheduler;
    function popNumber(args, defaultValue) {
      return typeof last(args) === "number" ? args.pop() : defaultValue;
    }
    exports.popNumber = popNumber;
  }
});

// node_modules/rxjs/dist/cjs/internal/util/isArrayLike.js
var require_isArrayLike = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/isArrayLike.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isArrayLike = void 0;
    exports.isArrayLike = function(x) {
      return x && typeof x.length === "number" && typeof x !== "function";
    };
  }
});

// node_modules/rxjs/dist/cjs/internal/util/isPromise.js
var require_isPromise = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/isPromise.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isPromise = void 0;
    var isFunction_1 = require_isFunction();
    function isPromise(value) {
      return isFunction_1.isFunction(value === null || value === void 0 ? void 0 : value.then);
    }
    exports.isPromise = isPromise;
  }
});

// node_modules/rxjs/dist/cjs/internal/util/isInteropObservable.js
var require_isInteropObservable = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/isInteropObservable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isInteropObservable = void 0;
    var observable_1 = require_observable();
    var isFunction_1 = require_isFunction();
    function isInteropObservable(input) {
      return isFunction_1.isFunction(input[observable_1.observable]);
    }
    exports.isInteropObservable = isInteropObservable;
  }
});

// node_modules/rxjs/dist/cjs/internal/util/isAsyncIterable.js
var require_isAsyncIterable = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/isAsyncIterable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isAsyncIterable = void 0;
    var isFunction_1 = require_isFunction();
    function isAsyncIterable(obj) {
      return Symbol.asyncIterator && isFunction_1.isFunction(obj === null || obj === void 0 ? void 0 : obj[Symbol.asyncIterator]);
    }
    exports.isAsyncIterable = isAsyncIterable;
  }
});

// node_modules/rxjs/dist/cjs/internal/util/throwUnobservableError.js
var require_throwUnobservableError = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/throwUnobservableError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createInvalidObservableTypeError = void 0;
    function createInvalidObservableTypeError(input) {
      return new TypeError("You provided " + (input !== null && typeof input === "object" ? "an invalid object" : "'" + input + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
    }
    exports.createInvalidObservableTypeError = createInvalidObservableTypeError;
  }
});

// node_modules/rxjs/dist/cjs/internal/symbol/iterator.js
var require_iterator = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/symbol/iterator.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.iterator = exports.getSymbolIterator = void 0;
    function getSymbolIterator() {
      if (typeof Symbol !== "function" || !Symbol.iterator) {
        return "@@iterator";
      }
      return Symbol.iterator;
    }
    exports.getSymbolIterator = getSymbolIterator;
    exports.iterator = getSymbolIterator();
  }
});

// node_modules/rxjs/dist/cjs/internal/util/isIterable.js
var require_isIterable = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/isIterable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isIterable = void 0;
    var iterator_1 = require_iterator();
    var isFunction_1 = require_isFunction();
    function isIterable(input) {
      return isFunction_1.isFunction(input === null || input === void 0 ? void 0 : input[iterator_1.iterator]);
    }
    exports.isIterable = isIterable;
  }
});

// node_modules/rxjs/dist/cjs/internal/util/isReadableStreamLike.js
var require_isReadableStreamLike = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/isReadableStreamLike.js"(exports) {
    "use strict";
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    var __await = exports && exports.__await || function(v) {
      return this instanceof __await ? (this.v = v, this) : new __await(v);
    };
    var __asyncGenerator = exports && exports.__asyncGenerator || function(thisArg, _arguments, generator) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var g = generator.apply(thisArg, _arguments || []), i, q = [];
      return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
      }, i;
      function verb(n) {
        if (g[n])
          i[n] = function(v) {
            return new Promise(function(a, b) {
              q.push([n, v, a, b]) > 1 || resume(n, v);
            });
          };
      }
      function resume(n, v) {
        try {
          step(g[n](v));
        } catch (e) {
          settle(q[0][3], e);
        }
      }
      function step(r) {
        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
      }
      function fulfill(value) {
        resume("next", value);
      }
      function reject(value) {
        resume("throw", value);
      }
      function settle(f, v) {
        if (f(v), q.shift(), q.length)
          resume(q[0][0], q[0][1]);
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isReadableStreamLike = exports.readableStreamLikeToAsyncGenerator = void 0;
    var isFunction_1 = require_isFunction();
    function readableStreamLikeToAsyncGenerator(readableStream) {
      return __asyncGenerator(this, arguments, function readableStreamLikeToAsyncGenerator_1() {
        var reader, _a, value, done;
        return __generator(this, function(_b) {
          switch (_b.label) {
            case 0:
              reader = readableStream.getReader();
              _b.label = 1;
            case 1:
              _b.trys.push([1, , 9, 10]);
              _b.label = 2;
            case 2:
              if (false)
                return [3, 8];
              return [4, __await(reader.read())];
            case 3:
              _a = _b.sent(), value = _a.value, done = _a.done;
              if (!done)
                return [3, 5];
              return [4, __await(void 0)];
            case 4:
              return [2, _b.sent()];
            case 5:
              return [4, __await(value)];
            case 6:
              return [4, _b.sent()];
            case 7:
              _b.sent();
              return [3, 2];
            case 8:
              return [3, 10];
            case 9:
              reader.releaseLock();
              return [7];
            case 10:
              return [2];
          }
        });
      });
    }
    exports.readableStreamLikeToAsyncGenerator = readableStreamLikeToAsyncGenerator;
    function isReadableStreamLike(obj) {
      return isFunction_1.isFunction(obj === null || obj === void 0 ? void 0 : obj.getReader);
    }
    exports.isReadableStreamLike = isReadableStreamLike;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/innerFrom.js
var require_innerFrom = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/innerFrom.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    var __asyncValues = exports && exports.__asyncValues || function(o) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var m = o[Symbol.asyncIterator], i;
      return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
      }, i);
      function verb(n) {
        i[n] = o[n] && function(v) {
          return new Promise(function(resolve, reject) {
            v = o[n](v), settle(resolve, reject, v.done, v.value);
          });
        };
      }
      function settle(resolve, reject, d, v) {
        Promise.resolve(v).then(function(v2) {
          resolve({ value: v2, done: d });
        }, reject);
      }
    };
    var __values = exports && exports.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = void 0;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fromReadableStreamLike = exports.fromAsyncIterable = exports.fromIterable = exports.fromPromise = exports.fromArrayLike = exports.fromInteropObservable = exports.innerFrom = void 0;
    var isArrayLike_1 = require_isArrayLike();
    var isPromise_1 = require_isPromise();
    var Observable_1 = require_Observable();
    var isInteropObservable_1 = require_isInteropObservable();
    var isAsyncIterable_1 = require_isAsyncIterable();
    var throwUnobservableError_1 = require_throwUnobservableError();
    var isIterable_1 = require_isIterable();
    var isReadableStreamLike_1 = require_isReadableStreamLike();
    var isFunction_1 = require_isFunction();
    var reportUnhandledError_1 = require_reportUnhandledError();
    var observable_1 = require_observable();
    function innerFrom(input) {
      if (input instanceof Observable_1.Observable) {
        return input;
      }
      if (input != null) {
        if (isInteropObservable_1.isInteropObservable(input)) {
          return fromInteropObservable(input);
        }
        if (isArrayLike_1.isArrayLike(input)) {
          return fromArrayLike(input);
        }
        if (isPromise_1.isPromise(input)) {
          return fromPromise(input);
        }
        if (isAsyncIterable_1.isAsyncIterable(input)) {
          return fromAsyncIterable(input);
        }
        if (isIterable_1.isIterable(input)) {
          return fromIterable(input);
        }
        if (isReadableStreamLike_1.isReadableStreamLike(input)) {
          return fromReadableStreamLike(input);
        }
      }
      throw throwUnobservableError_1.createInvalidObservableTypeError(input);
    }
    exports.innerFrom = innerFrom;
    function fromInteropObservable(obj) {
      return new Observable_1.Observable(function(subscriber) {
        var obs = obj[observable_1.observable]();
        if (isFunction_1.isFunction(obs.subscribe)) {
          return obs.subscribe(subscriber);
        }
        throw new TypeError("Provided object does not correctly implement Symbol.observable");
      });
    }
    exports.fromInteropObservable = fromInteropObservable;
    function fromArrayLike(array) {
      return new Observable_1.Observable(function(subscriber) {
        for (var i = 0; i < array.length && !subscriber.closed; i++) {
          subscriber.next(array[i]);
        }
        subscriber.complete();
      });
    }
    exports.fromArrayLike = fromArrayLike;
    function fromPromise(promise) {
      return new Observable_1.Observable(function(subscriber) {
        promise.then(function(value) {
          if (!subscriber.closed) {
            subscriber.next(value);
            subscriber.complete();
          }
        }, function(err) {
          return subscriber.error(err);
        }).then(null, reportUnhandledError_1.reportUnhandledError);
      });
    }
    exports.fromPromise = fromPromise;
    function fromIterable(iterable) {
      return new Observable_1.Observable(function(subscriber) {
        var e_1, _a;
        try {
          for (var iterable_1 = __values(iterable), iterable_1_1 = iterable_1.next(); !iterable_1_1.done; iterable_1_1 = iterable_1.next()) {
            var value = iterable_1_1.value;
            subscriber.next(value);
            if (subscriber.closed) {
              return;
            }
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return))
              _a.call(iterable_1);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
        subscriber.complete();
      });
    }
    exports.fromIterable = fromIterable;
    function fromAsyncIterable(asyncIterable) {
      return new Observable_1.Observable(function(subscriber) {
        process2(asyncIterable, subscriber).catch(function(err) {
          return subscriber.error(err);
        });
      });
    }
    exports.fromAsyncIterable = fromAsyncIterable;
    function fromReadableStreamLike(readableStream) {
      return fromAsyncIterable(isReadableStreamLike_1.readableStreamLikeToAsyncGenerator(readableStream));
    }
    exports.fromReadableStreamLike = fromReadableStreamLike;
    function process2(asyncIterable, subscriber) {
      var asyncIterable_1, asyncIterable_1_1;
      var e_2, _a;
      return __awaiter(this, void 0, void 0, function() {
        var value, e_2_1;
        return __generator(this, function(_b) {
          switch (_b.label) {
            case 0:
              _b.trys.push([0, 5, 6, 11]);
              asyncIterable_1 = __asyncValues(asyncIterable);
              _b.label = 1;
            case 1:
              return [4, asyncIterable_1.next()];
            case 2:
              if (!(asyncIterable_1_1 = _b.sent(), !asyncIterable_1_1.done))
                return [3, 4];
              value = asyncIterable_1_1.value;
              subscriber.next(value);
              if (subscriber.closed) {
                return [2];
              }
              _b.label = 3;
            case 3:
              return [3, 1];
            case 4:
              return [3, 11];
            case 5:
              e_2_1 = _b.sent();
              e_2 = { error: e_2_1 };
              return [3, 11];
            case 6:
              _b.trys.push([6, , 9, 10]);
              if (!(asyncIterable_1_1 && !asyncIterable_1_1.done && (_a = asyncIterable_1.return)))
                return [3, 8];
              return [4, _a.call(asyncIterable_1)];
            case 7:
              _b.sent();
              _b.label = 8;
            case 8:
              return [3, 10];
            case 9:
              if (e_2)
                throw e_2.error;
              return [7];
            case 10:
              return [7];
            case 11:
              subscriber.complete();
              return [2];
          }
        });
      });
    }
  }
});

// node_modules/rxjs/dist/cjs/internal/util/executeSchedule.js
var require_executeSchedule = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/executeSchedule.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.executeSchedule = void 0;
    function executeSchedule(parentSubscription, scheduler, work, delay, repeat) {
      if (delay === void 0) {
        delay = 0;
      }
      if (repeat === void 0) {
        repeat = false;
      }
      var scheduleSubscription = scheduler.schedule(function() {
        work();
        if (repeat) {
          parentSubscription.add(this.schedule(null, delay));
        } else {
          this.unsubscribe();
        }
      }, delay);
      parentSubscription.add(scheduleSubscription);
      if (!repeat) {
        return scheduleSubscription;
      }
    }
    exports.executeSchedule = executeSchedule;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/observeOn.js
var require_observeOn = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/observeOn.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.observeOn = void 0;
    var executeSchedule_1 = require_executeSchedule();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function observeOn(scheduler, delay) {
      if (delay === void 0) {
        delay = 0;
      }
      return lift_1.operate(function(source, subscriber) {
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          return executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
            return subscriber.next(value);
          }, delay);
        }, function() {
          return executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
            return subscriber.complete();
          }, delay);
        }, function(err) {
          return executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
            return subscriber.error(err);
          }, delay);
        }));
      });
    }
    exports.observeOn = observeOn;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/subscribeOn.js
var require_subscribeOn = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/subscribeOn.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.subscribeOn = void 0;
    var lift_1 = require_lift();
    function subscribeOn(scheduler, delay) {
      if (delay === void 0) {
        delay = 0;
      }
      return lift_1.operate(function(source, subscriber) {
        subscriber.add(scheduler.schedule(function() {
          return source.subscribe(subscriber);
        }, delay));
      });
    }
    exports.subscribeOn = subscribeOn;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduled/scheduleObservable.js
var require_scheduleObservable = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduled/scheduleObservable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.scheduleObservable = void 0;
    var innerFrom_1 = require_innerFrom();
    var observeOn_1 = require_observeOn();
    var subscribeOn_1 = require_subscribeOn();
    function scheduleObservable(input, scheduler) {
      return innerFrom_1.innerFrom(input).pipe(subscribeOn_1.subscribeOn(scheduler), observeOn_1.observeOn(scheduler));
    }
    exports.scheduleObservable = scheduleObservable;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduled/schedulePromise.js
var require_schedulePromise = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduled/schedulePromise.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.schedulePromise = void 0;
    var innerFrom_1 = require_innerFrom();
    var observeOn_1 = require_observeOn();
    var subscribeOn_1 = require_subscribeOn();
    function schedulePromise(input, scheduler) {
      return innerFrom_1.innerFrom(input).pipe(subscribeOn_1.subscribeOn(scheduler), observeOn_1.observeOn(scheduler));
    }
    exports.schedulePromise = schedulePromise;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduled/scheduleArray.js
var require_scheduleArray = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduled/scheduleArray.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.scheduleArray = void 0;
    var Observable_1 = require_Observable();
    function scheduleArray(input, scheduler) {
      return new Observable_1.Observable(function(subscriber) {
        var i = 0;
        return scheduler.schedule(function() {
          if (i === input.length) {
            subscriber.complete();
          } else {
            subscriber.next(input[i++]);
            if (!subscriber.closed) {
              this.schedule();
            }
          }
        });
      });
    }
    exports.scheduleArray = scheduleArray;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduled/scheduleIterable.js
var require_scheduleIterable = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduled/scheduleIterable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.scheduleIterable = void 0;
    var Observable_1 = require_Observable();
    var iterator_1 = require_iterator();
    var isFunction_1 = require_isFunction();
    var executeSchedule_1 = require_executeSchedule();
    function scheduleIterable(input, scheduler) {
      return new Observable_1.Observable(function(subscriber) {
        var iterator;
        executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
          iterator = input[iterator_1.iterator]();
          executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
            var _a;
            var value;
            var done;
            try {
              _a = iterator.next(), value = _a.value, done = _a.done;
            } catch (err) {
              subscriber.error(err);
              return;
            }
            if (done) {
              subscriber.complete();
            } else {
              subscriber.next(value);
            }
          }, 0, true);
        });
        return function() {
          return isFunction_1.isFunction(iterator === null || iterator === void 0 ? void 0 : iterator.return) && iterator.return();
        };
      });
    }
    exports.scheduleIterable = scheduleIterable;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduled/scheduleAsyncIterable.js
var require_scheduleAsyncIterable = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduled/scheduleAsyncIterable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.scheduleAsyncIterable = void 0;
    var Observable_1 = require_Observable();
    var executeSchedule_1 = require_executeSchedule();
    function scheduleAsyncIterable(input, scheduler) {
      if (!input) {
        throw new Error("Iterable cannot be null");
      }
      return new Observable_1.Observable(function(subscriber) {
        executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
          var iterator = input[Symbol.asyncIterator]();
          executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
            iterator.next().then(function(result) {
              if (result.done) {
                subscriber.complete();
              } else {
                subscriber.next(result.value);
              }
            });
          }, 0, true);
        });
      });
    }
    exports.scheduleAsyncIterable = scheduleAsyncIterable;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduled/scheduleReadableStreamLike.js
var require_scheduleReadableStreamLike = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduled/scheduleReadableStreamLike.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.scheduleReadableStreamLike = void 0;
    var scheduleAsyncIterable_1 = require_scheduleAsyncIterable();
    var isReadableStreamLike_1 = require_isReadableStreamLike();
    function scheduleReadableStreamLike(input, scheduler) {
      return scheduleAsyncIterable_1.scheduleAsyncIterable(isReadableStreamLike_1.readableStreamLikeToAsyncGenerator(input), scheduler);
    }
    exports.scheduleReadableStreamLike = scheduleReadableStreamLike;
  }
});

// node_modules/rxjs/dist/cjs/internal/scheduled/scheduled.js
var require_scheduled = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/scheduled/scheduled.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.scheduled = void 0;
    var scheduleObservable_1 = require_scheduleObservable();
    var schedulePromise_1 = require_schedulePromise();
    var scheduleArray_1 = require_scheduleArray();
    var scheduleIterable_1 = require_scheduleIterable();
    var scheduleAsyncIterable_1 = require_scheduleAsyncIterable();
    var isInteropObservable_1 = require_isInteropObservable();
    var isPromise_1 = require_isPromise();
    var isArrayLike_1 = require_isArrayLike();
    var isIterable_1 = require_isIterable();
    var isAsyncIterable_1 = require_isAsyncIterable();
    var throwUnobservableError_1 = require_throwUnobservableError();
    var isReadableStreamLike_1 = require_isReadableStreamLike();
    var scheduleReadableStreamLike_1 = require_scheduleReadableStreamLike();
    function scheduled(input, scheduler) {
      if (input != null) {
        if (isInteropObservable_1.isInteropObservable(input)) {
          return scheduleObservable_1.scheduleObservable(input, scheduler);
        }
        if (isArrayLike_1.isArrayLike(input)) {
          return scheduleArray_1.scheduleArray(input, scheduler);
        }
        if (isPromise_1.isPromise(input)) {
          return schedulePromise_1.schedulePromise(input, scheduler);
        }
        if (isAsyncIterable_1.isAsyncIterable(input)) {
          return scheduleAsyncIterable_1.scheduleAsyncIterable(input, scheduler);
        }
        if (isIterable_1.isIterable(input)) {
          return scheduleIterable_1.scheduleIterable(input, scheduler);
        }
        if (isReadableStreamLike_1.isReadableStreamLike(input)) {
          return scheduleReadableStreamLike_1.scheduleReadableStreamLike(input, scheduler);
        }
      }
      throw throwUnobservableError_1.createInvalidObservableTypeError(input);
    }
    exports.scheduled = scheduled;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/from.js
var require_from = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/from.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.from = void 0;
    var scheduled_1 = require_scheduled();
    var innerFrom_1 = require_innerFrom();
    function from(input, scheduler) {
      return scheduler ? scheduled_1.scheduled(input, scheduler) : innerFrom_1.innerFrom(input);
    }
    exports.from = from;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/of.js
var require_of = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/of.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.of = void 0;
    var args_1 = require_args();
    var from_1 = require_from();
    function of() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var scheduler = args_1.popScheduler(args);
      return from_1.from(args, scheduler);
    }
    exports.of = of;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/throwError.js
var require_throwError = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/throwError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.throwError = void 0;
    var Observable_1 = require_Observable();
    var isFunction_1 = require_isFunction();
    function throwError(errorOrErrorFactory, scheduler) {
      var errorFactory = isFunction_1.isFunction(errorOrErrorFactory) ? errorOrErrorFactory : function() {
        return errorOrErrorFactory;
      };
      var init = function(subscriber) {
        return subscriber.error(errorFactory());
      };
      return new Observable_1.Observable(scheduler ? function(subscriber) {
        return scheduler.schedule(init, 0, subscriber);
      } : init);
    }
    exports.throwError = throwError;
  }
});

// node_modules/rxjs/dist/cjs/internal/Notification.js
var require_Notification = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/Notification.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.observeNotification = exports.Notification = exports.NotificationKind = void 0;
    var empty_1 = require_empty();
    var of_1 = require_of();
    var throwError_1 = require_throwError();
    var isFunction_1 = require_isFunction();
    var NotificationKind;
    (function(NotificationKind2) {
      NotificationKind2["NEXT"] = "N";
      NotificationKind2["ERROR"] = "E";
      NotificationKind2["COMPLETE"] = "C";
    })(NotificationKind = exports.NotificationKind || (exports.NotificationKind = {}));
    var Notification = function() {
      function Notification2(kind, value, error) {
        this.kind = kind;
        this.value = value;
        this.error = error;
        this.hasValue = kind === "N";
      }
      Notification2.prototype.observe = function(observer) {
        return observeNotification(this, observer);
      };
      Notification2.prototype.do = function(nextHandler, errorHandler, completeHandler) {
        var _a = this, kind = _a.kind, value = _a.value, error = _a.error;
        return kind === "N" ? nextHandler === null || nextHandler === void 0 ? void 0 : nextHandler(value) : kind === "E" ? errorHandler === null || errorHandler === void 0 ? void 0 : errorHandler(error) : completeHandler === null || completeHandler === void 0 ? void 0 : completeHandler();
      };
      Notification2.prototype.accept = function(nextOrObserver, error, complete) {
        var _a;
        return isFunction_1.isFunction((_a = nextOrObserver) === null || _a === void 0 ? void 0 : _a.next) ? this.observe(nextOrObserver) : this.do(nextOrObserver, error, complete);
      };
      Notification2.prototype.toObservable = function() {
        var _a = this, kind = _a.kind, value = _a.value, error = _a.error;
        var result = kind === "N" ? of_1.of(value) : kind === "E" ? throwError_1.throwError(function() {
          return error;
        }) : kind === "C" ? empty_1.EMPTY : 0;
        if (!result) {
          throw new TypeError("Unexpected notification kind " + kind);
        }
        return result;
      };
      Notification2.createNext = function(value) {
        return new Notification2("N", value);
      };
      Notification2.createError = function(err) {
        return new Notification2("E", void 0, err);
      };
      Notification2.createComplete = function() {
        return Notification2.completeNotification;
      };
      Notification2.completeNotification = new Notification2("C");
      return Notification2;
    }();
    exports.Notification = Notification;
    function observeNotification(notification, observer) {
      var _a, _b, _c;
      var _d = notification, kind = _d.kind, value = _d.value, error = _d.error;
      if (typeof kind !== "string") {
        throw new TypeError('Invalid notification, missing "kind"');
      }
      kind === "N" ? (_a = observer.next) === null || _a === void 0 ? void 0 : _a.call(observer, value) : kind === "E" ? (_b = observer.error) === null || _b === void 0 ? void 0 : _b.call(observer, error) : (_c = observer.complete) === null || _c === void 0 ? void 0 : _c.call(observer);
    }
    exports.observeNotification = observeNotification;
  }
});

// node_modules/rxjs/dist/cjs/internal/util/isObservable.js
var require_isObservable = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/isObservable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isObservable = void 0;
    var Observable_1 = require_Observable();
    var isFunction_1 = require_isFunction();
    function isObservable(obj) {
      return !!obj && (obj instanceof Observable_1.Observable || isFunction_1.isFunction(obj.lift) && isFunction_1.isFunction(obj.subscribe));
    }
    exports.isObservable = isObservable;
  }
});

// node_modules/rxjs/dist/cjs/internal/util/EmptyError.js
var require_EmptyError = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/EmptyError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EmptyError = void 0;
    var createErrorClass_1 = require_createErrorClass();
    exports.EmptyError = createErrorClass_1.createErrorClass(function(_super) {
      return function EmptyErrorImpl() {
        _super(this);
        this.name = "EmptyError";
        this.message = "no elements in sequence";
      };
    });
  }
});

// node_modules/rxjs/dist/cjs/internal/lastValueFrom.js
var require_lastValueFrom = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/lastValueFrom.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.lastValueFrom = void 0;
    var EmptyError_1 = require_EmptyError();
    function lastValueFrom(source, config2) {
      var hasConfig = typeof config2 === "object";
      return new Promise(function(resolve, reject) {
        var _hasValue = false;
        var _value;
        source.subscribe({
          next: function(value) {
            _value = value;
            _hasValue = true;
          },
          error: reject,
          complete: function() {
            if (_hasValue) {
              resolve(_value);
            } else if (hasConfig) {
              resolve(config2.defaultValue);
            } else {
              reject(new EmptyError_1.EmptyError());
            }
          }
        });
      });
    }
    exports.lastValueFrom = lastValueFrom;
  }
});

// node_modules/rxjs/dist/cjs/internal/firstValueFrom.js
var require_firstValueFrom = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/firstValueFrom.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.firstValueFrom = void 0;
    var EmptyError_1 = require_EmptyError();
    var Subscriber_1 = require_Subscriber();
    function firstValueFrom(source, config2) {
      var hasConfig = typeof config2 === "object";
      return new Promise(function(resolve, reject) {
        var subscriber = new Subscriber_1.SafeSubscriber({
          next: function(value) {
            resolve(value);
            subscriber.unsubscribe();
          },
          error: reject,
          complete: function() {
            if (hasConfig) {
              resolve(config2.defaultValue);
            } else {
              reject(new EmptyError_1.EmptyError());
            }
          }
        });
        source.subscribe(subscriber);
      });
    }
    exports.firstValueFrom = firstValueFrom;
  }
});

// node_modules/rxjs/dist/cjs/internal/util/ArgumentOutOfRangeError.js
var require_ArgumentOutOfRangeError = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/ArgumentOutOfRangeError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ArgumentOutOfRangeError = void 0;
    var createErrorClass_1 = require_createErrorClass();
    exports.ArgumentOutOfRangeError = createErrorClass_1.createErrorClass(function(_super) {
      return function ArgumentOutOfRangeErrorImpl() {
        _super(this);
        this.name = "ArgumentOutOfRangeError";
        this.message = "argument out of range";
      };
    });
  }
});

// node_modules/rxjs/dist/cjs/internal/util/NotFoundError.js
var require_NotFoundError = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/NotFoundError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NotFoundError = void 0;
    var createErrorClass_1 = require_createErrorClass();
    exports.NotFoundError = createErrorClass_1.createErrorClass(function(_super) {
      return function NotFoundErrorImpl(message) {
        _super(this);
        this.name = "NotFoundError";
        this.message = message;
      };
    });
  }
});

// node_modules/rxjs/dist/cjs/internal/util/SequenceError.js
var require_SequenceError = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/SequenceError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SequenceError = void 0;
    var createErrorClass_1 = require_createErrorClass();
    exports.SequenceError = createErrorClass_1.createErrorClass(function(_super) {
      return function SequenceErrorImpl(message) {
        _super(this);
        this.name = "SequenceError";
        this.message = message;
      };
    });
  }
});

// node_modules/rxjs/dist/cjs/internal/util/isDate.js
var require_isDate = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/isDate.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isValidDate = void 0;
    function isValidDate(value) {
      return value instanceof Date && !isNaN(value);
    }
    exports.isValidDate = isValidDate;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/timeout.js
var require_timeout = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/timeout.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.timeout = exports.TimeoutError = void 0;
    var async_1 = require_async();
    var isDate_1 = require_isDate();
    var lift_1 = require_lift();
    var innerFrom_1 = require_innerFrom();
    var createErrorClass_1 = require_createErrorClass();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var executeSchedule_1 = require_executeSchedule();
    exports.TimeoutError = createErrorClass_1.createErrorClass(function(_super) {
      return function TimeoutErrorImpl(info) {
        if (info === void 0) {
          info = null;
        }
        _super(this);
        this.message = "Timeout has occurred";
        this.name = "TimeoutError";
        this.info = info;
      };
    });
    function timeout(config2, schedulerArg) {
      var _a = isDate_1.isValidDate(config2) ? { first: config2 } : typeof config2 === "number" ? { each: config2 } : config2, first = _a.first, each = _a.each, _b = _a.with, _with = _b === void 0 ? timeoutErrorFactory : _b, _c = _a.scheduler, scheduler = _c === void 0 ? schedulerArg !== null && schedulerArg !== void 0 ? schedulerArg : async_1.asyncScheduler : _c, _d = _a.meta, meta = _d === void 0 ? null : _d;
      if (first == null && each == null) {
        throw new TypeError("No timeout provided.");
      }
      return lift_1.operate(function(source, subscriber) {
        var originalSourceSubscription;
        var timerSubscription;
        var lastValue = null;
        var seen = 0;
        var startTimer = function(delay) {
          timerSubscription = executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
            try {
              originalSourceSubscription.unsubscribe();
              innerFrom_1.innerFrom(_with({
                meta,
                lastValue,
                seen
              })).subscribe(subscriber);
            } catch (err) {
              subscriber.error(err);
            }
          }, delay);
        };
        originalSourceSubscription = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          timerSubscription === null || timerSubscription === void 0 ? void 0 : timerSubscription.unsubscribe();
          seen++;
          subscriber.next(lastValue = value);
          each > 0 && startTimer(each);
        }, void 0, void 0, function() {
          if (!(timerSubscription === null || timerSubscription === void 0 ? void 0 : timerSubscription.closed)) {
            timerSubscription === null || timerSubscription === void 0 ? void 0 : timerSubscription.unsubscribe();
          }
          lastValue = null;
        }));
        !seen && startTimer(first != null ? typeof first === "number" ? first : +first - scheduler.now() : each);
      });
    }
    exports.timeout = timeout;
    function timeoutErrorFactory(info) {
      throw new exports.TimeoutError(info);
    }
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/map.js
var require_map = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/map.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.map = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function map(project, thisArg) {
      return lift_1.operate(function(source, subscriber) {
        var index = 0;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          subscriber.next(project.call(thisArg, value, index++));
        }));
      });
    }
    exports.map = map;
  }
});

// node_modules/rxjs/dist/cjs/internal/util/mapOneOrManyArgs.js
var require_mapOneOrManyArgs = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/mapOneOrManyArgs.js"(exports) {
    "use strict";
    var __read = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray2 = exports && exports.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mapOneOrManyArgs = void 0;
    var map_1 = require_map();
    var isArray2 = Array.isArray;
    function callOrApply(fn, args) {
      return isArray2(args) ? fn.apply(void 0, __spreadArray2([], __read(args))) : fn(args);
    }
    function mapOneOrManyArgs(fn) {
      return map_1.map(function(args) {
        return callOrApply(fn, args);
      });
    }
    exports.mapOneOrManyArgs = mapOneOrManyArgs;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/bindCallbackInternals.js
var require_bindCallbackInternals = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/bindCallbackInternals.js"(exports) {
    "use strict";
    var __read = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray2 = exports && exports.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bindCallbackInternals = void 0;
    var isScheduler_1 = require_isScheduler();
    var Observable_1 = require_Observable();
    var subscribeOn_1 = require_subscribeOn();
    var mapOneOrManyArgs_1 = require_mapOneOrManyArgs();
    var observeOn_1 = require_observeOn();
    var AsyncSubject_1 = require_AsyncSubject();
    function bindCallbackInternals(isNodeStyle, callbackFunc, resultSelector, scheduler) {
      if (resultSelector) {
        if (isScheduler_1.isScheduler(resultSelector)) {
          scheduler = resultSelector;
        } else {
          return function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            return bindCallbackInternals(isNodeStyle, callbackFunc, scheduler).apply(this, args).pipe(mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector));
          };
        }
      }
      if (scheduler) {
        return function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          return bindCallbackInternals(isNodeStyle, callbackFunc).apply(this, args).pipe(subscribeOn_1.subscribeOn(scheduler), observeOn_1.observeOn(scheduler));
        };
      }
      return function() {
        var _this = this;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var subject = new AsyncSubject_1.AsyncSubject();
        var uninitialized = true;
        return new Observable_1.Observable(function(subscriber) {
          var subs = subject.subscribe(subscriber);
          if (uninitialized) {
            uninitialized = false;
            var isAsync_1 = false;
            var isComplete_1 = false;
            callbackFunc.apply(_this, __spreadArray2(__spreadArray2([], __read(args)), [
              function() {
                var results = [];
                for (var _i2 = 0; _i2 < arguments.length; _i2++) {
                  results[_i2] = arguments[_i2];
                }
                if (isNodeStyle) {
                  var err = results.shift();
                  if (err != null) {
                    subject.error(err);
                    return;
                  }
                }
                subject.next(1 < results.length ? results : results[0]);
                isComplete_1 = true;
                if (isAsync_1) {
                  subject.complete();
                }
              }
            ]));
            if (isComplete_1) {
              subject.complete();
            }
            isAsync_1 = true;
          }
          return subs;
        });
      };
    }
    exports.bindCallbackInternals = bindCallbackInternals;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/bindCallback.js
var require_bindCallback = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/bindCallback.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bindCallback = void 0;
    var bindCallbackInternals_1 = require_bindCallbackInternals();
    function bindCallback(callbackFunc, resultSelector, scheduler) {
      return bindCallbackInternals_1.bindCallbackInternals(false, callbackFunc, resultSelector, scheduler);
    }
    exports.bindCallback = bindCallback;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/bindNodeCallback.js
var require_bindNodeCallback = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/bindNodeCallback.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bindNodeCallback = void 0;
    var bindCallbackInternals_1 = require_bindCallbackInternals();
    function bindNodeCallback(callbackFunc, resultSelector, scheduler) {
      return bindCallbackInternals_1.bindCallbackInternals(true, callbackFunc, resultSelector, scheduler);
    }
    exports.bindNodeCallback = bindNodeCallback;
  }
});

// node_modules/rxjs/dist/cjs/internal/util/argsArgArrayOrObject.js
var require_argsArgArrayOrObject = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/argsArgArrayOrObject.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.argsArgArrayOrObject = void 0;
    var isArray2 = Array.isArray;
    var getPrototypeOf = Object.getPrototypeOf;
    var objectProto = Object.prototype;
    var getKeys = Object.keys;
    function argsArgArrayOrObject(args) {
      if (args.length === 1) {
        var first_1 = args[0];
        if (isArray2(first_1)) {
          return { args: first_1, keys: null };
        }
        if (isPOJO(first_1)) {
          var keys = getKeys(first_1);
          return {
            args: keys.map(function(key) {
              return first_1[key];
            }),
            keys
          };
        }
      }
      return { args, keys: null };
    }
    exports.argsArgArrayOrObject = argsArgArrayOrObject;
    function isPOJO(obj) {
      return obj && typeof obj === "object" && getPrototypeOf(obj) === objectProto;
    }
  }
});

// node_modules/rxjs/dist/cjs/internal/util/createObject.js
var require_createObject = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/createObject.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createObject = void 0;
    function createObject(keys, values) {
      return keys.reduce(function(result, key, i) {
        return result[key] = values[i], result;
      }, {});
    }
    exports.createObject = createObject;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/combineLatest.js
var require_combineLatest = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/combineLatest.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.combineLatestInit = exports.combineLatest = void 0;
    var Observable_1 = require_Observable();
    var argsArgArrayOrObject_1 = require_argsArgArrayOrObject();
    var from_1 = require_from();
    var identity_1 = require_identity();
    var mapOneOrManyArgs_1 = require_mapOneOrManyArgs();
    var args_1 = require_args();
    var createObject_1 = require_createObject();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var executeSchedule_1 = require_executeSchedule();
    function combineLatest() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var scheduler = args_1.popScheduler(args);
      var resultSelector = args_1.popResultSelector(args);
      var _a = argsArgArrayOrObject_1.argsArgArrayOrObject(args), observables = _a.args, keys = _a.keys;
      if (observables.length === 0) {
        return from_1.from([], scheduler);
      }
      var result = new Observable_1.Observable(combineLatestInit(observables, scheduler, keys ? function(values) {
        return createObject_1.createObject(keys, values);
      } : identity_1.identity));
      return resultSelector ? result.pipe(mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector)) : result;
    }
    exports.combineLatest = combineLatest;
    function combineLatestInit(observables, scheduler, valueTransform) {
      if (valueTransform === void 0) {
        valueTransform = identity_1.identity;
      }
      return function(subscriber) {
        maybeSchedule(scheduler, function() {
          var length = observables.length;
          var values = new Array(length);
          var active = length;
          var remainingFirstValues = length;
          var _loop_1 = function(i2) {
            maybeSchedule(scheduler, function() {
              var source = from_1.from(observables[i2], scheduler);
              var hasFirstValue = false;
              source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
                values[i2] = value;
                if (!hasFirstValue) {
                  hasFirstValue = true;
                  remainingFirstValues--;
                }
                if (!remainingFirstValues) {
                  subscriber.next(valueTransform(values.slice()));
                }
              }, function() {
                if (!--active) {
                  subscriber.complete();
                }
              }));
            }, subscriber);
          };
          for (var i = 0; i < length; i++) {
            _loop_1(i);
          }
        }, subscriber);
      };
    }
    exports.combineLatestInit = combineLatestInit;
    function maybeSchedule(scheduler, execute, subscription) {
      if (scheduler) {
        executeSchedule_1.executeSchedule(subscription, scheduler, execute);
      } else {
        execute();
      }
    }
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/mergeInternals.js
var require_mergeInternals = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/mergeInternals.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mergeInternals = void 0;
    var innerFrom_1 = require_innerFrom();
    var executeSchedule_1 = require_executeSchedule();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function mergeInternals(source, subscriber, project, concurrent, onBeforeNext, expand, innerSubScheduler, additionalFinalizer) {
      var buffer = [];
      var active = 0;
      var index = 0;
      var isComplete = false;
      var checkComplete = function() {
        if (isComplete && !buffer.length && !active) {
          subscriber.complete();
        }
      };
      var outerNext = function(value) {
        return active < concurrent ? doInnerSub(value) : buffer.push(value);
      };
      var doInnerSub = function(value) {
        expand && subscriber.next(value);
        active++;
        var innerComplete = false;
        innerFrom_1.innerFrom(project(value, index++)).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(innerValue) {
          onBeforeNext === null || onBeforeNext === void 0 ? void 0 : onBeforeNext(innerValue);
          if (expand) {
            outerNext(innerValue);
          } else {
            subscriber.next(innerValue);
          }
        }, function() {
          innerComplete = true;
        }, void 0, function() {
          if (innerComplete) {
            try {
              active--;
              var _loop_1 = function() {
                var bufferedValue = buffer.shift();
                if (innerSubScheduler) {
                  executeSchedule_1.executeSchedule(subscriber, innerSubScheduler, function() {
                    return doInnerSub(bufferedValue);
                  });
                } else {
                  doInnerSub(bufferedValue);
                }
              };
              while (buffer.length && active < concurrent) {
                _loop_1();
              }
              checkComplete();
            } catch (err) {
              subscriber.error(err);
            }
          }
        }));
      };
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, outerNext, function() {
        isComplete = true;
        checkComplete();
      }));
      return function() {
        additionalFinalizer === null || additionalFinalizer === void 0 ? void 0 : additionalFinalizer();
      };
    }
    exports.mergeInternals = mergeInternals;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/mergeMap.js
var require_mergeMap = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/mergeMap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mergeMap = void 0;
    var map_1 = require_map();
    var innerFrom_1 = require_innerFrom();
    var lift_1 = require_lift();
    var mergeInternals_1 = require_mergeInternals();
    var isFunction_1 = require_isFunction();
    function mergeMap(project, resultSelector, concurrent) {
      if (concurrent === void 0) {
        concurrent = Infinity;
      }
      if (isFunction_1.isFunction(resultSelector)) {
        return mergeMap(function(a, i) {
          return map_1.map(function(b, ii) {
            return resultSelector(a, b, i, ii);
          })(innerFrom_1.innerFrom(project(a, i)));
        }, concurrent);
      } else if (typeof resultSelector === "number") {
        concurrent = resultSelector;
      }
      return lift_1.operate(function(source, subscriber) {
        return mergeInternals_1.mergeInternals(source, subscriber, project, concurrent);
      });
    }
    exports.mergeMap = mergeMap;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/mergeAll.js
var require_mergeAll = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/mergeAll.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mergeAll = void 0;
    var mergeMap_1 = require_mergeMap();
    var identity_1 = require_identity();
    function mergeAll(concurrent) {
      if (concurrent === void 0) {
        concurrent = Infinity;
      }
      return mergeMap_1.mergeMap(identity_1.identity, concurrent);
    }
    exports.mergeAll = mergeAll;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/concatAll.js
var require_concatAll = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/concatAll.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.concatAll = void 0;
    var mergeAll_1 = require_mergeAll();
    function concatAll() {
      return mergeAll_1.mergeAll(1);
    }
    exports.concatAll = concatAll;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/concat.js
var require_concat = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/concat.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.concat = void 0;
    var concatAll_1 = require_concatAll();
    var args_1 = require_args();
    var from_1 = require_from();
    function concat() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return concatAll_1.concatAll()(from_1.from(args, args_1.popScheduler(args)));
    }
    exports.concat = concat;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/defer.js
var require_defer = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/defer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.defer = void 0;
    var Observable_1 = require_Observable();
    var innerFrom_1 = require_innerFrom();
    function defer(observableFactory) {
      return new Observable_1.Observable(function(subscriber) {
        innerFrom_1.innerFrom(observableFactory()).subscribe(subscriber);
      });
    }
    exports.defer = defer;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/connectable.js
var require_connectable = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/connectable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.connectable = void 0;
    var Subject_1 = require_Subject();
    var Observable_1 = require_Observable();
    var defer_1 = require_defer();
    var DEFAULT_CONFIG = {
      connector: function() {
        return new Subject_1.Subject();
      },
      resetOnDisconnect: true
    };
    function connectable(source, config2) {
      if (config2 === void 0) {
        config2 = DEFAULT_CONFIG;
      }
      var connection = null;
      var connector = config2.connector, _a = config2.resetOnDisconnect, resetOnDisconnect = _a === void 0 ? true : _a;
      var subject = connector();
      var result = new Observable_1.Observable(function(subscriber) {
        return subject.subscribe(subscriber);
      });
      result.connect = function() {
        if (!connection || connection.closed) {
          connection = defer_1.defer(function() {
            return source;
          }).subscribe(subject);
          if (resetOnDisconnect) {
            connection.add(function() {
              return subject = connector();
            });
          }
        }
        return connection;
      };
      return result;
    }
    exports.connectable = connectable;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/forkJoin.js
var require_forkJoin = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/forkJoin.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.forkJoin = void 0;
    var Observable_1 = require_Observable();
    var argsArgArrayOrObject_1 = require_argsArgArrayOrObject();
    var innerFrom_1 = require_innerFrom();
    var args_1 = require_args();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var mapOneOrManyArgs_1 = require_mapOneOrManyArgs();
    var createObject_1 = require_createObject();
    function forkJoin() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var resultSelector = args_1.popResultSelector(args);
      var _a = argsArgArrayOrObject_1.argsArgArrayOrObject(args), sources = _a.args, keys = _a.keys;
      var result = new Observable_1.Observable(function(subscriber) {
        var length = sources.length;
        if (!length) {
          subscriber.complete();
          return;
        }
        var values = new Array(length);
        var remainingCompletions = length;
        var remainingEmissions = length;
        var _loop_1 = function(sourceIndex2) {
          var hasValue = false;
          innerFrom_1.innerFrom(sources[sourceIndex2]).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
            if (!hasValue) {
              hasValue = true;
              remainingEmissions--;
            }
            values[sourceIndex2] = value;
          }, function() {
            return remainingCompletions--;
          }, void 0, function() {
            if (!remainingCompletions || !hasValue) {
              if (!remainingEmissions) {
                subscriber.next(keys ? createObject_1.createObject(keys, values) : values);
              }
              subscriber.complete();
            }
          }));
        };
        for (var sourceIndex = 0; sourceIndex < length; sourceIndex++) {
          _loop_1(sourceIndex);
        }
      });
      return resultSelector ? result.pipe(mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector)) : result;
    }
    exports.forkJoin = forkJoin;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/fromEvent.js
var require_fromEvent = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/fromEvent.js"(exports) {
    "use strict";
    var __read = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fromEvent = void 0;
    var innerFrom_1 = require_innerFrom();
    var Observable_1 = require_Observable();
    var mergeMap_1 = require_mergeMap();
    var isArrayLike_1 = require_isArrayLike();
    var isFunction_1 = require_isFunction();
    var mapOneOrManyArgs_1 = require_mapOneOrManyArgs();
    var nodeEventEmitterMethods = ["addListener", "removeListener"];
    var eventTargetMethods = ["addEventListener", "removeEventListener"];
    var jqueryMethods = ["on", "off"];
    function fromEvent(target, eventName, options, resultSelector) {
      if (isFunction_1.isFunction(options)) {
        resultSelector = options;
        options = void 0;
      }
      if (resultSelector) {
        return fromEvent(target, eventName, options).pipe(mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector));
      }
      var _a = __read(isEventTarget(target) ? eventTargetMethods.map(function(methodName) {
        return function(handler) {
          return target[methodName](eventName, handler, options);
        };
      }) : isNodeStyleEventEmitter(target) ? nodeEventEmitterMethods.map(toCommonHandlerRegistry(target, eventName)) : isJQueryStyleEventEmitter(target) ? jqueryMethods.map(toCommonHandlerRegistry(target, eventName)) : [], 2), add = _a[0], remove = _a[1];
      if (!add) {
        if (isArrayLike_1.isArrayLike(target)) {
          return mergeMap_1.mergeMap(function(subTarget) {
            return fromEvent(subTarget, eventName, options);
          })(innerFrom_1.innerFrom(target));
        }
      }
      if (!add) {
        throw new TypeError("Invalid event target");
      }
      return new Observable_1.Observable(function(subscriber) {
        var handler = function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          return subscriber.next(1 < args.length ? args : args[0]);
        };
        add(handler);
        return function() {
          return remove(handler);
        };
      });
    }
    exports.fromEvent = fromEvent;
    function toCommonHandlerRegistry(target, eventName) {
      return function(methodName) {
        return function(handler) {
          return target[methodName](eventName, handler);
        };
      };
    }
    function isNodeStyleEventEmitter(target) {
      return isFunction_1.isFunction(target.addListener) && isFunction_1.isFunction(target.removeListener);
    }
    function isJQueryStyleEventEmitter(target) {
      return isFunction_1.isFunction(target.on) && isFunction_1.isFunction(target.off);
    }
    function isEventTarget(target) {
      return isFunction_1.isFunction(target.addEventListener) && isFunction_1.isFunction(target.removeEventListener);
    }
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/fromEventPattern.js
var require_fromEventPattern = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/fromEventPattern.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fromEventPattern = void 0;
    var Observable_1 = require_Observable();
    var isFunction_1 = require_isFunction();
    var mapOneOrManyArgs_1 = require_mapOneOrManyArgs();
    function fromEventPattern(addHandler, removeHandler, resultSelector) {
      if (resultSelector) {
        return fromEventPattern(addHandler, removeHandler).pipe(mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector));
      }
      return new Observable_1.Observable(function(subscriber) {
        var handler = function() {
          var e = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            e[_i] = arguments[_i];
          }
          return subscriber.next(e.length === 1 ? e[0] : e);
        };
        var retValue = addHandler(handler);
        return isFunction_1.isFunction(removeHandler) ? function() {
          return removeHandler(handler, retValue);
        } : void 0;
      });
    }
    exports.fromEventPattern = fromEventPattern;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/generate.js
var require_generate = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/generate.js"(exports) {
    "use strict";
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.generate = void 0;
    var identity_1 = require_identity();
    var isScheduler_1 = require_isScheduler();
    var defer_1 = require_defer();
    var scheduleIterable_1 = require_scheduleIterable();
    function generate(initialStateOrOptions, condition, iterate, resultSelectorOrScheduler, scheduler) {
      var _a, _b;
      var resultSelector;
      var initialState;
      if (arguments.length === 1) {
        _a = initialStateOrOptions, initialState = _a.initialState, condition = _a.condition, iterate = _a.iterate, _b = _a.resultSelector, resultSelector = _b === void 0 ? identity_1.identity : _b, scheduler = _a.scheduler;
      } else {
        initialState = initialStateOrOptions;
        if (!resultSelectorOrScheduler || isScheduler_1.isScheduler(resultSelectorOrScheduler)) {
          resultSelector = identity_1.identity;
          scheduler = resultSelectorOrScheduler;
        } else {
          resultSelector = resultSelectorOrScheduler;
        }
      }
      function gen() {
        var state;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              state = initialState;
              _a2.label = 1;
            case 1:
              if (!(!condition || condition(state)))
                return [3, 4];
              return [4, resultSelector(state)];
            case 2:
              _a2.sent();
              _a2.label = 3;
            case 3:
              state = iterate(state);
              return [3, 1];
            case 4:
              return [2];
          }
        });
      }
      return defer_1.defer(scheduler ? function() {
        return scheduleIterable_1.scheduleIterable(gen(), scheduler);
      } : gen);
    }
    exports.generate = generate;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/iif.js
var require_iif = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/iif.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.iif = void 0;
    var defer_1 = require_defer();
    function iif(condition, trueResult, falseResult) {
      return defer_1.defer(function() {
        return condition() ? trueResult : falseResult;
      });
    }
    exports.iif = iif;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/timer.js
var require_timer = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/timer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.timer = void 0;
    var Observable_1 = require_Observable();
    var async_1 = require_async();
    var isScheduler_1 = require_isScheduler();
    var isDate_1 = require_isDate();
    function timer(dueTime, intervalOrScheduler, scheduler) {
      if (dueTime === void 0) {
        dueTime = 0;
      }
      if (scheduler === void 0) {
        scheduler = async_1.async;
      }
      var intervalDuration = -1;
      if (intervalOrScheduler != null) {
        if (isScheduler_1.isScheduler(intervalOrScheduler)) {
          scheduler = intervalOrScheduler;
        } else {
          intervalDuration = intervalOrScheduler;
        }
      }
      return new Observable_1.Observable(function(subscriber) {
        var due = isDate_1.isValidDate(dueTime) ? +dueTime - scheduler.now() : dueTime;
        if (due < 0) {
          due = 0;
        }
        var n = 0;
        return scheduler.schedule(function() {
          if (!subscriber.closed) {
            subscriber.next(n++);
            if (0 <= intervalDuration) {
              this.schedule(void 0, intervalDuration);
            } else {
              subscriber.complete();
            }
          }
        }, due);
      });
    }
    exports.timer = timer;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/interval.js
var require_interval = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/interval.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.interval = void 0;
    var async_1 = require_async();
    var timer_1 = require_timer();
    function interval(period, scheduler) {
      if (period === void 0) {
        period = 0;
      }
      if (scheduler === void 0) {
        scheduler = async_1.asyncScheduler;
      }
      if (period < 0) {
        period = 0;
      }
      return timer_1.timer(period, period, scheduler);
    }
    exports.interval = interval;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/merge.js
var require_merge = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/merge.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.merge = void 0;
    var mergeAll_1 = require_mergeAll();
    var innerFrom_1 = require_innerFrom();
    var empty_1 = require_empty();
    var args_1 = require_args();
    var from_1 = require_from();
    function merge() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var scheduler = args_1.popScheduler(args);
      var concurrent = args_1.popNumber(args, Infinity);
      var sources = args;
      return !sources.length ? empty_1.EMPTY : sources.length === 1 ? innerFrom_1.innerFrom(sources[0]) : mergeAll_1.mergeAll(concurrent)(from_1.from(sources, scheduler));
    }
    exports.merge = merge;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/never.js
var require_never = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/never.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.never = exports.NEVER = void 0;
    var Observable_1 = require_Observable();
    var noop_1 = require_noop();
    exports.NEVER = new Observable_1.Observable(noop_1.noop);
    function never() {
      return exports.NEVER;
    }
    exports.never = never;
  }
});

// node_modules/rxjs/dist/cjs/internal/util/argsOrArgArray.js
var require_argsOrArgArray = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/argsOrArgArray.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.argsOrArgArray = void 0;
    var isArray2 = Array.isArray;
    function argsOrArgArray(args) {
      return args.length === 1 && isArray2(args[0]) ? args[0] : args;
    }
    exports.argsOrArgArray = argsOrArgArray;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/onErrorResumeNext.js
var require_onErrorResumeNext = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/onErrorResumeNext.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.onErrorResumeNext = void 0;
    var Observable_1 = require_Observable();
    var argsOrArgArray_1 = require_argsOrArgArray();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var noop_1 = require_noop();
    var innerFrom_1 = require_innerFrom();
    function onErrorResumeNext() {
      var sources = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        sources[_i] = arguments[_i];
      }
      var nextSources = argsOrArgArray_1.argsOrArgArray(sources);
      return new Observable_1.Observable(function(subscriber) {
        var sourceIndex = 0;
        var subscribeNext = function() {
          if (sourceIndex < nextSources.length) {
            var nextSource = void 0;
            try {
              nextSource = innerFrom_1.innerFrom(nextSources[sourceIndex++]);
            } catch (err) {
              subscribeNext();
              return;
            }
            var innerSubscriber = new OperatorSubscriber_1.OperatorSubscriber(subscriber, void 0, noop_1.noop, noop_1.noop);
            nextSource.subscribe(innerSubscriber);
            innerSubscriber.add(subscribeNext);
          } else {
            subscriber.complete();
          }
        };
        subscribeNext();
      });
    }
    exports.onErrorResumeNext = onErrorResumeNext;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/pairs.js
var require_pairs = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/pairs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.pairs = void 0;
    var from_1 = require_from();
    function pairs(obj, scheduler) {
      return from_1.from(Object.entries(obj), scheduler);
    }
    exports.pairs = pairs;
  }
});

// node_modules/rxjs/dist/cjs/internal/util/not.js
var require_not = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/util/not.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.not = void 0;
    function not(pred, thisArg) {
      return function(value, index) {
        return !pred.call(thisArg, value, index);
      };
    }
    exports.not = not;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/filter.js
var require_filter = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/filter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.filter = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function filter(predicate, thisArg) {
      return lift_1.operate(function(source, subscriber) {
        var index = 0;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          return predicate.call(thisArg, value, index++) && subscriber.next(value);
        }));
      });
    }
    exports.filter = filter;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/partition.js
var require_partition = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/partition.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.partition = void 0;
    var not_1 = require_not();
    var filter_1 = require_filter();
    var innerFrom_1 = require_innerFrom();
    function partition(source, predicate, thisArg) {
      return [filter_1.filter(predicate, thisArg)(innerFrom_1.innerFrom(source)), filter_1.filter(not_1.not(predicate, thisArg))(innerFrom_1.innerFrom(source))];
    }
    exports.partition = partition;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/race.js
var require_race = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/race.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.raceInit = exports.race = void 0;
    var Observable_1 = require_Observable();
    var innerFrom_1 = require_innerFrom();
    var argsOrArgArray_1 = require_argsOrArgArray();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function race() {
      var sources = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        sources[_i] = arguments[_i];
      }
      sources = argsOrArgArray_1.argsOrArgArray(sources);
      return sources.length === 1 ? innerFrom_1.innerFrom(sources[0]) : new Observable_1.Observable(raceInit(sources));
    }
    exports.race = race;
    function raceInit(sources) {
      return function(subscriber) {
        var subscriptions = [];
        var _loop_1 = function(i2) {
          subscriptions.push(innerFrom_1.innerFrom(sources[i2]).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
            if (subscriptions) {
              for (var s = 0; s < subscriptions.length; s++) {
                s !== i2 && subscriptions[s].unsubscribe();
              }
              subscriptions = null;
            }
            subscriber.next(value);
          })));
        };
        for (var i = 0; subscriptions && !subscriber.closed && i < sources.length; i++) {
          _loop_1(i);
        }
      };
    }
    exports.raceInit = raceInit;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/range.js
var require_range = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/range.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.range = void 0;
    var Observable_1 = require_Observable();
    var empty_1 = require_empty();
    function range(start, count, scheduler) {
      if (count == null) {
        count = start;
        start = 0;
      }
      if (count <= 0) {
        return empty_1.EMPTY;
      }
      var end = count + start;
      return new Observable_1.Observable(scheduler ? function(subscriber) {
        var n = start;
        return scheduler.schedule(function() {
          if (n < end) {
            subscriber.next(n++);
            this.schedule();
          } else {
            subscriber.complete();
          }
        });
      } : function(subscriber) {
        var n = start;
        while (n < end && !subscriber.closed) {
          subscriber.next(n++);
        }
        subscriber.complete();
      });
    }
    exports.range = range;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/using.js
var require_using = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/using.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.using = void 0;
    var Observable_1 = require_Observable();
    var innerFrom_1 = require_innerFrom();
    var empty_1 = require_empty();
    function using(resourceFactory, observableFactory) {
      return new Observable_1.Observable(function(subscriber) {
        var resource = resourceFactory();
        var result = observableFactory(resource);
        var source = result ? innerFrom_1.innerFrom(result) : empty_1.EMPTY;
        source.subscribe(subscriber);
        return function() {
          if (resource) {
            resource.unsubscribe();
          }
        };
      });
    }
    exports.using = using;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/zip.js
var require_zip = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/zip.js"(exports) {
    "use strict";
    var __read = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray2 = exports && exports.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.zip = void 0;
    var Observable_1 = require_Observable();
    var innerFrom_1 = require_innerFrom();
    var argsOrArgArray_1 = require_argsOrArgArray();
    var empty_1 = require_empty();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var args_1 = require_args();
    function zip() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var resultSelector = args_1.popResultSelector(args);
      var sources = argsOrArgArray_1.argsOrArgArray(args);
      return sources.length ? new Observable_1.Observable(function(subscriber) {
        var buffers = sources.map(function() {
          return [];
        });
        var completed = sources.map(function() {
          return false;
        });
        subscriber.add(function() {
          buffers = completed = null;
        });
        var _loop_1 = function(sourceIndex2) {
          innerFrom_1.innerFrom(sources[sourceIndex2]).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
            buffers[sourceIndex2].push(value);
            if (buffers.every(function(buffer) {
              return buffer.length;
            })) {
              var result = buffers.map(function(buffer) {
                return buffer.shift();
              });
              subscriber.next(resultSelector ? resultSelector.apply(void 0, __spreadArray2([], __read(result))) : result);
              if (buffers.some(function(buffer, i) {
                return !buffer.length && completed[i];
              })) {
                subscriber.complete();
              }
            }
          }, function() {
            completed[sourceIndex2] = true;
            !buffers[sourceIndex2].length && subscriber.complete();
          }));
        };
        for (var sourceIndex = 0; !subscriber.closed && sourceIndex < sources.length; sourceIndex++) {
          _loop_1(sourceIndex);
        }
        return function() {
          buffers = completed = null;
        };
      }) : empty_1.EMPTY;
    }
    exports.zip = zip;
  }
});

// node_modules/rxjs/dist/cjs/internal/types.js
var require_types = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/audit.js
var require_audit = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/audit.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.audit = void 0;
    var lift_1 = require_lift();
    var innerFrom_1 = require_innerFrom();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function audit(durationSelector) {
      return lift_1.operate(function(source, subscriber) {
        var hasValue = false;
        var lastValue = null;
        var durationSubscriber = null;
        var isComplete = false;
        var endDuration = function() {
          durationSubscriber === null || durationSubscriber === void 0 ? void 0 : durationSubscriber.unsubscribe();
          durationSubscriber = null;
          if (hasValue) {
            hasValue = false;
            var value = lastValue;
            lastValue = null;
            subscriber.next(value);
          }
          isComplete && subscriber.complete();
        };
        var cleanupDuration = function() {
          durationSubscriber = null;
          isComplete && subscriber.complete();
        };
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          hasValue = true;
          lastValue = value;
          if (!durationSubscriber) {
            innerFrom_1.innerFrom(durationSelector(value)).subscribe(durationSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, endDuration, cleanupDuration));
          }
        }, function() {
          isComplete = true;
          (!hasValue || !durationSubscriber || durationSubscriber.closed) && subscriber.complete();
        }));
      });
    }
    exports.audit = audit;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/auditTime.js
var require_auditTime = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/auditTime.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.auditTime = void 0;
    var async_1 = require_async();
    var audit_1 = require_audit();
    var timer_1 = require_timer();
    function auditTime(duration, scheduler) {
      if (scheduler === void 0) {
        scheduler = async_1.asyncScheduler;
      }
      return audit_1.audit(function() {
        return timer_1.timer(duration, scheduler);
      });
    }
    exports.auditTime = auditTime;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/buffer.js
var require_buffer = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/buffer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.buffer = void 0;
    var lift_1 = require_lift();
    var noop_1 = require_noop();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var innerFrom_1 = require_innerFrom();
    function buffer(closingNotifier) {
      return lift_1.operate(function(source, subscriber) {
        var currentBuffer = [];
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          return currentBuffer.push(value);
        }, function() {
          subscriber.next(currentBuffer);
          subscriber.complete();
        }));
        innerFrom_1.innerFrom(closingNotifier).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
          var b = currentBuffer;
          currentBuffer = [];
          subscriber.next(b);
        }, noop_1.noop));
        return function() {
          currentBuffer = null;
        };
      });
    }
    exports.buffer = buffer;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/bufferCount.js
var require_bufferCount = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/bufferCount.js"(exports) {
    "use strict";
    var __values = exports && exports.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = void 0;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bufferCount = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var arrRemove_1 = require_arrRemove();
    function bufferCount(bufferSize, startBufferEvery) {
      if (startBufferEvery === void 0) {
        startBufferEvery = null;
      }
      startBufferEvery = startBufferEvery !== null && startBufferEvery !== void 0 ? startBufferEvery : bufferSize;
      return lift_1.operate(function(source, subscriber) {
        var buffers = [];
        var count = 0;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          var e_1, _a, e_2, _b;
          var toEmit = null;
          if (count++ % startBufferEvery === 0) {
            buffers.push([]);
          }
          try {
            for (var buffers_1 = __values(buffers), buffers_1_1 = buffers_1.next(); !buffers_1_1.done; buffers_1_1 = buffers_1.next()) {
              var buffer = buffers_1_1.value;
              buffer.push(value);
              if (bufferSize <= buffer.length) {
                toEmit = toEmit !== null && toEmit !== void 0 ? toEmit : [];
                toEmit.push(buffer);
              }
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (buffers_1_1 && !buffers_1_1.done && (_a = buffers_1.return))
                _a.call(buffers_1);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
          if (toEmit) {
            try {
              for (var toEmit_1 = __values(toEmit), toEmit_1_1 = toEmit_1.next(); !toEmit_1_1.done; toEmit_1_1 = toEmit_1.next()) {
                var buffer = toEmit_1_1.value;
                arrRemove_1.arrRemove(buffers, buffer);
                subscriber.next(buffer);
              }
            } catch (e_2_1) {
              e_2 = { error: e_2_1 };
            } finally {
              try {
                if (toEmit_1_1 && !toEmit_1_1.done && (_b = toEmit_1.return))
                  _b.call(toEmit_1);
              } finally {
                if (e_2)
                  throw e_2.error;
              }
            }
          }
        }, function() {
          var e_3, _a;
          try {
            for (var buffers_2 = __values(buffers), buffers_2_1 = buffers_2.next(); !buffers_2_1.done; buffers_2_1 = buffers_2.next()) {
              var buffer = buffers_2_1.value;
              subscriber.next(buffer);
            }
          } catch (e_3_1) {
            e_3 = { error: e_3_1 };
          } finally {
            try {
              if (buffers_2_1 && !buffers_2_1.done && (_a = buffers_2.return))
                _a.call(buffers_2);
            } finally {
              if (e_3)
                throw e_3.error;
            }
          }
          subscriber.complete();
        }, void 0, function() {
          buffers = null;
        }));
      });
    }
    exports.bufferCount = bufferCount;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/bufferTime.js
var require_bufferTime = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/bufferTime.js"(exports) {
    "use strict";
    var __values = exports && exports.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = void 0;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bufferTime = void 0;
    var Subscription_1 = require_Subscription();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var arrRemove_1 = require_arrRemove();
    var async_1 = require_async();
    var args_1 = require_args();
    var executeSchedule_1 = require_executeSchedule();
    function bufferTime(bufferTimeSpan) {
      var _a, _b;
      var otherArgs = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        otherArgs[_i - 1] = arguments[_i];
      }
      var scheduler = (_a = args_1.popScheduler(otherArgs)) !== null && _a !== void 0 ? _a : async_1.asyncScheduler;
      var bufferCreationInterval = (_b = otherArgs[0]) !== null && _b !== void 0 ? _b : null;
      var maxBufferSize = otherArgs[1] || Infinity;
      return lift_1.operate(function(source, subscriber) {
        var bufferRecords = [];
        var restartOnEmit = false;
        var emit = function(record) {
          var buffer = record.buffer, subs = record.subs;
          subs.unsubscribe();
          arrRemove_1.arrRemove(bufferRecords, record);
          subscriber.next(buffer);
          restartOnEmit && startBuffer();
        };
        var startBuffer = function() {
          if (bufferRecords) {
            var subs = new Subscription_1.Subscription();
            subscriber.add(subs);
            var buffer = [];
            var record_1 = {
              buffer,
              subs
            };
            bufferRecords.push(record_1);
            executeSchedule_1.executeSchedule(subs, scheduler, function() {
              return emit(record_1);
            }, bufferTimeSpan);
          }
        };
        if (bufferCreationInterval !== null && bufferCreationInterval >= 0) {
          executeSchedule_1.executeSchedule(subscriber, scheduler, startBuffer, bufferCreationInterval, true);
        } else {
          restartOnEmit = true;
        }
        startBuffer();
        var bufferTimeSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          var e_1, _a2;
          var recordsCopy = bufferRecords.slice();
          try {
            for (var recordsCopy_1 = __values(recordsCopy), recordsCopy_1_1 = recordsCopy_1.next(); !recordsCopy_1_1.done; recordsCopy_1_1 = recordsCopy_1.next()) {
              var record = recordsCopy_1_1.value;
              var buffer = record.buffer;
              buffer.push(value);
              maxBufferSize <= buffer.length && emit(record);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (recordsCopy_1_1 && !recordsCopy_1_1.done && (_a2 = recordsCopy_1.return))
                _a2.call(recordsCopy_1);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
        }, function() {
          while (bufferRecords === null || bufferRecords === void 0 ? void 0 : bufferRecords.length) {
            subscriber.next(bufferRecords.shift().buffer);
          }
          bufferTimeSubscriber === null || bufferTimeSubscriber === void 0 ? void 0 : bufferTimeSubscriber.unsubscribe();
          subscriber.complete();
          subscriber.unsubscribe();
        }, void 0, function() {
          return bufferRecords = null;
        });
        source.subscribe(bufferTimeSubscriber);
      });
    }
    exports.bufferTime = bufferTime;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/bufferToggle.js
var require_bufferToggle = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/bufferToggle.js"(exports) {
    "use strict";
    var __values = exports && exports.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = void 0;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bufferToggle = void 0;
    var Subscription_1 = require_Subscription();
    var lift_1 = require_lift();
    var innerFrom_1 = require_innerFrom();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var noop_1 = require_noop();
    var arrRemove_1 = require_arrRemove();
    function bufferToggle(openings, closingSelector) {
      return lift_1.operate(function(source, subscriber) {
        var buffers = [];
        innerFrom_1.innerFrom(openings).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(openValue) {
          var buffer = [];
          buffers.push(buffer);
          var closingSubscription = new Subscription_1.Subscription();
          var emitBuffer = function() {
            arrRemove_1.arrRemove(buffers, buffer);
            subscriber.next(buffer);
            closingSubscription.unsubscribe();
          };
          closingSubscription.add(innerFrom_1.innerFrom(closingSelector(openValue)).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, emitBuffer, noop_1.noop)));
        }, noop_1.noop));
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          var e_1, _a;
          try {
            for (var buffers_1 = __values(buffers), buffers_1_1 = buffers_1.next(); !buffers_1_1.done; buffers_1_1 = buffers_1.next()) {
              var buffer = buffers_1_1.value;
              buffer.push(value);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (buffers_1_1 && !buffers_1_1.done && (_a = buffers_1.return))
                _a.call(buffers_1);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
        }, function() {
          while (buffers.length > 0) {
            subscriber.next(buffers.shift());
          }
          subscriber.complete();
        }));
      });
    }
    exports.bufferToggle = bufferToggle;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/bufferWhen.js
var require_bufferWhen = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/bufferWhen.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bufferWhen = void 0;
    var lift_1 = require_lift();
    var noop_1 = require_noop();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var innerFrom_1 = require_innerFrom();
    function bufferWhen(closingSelector) {
      return lift_1.operate(function(source, subscriber) {
        var buffer = null;
        var closingSubscriber = null;
        var openBuffer = function() {
          closingSubscriber === null || closingSubscriber === void 0 ? void 0 : closingSubscriber.unsubscribe();
          var b = buffer;
          buffer = [];
          b && subscriber.next(b);
          innerFrom_1.innerFrom(closingSelector()).subscribe(closingSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, openBuffer, noop_1.noop));
        };
        openBuffer();
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          return buffer === null || buffer === void 0 ? void 0 : buffer.push(value);
        }, function() {
          buffer && subscriber.next(buffer);
          subscriber.complete();
        }, void 0, function() {
          return buffer = closingSubscriber = null;
        }));
      });
    }
    exports.bufferWhen = bufferWhen;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/catchError.js
var require_catchError = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/catchError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.catchError = void 0;
    var innerFrom_1 = require_innerFrom();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var lift_1 = require_lift();
    function catchError(selector) {
      return lift_1.operate(function(source, subscriber) {
        var innerSub = null;
        var syncUnsub = false;
        var handledResult;
        innerSub = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, void 0, void 0, function(err) {
          handledResult = innerFrom_1.innerFrom(selector(err, catchError(selector)(source)));
          if (innerSub) {
            innerSub.unsubscribe();
            innerSub = null;
            handledResult.subscribe(subscriber);
          } else {
            syncUnsub = true;
          }
        }));
        if (syncUnsub) {
          innerSub.unsubscribe();
          innerSub = null;
          handledResult.subscribe(subscriber);
        }
      });
    }
    exports.catchError = catchError;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/scanInternals.js
var require_scanInternals = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/scanInternals.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.scanInternals = void 0;
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function scanInternals(accumulator, seed, hasSeed, emitOnNext, emitBeforeComplete) {
      return function(source, subscriber) {
        var hasState = hasSeed;
        var state = seed;
        var index = 0;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          var i = index++;
          state = hasState ? accumulator(state, value, i) : (hasState = true, value);
          emitOnNext && subscriber.next(state);
        }, emitBeforeComplete && function() {
          hasState && subscriber.next(state);
          subscriber.complete();
        }));
      };
    }
    exports.scanInternals = scanInternals;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/reduce.js
var require_reduce = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/reduce.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.reduce = void 0;
    var scanInternals_1 = require_scanInternals();
    var lift_1 = require_lift();
    function reduce(accumulator, seed) {
      return lift_1.operate(scanInternals_1.scanInternals(accumulator, seed, arguments.length >= 2, false, true));
    }
    exports.reduce = reduce;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/toArray.js
var require_toArray = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/toArray.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toArray = void 0;
    var reduce_1 = require_reduce();
    var lift_1 = require_lift();
    var arrReducer = function(arr, value) {
      return arr.push(value), arr;
    };
    function toArray() {
      return lift_1.operate(function(source, subscriber) {
        reduce_1.reduce(arrReducer, [])(source).subscribe(subscriber);
      });
    }
    exports.toArray = toArray;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/joinAllInternals.js
var require_joinAllInternals = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/joinAllInternals.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.joinAllInternals = void 0;
    var identity_1 = require_identity();
    var mapOneOrManyArgs_1 = require_mapOneOrManyArgs();
    var pipe_1 = require_pipe();
    var mergeMap_1 = require_mergeMap();
    var toArray_1 = require_toArray();
    function joinAllInternals(joinFn, project) {
      return pipe_1.pipe(toArray_1.toArray(), mergeMap_1.mergeMap(function(sources) {
        return joinFn(sources);
      }), project ? mapOneOrManyArgs_1.mapOneOrManyArgs(project) : identity_1.identity);
    }
    exports.joinAllInternals = joinAllInternals;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/combineLatestAll.js
var require_combineLatestAll = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/combineLatestAll.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.combineLatestAll = void 0;
    var combineLatest_1 = require_combineLatest();
    var joinAllInternals_1 = require_joinAllInternals();
    function combineLatestAll(project) {
      return joinAllInternals_1.joinAllInternals(combineLatest_1.combineLatest, project);
    }
    exports.combineLatestAll = combineLatestAll;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/combineAll.js
var require_combineAll = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/combineAll.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.combineAll = void 0;
    var combineLatestAll_1 = require_combineLatestAll();
    exports.combineAll = combineLatestAll_1.combineLatestAll;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/combineLatest.js
var require_combineLatest2 = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/combineLatest.js"(exports) {
    "use strict";
    var __read = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray2 = exports && exports.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.combineLatest = void 0;
    var combineLatest_1 = require_combineLatest();
    var lift_1 = require_lift();
    var argsOrArgArray_1 = require_argsOrArgArray();
    var mapOneOrManyArgs_1 = require_mapOneOrManyArgs();
    var pipe_1 = require_pipe();
    var args_1 = require_args();
    function combineLatest() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var resultSelector = args_1.popResultSelector(args);
      return resultSelector ? pipe_1.pipe(combineLatest.apply(void 0, __spreadArray2([], __read(args))), mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector)) : lift_1.operate(function(source, subscriber) {
        combineLatest_1.combineLatestInit(__spreadArray2([source], __read(argsOrArgArray_1.argsOrArgArray(args))))(subscriber);
      });
    }
    exports.combineLatest = combineLatest;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/combineLatestWith.js
var require_combineLatestWith = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/combineLatestWith.js"(exports) {
    "use strict";
    var __read = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray2 = exports && exports.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.combineLatestWith = void 0;
    var combineLatest_1 = require_combineLatest2();
    function combineLatestWith() {
      var otherSources = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        otherSources[_i] = arguments[_i];
      }
      return combineLatest_1.combineLatest.apply(void 0, __spreadArray2([], __read(otherSources)));
    }
    exports.combineLatestWith = combineLatestWith;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/concatMap.js
var require_concatMap = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/concatMap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.concatMap = void 0;
    var mergeMap_1 = require_mergeMap();
    var isFunction_1 = require_isFunction();
    function concatMap(project, resultSelector) {
      return isFunction_1.isFunction(resultSelector) ? mergeMap_1.mergeMap(project, resultSelector, 1) : mergeMap_1.mergeMap(project, 1);
    }
    exports.concatMap = concatMap;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/concatMapTo.js
var require_concatMapTo = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/concatMapTo.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.concatMapTo = void 0;
    var concatMap_1 = require_concatMap();
    var isFunction_1 = require_isFunction();
    function concatMapTo(innerObservable, resultSelector) {
      return isFunction_1.isFunction(resultSelector) ? concatMap_1.concatMap(function() {
        return innerObservable;
      }, resultSelector) : concatMap_1.concatMap(function() {
        return innerObservable;
      });
    }
    exports.concatMapTo = concatMapTo;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/concat.js
var require_concat2 = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/concat.js"(exports) {
    "use strict";
    var __read = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray2 = exports && exports.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.concat = void 0;
    var lift_1 = require_lift();
    var concatAll_1 = require_concatAll();
    var args_1 = require_args();
    var from_1 = require_from();
    function concat() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var scheduler = args_1.popScheduler(args);
      return lift_1.operate(function(source, subscriber) {
        concatAll_1.concatAll()(from_1.from(__spreadArray2([source], __read(args)), scheduler)).subscribe(subscriber);
      });
    }
    exports.concat = concat;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/concatWith.js
var require_concatWith = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/concatWith.js"(exports) {
    "use strict";
    var __read = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray2 = exports && exports.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.concatWith = void 0;
    var concat_1 = require_concat2();
    function concatWith() {
      var otherSources = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        otherSources[_i] = arguments[_i];
      }
      return concat_1.concat.apply(void 0, __spreadArray2([], __read(otherSources)));
    }
    exports.concatWith = concatWith;
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/fromSubscribable.js
var require_fromSubscribable = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/observable/fromSubscribable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fromSubscribable = void 0;
    var Observable_1 = require_Observable();
    function fromSubscribable(subscribable) {
      return new Observable_1.Observable(function(subscriber) {
        return subscribable.subscribe(subscriber);
      });
    }
    exports.fromSubscribable = fromSubscribable;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/connect.js
var require_connect = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/connect.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.connect = void 0;
    var Subject_1 = require_Subject();
    var innerFrom_1 = require_innerFrom();
    var lift_1 = require_lift();
    var fromSubscribable_1 = require_fromSubscribable();
    var DEFAULT_CONFIG = {
      connector: function() {
        return new Subject_1.Subject();
      }
    };
    function connect(selector, config2) {
      if (config2 === void 0) {
        config2 = DEFAULT_CONFIG;
      }
      var connector = config2.connector;
      return lift_1.operate(function(source, subscriber) {
        var subject = connector();
        innerFrom_1.innerFrom(selector(fromSubscribable_1.fromSubscribable(subject))).subscribe(subscriber);
        subscriber.add(source.subscribe(subject));
      });
    }
    exports.connect = connect;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/count.js
var require_count = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/count.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.count = void 0;
    var reduce_1 = require_reduce();
    function count(predicate) {
      return reduce_1.reduce(function(total, value, i) {
        return !predicate || predicate(value, i) ? total + 1 : total;
      }, 0);
    }
    exports.count = count;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/debounce.js
var require_debounce = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/debounce.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.debounce = void 0;
    var lift_1 = require_lift();
    var noop_1 = require_noop();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var innerFrom_1 = require_innerFrom();
    function debounce(durationSelector) {
      return lift_1.operate(function(source, subscriber) {
        var hasValue = false;
        var lastValue = null;
        var durationSubscriber = null;
        var emit = function() {
          durationSubscriber === null || durationSubscriber === void 0 ? void 0 : durationSubscriber.unsubscribe();
          durationSubscriber = null;
          if (hasValue) {
            hasValue = false;
            var value = lastValue;
            lastValue = null;
            subscriber.next(value);
          }
        };
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          durationSubscriber === null || durationSubscriber === void 0 ? void 0 : durationSubscriber.unsubscribe();
          hasValue = true;
          lastValue = value;
          durationSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, emit, noop_1.noop);
          innerFrom_1.innerFrom(durationSelector(value)).subscribe(durationSubscriber);
        }, function() {
          emit();
          subscriber.complete();
        }, void 0, function() {
          lastValue = durationSubscriber = null;
        }));
      });
    }
    exports.debounce = debounce;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/debounceTime.js
var require_debounceTime = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/debounceTime.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.debounceTime = void 0;
    var async_1 = require_async();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function debounceTime(dueTime, scheduler) {
      if (scheduler === void 0) {
        scheduler = async_1.asyncScheduler;
      }
      return lift_1.operate(function(source, subscriber) {
        var activeTask = null;
        var lastValue = null;
        var lastTime = null;
        var emit = function() {
          if (activeTask) {
            activeTask.unsubscribe();
            activeTask = null;
            var value = lastValue;
            lastValue = null;
            subscriber.next(value);
          }
        };
        function emitWhenIdle() {
          var targetTime = lastTime + dueTime;
          var now = scheduler.now();
          if (now < targetTime) {
            activeTask = this.schedule(void 0, targetTime - now);
            subscriber.add(activeTask);
            return;
          }
          emit();
        }
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          lastValue = value;
          lastTime = scheduler.now();
          if (!activeTask) {
            activeTask = scheduler.schedule(emitWhenIdle, dueTime);
            subscriber.add(activeTask);
          }
        }, function() {
          emit();
          subscriber.complete();
        }, void 0, function() {
          lastValue = activeTask = null;
        }));
      });
    }
    exports.debounceTime = debounceTime;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/defaultIfEmpty.js
var require_defaultIfEmpty = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/defaultIfEmpty.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.defaultIfEmpty = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function defaultIfEmpty(defaultValue) {
      return lift_1.operate(function(source, subscriber) {
        var hasValue = false;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          hasValue = true;
          subscriber.next(value);
        }, function() {
          if (!hasValue) {
            subscriber.next(defaultValue);
          }
          subscriber.complete();
        }));
      });
    }
    exports.defaultIfEmpty = defaultIfEmpty;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/take.js
var require_take = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/take.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.take = void 0;
    var empty_1 = require_empty();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function take(count) {
      return count <= 0 ? function() {
        return empty_1.EMPTY;
      } : lift_1.operate(function(source, subscriber) {
        var seen = 0;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          if (++seen <= count) {
            subscriber.next(value);
            if (count <= seen) {
              subscriber.complete();
            }
          }
        }));
      });
    }
    exports.take = take;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/ignoreElements.js
var require_ignoreElements = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/ignoreElements.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ignoreElements = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var noop_1 = require_noop();
    function ignoreElements() {
      return lift_1.operate(function(source, subscriber) {
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, noop_1.noop));
      });
    }
    exports.ignoreElements = ignoreElements;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/mapTo.js
var require_mapTo = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/mapTo.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mapTo = void 0;
    var map_1 = require_map();
    function mapTo(value) {
      return map_1.map(function() {
        return value;
      });
    }
    exports.mapTo = mapTo;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/delayWhen.js
var require_delayWhen = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/delayWhen.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.delayWhen = void 0;
    var concat_1 = require_concat();
    var take_1 = require_take();
    var ignoreElements_1 = require_ignoreElements();
    var mapTo_1 = require_mapTo();
    var mergeMap_1 = require_mergeMap();
    var innerFrom_1 = require_innerFrom();
    function delayWhen(delayDurationSelector, subscriptionDelay) {
      if (subscriptionDelay) {
        return function(source) {
          return concat_1.concat(subscriptionDelay.pipe(take_1.take(1), ignoreElements_1.ignoreElements()), source.pipe(delayWhen(delayDurationSelector)));
        };
      }
      return mergeMap_1.mergeMap(function(value, index) {
        return innerFrom_1.innerFrom(delayDurationSelector(value, index)).pipe(take_1.take(1), mapTo_1.mapTo(value));
      });
    }
    exports.delayWhen = delayWhen;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/delay.js
var require_delay = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/delay.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.delay = void 0;
    var async_1 = require_async();
    var delayWhen_1 = require_delayWhen();
    var timer_1 = require_timer();
    function delay(due, scheduler) {
      if (scheduler === void 0) {
        scheduler = async_1.asyncScheduler;
      }
      var duration = timer_1.timer(due, scheduler);
      return delayWhen_1.delayWhen(function() {
        return duration;
      });
    }
    exports.delay = delay;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/dematerialize.js
var require_dematerialize = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/dematerialize.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.dematerialize = void 0;
    var Notification_1 = require_Notification();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function dematerialize() {
      return lift_1.operate(function(source, subscriber) {
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(notification) {
          return Notification_1.observeNotification(notification, subscriber);
        }));
      });
    }
    exports.dematerialize = dematerialize;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/distinct.js
var require_distinct = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/distinct.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.distinct = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var noop_1 = require_noop();
    var innerFrom_1 = require_innerFrom();
    function distinct(keySelector, flushes) {
      return lift_1.operate(function(source, subscriber) {
        var distinctKeys = /* @__PURE__ */ new Set();
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          var key = keySelector ? keySelector(value) : value;
          if (!distinctKeys.has(key)) {
            distinctKeys.add(key);
            subscriber.next(value);
          }
        }));
        flushes && innerFrom_1.innerFrom(flushes).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
          return distinctKeys.clear();
        }, noop_1.noop));
      });
    }
    exports.distinct = distinct;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/distinctUntilChanged.js
var require_distinctUntilChanged = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/distinctUntilChanged.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.distinctUntilChanged = void 0;
    var identity_1 = require_identity();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function distinctUntilChanged(comparator, keySelector) {
      if (keySelector === void 0) {
        keySelector = identity_1.identity;
      }
      comparator = comparator !== null && comparator !== void 0 ? comparator : defaultCompare;
      return lift_1.operate(function(source, subscriber) {
        var previousKey;
        var first = true;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          var currentKey = keySelector(value);
          if (first || !comparator(previousKey, currentKey)) {
            first = false;
            previousKey = currentKey;
            subscriber.next(value);
          }
        }));
      });
    }
    exports.distinctUntilChanged = distinctUntilChanged;
    function defaultCompare(a, b) {
      return a === b;
    }
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/distinctUntilKeyChanged.js
var require_distinctUntilKeyChanged = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/distinctUntilKeyChanged.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.distinctUntilKeyChanged = void 0;
    var distinctUntilChanged_1 = require_distinctUntilChanged();
    function distinctUntilKeyChanged(key, compare) {
      return distinctUntilChanged_1.distinctUntilChanged(function(x, y) {
        return compare ? compare(x[key], y[key]) : x[key] === y[key];
      });
    }
    exports.distinctUntilKeyChanged = distinctUntilKeyChanged;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/throwIfEmpty.js
var require_throwIfEmpty = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/throwIfEmpty.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.throwIfEmpty = void 0;
    var EmptyError_1 = require_EmptyError();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function throwIfEmpty(errorFactory) {
      if (errorFactory === void 0) {
        errorFactory = defaultErrorFactory;
      }
      return lift_1.operate(function(source, subscriber) {
        var hasValue = false;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          hasValue = true;
          subscriber.next(value);
        }, function() {
          return hasValue ? subscriber.complete() : subscriber.error(errorFactory());
        }));
      });
    }
    exports.throwIfEmpty = throwIfEmpty;
    function defaultErrorFactory() {
      return new EmptyError_1.EmptyError();
    }
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/elementAt.js
var require_elementAt = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/elementAt.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.elementAt = void 0;
    var ArgumentOutOfRangeError_1 = require_ArgumentOutOfRangeError();
    var filter_1 = require_filter();
    var throwIfEmpty_1 = require_throwIfEmpty();
    var defaultIfEmpty_1 = require_defaultIfEmpty();
    var take_1 = require_take();
    function elementAt(index, defaultValue) {
      if (index < 0) {
        throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError();
      }
      var hasDefaultValue = arguments.length >= 2;
      return function(source) {
        return source.pipe(filter_1.filter(function(v, i) {
          return i === index;
        }), take_1.take(1), hasDefaultValue ? defaultIfEmpty_1.defaultIfEmpty(defaultValue) : throwIfEmpty_1.throwIfEmpty(function() {
          return new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError();
        }));
      };
    }
    exports.elementAt = elementAt;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/endWith.js
var require_endWith = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/endWith.js"(exports) {
    "use strict";
    var __read = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray2 = exports && exports.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.endWith = void 0;
    var concat_1 = require_concat();
    var of_1 = require_of();
    function endWith() {
      var values = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        values[_i] = arguments[_i];
      }
      return function(source) {
        return concat_1.concat(source, of_1.of.apply(void 0, __spreadArray2([], __read(values))));
      };
    }
    exports.endWith = endWith;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/every.js
var require_every = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/every.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.every = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function every(predicate, thisArg) {
      return lift_1.operate(function(source, subscriber) {
        var index = 0;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          if (!predicate.call(thisArg, value, index++, source)) {
            subscriber.next(false);
            subscriber.complete();
          }
        }, function() {
          subscriber.next(true);
          subscriber.complete();
        }));
      });
    }
    exports.every = every;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/exhaustMap.js
var require_exhaustMap = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/exhaustMap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.exhaustMap = void 0;
    var map_1 = require_map();
    var innerFrom_1 = require_innerFrom();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function exhaustMap(project, resultSelector) {
      if (resultSelector) {
        return function(source) {
          return source.pipe(exhaustMap(function(a, i) {
            return innerFrom_1.innerFrom(project(a, i)).pipe(map_1.map(function(b, ii) {
              return resultSelector(a, b, i, ii);
            }));
          }));
        };
      }
      return lift_1.operate(function(source, subscriber) {
        var index = 0;
        var innerSub = null;
        var isComplete = false;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(outerValue) {
          if (!innerSub) {
            innerSub = OperatorSubscriber_1.createOperatorSubscriber(subscriber, void 0, function() {
              innerSub = null;
              isComplete && subscriber.complete();
            });
            innerFrom_1.innerFrom(project(outerValue, index++)).subscribe(innerSub);
          }
        }, function() {
          isComplete = true;
          !innerSub && subscriber.complete();
        }));
      });
    }
    exports.exhaustMap = exhaustMap;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/exhaustAll.js
var require_exhaustAll = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/exhaustAll.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.exhaustAll = void 0;
    var exhaustMap_1 = require_exhaustMap();
    var identity_1 = require_identity();
    function exhaustAll() {
      return exhaustMap_1.exhaustMap(identity_1.identity);
    }
    exports.exhaustAll = exhaustAll;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/exhaust.js
var require_exhaust = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/exhaust.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.exhaust = void 0;
    var exhaustAll_1 = require_exhaustAll();
    exports.exhaust = exhaustAll_1.exhaustAll;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/expand.js
var require_expand = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/expand.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.expand = void 0;
    var lift_1 = require_lift();
    var mergeInternals_1 = require_mergeInternals();
    function expand(project, concurrent, scheduler) {
      if (concurrent === void 0) {
        concurrent = Infinity;
      }
      concurrent = (concurrent || 0) < 1 ? Infinity : concurrent;
      return lift_1.operate(function(source, subscriber) {
        return mergeInternals_1.mergeInternals(source, subscriber, project, concurrent, void 0, true, scheduler);
      });
    }
    exports.expand = expand;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/finalize.js
var require_finalize = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/finalize.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.finalize = void 0;
    var lift_1 = require_lift();
    function finalize(callback) {
      return lift_1.operate(function(source, subscriber) {
        try {
          source.subscribe(subscriber);
        } finally {
          subscriber.add(callback);
        }
      });
    }
    exports.finalize = finalize;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/find.js
var require_find = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/find.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createFind = exports.find = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function find(predicate, thisArg) {
      return lift_1.operate(createFind(predicate, thisArg, "value"));
    }
    exports.find = find;
    function createFind(predicate, thisArg, emit) {
      var findIndex = emit === "index";
      return function(source, subscriber) {
        var index = 0;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          var i = index++;
          if (predicate.call(thisArg, value, i, source)) {
            subscriber.next(findIndex ? i : value);
            subscriber.complete();
          }
        }, function() {
          subscriber.next(findIndex ? -1 : void 0);
          subscriber.complete();
        }));
      };
    }
    exports.createFind = createFind;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/findIndex.js
var require_findIndex = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/findIndex.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.findIndex = void 0;
    var lift_1 = require_lift();
    var find_1 = require_find();
    function findIndex(predicate, thisArg) {
      return lift_1.operate(find_1.createFind(predicate, thisArg, "index"));
    }
    exports.findIndex = findIndex;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/first.js
var require_first = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/first.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.first = void 0;
    var EmptyError_1 = require_EmptyError();
    var filter_1 = require_filter();
    var take_1 = require_take();
    var defaultIfEmpty_1 = require_defaultIfEmpty();
    var throwIfEmpty_1 = require_throwIfEmpty();
    var identity_1 = require_identity();
    function first(predicate, defaultValue) {
      var hasDefaultValue = arguments.length >= 2;
      return function(source) {
        return source.pipe(predicate ? filter_1.filter(function(v, i) {
          return predicate(v, i, source);
        }) : identity_1.identity, take_1.take(1), hasDefaultValue ? defaultIfEmpty_1.defaultIfEmpty(defaultValue) : throwIfEmpty_1.throwIfEmpty(function() {
          return new EmptyError_1.EmptyError();
        }));
      };
    }
    exports.first = first;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/groupBy.js
var require_groupBy = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/groupBy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.groupBy = void 0;
    var Observable_1 = require_Observable();
    var innerFrom_1 = require_innerFrom();
    var Subject_1 = require_Subject();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function groupBy(keySelector, elementOrOptions, duration, connector) {
      return lift_1.operate(function(source, subscriber) {
        var element;
        if (!elementOrOptions || typeof elementOrOptions === "function") {
          element = elementOrOptions;
        } else {
          duration = elementOrOptions.duration, element = elementOrOptions.element, connector = elementOrOptions.connector;
        }
        var groups = /* @__PURE__ */ new Map();
        var notify = function(cb) {
          groups.forEach(cb);
          cb(subscriber);
        };
        var handleError = function(err) {
          return notify(function(consumer) {
            return consumer.error(err);
          });
        };
        var activeGroups = 0;
        var teardownAttempted = false;
        var groupBySourceSubscriber = new OperatorSubscriber_1.OperatorSubscriber(subscriber, function(value) {
          try {
            var key_1 = keySelector(value);
            var group_1 = groups.get(key_1);
            if (!group_1) {
              groups.set(key_1, group_1 = connector ? connector() : new Subject_1.Subject());
              var grouped = createGroupedObservable(key_1, group_1);
              subscriber.next(grouped);
              if (duration) {
                var durationSubscriber_1 = OperatorSubscriber_1.createOperatorSubscriber(group_1, function() {
                  group_1.complete();
                  durationSubscriber_1 === null || durationSubscriber_1 === void 0 ? void 0 : durationSubscriber_1.unsubscribe();
                }, void 0, void 0, function() {
                  return groups.delete(key_1);
                });
                groupBySourceSubscriber.add(innerFrom_1.innerFrom(duration(grouped)).subscribe(durationSubscriber_1));
              }
            }
            group_1.next(element ? element(value) : value);
          } catch (err) {
            handleError(err);
          }
        }, function() {
          return notify(function(consumer) {
            return consumer.complete();
          });
        }, handleError, function() {
          return groups.clear();
        }, function() {
          teardownAttempted = true;
          return activeGroups === 0;
        });
        source.subscribe(groupBySourceSubscriber);
        function createGroupedObservable(key, groupSubject) {
          var result = new Observable_1.Observable(function(groupSubscriber) {
            activeGroups++;
            var innerSub = groupSubject.subscribe(groupSubscriber);
            return function() {
              innerSub.unsubscribe();
              --activeGroups === 0 && teardownAttempted && groupBySourceSubscriber.unsubscribe();
            };
          });
          result.key = key;
          return result;
        }
      });
    }
    exports.groupBy = groupBy;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/isEmpty.js
var require_isEmpty = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/isEmpty.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isEmpty = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function isEmpty() {
      return lift_1.operate(function(source, subscriber) {
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
          subscriber.next(false);
          subscriber.complete();
        }, function() {
          subscriber.next(true);
          subscriber.complete();
        }));
      });
    }
    exports.isEmpty = isEmpty;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/takeLast.js
var require_takeLast = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/takeLast.js"(exports) {
    "use strict";
    var __values = exports && exports.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = void 0;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.takeLast = void 0;
    var empty_1 = require_empty();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function takeLast(count) {
      return count <= 0 ? function() {
        return empty_1.EMPTY;
      } : lift_1.operate(function(source, subscriber) {
        var buffer = [];
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          buffer.push(value);
          count < buffer.length && buffer.shift();
        }, function() {
          var e_1, _a;
          try {
            for (var buffer_1 = __values(buffer), buffer_1_1 = buffer_1.next(); !buffer_1_1.done; buffer_1_1 = buffer_1.next()) {
              var value = buffer_1_1.value;
              subscriber.next(value);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (buffer_1_1 && !buffer_1_1.done && (_a = buffer_1.return))
                _a.call(buffer_1);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
          subscriber.complete();
        }, void 0, function() {
          buffer = null;
        }));
      });
    }
    exports.takeLast = takeLast;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/last.js
var require_last = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/last.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.last = void 0;
    var EmptyError_1 = require_EmptyError();
    var filter_1 = require_filter();
    var takeLast_1 = require_takeLast();
    var throwIfEmpty_1 = require_throwIfEmpty();
    var defaultIfEmpty_1 = require_defaultIfEmpty();
    var identity_1 = require_identity();
    function last(predicate, defaultValue) {
      var hasDefaultValue = arguments.length >= 2;
      return function(source) {
        return source.pipe(predicate ? filter_1.filter(function(v, i) {
          return predicate(v, i, source);
        }) : identity_1.identity, takeLast_1.takeLast(1), hasDefaultValue ? defaultIfEmpty_1.defaultIfEmpty(defaultValue) : throwIfEmpty_1.throwIfEmpty(function() {
          return new EmptyError_1.EmptyError();
        }));
      };
    }
    exports.last = last;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/materialize.js
var require_materialize = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/materialize.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.materialize = void 0;
    var Notification_1 = require_Notification();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function materialize() {
      return lift_1.operate(function(source, subscriber) {
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          subscriber.next(Notification_1.Notification.createNext(value));
        }, function() {
          subscriber.next(Notification_1.Notification.createComplete());
          subscriber.complete();
        }, function(err) {
          subscriber.next(Notification_1.Notification.createError(err));
          subscriber.complete();
        }));
      });
    }
    exports.materialize = materialize;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/max.js
var require_max = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/max.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.max = void 0;
    var reduce_1 = require_reduce();
    var isFunction_1 = require_isFunction();
    function max(comparer) {
      return reduce_1.reduce(isFunction_1.isFunction(comparer) ? function(x, y) {
        return comparer(x, y) > 0 ? x : y;
      } : function(x, y) {
        return x > y ? x : y;
      });
    }
    exports.max = max;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/flatMap.js
var require_flatMap = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/flatMap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.flatMap = void 0;
    var mergeMap_1 = require_mergeMap();
    exports.flatMap = mergeMap_1.mergeMap;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/mergeMapTo.js
var require_mergeMapTo = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/mergeMapTo.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mergeMapTo = void 0;
    var mergeMap_1 = require_mergeMap();
    var isFunction_1 = require_isFunction();
    function mergeMapTo(innerObservable, resultSelector, concurrent) {
      if (concurrent === void 0) {
        concurrent = Infinity;
      }
      if (isFunction_1.isFunction(resultSelector)) {
        return mergeMap_1.mergeMap(function() {
          return innerObservable;
        }, resultSelector, concurrent);
      }
      if (typeof resultSelector === "number") {
        concurrent = resultSelector;
      }
      return mergeMap_1.mergeMap(function() {
        return innerObservable;
      }, concurrent);
    }
    exports.mergeMapTo = mergeMapTo;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/mergeScan.js
var require_mergeScan = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/mergeScan.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mergeScan = void 0;
    var lift_1 = require_lift();
    var mergeInternals_1 = require_mergeInternals();
    function mergeScan(accumulator, seed, concurrent) {
      if (concurrent === void 0) {
        concurrent = Infinity;
      }
      return lift_1.operate(function(source, subscriber) {
        var state = seed;
        return mergeInternals_1.mergeInternals(source, subscriber, function(value, index) {
          return accumulator(state, value, index);
        }, concurrent, function(value) {
          state = value;
        }, false, void 0, function() {
          return state = null;
        });
      });
    }
    exports.mergeScan = mergeScan;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/merge.js
var require_merge2 = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/merge.js"(exports) {
    "use strict";
    var __read = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray2 = exports && exports.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.merge = void 0;
    var lift_1 = require_lift();
    var argsOrArgArray_1 = require_argsOrArgArray();
    var mergeAll_1 = require_mergeAll();
    var args_1 = require_args();
    var from_1 = require_from();
    function merge() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var scheduler = args_1.popScheduler(args);
      var concurrent = args_1.popNumber(args, Infinity);
      args = argsOrArgArray_1.argsOrArgArray(args);
      return lift_1.operate(function(source, subscriber) {
        mergeAll_1.mergeAll(concurrent)(from_1.from(__spreadArray2([source], __read(args)), scheduler)).subscribe(subscriber);
      });
    }
    exports.merge = merge;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/mergeWith.js
var require_mergeWith = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/mergeWith.js"(exports) {
    "use strict";
    var __read = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray2 = exports && exports.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mergeWith = void 0;
    var merge_1 = require_merge2();
    function mergeWith() {
      var otherSources = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        otherSources[_i] = arguments[_i];
      }
      return merge_1.merge.apply(void 0, __spreadArray2([], __read(otherSources)));
    }
    exports.mergeWith = mergeWith;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/min.js
var require_min = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/min.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.min = void 0;
    var reduce_1 = require_reduce();
    var isFunction_1 = require_isFunction();
    function min(comparer) {
      return reduce_1.reduce(isFunction_1.isFunction(comparer) ? function(x, y) {
        return comparer(x, y) < 0 ? x : y;
      } : function(x, y) {
        return x < y ? x : y;
      });
    }
    exports.min = min;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/multicast.js
var require_multicast = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/multicast.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.multicast = void 0;
    var ConnectableObservable_1 = require_ConnectableObservable();
    var isFunction_1 = require_isFunction();
    var connect_1 = require_connect();
    function multicast(subjectOrSubjectFactory, selector) {
      var subjectFactory = isFunction_1.isFunction(subjectOrSubjectFactory) ? subjectOrSubjectFactory : function() {
        return subjectOrSubjectFactory;
      };
      if (isFunction_1.isFunction(selector)) {
        return connect_1.connect(selector, {
          connector: subjectFactory
        });
      }
      return function(source) {
        return new ConnectableObservable_1.ConnectableObservable(source, subjectFactory);
      };
    }
    exports.multicast = multicast;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/onErrorResumeNextWith.js
var require_onErrorResumeNextWith = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/onErrorResumeNextWith.js"(exports) {
    "use strict";
    var __read = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray2 = exports && exports.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.onErrorResumeNext = exports.onErrorResumeNextWith = void 0;
    var argsOrArgArray_1 = require_argsOrArgArray();
    var onErrorResumeNext_1 = require_onErrorResumeNext();
    function onErrorResumeNextWith() {
      var sources = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        sources[_i] = arguments[_i];
      }
      var nextSources = argsOrArgArray_1.argsOrArgArray(sources);
      return function(source) {
        return onErrorResumeNext_1.onErrorResumeNext.apply(void 0, __spreadArray2([source], __read(nextSources)));
      };
    }
    exports.onErrorResumeNextWith = onErrorResumeNextWith;
    exports.onErrorResumeNext = onErrorResumeNextWith;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/pairwise.js
var require_pairwise = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/pairwise.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.pairwise = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function pairwise() {
      return lift_1.operate(function(source, subscriber) {
        var prev;
        var hasPrev = false;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          var p = prev;
          prev = value;
          hasPrev && subscriber.next([p, value]);
          hasPrev = true;
        }));
      });
    }
    exports.pairwise = pairwise;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/pluck.js
var require_pluck = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/pluck.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.pluck = void 0;
    var map_1 = require_map();
    function pluck() {
      var properties = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        properties[_i] = arguments[_i];
      }
      var length = properties.length;
      if (length === 0) {
        throw new Error("list of properties cannot be empty.");
      }
      return map_1.map(function(x) {
        var currentProp = x;
        for (var i = 0; i < length; i++) {
          var p = currentProp === null || currentProp === void 0 ? void 0 : currentProp[properties[i]];
          if (typeof p !== "undefined") {
            currentProp = p;
          } else {
            return void 0;
          }
        }
        return currentProp;
      });
    }
    exports.pluck = pluck;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/publish.js
var require_publish = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/publish.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.publish = void 0;
    var Subject_1 = require_Subject();
    var multicast_1 = require_multicast();
    var connect_1 = require_connect();
    function publish(selector) {
      return selector ? function(source) {
        return connect_1.connect(selector)(source);
      } : function(source) {
        return multicast_1.multicast(new Subject_1.Subject())(source);
      };
    }
    exports.publish = publish;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/publishBehavior.js
var require_publishBehavior = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/publishBehavior.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.publishBehavior = void 0;
    var BehaviorSubject_1 = require_BehaviorSubject();
    var ConnectableObservable_1 = require_ConnectableObservable();
    function publishBehavior(initialValue) {
      return function(source) {
        var subject = new BehaviorSubject_1.BehaviorSubject(initialValue);
        return new ConnectableObservable_1.ConnectableObservable(source, function() {
          return subject;
        });
      };
    }
    exports.publishBehavior = publishBehavior;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/publishLast.js
var require_publishLast = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/publishLast.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.publishLast = void 0;
    var AsyncSubject_1 = require_AsyncSubject();
    var ConnectableObservable_1 = require_ConnectableObservable();
    function publishLast() {
      return function(source) {
        var subject = new AsyncSubject_1.AsyncSubject();
        return new ConnectableObservable_1.ConnectableObservable(source, function() {
          return subject;
        });
      };
    }
    exports.publishLast = publishLast;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/publishReplay.js
var require_publishReplay = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/publishReplay.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.publishReplay = void 0;
    var ReplaySubject_1 = require_ReplaySubject();
    var multicast_1 = require_multicast();
    var isFunction_1 = require_isFunction();
    function publishReplay(bufferSize, windowTime, selectorOrScheduler, timestampProvider) {
      if (selectorOrScheduler && !isFunction_1.isFunction(selectorOrScheduler)) {
        timestampProvider = selectorOrScheduler;
      }
      var selector = isFunction_1.isFunction(selectorOrScheduler) ? selectorOrScheduler : void 0;
      return function(source) {
        return multicast_1.multicast(new ReplaySubject_1.ReplaySubject(bufferSize, windowTime, timestampProvider), selector)(source);
      };
    }
    exports.publishReplay = publishReplay;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/raceWith.js
var require_raceWith = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/raceWith.js"(exports) {
    "use strict";
    var __read = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray2 = exports && exports.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.raceWith = void 0;
    var race_1 = require_race();
    var lift_1 = require_lift();
    var identity_1 = require_identity();
    function raceWith() {
      var otherSources = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        otherSources[_i] = arguments[_i];
      }
      return !otherSources.length ? identity_1.identity : lift_1.operate(function(source, subscriber) {
        race_1.raceInit(__spreadArray2([source], __read(otherSources)))(subscriber);
      });
    }
    exports.raceWith = raceWith;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/repeat.js
var require_repeat = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/repeat.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.repeat = void 0;
    var empty_1 = require_empty();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var innerFrom_1 = require_innerFrom();
    var timer_1 = require_timer();
    function repeat(countOrConfig) {
      var _a;
      var count = Infinity;
      var delay;
      if (countOrConfig != null) {
        if (typeof countOrConfig === "object") {
          _a = countOrConfig.count, count = _a === void 0 ? Infinity : _a, delay = countOrConfig.delay;
        } else {
          count = countOrConfig;
        }
      }
      return count <= 0 ? function() {
        return empty_1.EMPTY;
      } : lift_1.operate(function(source, subscriber) {
        var soFar = 0;
        var sourceSub;
        var resubscribe = function() {
          sourceSub === null || sourceSub === void 0 ? void 0 : sourceSub.unsubscribe();
          sourceSub = null;
          if (delay != null) {
            var notifier = typeof delay === "number" ? timer_1.timer(delay) : innerFrom_1.innerFrom(delay(soFar));
            var notifierSubscriber_1 = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
              notifierSubscriber_1.unsubscribe();
              subscribeToSource();
            });
            notifier.subscribe(notifierSubscriber_1);
          } else {
            subscribeToSource();
          }
        };
        var subscribeToSource = function() {
          var syncUnsub = false;
          sourceSub = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, void 0, function() {
            if (++soFar < count) {
              if (sourceSub) {
                resubscribe();
              } else {
                syncUnsub = true;
              }
            } else {
              subscriber.complete();
            }
          }));
          if (syncUnsub) {
            resubscribe();
          }
        };
        subscribeToSource();
      });
    }
    exports.repeat = repeat;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/repeatWhen.js
var require_repeatWhen = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/repeatWhen.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.repeatWhen = void 0;
    var innerFrom_1 = require_innerFrom();
    var Subject_1 = require_Subject();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function repeatWhen(notifier) {
      return lift_1.operate(function(source, subscriber) {
        var innerSub;
        var syncResub = false;
        var completions$;
        var isNotifierComplete = false;
        var isMainComplete = false;
        var checkComplete = function() {
          return isMainComplete && isNotifierComplete && (subscriber.complete(), true);
        };
        var getCompletionSubject = function() {
          if (!completions$) {
            completions$ = new Subject_1.Subject();
            innerFrom_1.innerFrom(notifier(completions$)).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
              if (innerSub) {
                subscribeForRepeatWhen();
              } else {
                syncResub = true;
              }
            }, function() {
              isNotifierComplete = true;
              checkComplete();
            }));
          }
          return completions$;
        };
        var subscribeForRepeatWhen = function() {
          isMainComplete = false;
          innerSub = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, void 0, function() {
            isMainComplete = true;
            !checkComplete() && getCompletionSubject().next();
          }));
          if (syncResub) {
            innerSub.unsubscribe();
            innerSub = null;
            syncResub = false;
            subscribeForRepeatWhen();
          }
        };
        subscribeForRepeatWhen();
      });
    }
    exports.repeatWhen = repeatWhen;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/retry.js
var require_retry = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/retry.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.retry = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var identity_1 = require_identity();
    var timer_1 = require_timer();
    var innerFrom_1 = require_innerFrom();
    function retry(configOrCount) {
      if (configOrCount === void 0) {
        configOrCount = Infinity;
      }
      var config2;
      if (configOrCount && typeof configOrCount === "object") {
        config2 = configOrCount;
      } else {
        config2 = {
          count: configOrCount
        };
      }
      var _a = config2.count, count = _a === void 0 ? Infinity : _a, delay = config2.delay, _b = config2.resetOnSuccess, resetOnSuccess = _b === void 0 ? false : _b;
      return count <= 0 ? identity_1.identity : lift_1.operate(function(source, subscriber) {
        var soFar = 0;
        var innerSub;
        var subscribeForRetry = function() {
          var syncUnsub = false;
          innerSub = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
            if (resetOnSuccess) {
              soFar = 0;
            }
            subscriber.next(value);
          }, void 0, function(err) {
            if (soFar++ < count) {
              var resub_1 = function() {
                if (innerSub) {
                  innerSub.unsubscribe();
                  innerSub = null;
                  subscribeForRetry();
                } else {
                  syncUnsub = true;
                }
              };
              if (delay != null) {
                var notifier = typeof delay === "number" ? timer_1.timer(delay) : innerFrom_1.innerFrom(delay(err, soFar));
                var notifierSubscriber_1 = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
                  notifierSubscriber_1.unsubscribe();
                  resub_1();
                }, function() {
                  subscriber.complete();
                });
                notifier.subscribe(notifierSubscriber_1);
              } else {
                resub_1();
              }
            } else {
              subscriber.error(err);
            }
          }));
          if (syncUnsub) {
            innerSub.unsubscribe();
            innerSub = null;
            subscribeForRetry();
          }
        };
        subscribeForRetry();
      });
    }
    exports.retry = retry;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/retryWhen.js
var require_retryWhen = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/retryWhen.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.retryWhen = void 0;
    var innerFrom_1 = require_innerFrom();
    var Subject_1 = require_Subject();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function retryWhen(notifier) {
      return lift_1.operate(function(source, subscriber) {
        var innerSub;
        var syncResub = false;
        var errors$;
        var subscribeForRetryWhen = function() {
          innerSub = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, void 0, void 0, function(err) {
            if (!errors$) {
              errors$ = new Subject_1.Subject();
              innerFrom_1.innerFrom(notifier(errors$)).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
                return innerSub ? subscribeForRetryWhen() : syncResub = true;
              }));
            }
            if (errors$) {
              errors$.next(err);
            }
          }));
          if (syncResub) {
            innerSub.unsubscribe();
            innerSub = null;
            syncResub = false;
            subscribeForRetryWhen();
          }
        };
        subscribeForRetryWhen();
      });
    }
    exports.retryWhen = retryWhen;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/sample.js
var require_sample = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/sample.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sample = void 0;
    var innerFrom_1 = require_innerFrom();
    var lift_1 = require_lift();
    var noop_1 = require_noop();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function sample(notifier) {
      return lift_1.operate(function(source, subscriber) {
        var hasValue = false;
        var lastValue = null;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          hasValue = true;
          lastValue = value;
        }));
        innerFrom_1.innerFrom(notifier).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
          if (hasValue) {
            hasValue = false;
            var value = lastValue;
            lastValue = null;
            subscriber.next(value);
          }
        }, noop_1.noop));
      });
    }
    exports.sample = sample;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/sampleTime.js
var require_sampleTime = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/sampleTime.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sampleTime = void 0;
    var async_1 = require_async();
    var sample_1 = require_sample();
    var interval_1 = require_interval();
    function sampleTime(period, scheduler) {
      if (scheduler === void 0) {
        scheduler = async_1.asyncScheduler;
      }
      return sample_1.sample(interval_1.interval(period, scheduler));
    }
    exports.sampleTime = sampleTime;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/scan.js
var require_scan = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/scan.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.scan = void 0;
    var lift_1 = require_lift();
    var scanInternals_1 = require_scanInternals();
    function scan(accumulator, seed) {
      return lift_1.operate(scanInternals_1.scanInternals(accumulator, seed, arguments.length >= 2, true));
    }
    exports.scan = scan;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/sequenceEqual.js
var require_sequenceEqual = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/sequenceEqual.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sequenceEqual = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var innerFrom_1 = require_innerFrom();
    function sequenceEqual(compareTo, comparator) {
      if (comparator === void 0) {
        comparator = function(a, b) {
          return a === b;
        };
      }
      return lift_1.operate(function(source, subscriber) {
        var aState = createState();
        var bState = createState();
        var emit = function(isEqual) {
          subscriber.next(isEqual);
          subscriber.complete();
        };
        var createSubscriber = function(selfState, otherState) {
          var sequenceEqualSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(a) {
            var buffer = otherState.buffer, complete = otherState.complete;
            if (buffer.length === 0) {
              complete ? emit(false) : selfState.buffer.push(a);
            } else {
              !comparator(a, buffer.shift()) && emit(false);
            }
          }, function() {
            selfState.complete = true;
            var complete = otherState.complete, buffer = otherState.buffer;
            complete && emit(buffer.length === 0);
            sequenceEqualSubscriber === null || sequenceEqualSubscriber === void 0 ? void 0 : sequenceEqualSubscriber.unsubscribe();
          });
          return sequenceEqualSubscriber;
        };
        source.subscribe(createSubscriber(aState, bState));
        innerFrom_1.innerFrom(compareTo).subscribe(createSubscriber(bState, aState));
      });
    }
    exports.sequenceEqual = sequenceEqual;
    function createState() {
      return {
        buffer: [],
        complete: false
      };
    }
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/share.js
var require_share = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/share.js"(exports) {
    "use strict";
    var __read = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray2 = exports && exports.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.share = void 0;
    var innerFrom_1 = require_innerFrom();
    var Subject_1 = require_Subject();
    var Subscriber_1 = require_Subscriber();
    var lift_1 = require_lift();
    function share(options) {
      if (options === void 0) {
        options = {};
      }
      var _a = options.connector, connector = _a === void 0 ? function() {
        return new Subject_1.Subject();
      } : _a, _b = options.resetOnError, resetOnError = _b === void 0 ? true : _b, _c = options.resetOnComplete, resetOnComplete = _c === void 0 ? true : _c, _d = options.resetOnRefCountZero, resetOnRefCountZero = _d === void 0 ? true : _d;
      return function(wrapperSource) {
        var connection;
        var resetConnection;
        var subject;
        var refCount = 0;
        var hasCompleted = false;
        var hasErrored = false;
        var cancelReset = function() {
          resetConnection === null || resetConnection === void 0 ? void 0 : resetConnection.unsubscribe();
          resetConnection = void 0;
        };
        var reset = function() {
          cancelReset();
          connection = subject = void 0;
          hasCompleted = hasErrored = false;
        };
        var resetAndUnsubscribe = function() {
          var conn = connection;
          reset();
          conn === null || conn === void 0 ? void 0 : conn.unsubscribe();
        };
        return lift_1.operate(function(source, subscriber) {
          refCount++;
          if (!hasErrored && !hasCompleted) {
            cancelReset();
          }
          var dest = subject = subject !== null && subject !== void 0 ? subject : connector();
          subscriber.add(function() {
            refCount--;
            if (refCount === 0 && !hasErrored && !hasCompleted) {
              resetConnection = handleReset(resetAndUnsubscribe, resetOnRefCountZero);
            }
          });
          dest.subscribe(subscriber);
          if (!connection && refCount > 0) {
            connection = new Subscriber_1.SafeSubscriber({
              next: function(value) {
                return dest.next(value);
              },
              error: function(err) {
                hasErrored = true;
                cancelReset();
                resetConnection = handleReset(reset, resetOnError, err);
                dest.error(err);
              },
              complete: function() {
                hasCompleted = true;
                cancelReset();
                resetConnection = handleReset(reset, resetOnComplete);
                dest.complete();
              }
            });
            innerFrom_1.innerFrom(source).subscribe(connection);
          }
        })(wrapperSource);
      };
    }
    exports.share = share;
    function handleReset(reset, on) {
      var args = [];
      for (var _i = 2; _i < arguments.length; _i++) {
        args[_i - 2] = arguments[_i];
      }
      if (on === true) {
        reset();
        return;
      }
      if (on === false) {
        return;
      }
      var onSubscriber = new Subscriber_1.SafeSubscriber({
        next: function() {
          onSubscriber.unsubscribe();
          reset();
        }
      });
      return innerFrom_1.innerFrom(on.apply(void 0, __spreadArray2([], __read(args)))).subscribe(onSubscriber);
    }
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/shareReplay.js
var require_shareReplay = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/shareReplay.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.shareReplay = void 0;
    var ReplaySubject_1 = require_ReplaySubject();
    var share_1 = require_share();
    function shareReplay(configOrBufferSize, windowTime, scheduler) {
      var _a, _b, _c;
      var bufferSize;
      var refCount = false;
      if (configOrBufferSize && typeof configOrBufferSize === "object") {
        _a = configOrBufferSize.bufferSize, bufferSize = _a === void 0 ? Infinity : _a, _b = configOrBufferSize.windowTime, windowTime = _b === void 0 ? Infinity : _b, _c = configOrBufferSize.refCount, refCount = _c === void 0 ? false : _c, scheduler = configOrBufferSize.scheduler;
      } else {
        bufferSize = configOrBufferSize !== null && configOrBufferSize !== void 0 ? configOrBufferSize : Infinity;
      }
      return share_1.share({
        connector: function() {
          return new ReplaySubject_1.ReplaySubject(bufferSize, windowTime, scheduler);
        },
        resetOnError: true,
        resetOnComplete: false,
        resetOnRefCountZero: refCount
      });
    }
    exports.shareReplay = shareReplay;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/single.js
var require_single = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/single.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.single = void 0;
    var EmptyError_1 = require_EmptyError();
    var SequenceError_1 = require_SequenceError();
    var NotFoundError_1 = require_NotFoundError();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function single(predicate) {
      return lift_1.operate(function(source, subscriber) {
        var hasValue = false;
        var singleValue;
        var seenValue = false;
        var index = 0;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          seenValue = true;
          if (!predicate || predicate(value, index++, source)) {
            hasValue && subscriber.error(new SequenceError_1.SequenceError("Too many matching values"));
            hasValue = true;
            singleValue = value;
          }
        }, function() {
          if (hasValue) {
            subscriber.next(singleValue);
            subscriber.complete();
          } else {
            subscriber.error(seenValue ? new NotFoundError_1.NotFoundError("No matching values") : new EmptyError_1.EmptyError());
          }
        }));
      });
    }
    exports.single = single;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/skip.js
var require_skip = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/skip.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.skip = void 0;
    var filter_1 = require_filter();
    function skip(count) {
      return filter_1.filter(function(_, index) {
        return count <= index;
      });
    }
    exports.skip = skip;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/skipLast.js
var require_skipLast = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/skipLast.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.skipLast = void 0;
    var identity_1 = require_identity();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function skipLast(skipCount) {
      return skipCount <= 0 ? identity_1.identity : lift_1.operate(function(source, subscriber) {
        var ring = new Array(skipCount);
        var seen = 0;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          var valueIndex = seen++;
          if (valueIndex < skipCount) {
            ring[valueIndex] = value;
          } else {
            var index = valueIndex % skipCount;
            var oldValue = ring[index];
            ring[index] = value;
            subscriber.next(oldValue);
          }
        }));
        return function() {
          ring = null;
        };
      });
    }
    exports.skipLast = skipLast;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/skipUntil.js
var require_skipUntil = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/skipUntil.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.skipUntil = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var innerFrom_1 = require_innerFrom();
    var noop_1 = require_noop();
    function skipUntil(notifier) {
      return lift_1.operate(function(source, subscriber) {
        var taking = false;
        var skipSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
          skipSubscriber === null || skipSubscriber === void 0 ? void 0 : skipSubscriber.unsubscribe();
          taking = true;
        }, noop_1.noop);
        innerFrom_1.innerFrom(notifier).subscribe(skipSubscriber);
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          return taking && subscriber.next(value);
        }));
      });
    }
    exports.skipUntil = skipUntil;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/skipWhile.js
var require_skipWhile = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/skipWhile.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.skipWhile = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function skipWhile(predicate) {
      return lift_1.operate(function(source, subscriber) {
        var taking = false;
        var index = 0;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          return (taking || (taking = !predicate(value, index++))) && subscriber.next(value);
        }));
      });
    }
    exports.skipWhile = skipWhile;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/startWith.js
var require_startWith = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/startWith.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.startWith = void 0;
    var concat_1 = require_concat();
    var args_1 = require_args();
    var lift_1 = require_lift();
    function startWith() {
      var values = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        values[_i] = arguments[_i];
      }
      var scheduler = args_1.popScheduler(values);
      return lift_1.operate(function(source, subscriber) {
        (scheduler ? concat_1.concat(values, source, scheduler) : concat_1.concat(values, source)).subscribe(subscriber);
      });
    }
    exports.startWith = startWith;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/switchMap.js
var require_switchMap = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/switchMap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.switchMap = void 0;
    var innerFrom_1 = require_innerFrom();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function switchMap(project, resultSelector) {
      return lift_1.operate(function(source, subscriber) {
        var innerSubscriber = null;
        var index = 0;
        var isComplete = false;
        var checkComplete = function() {
          return isComplete && !innerSubscriber && subscriber.complete();
        };
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          innerSubscriber === null || innerSubscriber === void 0 ? void 0 : innerSubscriber.unsubscribe();
          var innerIndex = 0;
          var outerIndex = index++;
          innerFrom_1.innerFrom(project(value, outerIndex)).subscribe(innerSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(innerValue) {
            return subscriber.next(resultSelector ? resultSelector(value, innerValue, outerIndex, innerIndex++) : innerValue);
          }, function() {
            innerSubscriber = null;
            checkComplete();
          }));
        }, function() {
          isComplete = true;
          checkComplete();
        }));
      });
    }
    exports.switchMap = switchMap;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/switchAll.js
var require_switchAll = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/switchAll.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.switchAll = void 0;
    var switchMap_1 = require_switchMap();
    var identity_1 = require_identity();
    function switchAll() {
      return switchMap_1.switchMap(identity_1.identity);
    }
    exports.switchAll = switchAll;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/switchMapTo.js
var require_switchMapTo = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/switchMapTo.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.switchMapTo = void 0;
    var switchMap_1 = require_switchMap();
    var isFunction_1 = require_isFunction();
    function switchMapTo(innerObservable, resultSelector) {
      return isFunction_1.isFunction(resultSelector) ? switchMap_1.switchMap(function() {
        return innerObservable;
      }, resultSelector) : switchMap_1.switchMap(function() {
        return innerObservable;
      });
    }
    exports.switchMapTo = switchMapTo;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/switchScan.js
var require_switchScan = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/switchScan.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.switchScan = void 0;
    var switchMap_1 = require_switchMap();
    var lift_1 = require_lift();
    function switchScan(accumulator, seed) {
      return lift_1.operate(function(source, subscriber) {
        var state = seed;
        switchMap_1.switchMap(function(value, index) {
          return accumulator(state, value, index);
        }, function(_, innerValue) {
          return state = innerValue, innerValue;
        })(source).subscribe(subscriber);
        return function() {
          state = null;
        };
      });
    }
    exports.switchScan = switchScan;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/takeUntil.js
var require_takeUntil = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/takeUntil.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.takeUntil = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var innerFrom_1 = require_innerFrom();
    var noop_1 = require_noop();
    function takeUntil(notifier) {
      return lift_1.operate(function(source, subscriber) {
        innerFrom_1.innerFrom(notifier).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
          return subscriber.complete();
        }, noop_1.noop));
        !subscriber.closed && source.subscribe(subscriber);
      });
    }
    exports.takeUntil = takeUntil;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/takeWhile.js
var require_takeWhile = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/takeWhile.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.takeWhile = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function takeWhile(predicate, inclusive) {
      if (inclusive === void 0) {
        inclusive = false;
      }
      return lift_1.operate(function(source, subscriber) {
        var index = 0;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          var result = predicate(value, index++);
          (result || inclusive) && subscriber.next(value);
          !result && subscriber.complete();
        }));
      });
    }
    exports.takeWhile = takeWhile;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/tap.js
var require_tap = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/tap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.tap = void 0;
    var isFunction_1 = require_isFunction();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var identity_1 = require_identity();
    function tap(observerOrNext, error, complete) {
      var tapObserver = isFunction_1.isFunction(observerOrNext) || error || complete ? { next: observerOrNext, error, complete } : observerOrNext;
      return tapObserver ? lift_1.operate(function(source, subscriber) {
        var _a;
        (_a = tapObserver.subscribe) === null || _a === void 0 ? void 0 : _a.call(tapObserver);
        var isUnsub = true;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          var _a2;
          (_a2 = tapObserver.next) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver, value);
          subscriber.next(value);
        }, function() {
          var _a2;
          isUnsub = false;
          (_a2 = tapObserver.complete) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver);
          subscriber.complete();
        }, function(err) {
          var _a2;
          isUnsub = false;
          (_a2 = tapObserver.error) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver, err);
          subscriber.error(err);
        }, function() {
          var _a2, _b;
          if (isUnsub) {
            (_a2 = tapObserver.unsubscribe) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver);
          }
          (_b = tapObserver.finalize) === null || _b === void 0 ? void 0 : _b.call(tapObserver);
        }));
      }) : identity_1.identity;
    }
    exports.tap = tap;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/throttle.js
var require_throttle = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/throttle.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.throttle = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var innerFrom_1 = require_innerFrom();
    function throttle(durationSelector, config2) {
      return lift_1.operate(function(source, subscriber) {
        var _a = config2 !== null && config2 !== void 0 ? config2 : {}, _b = _a.leading, leading = _b === void 0 ? true : _b, _c = _a.trailing, trailing = _c === void 0 ? false : _c;
        var hasValue = false;
        var sendValue = null;
        var throttled = null;
        var isComplete = false;
        var endThrottling = function() {
          throttled === null || throttled === void 0 ? void 0 : throttled.unsubscribe();
          throttled = null;
          if (trailing) {
            send();
            isComplete && subscriber.complete();
          }
        };
        var cleanupThrottling = function() {
          throttled = null;
          isComplete && subscriber.complete();
        };
        var startThrottle = function(value) {
          return throttled = innerFrom_1.innerFrom(durationSelector(value)).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, endThrottling, cleanupThrottling));
        };
        var send = function() {
          if (hasValue) {
            hasValue = false;
            var value = sendValue;
            sendValue = null;
            subscriber.next(value);
            !isComplete && startThrottle(value);
          }
        };
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          hasValue = true;
          sendValue = value;
          !(throttled && !throttled.closed) && (leading ? send() : startThrottle(value));
        }, function() {
          isComplete = true;
          !(trailing && hasValue && throttled && !throttled.closed) && subscriber.complete();
        }));
      });
    }
    exports.throttle = throttle;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/throttleTime.js
var require_throttleTime = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/throttleTime.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.throttleTime = void 0;
    var async_1 = require_async();
    var throttle_1 = require_throttle();
    var timer_1 = require_timer();
    function throttleTime(duration, scheduler, config2) {
      if (scheduler === void 0) {
        scheduler = async_1.asyncScheduler;
      }
      var duration$ = timer_1.timer(duration, scheduler);
      return throttle_1.throttle(function() {
        return duration$;
      }, config2);
    }
    exports.throttleTime = throttleTime;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/timeInterval.js
var require_timeInterval = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/timeInterval.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TimeInterval = exports.timeInterval = void 0;
    var async_1 = require_async();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function timeInterval(scheduler) {
      if (scheduler === void 0) {
        scheduler = async_1.asyncScheduler;
      }
      return lift_1.operate(function(source, subscriber) {
        var last = scheduler.now();
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          var now = scheduler.now();
          var interval = now - last;
          last = now;
          subscriber.next(new TimeInterval(value, interval));
        }));
      });
    }
    exports.timeInterval = timeInterval;
    var TimeInterval = /* @__PURE__ */ function() {
      function TimeInterval2(value, interval) {
        this.value = value;
        this.interval = interval;
      }
      return TimeInterval2;
    }();
    exports.TimeInterval = TimeInterval;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/timeoutWith.js
var require_timeoutWith = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/timeoutWith.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.timeoutWith = void 0;
    var async_1 = require_async();
    var isDate_1 = require_isDate();
    var timeout_1 = require_timeout();
    function timeoutWith(due, withObservable, scheduler) {
      var first;
      var each;
      var _with;
      scheduler = scheduler !== null && scheduler !== void 0 ? scheduler : async_1.async;
      if (isDate_1.isValidDate(due)) {
        first = due;
      } else if (typeof due === "number") {
        each = due;
      }
      if (withObservable) {
        _with = function() {
          return withObservable;
        };
      } else {
        throw new TypeError("No observable provided to switch to");
      }
      if (first == null && each == null) {
        throw new TypeError("No timeout provided.");
      }
      return timeout_1.timeout({
        first,
        each,
        scheduler,
        with: _with
      });
    }
    exports.timeoutWith = timeoutWith;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/timestamp.js
var require_timestamp = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/timestamp.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.timestamp = void 0;
    var dateTimestampProvider_1 = require_dateTimestampProvider();
    var map_1 = require_map();
    function timestamp(timestampProvider) {
      if (timestampProvider === void 0) {
        timestampProvider = dateTimestampProvider_1.dateTimestampProvider;
      }
      return map_1.map(function(value) {
        return { value, timestamp: timestampProvider.now() };
      });
    }
    exports.timestamp = timestamp;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/window.js
var require_window = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/window.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.window = void 0;
    var Subject_1 = require_Subject();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var noop_1 = require_noop();
    var innerFrom_1 = require_innerFrom();
    function window2(windowBoundaries) {
      return lift_1.operate(function(source, subscriber) {
        var windowSubject = new Subject_1.Subject();
        subscriber.next(windowSubject.asObservable());
        var errorHandler = function(err) {
          windowSubject.error(err);
          subscriber.error(err);
        };
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          return windowSubject === null || windowSubject === void 0 ? void 0 : windowSubject.next(value);
        }, function() {
          windowSubject.complete();
          subscriber.complete();
        }, errorHandler));
        innerFrom_1.innerFrom(windowBoundaries).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
          windowSubject.complete();
          subscriber.next(windowSubject = new Subject_1.Subject());
        }, noop_1.noop, errorHandler));
        return function() {
          windowSubject === null || windowSubject === void 0 ? void 0 : windowSubject.unsubscribe();
          windowSubject = null;
        };
      });
    }
    exports.window = window2;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/windowCount.js
var require_windowCount = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/windowCount.js"(exports) {
    "use strict";
    var __values = exports && exports.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = void 0;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.windowCount = void 0;
    var Subject_1 = require_Subject();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function windowCount(windowSize, startWindowEvery) {
      if (startWindowEvery === void 0) {
        startWindowEvery = 0;
      }
      var startEvery = startWindowEvery > 0 ? startWindowEvery : windowSize;
      return lift_1.operate(function(source, subscriber) {
        var windows = [new Subject_1.Subject()];
        var starts = [];
        var count = 0;
        subscriber.next(windows[0].asObservable());
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          var e_1, _a;
          try {
            for (var windows_1 = __values(windows), windows_1_1 = windows_1.next(); !windows_1_1.done; windows_1_1 = windows_1.next()) {
              var window_1 = windows_1_1.value;
              window_1.next(value);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (windows_1_1 && !windows_1_1.done && (_a = windows_1.return))
                _a.call(windows_1);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
          var c = count - windowSize + 1;
          if (c >= 0 && c % startEvery === 0) {
            windows.shift().complete();
          }
          if (++count % startEvery === 0) {
            var window_2 = new Subject_1.Subject();
            windows.push(window_2);
            subscriber.next(window_2.asObservable());
          }
        }, function() {
          while (windows.length > 0) {
            windows.shift().complete();
          }
          subscriber.complete();
        }, function(err) {
          while (windows.length > 0) {
            windows.shift().error(err);
          }
          subscriber.error(err);
        }, function() {
          starts = null;
          windows = null;
        }));
      });
    }
    exports.windowCount = windowCount;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/windowTime.js
var require_windowTime = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/windowTime.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.windowTime = void 0;
    var Subject_1 = require_Subject();
    var async_1 = require_async();
    var Subscription_1 = require_Subscription();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var arrRemove_1 = require_arrRemove();
    var args_1 = require_args();
    var executeSchedule_1 = require_executeSchedule();
    function windowTime(windowTimeSpan) {
      var _a, _b;
      var otherArgs = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        otherArgs[_i - 1] = arguments[_i];
      }
      var scheduler = (_a = args_1.popScheduler(otherArgs)) !== null && _a !== void 0 ? _a : async_1.asyncScheduler;
      var windowCreationInterval = (_b = otherArgs[0]) !== null && _b !== void 0 ? _b : null;
      var maxWindowSize = otherArgs[1] || Infinity;
      return lift_1.operate(function(source, subscriber) {
        var windowRecords = [];
        var restartOnClose = false;
        var closeWindow = function(record) {
          var window2 = record.window, subs = record.subs;
          window2.complete();
          subs.unsubscribe();
          arrRemove_1.arrRemove(windowRecords, record);
          restartOnClose && startWindow();
        };
        var startWindow = function() {
          if (windowRecords) {
            var subs = new Subscription_1.Subscription();
            subscriber.add(subs);
            var window_1 = new Subject_1.Subject();
            var record_1 = {
              window: window_1,
              subs,
              seen: 0
            };
            windowRecords.push(record_1);
            subscriber.next(window_1.asObservable());
            executeSchedule_1.executeSchedule(subs, scheduler, function() {
              return closeWindow(record_1);
            }, windowTimeSpan);
          }
        };
        if (windowCreationInterval !== null && windowCreationInterval >= 0) {
          executeSchedule_1.executeSchedule(subscriber, scheduler, startWindow, windowCreationInterval, true);
        } else {
          restartOnClose = true;
        }
        startWindow();
        var loop = function(cb) {
          return windowRecords.slice().forEach(cb);
        };
        var terminate = function(cb) {
          loop(function(_a2) {
            var window2 = _a2.window;
            return cb(window2);
          });
          cb(subscriber);
          subscriber.unsubscribe();
        };
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          loop(function(record) {
            record.window.next(value);
            maxWindowSize <= ++record.seen && closeWindow(record);
          });
        }, function() {
          return terminate(function(consumer) {
            return consumer.complete();
          });
        }, function(err) {
          return terminate(function(consumer) {
            return consumer.error(err);
          });
        }));
        return function() {
          windowRecords = null;
        };
      });
    }
    exports.windowTime = windowTime;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/windowToggle.js
var require_windowToggle = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/windowToggle.js"(exports) {
    "use strict";
    var __values = exports && exports.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = void 0;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.windowToggle = void 0;
    var Subject_1 = require_Subject();
    var Subscription_1 = require_Subscription();
    var lift_1 = require_lift();
    var innerFrom_1 = require_innerFrom();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var noop_1 = require_noop();
    var arrRemove_1 = require_arrRemove();
    function windowToggle(openings, closingSelector) {
      return lift_1.operate(function(source, subscriber) {
        var windows = [];
        var handleError = function(err) {
          while (0 < windows.length) {
            windows.shift().error(err);
          }
          subscriber.error(err);
        };
        innerFrom_1.innerFrom(openings).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(openValue) {
          var window2 = new Subject_1.Subject();
          windows.push(window2);
          var closingSubscription = new Subscription_1.Subscription();
          var closeWindow = function() {
            arrRemove_1.arrRemove(windows, window2);
            window2.complete();
            closingSubscription.unsubscribe();
          };
          var closingNotifier;
          try {
            closingNotifier = innerFrom_1.innerFrom(closingSelector(openValue));
          } catch (err) {
            handleError(err);
            return;
          }
          subscriber.next(window2.asObservable());
          closingSubscription.add(closingNotifier.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, closeWindow, noop_1.noop, handleError)));
        }, noop_1.noop));
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          var e_1, _a;
          var windowsCopy = windows.slice();
          try {
            for (var windowsCopy_1 = __values(windowsCopy), windowsCopy_1_1 = windowsCopy_1.next(); !windowsCopy_1_1.done; windowsCopy_1_1 = windowsCopy_1.next()) {
              var window_1 = windowsCopy_1_1.value;
              window_1.next(value);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (windowsCopy_1_1 && !windowsCopy_1_1.done && (_a = windowsCopy_1.return))
                _a.call(windowsCopy_1);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
        }, function() {
          while (0 < windows.length) {
            windows.shift().complete();
          }
          subscriber.complete();
        }, handleError, function() {
          while (0 < windows.length) {
            windows.shift().unsubscribe();
          }
        }));
      });
    }
    exports.windowToggle = windowToggle;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/windowWhen.js
var require_windowWhen = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/windowWhen.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.windowWhen = void 0;
    var Subject_1 = require_Subject();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var innerFrom_1 = require_innerFrom();
    function windowWhen(closingSelector) {
      return lift_1.operate(function(source, subscriber) {
        var window2;
        var closingSubscriber;
        var handleError = function(err) {
          window2.error(err);
          subscriber.error(err);
        };
        var openWindow = function() {
          closingSubscriber === null || closingSubscriber === void 0 ? void 0 : closingSubscriber.unsubscribe();
          window2 === null || window2 === void 0 ? void 0 : window2.complete();
          window2 = new Subject_1.Subject();
          subscriber.next(window2.asObservable());
          var closingNotifier;
          try {
            closingNotifier = innerFrom_1.innerFrom(closingSelector());
          } catch (err) {
            handleError(err);
            return;
          }
          closingNotifier.subscribe(closingSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, openWindow, openWindow, handleError));
        };
        openWindow();
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          return window2.next(value);
        }, function() {
          window2.complete();
          subscriber.complete();
        }, handleError, function() {
          closingSubscriber === null || closingSubscriber === void 0 ? void 0 : closingSubscriber.unsubscribe();
          window2 = null;
        }));
      });
    }
    exports.windowWhen = windowWhen;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/withLatestFrom.js
var require_withLatestFrom = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/withLatestFrom.js"(exports) {
    "use strict";
    var __read = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray2 = exports && exports.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.withLatestFrom = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var innerFrom_1 = require_innerFrom();
    var identity_1 = require_identity();
    var noop_1 = require_noop();
    var args_1 = require_args();
    function withLatestFrom() {
      var inputs = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        inputs[_i] = arguments[_i];
      }
      var project = args_1.popResultSelector(inputs);
      return lift_1.operate(function(source, subscriber) {
        var len = inputs.length;
        var otherValues = new Array(len);
        var hasValue = inputs.map(function() {
          return false;
        });
        var ready = false;
        var _loop_1 = function(i2) {
          innerFrom_1.innerFrom(inputs[i2]).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
            otherValues[i2] = value;
            if (!ready && !hasValue[i2]) {
              hasValue[i2] = true;
              (ready = hasValue.every(identity_1.identity)) && (hasValue = null);
            }
          }, noop_1.noop));
        };
        for (var i = 0; i < len; i++) {
          _loop_1(i);
        }
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          if (ready) {
            var values = __spreadArray2([value], __read(otherValues));
            subscriber.next(project ? project.apply(void 0, __spreadArray2([], __read(values))) : values);
          }
        }));
      });
    }
    exports.withLatestFrom = withLatestFrom;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/zipAll.js
var require_zipAll = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/zipAll.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.zipAll = void 0;
    var zip_1 = require_zip();
    var joinAllInternals_1 = require_joinAllInternals();
    function zipAll(project) {
      return joinAllInternals_1.joinAllInternals(zip_1.zip, project);
    }
    exports.zipAll = zipAll;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/zip.js
var require_zip2 = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/zip.js"(exports) {
    "use strict";
    var __read = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray2 = exports && exports.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.zip = void 0;
    var zip_1 = require_zip();
    var lift_1 = require_lift();
    function zip() {
      var sources = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        sources[_i] = arguments[_i];
      }
      return lift_1.operate(function(source, subscriber) {
        zip_1.zip.apply(void 0, __spreadArray2([source], __read(sources))).subscribe(subscriber);
      });
    }
    exports.zip = zip;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/zipWith.js
var require_zipWith = __commonJS({
  "node_modules/rxjs/dist/cjs/internal/operators/zipWith.js"(exports) {
    "use strict";
    var __read = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray2 = exports && exports.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.zipWith = void 0;
    var zip_1 = require_zip2();
    function zipWith() {
      var otherInputs = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        otherInputs[_i] = arguments[_i];
      }
      return zip_1.zip.apply(void 0, __spreadArray2([], __read(otherInputs)));
    }
    exports.zipWith = zipWith;
  }
});

// node_modules/rxjs/dist/cjs/index.js
var require_cjs = __commonJS({
  "node_modules/rxjs/dist/cjs/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.interval = exports.iif = exports.generate = exports.fromEventPattern = exports.fromEvent = exports.from = exports.forkJoin = exports.empty = exports.defer = exports.connectable = exports.concat = exports.combineLatest = exports.bindNodeCallback = exports.bindCallback = exports.UnsubscriptionError = exports.TimeoutError = exports.SequenceError = exports.ObjectUnsubscribedError = exports.NotFoundError = exports.EmptyError = exports.ArgumentOutOfRangeError = exports.firstValueFrom = exports.lastValueFrom = exports.isObservable = exports.identity = exports.noop = exports.pipe = exports.NotificationKind = exports.Notification = exports.Subscriber = exports.Subscription = exports.Scheduler = exports.VirtualAction = exports.VirtualTimeScheduler = exports.animationFrameScheduler = exports.animationFrame = exports.queueScheduler = exports.queue = exports.asyncScheduler = exports.async = exports.asapScheduler = exports.asap = exports.AsyncSubject = exports.ReplaySubject = exports.BehaviorSubject = exports.Subject = exports.animationFrames = exports.observable = exports.ConnectableObservable = exports.Observable = void 0;
    exports.filter = exports.expand = exports.exhaustMap = exports.exhaustAll = exports.exhaust = exports.every = exports.endWith = exports.elementAt = exports.distinctUntilKeyChanged = exports.distinctUntilChanged = exports.distinct = exports.dematerialize = exports.delayWhen = exports.delay = exports.defaultIfEmpty = exports.debounceTime = exports.debounce = exports.count = exports.connect = exports.concatWith = exports.concatMapTo = exports.concatMap = exports.concatAll = exports.combineLatestWith = exports.combineLatestAll = exports.combineAll = exports.catchError = exports.bufferWhen = exports.bufferToggle = exports.bufferTime = exports.bufferCount = exports.buffer = exports.auditTime = exports.audit = exports.config = exports.NEVER = exports.EMPTY = exports.scheduled = exports.zip = exports.using = exports.timer = exports.throwError = exports.range = exports.race = exports.partition = exports.pairs = exports.onErrorResumeNext = exports.of = exports.never = exports.merge = void 0;
    exports.switchMap = exports.switchAll = exports.subscribeOn = exports.startWith = exports.skipWhile = exports.skipUntil = exports.skipLast = exports.skip = exports.single = exports.shareReplay = exports.share = exports.sequenceEqual = exports.scan = exports.sampleTime = exports.sample = exports.refCount = exports.retryWhen = exports.retry = exports.repeatWhen = exports.repeat = exports.reduce = exports.raceWith = exports.publishReplay = exports.publishLast = exports.publishBehavior = exports.publish = exports.pluck = exports.pairwise = exports.onErrorResumeNextWith = exports.observeOn = exports.multicast = exports.min = exports.mergeWith = exports.mergeScan = exports.mergeMapTo = exports.mergeMap = exports.flatMap = exports.mergeAll = exports.max = exports.materialize = exports.mapTo = exports.map = exports.last = exports.isEmpty = exports.ignoreElements = exports.groupBy = exports.first = exports.findIndex = exports.find = exports.finalize = void 0;
    exports.zipWith = exports.zipAll = exports.withLatestFrom = exports.windowWhen = exports.windowToggle = exports.windowTime = exports.windowCount = exports.window = exports.toArray = exports.timestamp = exports.timeoutWith = exports.timeout = exports.timeInterval = exports.throwIfEmpty = exports.throttleTime = exports.throttle = exports.tap = exports.takeWhile = exports.takeUntil = exports.takeLast = exports.take = exports.switchScan = exports.switchMapTo = void 0;
    var Observable_1 = require_Observable();
    Object.defineProperty(exports, "Observable", { enumerable: true, get: function() {
      return Observable_1.Observable;
    } });
    var ConnectableObservable_1 = require_ConnectableObservable();
    Object.defineProperty(exports, "ConnectableObservable", { enumerable: true, get: function() {
      return ConnectableObservable_1.ConnectableObservable;
    } });
    var observable_1 = require_observable();
    Object.defineProperty(exports, "observable", { enumerable: true, get: function() {
      return observable_1.observable;
    } });
    var animationFrames_1 = require_animationFrames();
    Object.defineProperty(exports, "animationFrames", { enumerable: true, get: function() {
      return animationFrames_1.animationFrames;
    } });
    var Subject_1 = require_Subject();
    Object.defineProperty(exports, "Subject", { enumerable: true, get: function() {
      return Subject_1.Subject;
    } });
    var BehaviorSubject_1 = require_BehaviorSubject();
    Object.defineProperty(exports, "BehaviorSubject", { enumerable: true, get: function() {
      return BehaviorSubject_1.BehaviorSubject;
    } });
    var ReplaySubject_1 = require_ReplaySubject();
    Object.defineProperty(exports, "ReplaySubject", { enumerable: true, get: function() {
      return ReplaySubject_1.ReplaySubject;
    } });
    var AsyncSubject_1 = require_AsyncSubject();
    Object.defineProperty(exports, "AsyncSubject", { enumerable: true, get: function() {
      return AsyncSubject_1.AsyncSubject;
    } });
    var asap_1 = require_asap();
    Object.defineProperty(exports, "asap", { enumerable: true, get: function() {
      return asap_1.asap;
    } });
    Object.defineProperty(exports, "asapScheduler", { enumerable: true, get: function() {
      return asap_1.asapScheduler;
    } });
    var async_1 = require_async();
    Object.defineProperty(exports, "async", { enumerable: true, get: function() {
      return async_1.async;
    } });
    Object.defineProperty(exports, "asyncScheduler", { enumerable: true, get: function() {
      return async_1.asyncScheduler;
    } });
    var queue_1 = require_queue();
    Object.defineProperty(exports, "queue", { enumerable: true, get: function() {
      return queue_1.queue;
    } });
    Object.defineProperty(exports, "queueScheduler", { enumerable: true, get: function() {
      return queue_1.queueScheduler;
    } });
    var animationFrame_1 = require_animationFrame();
    Object.defineProperty(exports, "animationFrame", { enumerable: true, get: function() {
      return animationFrame_1.animationFrame;
    } });
    Object.defineProperty(exports, "animationFrameScheduler", { enumerable: true, get: function() {
      return animationFrame_1.animationFrameScheduler;
    } });
    var VirtualTimeScheduler_1 = require_VirtualTimeScheduler();
    Object.defineProperty(exports, "VirtualTimeScheduler", { enumerable: true, get: function() {
      return VirtualTimeScheduler_1.VirtualTimeScheduler;
    } });
    Object.defineProperty(exports, "VirtualAction", { enumerable: true, get: function() {
      return VirtualTimeScheduler_1.VirtualAction;
    } });
    var Scheduler_1 = require_Scheduler();
    Object.defineProperty(exports, "Scheduler", { enumerable: true, get: function() {
      return Scheduler_1.Scheduler;
    } });
    var Subscription_1 = require_Subscription();
    Object.defineProperty(exports, "Subscription", { enumerable: true, get: function() {
      return Subscription_1.Subscription;
    } });
    var Subscriber_1 = require_Subscriber();
    Object.defineProperty(exports, "Subscriber", { enumerable: true, get: function() {
      return Subscriber_1.Subscriber;
    } });
    var Notification_1 = require_Notification();
    Object.defineProperty(exports, "Notification", { enumerable: true, get: function() {
      return Notification_1.Notification;
    } });
    Object.defineProperty(exports, "NotificationKind", { enumerable: true, get: function() {
      return Notification_1.NotificationKind;
    } });
    var pipe_1 = require_pipe();
    Object.defineProperty(exports, "pipe", { enumerable: true, get: function() {
      return pipe_1.pipe;
    } });
    var noop_1 = require_noop();
    Object.defineProperty(exports, "noop", { enumerable: true, get: function() {
      return noop_1.noop;
    } });
    var identity_1 = require_identity();
    Object.defineProperty(exports, "identity", { enumerable: true, get: function() {
      return identity_1.identity;
    } });
    var isObservable_1 = require_isObservable();
    Object.defineProperty(exports, "isObservable", { enumerable: true, get: function() {
      return isObservable_1.isObservable;
    } });
    var lastValueFrom_1 = require_lastValueFrom();
    Object.defineProperty(exports, "lastValueFrom", { enumerable: true, get: function() {
      return lastValueFrom_1.lastValueFrom;
    } });
    var firstValueFrom_1 = require_firstValueFrom();
    Object.defineProperty(exports, "firstValueFrom", { enumerable: true, get: function() {
      return firstValueFrom_1.firstValueFrom;
    } });
    var ArgumentOutOfRangeError_1 = require_ArgumentOutOfRangeError();
    Object.defineProperty(exports, "ArgumentOutOfRangeError", { enumerable: true, get: function() {
      return ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;
    } });
    var EmptyError_1 = require_EmptyError();
    Object.defineProperty(exports, "EmptyError", { enumerable: true, get: function() {
      return EmptyError_1.EmptyError;
    } });
    var NotFoundError_1 = require_NotFoundError();
    Object.defineProperty(exports, "NotFoundError", { enumerable: true, get: function() {
      return NotFoundError_1.NotFoundError;
    } });
    var ObjectUnsubscribedError_1 = require_ObjectUnsubscribedError();
    Object.defineProperty(exports, "ObjectUnsubscribedError", { enumerable: true, get: function() {
      return ObjectUnsubscribedError_1.ObjectUnsubscribedError;
    } });
    var SequenceError_1 = require_SequenceError();
    Object.defineProperty(exports, "SequenceError", { enumerable: true, get: function() {
      return SequenceError_1.SequenceError;
    } });
    var timeout_1 = require_timeout();
    Object.defineProperty(exports, "TimeoutError", { enumerable: true, get: function() {
      return timeout_1.TimeoutError;
    } });
    var UnsubscriptionError_1 = require_UnsubscriptionError();
    Object.defineProperty(exports, "UnsubscriptionError", { enumerable: true, get: function() {
      return UnsubscriptionError_1.UnsubscriptionError;
    } });
    var bindCallback_1 = require_bindCallback();
    Object.defineProperty(exports, "bindCallback", { enumerable: true, get: function() {
      return bindCallback_1.bindCallback;
    } });
    var bindNodeCallback_1 = require_bindNodeCallback();
    Object.defineProperty(exports, "bindNodeCallback", { enumerable: true, get: function() {
      return bindNodeCallback_1.bindNodeCallback;
    } });
    var combineLatest_1 = require_combineLatest();
    Object.defineProperty(exports, "combineLatest", { enumerable: true, get: function() {
      return combineLatest_1.combineLatest;
    } });
    var concat_1 = require_concat();
    Object.defineProperty(exports, "concat", { enumerable: true, get: function() {
      return concat_1.concat;
    } });
    var connectable_1 = require_connectable();
    Object.defineProperty(exports, "connectable", { enumerable: true, get: function() {
      return connectable_1.connectable;
    } });
    var defer_1 = require_defer();
    Object.defineProperty(exports, "defer", { enumerable: true, get: function() {
      return defer_1.defer;
    } });
    var empty_1 = require_empty();
    Object.defineProperty(exports, "empty", { enumerable: true, get: function() {
      return empty_1.empty;
    } });
    var forkJoin_1 = require_forkJoin();
    Object.defineProperty(exports, "forkJoin", { enumerable: true, get: function() {
      return forkJoin_1.forkJoin;
    } });
    var from_1 = require_from();
    Object.defineProperty(exports, "from", { enumerable: true, get: function() {
      return from_1.from;
    } });
    var fromEvent_1 = require_fromEvent();
    Object.defineProperty(exports, "fromEvent", { enumerable: true, get: function() {
      return fromEvent_1.fromEvent;
    } });
    var fromEventPattern_1 = require_fromEventPattern();
    Object.defineProperty(exports, "fromEventPattern", { enumerable: true, get: function() {
      return fromEventPattern_1.fromEventPattern;
    } });
    var generate_1 = require_generate();
    Object.defineProperty(exports, "generate", { enumerable: true, get: function() {
      return generate_1.generate;
    } });
    var iif_1 = require_iif();
    Object.defineProperty(exports, "iif", { enumerable: true, get: function() {
      return iif_1.iif;
    } });
    var interval_1 = require_interval();
    Object.defineProperty(exports, "interval", { enumerable: true, get: function() {
      return interval_1.interval;
    } });
    var merge_1 = require_merge();
    Object.defineProperty(exports, "merge", { enumerable: true, get: function() {
      return merge_1.merge;
    } });
    var never_1 = require_never();
    Object.defineProperty(exports, "never", { enumerable: true, get: function() {
      return never_1.never;
    } });
    var of_1 = require_of();
    Object.defineProperty(exports, "of", { enumerable: true, get: function() {
      return of_1.of;
    } });
    var onErrorResumeNext_1 = require_onErrorResumeNext();
    Object.defineProperty(exports, "onErrorResumeNext", { enumerable: true, get: function() {
      return onErrorResumeNext_1.onErrorResumeNext;
    } });
    var pairs_1 = require_pairs();
    Object.defineProperty(exports, "pairs", { enumerable: true, get: function() {
      return pairs_1.pairs;
    } });
    var partition_1 = require_partition();
    Object.defineProperty(exports, "partition", { enumerable: true, get: function() {
      return partition_1.partition;
    } });
    var race_1 = require_race();
    Object.defineProperty(exports, "race", { enumerable: true, get: function() {
      return race_1.race;
    } });
    var range_1 = require_range();
    Object.defineProperty(exports, "range", { enumerable: true, get: function() {
      return range_1.range;
    } });
    var throwError_1 = require_throwError();
    Object.defineProperty(exports, "throwError", { enumerable: true, get: function() {
      return throwError_1.throwError;
    } });
    var timer_1 = require_timer();
    Object.defineProperty(exports, "timer", { enumerable: true, get: function() {
      return timer_1.timer;
    } });
    var using_1 = require_using();
    Object.defineProperty(exports, "using", { enumerable: true, get: function() {
      return using_1.using;
    } });
    var zip_1 = require_zip();
    Object.defineProperty(exports, "zip", { enumerable: true, get: function() {
      return zip_1.zip;
    } });
    var scheduled_1 = require_scheduled();
    Object.defineProperty(exports, "scheduled", { enumerable: true, get: function() {
      return scheduled_1.scheduled;
    } });
    var empty_2 = require_empty();
    Object.defineProperty(exports, "EMPTY", { enumerable: true, get: function() {
      return empty_2.EMPTY;
    } });
    var never_2 = require_never();
    Object.defineProperty(exports, "NEVER", { enumerable: true, get: function() {
      return never_2.NEVER;
    } });
    __exportStar(require_types(), exports);
    var config_1 = require_config();
    Object.defineProperty(exports, "config", { enumerable: true, get: function() {
      return config_1.config;
    } });
    var audit_1 = require_audit();
    Object.defineProperty(exports, "audit", { enumerable: true, get: function() {
      return audit_1.audit;
    } });
    var auditTime_1 = require_auditTime();
    Object.defineProperty(exports, "auditTime", { enumerable: true, get: function() {
      return auditTime_1.auditTime;
    } });
    var buffer_1 = require_buffer();
    Object.defineProperty(exports, "buffer", { enumerable: true, get: function() {
      return buffer_1.buffer;
    } });
    var bufferCount_1 = require_bufferCount();
    Object.defineProperty(exports, "bufferCount", { enumerable: true, get: function() {
      return bufferCount_1.bufferCount;
    } });
    var bufferTime_1 = require_bufferTime();
    Object.defineProperty(exports, "bufferTime", { enumerable: true, get: function() {
      return bufferTime_1.bufferTime;
    } });
    var bufferToggle_1 = require_bufferToggle();
    Object.defineProperty(exports, "bufferToggle", { enumerable: true, get: function() {
      return bufferToggle_1.bufferToggle;
    } });
    var bufferWhen_1 = require_bufferWhen();
    Object.defineProperty(exports, "bufferWhen", { enumerable: true, get: function() {
      return bufferWhen_1.bufferWhen;
    } });
    var catchError_1 = require_catchError();
    Object.defineProperty(exports, "catchError", { enumerable: true, get: function() {
      return catchError_1.catchError;
    } });
    var combineAll_1 = require_combineAll();
    Object.defineProperty(exports, "combineAll", { enumerable: true, get: function() {
      return combineAll_1.combineAll;
    } });
    var combineLatestAll_1 = require_combineLatestAll();
    Object.defineProperty(exports, "combineLatestAll", { enumerable: true, get: function() {
      return combineLatestAll_1.combineLatestAll;
    } });
    var combineLatestWith_1 = require_combineLatestWith();
    Object.defineProperty(exports, "combineLatestWith", { enumerable: true, get: function() {
      return combineLatestWith_1.combineLatestWith;
    } });
    var concatAll_1 = require_concatAll();
    Object.defineProperty(exports, "concatAll", { enumerable: true, get: function() {
      return concatAll_1.concatAll;
    } });
    var concatMap_1 = require_concatMap();
    Object.defineProperty(exports, "concatMap", { enumerable: true, get: function() {
      return concatMap_1.concatMap;
    } });
    var concatMapTo_1 = require_concatMapTo();
    Object.defineProperty(exports, "concatMapTo", { enumerable: true, get: function() {
      return concatMapTo_1.concatMapTo;
    } });
    var concatWith_1 = require_concatWith();
    Object.defineProperty(exports, "concatWith", { enumerable: true, get: function() {
      return concatWith_1.concatWith;
    } });
    var connect_1 = require_connect();
    Object.defineProperty(exports, "connect", { enumerable: true, get: function() {
      return connect_1.connect;
    } });
    var count_1 = require_count();
    Object.defineProperty(exports, "count", { enumerable: true, get: function() {
      return count_1.count;
    } });
    var debounce_1 = require_debounce();
    Object.defineProperty(exports, "debounce", { enumerable: true, get: function() {
      return debounce_1.debounce;
    } });
    var debounceTime_1 = require_debounceTime();
    Object.defineProperty(exports, "debounceTime", { enumerable: true, get: function() {
      return debounceTime_1.debounceTime;
    } });
    var defaultIfEmpty_1 = require_defaultIfEmpty();
    Object.defineProperty(exports, "defaultIfEmpty", { enumerable: true, get: function() {
      return defaultIfEmpty_1.defaultIfEmpty;
    } });
    var delay_1 = require_delay();
    Object.defineProperty(exports, "delay", { enumerable: true, get: function() {
      return delay_1.delay;
    } });
    var delayWhen_1 = require_delayWhen();
    Object.defineProperty(exports, "delayWhen", { enumerable: true, get: function() {
      return delayWhen_1.delayWhen;
    } });
    var dematerialize_1 = require_dematerialize();
    Object.defineProperty(exports, "dematerialize", { enumerable: true, get: function() {
      return dematerialize_1.dematerialize;
    } });
    var distinct_1 = require_distinct();
    Object.defineProperty(exports, "distinct", { enumerable: true, get: function() {
      return distinct_1.distinct;
    } });
    var distinctUntilChanged_1 = require_distinctUntilChanged();
    Object.defineProperty(exports, "distinctUntilChanged", { enumerable: true, get: function() {
      return distinctUntilChanged_1.distinctUntilChanged;
    } });
    var distinctUntilKeyChanged_1 = require_distinctUntilKeyChanged();
    Object.defineProperty(exports, "distinctUntilKeyChanged", { enumerable: true, get: function() {
      return distinctUntilKeyChanged_1.distinctUntilKeyChanged;
    } });
    var elementAt_1 = require_elementAt();
    Object.defineProperty(exports, "elementAt", { enumerable: true, get: function() {
      return elementAt_1.elementAt;
    } });
    var endWith_1 = require_endWith();
    Object.defineProperty(exports, "endWith", { enumerable: true, get: function() {
      return endWith_1.endWith;
    } });
    var every_1 = require_every();
    Object.defineProperty(exports, "every", { enumerable: true, get: function() {
      return every_1.every;
    } });
    var exhaust_1 = require_exhaust();
    Object.defineProperty(exports, "exhaust", { enumerable: true, get: function() {
      return exhaust_1.exhaust;
    } });
    var exhaustAll_1 = require_exhaustAll();
    Object.defineProperty(exports, "exhaustAll", { enumerable: true, get: function() {
      return exhaustAll_1.exhaustAll;
    } });
    var exhaustMap_1 = require_exhaustMap();
    Object.defineProperty(exports, "exhaustMap", { enumerable: true, get: function() {
      return exhaustMap_1.exhaustMap;
    } });
    var expand_1 = require_expand();
    Object.defineProperty(exports, "expand", { enumerable: true, get: function() {
      return expand_1.expand;
    } });
    var filter_1 = require_filter();
    Object.defineProperty(exports, "filter", { enumerable: true, get: function() {
      return filter_1.filter;
    } });
    var finalize_1 = require_finalize();
    Object.defineProperty(exports, "finalize", { enumerable: true, get: function() {
      return finalize_1.finalize;
    } });
    var find_1 = require_find();
    Object.defineProperty(exports, "find", { enumerable: true, get: function() {
      return find_1.find;
    } });
    var findIndex_1 = require_findIndex();
    Object.defineProperty(exports, "findIndex", { enumerable: true, get: function() {
      return findIndex_1.findIndex;
    } });
    var first_1 = require_first();
    Object.defineProperty(exports, "first", { enumerable: true, get: function() {
      return first_1.first;
    } });
    var groupBy_1 = require_groupBy();
    Object.defineProperty(exports, "groupBy", { enumerable: true, get: function() {
      return groupBy_1.groupBy;
    } });
    var ignoreElements_1 = require_ignoreElements();
    Object.defineProperty(exports, "ignoreElements", { enumerable: true, get: function() {
      return ignoreElements_1.ignoreElements;
    } });
    var isEmpty_1 = require_isEmpty();
    Object.defineProperty(exports, "isEmpty", { enumerable: true, get: function() {
      return isEmpty_1.isEmpty;
    } });
    var last_1 = require_last();
    Object.defineProperty(exports, "last", { enumerable: true, get: function() {
      return last_1.last;
    } });
    var map_1 = require_map();
    Object.defineProperty(exports, "map", { enumerable: true, get: function() {
      return map_1.map;
    } });
    var mapTo_1 = require_mapTo();
    Object.defineProperty(exports, "mapTo", { enumerable: true, get: function() {
      return mapTo_1.mapTo;
    } });
    var materialize_1 = require_materialize();
    Object.defineProperty(exports, "materialize", { enumerable: true, get: function() {
      return materialize_1.materialize;
    } });
    var max_1 = require_max();
    Object.defineProperty(exports, "max", { enumerable: true, get: function() {
      return max_1.max;
    } });
    var mergeAll_1 = require_mergeAll();
    Object.defineProperty(exports, "mergeAll", { enumerable: true, get: function() {
      return mergeAll_1.mergeAll;
    } });
    var flatMap_1 = require_flatMap();
    Object.defineProperty(exports, "flatMap", { enumerable: true, get: function() {
      return flatMap_1.flatMap;
    } });
    var mergeMap_1 = require_mergeMap();
    Object.defineProperty(exports, "mergeMap", { enumerable: true, get: function() {
      return mergeMap_1.mergeMap;
    } });
    var mergeMapTo_1 = require_mergeMapTo();
    Object.defineProperty(exports, "mergeMapTo", { enumerable: true, get: function() {
      return mergeMapTo_1.mergeMapTo;
    } });
    var mergeScan_1 = require_mergeScan();
    Object.defineProperty(exports, "mergeScan", { enumerable: true, get: function() {
      return mergeScan_1.mergeScan;
    } });
    var mergeWith_1 = require_mergeWith();
    Object.defineProperty(exports, "mergeWith", { enumerable: true, get: function() {
      return mergeWith_1.mergeWith;
    } });
    var min_1 = require_min();
    Object.defineProperty(exports, "min", { enumerable: true, get: function() {
      return min_1.min;
    } });
    var multicast_1 = require_multicast();
    Object.defineProperty(exports, "multicast", { enumerable: true, get: function() {
      return multicast_1.multicast;
    } });
    var observeOn_1 = require_observeOn();
    Object.defineProperty(exports, "observeOn", { enumerable: true, get: function() {
      return observeOn_1.observeOn;
    } });
    var onErrorResumeNextWith_1 = require_onErrorResumeNextWith();
    Object.defineProperty(exports, "onErrorResumeNextWith", { enumerable: true, get: function() {
      return onErrorResumeNextWith_1.onErrorResumeNextWith;
    } });
    var pairwise_1 = require_pairwise();
    Object.defineProperty(exports, "pairwise", { enumerable: true, get: function() {
      return pairwise_1.pairwise;
    } });
    var pluck_1 = require_pluck();
    Object.defineProperty(exports, "pluck", { enumerable: true, get: function() {
      return pluck_1.pluck;
    } });
    var publish_1 = require_publish();
    Object.defineProperty(exports, "publish", { enumerable: true, get: function() {
      return publish_1.publish;
    } });
    var publishBehavior_1 = require_publishBehavior();
    Object.defineProperty(exports, "publishBehavior", { enumerable: true, get: function() {
      return publishBehavior_1.publishBehavior;
    } });
    var publishLast_1 = require_publishLast();
    Object.defineProperty(exports, "publishLast", { enumerable: true, get: function() {
      return publishLast_1.publishLast;
    } });
    var publishReplay_1 = require_publishReplay();
    Object.defineProperty(exports, "publishReplay", { enumerable: true, get: function() {
      return publishReplay_1.publishReplay;
    } });
    var raceWith_1 = require_raceWith();
    Object.defineProperty(exports, "raceWith", { enumerable: true, get: function() {
      return raceWith_1.raceWith;
    } });
    var reduce_1 = require_reduce();
    Object.defineProperty(exports, "reduce", { enumerable: true, get: function() {
      return reduce_1.reduce;
    } });
    var repeat_1 = require_repeat();
    Object.defineProperty(exports, "repeat", { enumerable: true, get: function() {
      return repeat_1.repeat;
    } });
    var repeatWhen_1 = require_repeatWhen();
    Object.defineProperty(exports, "repeatWhen", { enumerable: true, get: function() {
      return repeatWhen_1.repeatWhen;
    } });
    var retry_1 = require_retry();
    Object.defineProperty(exports, "retry", { enumerable: true, get: function() {
      return retry_1.retry;
    } });
    var retryWhen_1 = require_retryWhen();
    Object.defineProperty(exports, "retryWhen", { enumerable: true, get: function() {
      return retryWhen_1.retryWhen;
    } });
    var refCount_1 = require_refCount();
    Object.defineProperty(exports, "refCount", { enumerable: true, get: function() {
      return refCount_1.refCount;
    } });
    var sample_1 = require_sample();
    Object.defineProperty(exports, "sample", { enumerable: true, get: function() {
      return sample_1.sample;
    } });
    var sampleTime_1 = require_sampleTime();
    Object.defineProperty(exports, "sampleTime", { enumerable: true, get: function() {
      return sampleTime_1.sampleTime;
    } });
    var scan_1 = require_scan();
    Object.defineProperty(exports, "scan", { enumerable: true, get: function() {
      return scan_1.scan;
    } });
    var sequenceEqual_1 = require_sequenceEqual();
    Object.defineProperty(exports, "sequenceEqual", { enumerable: true, get: function() {
      return sequenceEqual_1.sequenceEqual;
    } });
    var share_1 = require_share();
    Object.defineProperty(exports, "share", { enumerable: true, get: function() {
      return share_1.share;
    } });
    var shareReplay_1 = require_shareReplay();
    Object.defineProperty(exports, "shareReplay", { enumerable: true, get: function() {
      return shareReplay_1.shareReplay;
    } });
    var single_1 = require_single();
    Object.defineProperty(exports, "single", { enumerable: true, get: function() {
      return single_1.single;
    } });
    var skip_1 = require_skip();
    Object.defineProperty(exports, "skip", { enumerable: true, get: function() {
      return skip_1.skip;
    } });
    var skipLast_1 = require_skipLast();
    Object.defineProperty(exports, "skipLast", { enumerable: true, get: function() {
      return skipLast_1.skipLast;
    } });
    var skipUntil_1 = require_skipUntil();
    Object.defineProperty(exports, "skipUntil", { enumerable: true, get: function() {
      return skipUntil_1.skipUntil;
    } });
    var skipWhile_1 = require_skipWhile();
    Object.defineProperty(exports, "skipWhile", { enumerable: true, get: function() {
      return skipWhile_1.skipWhile;
    } });
    var startWith_1 = require_startWith();
    Object.defineProperty(exports, "startWith", { enumerable: true, get: function() {
      return startWith_1.startWith;
    } });
    var subscribeOn_1 = require_subscribeOn();
    Object.defineProperty(exports, "subscribeOn", { enumerable: true, get: function() {
      return subscribeOn_1.subscribeOn;
    } });
    var switchAll_1 = require_switchAll();
    Object.defineProperty(exports, "switchAll", { enumerable: true, get: function() {
      return switchAll_1.switchAll;
    } });
    var switchMap_1 = require_switchMap();
    Object.defineProperty(exports, "switchMap", { enumerable: true, get: function() {
      return switchMap_1.switchMap;
    } });
    var switchMapTo_1 = require_switchMapTo();
    Object.defineProperty(exports, "switchMapTo", { enumerable: true, get: function() {
      return switchMapTo_1.switchMapTo;
    } });
    var switchScan_1 = require_switchScan();
    Object.defineProperty(exports, "switchScan", { enumerable: true, get: function() {
      return switchScan_1.switchScan;
    } });
    var take_1 = require_take();
    Object.defineProperty(exports, "take", { enumerable: true, get: function() {
      return take_1.take;
    } });
    var takeLast_1 = require_takeLast();
    Object.defineProperty(exports, "takeLast", { enumerable: true, get: function() {
      return takeLast_1.takeLast;
    } });
    var takeUntil_1 = require_takeUntil();
    Object.defineProperty(exports, "takeUntil", { enumerable: true, get: function() {
      return takeUntil_1.takeUntil;
    } });
    var takeWhile_1 = require_takeWhile();
    Object.defineProperty(exports, "takeWhile", { enumerable: true, get: function() {
      return takeWhile_1.takeWhile;
    } });
    var tap_1 = require_tap();
    Object.defineProperty(exports, "tap", { enumerable: true, get: function() {
      return tap_1.tap;
    } });
    var throttle_1 = require_throttle();
    Object.defineProperty(exports, "throttle", { enumerable: true, get: function() {
      return throttle_1.throttle;
    } });
    var throttleTime_1 = require_throttleTime();
    Object.defineProperty(exports, "throttleTime", { enumerable: true, get: function() {
      return throttleTime_1.throttleTime;
    } });
    var throwIfEmpty_1 = require_throwIfEmpty();
    Object.defineProperty(exports, "throwIfEmpty", { enumerable: true, get: function() {
      return throwIfEmpty_1.throwIfEmpty;
    } });
    var timeInterval_1 = require_timeInterval();
    Object.defineProperty(exports, "timeInterval", { enumerable: true, get: function() {
      return timeInterval_1.timeInterval;
    } });
    var timeout_2 = require_timeout();
    Object.defineProperty(exports, "timeout", { enumerable: true, get: function() {
      return timeout_2.timeout;
    } });
    var timeoutWith_1 = require_timeoutWith();
    Object.defineProperty(exports, "timeoutWith", { enumerable: true, get: function() {
      return timeoutWith_1.timeoutWith;
    } });
    var timestamp_1 = require_timestamp();
    Object.defineProperty(exports, "timestamp", { enumerable: true, get: function() {
      return timestamp_1.timestamp;
    } });
    var toArray_1 = require_toArray();
    Object.defineProperty(exports, "toArray", { enumerable: true, get: function() {
      return toArray_1.toArray;
    } });
    var window_1 = require_window();
    Object.defineProperty(exports, "window", { enumerable: true, get: function() {
      return window_1.window;
    } });
    var windowCount_1 = require_windowCount();
    Object.defineProperty(exports, "windowCount", { enumerable: true, get: function() {
      return windowCount_1.windowCount;
    } });
    var windowTime_1 = require_windowTime();
    Object.defineProperty(exports, "windowTime", { enumerable: true, get: function() {
      return windowTime_1.windowTime;
    } });
    var windowToggle_1 = require_windowToggle();
    Object.defineProperty(exports, "windowToggle", { enumerable: true, get: function() {
      return windowToggle_1.windowToggle;
    } });
    var windowWhen_1 = require_windowWhen();
    Object.defineProperty(exports, "windowWhen", { enumerable: true, get: function() {
      return windowWhen_1.windowWhen;
    } });
    var withLatestFrom_1 = require_withLatestFrom();
    Object.defineProperty(exports, "withLatestFrom", { enumerable: true, get: function() {
      return withLatestFrom_1.withLatestFrom;
    } });
    var zipAll_1 = require_zipAll();
    Object.defineProperty(exports, "zipAll", { enumerable: true, get: function() {
      return zipAll_1.zipAll;
    } });
    var zipWith_1 = require_zipWith();
    Object.defineProperty(exports, "zipWith", { enumerable: true, get: function() {
      return zipWith_1.zipWith;
    } });
  }
});

// node_modules/ws/browser.js
var require_browser = __commonJS({
  "node_modules/ws/browser.js"(exports, module) {
    "use strict";
    module.exports = function() {
      throw new Error(
        "ws does not work in the browser. Browser clients must use the native WebSocket object"
      );
    };
  }
});

// node_modules/axios/dist/browser/axios.cjs
var require_axios = __commonJS({
  "node_modules/axios/dist/browser/axios.cjs"(exports, module) {
    "use strict";
    function bind(fn, thisArg) {
      return function wrap() {
        return fn.apply(thisArg, arguments);
      };
    }
    var { toString } = Object.prototype;
    var { getPrototypeOf } = Object;
    var kindOf = /* @__PURE__ */ ((cache) => (thing) => {
      const str = toString.call(thing);
      return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
    })(/* @__PURE__ */ Object.create(null));
    var kindOfTest = (type) => {
      type = type.toLowerCase();
      return (thing) => kindOf(thing) === type;
    };
    var typeOfTest = (type) => (thing) => typeof thing === type;
    var { isArray: isArray2 } = Array;
    var isUndefined = typeOfTest("undefined");
    function isBuffer(val) {
      return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
    }
    var isArrayBuffer = kindOfTest("ArrayBuffer");
    function isArrayBufferView(val) {
      let result;
      if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
        result = ArrayBuffer.isView(val);
      } else {
        result = val && val.buffer && isArrayBuffer(val.buffer);
      }
      return result;
    }
    var isString = typeOfTest("string");
    var isFunction = typeOfTest("function");
    var isNumber = typeOfTest("number");
    var isObject = (thing) => thing !== null && typeof thing === "object";
    var isBoolean = (thing) => thing === true || thing === false;
    var isPlainObject = (val) => {
      if (kindOf(val) !== "object") {
        return false;
      }
      const prototype2 = getPrototypeOf(val);
      return (prototype2 === null || prototype2 === Object.prototype || Object.getPrototypeOf(prototype2) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
    };
    var isDate = kindOfTest("Date");
    var isFile = kindOfTest("File");
    var isBlob = kindOfTest("Blob");
    var isFileList = kindOfTest("FileList");
    var isStream = (val) => isObject(val) && isFunction(val.pipe);
    var isFormData = (thing) => {
      let kind;
      return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
      kind === "object" && isFunction(thing.toString) && thing.toString() === "[object FormData]"));
    };
    var isURLSearchParams = kindOfTest("URLSearchParams");
    var trim = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
    function forEach(obj, fn, { allOwnKeys = false } = {}) {
      if (obj === null || typeof obj === "undefined") {
        return;
      }
      let i;
      let l;
      if (typeof obj !== "object") {
        obj = [obj];
      }
      if (isArray2(obj)) {
        for (i = 0, l = obj.length; i < l; i++) {
          fn.call(null, obj[i], i, obj);
        }
      } else {
        const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
        const len = keys.length;
        let key;
        for (i = 0; i < len; i++) {
          key = keys[i];
          fn.call(null, obj[key], key, obj);
        }
      }
    }
    function findKey(obj, key) {
      key = key.toLowerCase();
      const keys = Object.keys(obj);
      let i = keys.length;
      let _key;
      while (i-- > 0) {
        _key = keys[i];
        if (key === _key.toLowerCase()) {
          return _key;
        }
      }
      return null;
    }
    var _global = (() => {
      if (typeof globalThis !== "undefined")
        return globalThis;
      return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
    })();
    var isContextDefined = (context) => !isUndefined(context) && context !== _global;
    function merge() {
      const { caseless } = isContextDefined(this) && this || {};
      const result = {};
      const assignValue = (val, key) => {
        const targetKey = caseless && findKey(result, key) || key;
        if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
          result[targetKey] = merge(result[targetKey], val);
        } else if (isPlainObject(val)) {
          result[targetKey] = merge({}, val);
        } else if (isArray2(val)) {
          result[targetKey] = val.slice();
        } else {
          result[targetKey] = val;
        }
      };
      for (let i = 0, l = arguments.length; i < l; i++) {
        arguments[i] && forEach(arguments[i], assignValue);
      }
      return result;
    }
    var extend = (a, b, thisArg, { allOwnKeys } = {}) => {
      forEach(b, (val, key) => {
        if (thisArg && isFunction(val)) {
          a[key] = bind(val, thisArg);
        } else {
          a[key] = val;
        }
      }, { allOwnKeys });
      return a;
    };
    var stripBOM = (content) => {
      if (content.charCodeAt(0) === 65279) {
        content = content.slice(1);
      }
      return content;
    };
    var inherits = (constructor, superConstructor, props, descriptors2) => {
      constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
      constructor.prototype.constructor = constructor;
      Object.defineProperty(constructor, "super", {
        value: superConstructor.prototype
      });
      props && Object.assign(constructor.prototype, props);
    };
    var toFlatObject = (sourceObj, destObj, filter, propFilter) => {
      let props;
      let i;
      let prop;
      const merged = {};
      destObj = destObj || {};
      if (sourceObj == null)
        return destObj;
      do {
        props = Object.getOwnPropertyNames(sourceObj);
        i = props.length;
        while (i-- > 0) {
          prop = props[i];
          if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
            destObj[prop] = sourceObj[prop];
            merged[prop] = true;
          }
        }
        sourceObj = filter !== false && getPrototypeOf(sourceObj);
      } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);
      return destObj;
    };
    var endsWith = (str, searchString, position) => {
      str = String(str);
      if (position === void 0 || position > str.length) {
        position = str.length;
      }
      position -= searchString.length;
      const lastIndex = str.indexOf(searchString, position);
      return lastIndex !== -1 && lastIndex === position;
    };
    var toArray = (thing) => {
      if (!thing)
        return null;
      if (isArray2(thing))
        return thing;
      let i = thing.length;
      if (!isNumber(i))
        return null;
      const arr = new Array(i);
      while (i-- > 0) {
        arr[i] = thing[i];
      }
      return arr;
    };
    var isTypedArray = /* @__PURE__ */ ((TypedArray) => {
      return (thing) => {
        return TypedArray && thing instanceof TypedArray;
      };
    })(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
    var forEachEntry = (obj, fn) => {
      const generator = obj && obj[Symbol.iterator];
      const iterator = generator.call(obj);
      let result;
      while ((result = iterator.next()) && !result.done) {
        const pair = result.value;
        fn.call(obj, pair[0], pair[1]);
      }
    };
    var matchAll = (regExp, str) => {
      let matches;
      const arr = [];
      while ((matches = regExp.exec(str)) !== null) {
        arr.push(matches);
      }
      return arr;
    };
    var isHTMLForm = kindOfTest("HTMLFormElement");
    var toCamelCase = (str) => {
      return str.toLowerCase().replace(
        /[-_\s]([a-z\d])(\w*)/g,
        function replacer(m, p1, p2) {
          return p1.toUpperCase() + p2;
        }
      );
    };
    var hasOwnProperty = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
    var isRegExp = kindOfTest("RegExp");
    var reduceDescriptors = (obj, reducer) => {
      const descriptors2 = Object.getOwnPropertyDescriptors(obj);
      const reducedDescriptors = {};
      forEach(descriptors2, (descriptor, name) => {
        let ret;
        if ((ret = reducer(descriptor, name, obj)) !== false) {
          reducedDescriptors[name] = ret || descriptor;
        }
      });
      Object.defineProperties(obj, reducedDescriptors);
    };
    var freezeMethods = (obj) => {
      reduceDescriptors(obj, (descriptor, name) => {
        if (isFunction(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
          return false;
        }
        const value = obj[name];
        if (!isFunction(value))
          return;
        descriptor.enumerable = false;
        if ("writable" in descriptor) {
          descriptor.writable = false;
          return;
        }
        if (!descriptor.set) {
          descriptor.set = () => {
            throw Error("Can not rewrite read-only method '" + name + "'");
          };
        }
      });
    };
    var toObjectSet = (arrayOrString, delimiter) => {
      const obj = {};
      const define = (arr) => {
        arr.forEach((value) => {
          obj[value] = true;
        });
      };
      isArray2(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));
      return obj;
    };
    var noop = () => {
    };
    var toFiniteNumber = (value, defaultValue) => {
      value = +value;
      return Number.isFinite(value) ? value : defaultValue;
    };
    var ALPHA = "abcdefghijklmnopqrstuvwxyz";
    var DIGIT = "0123456789";
    var ALPHABET = {
      DIGIT,
      ALPHA,
      ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
    };
    var generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
      let str = "";
      const { length } = alphabet;
      while (size--) {
        str += alphabet[Math.random() * length | 0];
      }
      return str;
    };
    function isSpecCompliantForm(thing) {
      return !!(thing && isFunction(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator]);
    }
    var toJSONObject = (obj) => {
      const stack = new Array(10);
      const visit2 = (source, i) => {
        if (isObject(source)) {
          if (stack.indexOf(source) >= 0) {
            return;
          }
          if (!("toJSON" in source)) {
            stack[i] = source;
            const target = isArray2(source) ? [] : {};
            forEach(source, (value, key) => {
              const reducedValue = visit2(value, i + 1);
              !isUndefined(reducedValue) && (target[key] = reducedValue);
            });
            stack[i] = void 0;
            return target;
          }
        }
        return source;
      };
      return visit2(obj, 0);
    };
    var isAsyncFn = kindOfTest("AsyncFunction");
    var isThenable = (thing) => thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);
    var utils$1 = {
      isArray: isArray2,
      isArrayBuffer,
      isBuffer,
      isFormData,
      isArrayBufferView,
      isString,
      isNumber,
      isBoolean,
      isObject,
      isPlainObject,
      isUndefined,
      isDate,
      isFile,
      isBlob,
      isRegExp,
      isFunction,
      isStream,
      isURLSearchParams,
      isTypedArray,
      isFileList,
      forEach,
      merge,
      extend,
      trim,
      stripBOM,
      inherits,
      toFlatObject,
      kindOf,
      kindOfTest,
      endsWith,
      toArray,
      forEachEntry,
      matchAll,
      isHTMLForm,
      hasOwnProperty,
      hasOwnProp: hasOwnProperty,
      // an alias to avoid ESLint no-prototype-builtins detection
      reduceDescriptors,
      freezeMethods,
      toObjectSet,
      toCamelCase,
      noop,
      toFiniteNumber,
      findKey,
      global: _global,
      isContextDefined,
      ALPHABET,
      generateString,
      isSpecCompliantForm,
      toJSONObject,
      isAsyncFn,
      isThenable
    };
    function AxiosError(message, code, config2, request, response) {
      Error.call(this);
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      } else {
        this.stack = new Error().stack;
      }
      this.message = message;
      this.name = "AxiosError";
      code && (this.code = code);
      config2 && (this.config = config2);
      request && (this.request = request);
      response && (this.response = response);
    }
    utils$1.inherits(AxiosError, Error, {
      toJSON: function toJSON() {
        return {
          // Standard
          message: this.message,
          name: this.name,
          // Microsoft
          description: this.description,
          number: this.number,
          // Mozilla
          fileName: this.fileName,
          lineNumber: this.lineNumber,
          columnNumber: this.columnNumber,
          stack: this.stack,
          // Axios
          config: utils$1.toJSONObject(this.config),
          code: this.code,
          status: this.response && this.response.status ? this.response.status : null
        };
      }
    });
    var prototype$1 = AxiosError.prototype;
    var descriptors = {};
    [
      "ERR_BAD_OPTION_VALUE",
      "ERR_BAD_OPTION",
      "ECONNABORTED",
      "ETIMEDOUT",
      "ERR_NETWORK",
      "ERR_FR_TOO_MANY_REDIRECTS",
      "ERR_DEPRECATED",
      "ERR_BAD_RESPONSE",
      "ERR_BAD_REQUEST",
      "ERR_CANCELED",
      "ERR_NOT_SUPPORT",
      "ERR_INVALID_URL"
      // eslint-disable-next-line func-names
    ].forEach((code) => {
      descriptors[code] = { value: code };
    });
    Object.defineProperties(AxiosError, descriptors);
    Object.defineProperty(prototype$1, "isAxiosError", { value: true });
    AxiosError.from = (error, code, config2, request, response, customProps) => {
      const axiosError = Object.create(prototype$1);
      utils$1.toFlatObject(error, axiosError, function filter(obj) {
        return obj !== Error.prototype;
      }, (prop) => {
        return prop !== "isAxiosError";
      });
      AxiosError.call(axiosError, error.message, code, config2, request, response);
      axiosError.cause = error;
      axiosError.name = error.name;
      customProps && Object.assign(axiosError, customProps);
      return axiosError;
    };
    var httpAdapter = null;
    function isVisitable(thing) {
      return utils$1.isPlainObject(thing) || utils$1.isArray(thing);
    }
    function removeBrackets(key) {
      return utils$1.endsWith(key, "[]") ? key.slice(0, -2) : key;
    }
    function renderKey(path, key, dots) {
      if (!path)
        return key;
      return path.concat(key).map(function each(token, i) {
        token = removeBrackets(token);
        return !dots && i ? "[" + token + "]" : token;
      }).join(dots ? "." : "");
    }
    function isFlatArray(arr) {
      return utils$1.isArray(arr) && !arr.some(isVisitable);
    }
    var predicates = utils$1.toFlatObject(utils$1, {}, null, function filter(prop) {
      return /^is[A-Z]/.test(prop);
    });
    function toFormData(obj, formData, options) {
      if (!utils$1.isObject(obj)) {
        throw new TypeError("target must be an object");
      }
      formData = formData || new FormData();
      options = utils$1.toFlatObject(options, {
        metaTokens: true,
        dots: false,
        indexes: false
      }, false, function defined(option, source) {
        return !utils$1.isUndefined(source[option]);
      });
      const metaTokens = options.metaTokens;
      const visitor = options.visitor || defaultVisitor;
      const dots = options.dots;
      const indexes = options.indexes;
      const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
      const useBlob = _Blob && utils$1.isSpecCompliantForm(formData);
      if (!utils$1.isFunction(visitor)) {
        throw new TypeError("visitor must be a function");
      }
      function convertValue(value) {
        if (value === null)
          return "";
        if (utils$1.isDate(value)) {
          return value.toISOString();
        }
        if (!useBlob && utils$1.isBlob(value)) {
          throw new AxiosError("Blob is not supported. Use a Buffer instead.");
        }
        if (utils$1.isArrayBuffer(value) || utils$1.isTypedArray(value)) {
          return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
        }
        return value;
      }
      function defaultVisitor(value, key, path) {
        let arr = value;
        if (value && !path && typeof value === "object") {
          if (utils$1.endsWith(key, "{}")) {
            key = metaTokens ? key : key.slice(0, -2);
            value = JSON.stringify(value);
          } else if (utils$1.isArray(value) && isFlatArray(value) || (utils$1.isFileList(value) || utils$1.endsWith(key, "[]")) && (arr = utils$1.toArray(value))) {
            key = removeBrackets(key);
            arr.forEach(function each(el, index) {
              !(utils$1.isUndefined(el) || el === null) && formData.append(
                // eslint-disable-next-line no-nested-ternary
                indexes === true ? renderKey([key], index, dots) : indexes === null ? key : key + "[]",
                convertValue(el)
              );
            });
            return false;
          }
        }
        if (isVisitable(value)) {
          return true;
        }
        formData.append(renderKey(path, key, dots), convertValue(value));
        return false;
      }
      const stack = [];
      const exposedHelpers = Object.assign(predicates, {
        defaultVisitor,
        convertValue,
        isVisitable
      });
      function build(value, path) {
        if (utils$1.isUndefined(value))
          return;
        if (stack.indexOf(value) !== -1) {
          throw Error("Circular reference detected in " + path.join("."));
        }
        stack.push(value);
        utils$1.forEach(value, function each(el, key) {
          const result = !(utils$1.isUndefined(el) || el === null) && visitor.call(
            formData,
            el,
            utils$1.isString(key) ? key.trim() : key,
            path,
            exposedHelpers
          );
          if (result === true) {
            build(el, path ? path.concat(key) : [key]);
          }
        });
        stack.pop();
      }
      if (!utils$1.isObject(obj)) {
        throw new TypeError("data must be an object");
      }
      build(obj);
      return formData;
    }
    function encode$1(str) {
      const charMap = {
        "!": "%21",
        "'": "%27",
        "(": "%28",
        ")": "%29",
        "~": "%7E",
        "%20": "+",
        "%00": "\0"
      };
      return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
        return charMap[match];
      });
    }
    function AxiosURLSearchParams(params, options) {
      this._pairs = [];
      params && toFormData(params, this, options);
    }
    var prototype = AxiosURLSearchParams.prototype;
    prototype.append = function append(name, value) {
      this._pairs.push([name, value]);
    };
    prototype.toString = function toString2(encoder) {
      const _encode = encoder ? function(value) {
        return encoder.call(this, value, encode$1);
      } : encode$1;
      return this._pairs.map(function each(pair) {
        return _encode(pair[0]) + "=" + _encode(pair[1]);
      }, "").join("&");
    };
    function encode(val) {
      return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
    }
    function buildURL(url, params, options) {
      if (!params) {
        return url;
      }
      const _encode = options && options.encode || encode;
      const serializeFn = options && options.serialize;
      let serializedParams;
      if (serializeFn) {
        serializedParams = serializeFn(params, options);
      } else {
        serializedParams = utils$1.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams(params, options).toString(_encode);
      }
      if (serializedParams) {
        const hashmarkIndex = url.indexOf("#");
        if (hashmarkIndex !== -1) {
          url = url.slice(0, hashmarkIndex);
        }
        url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
      }
      return url;
    }
    var InterceptorManager = class {
      constructor() {
        this.handlers = [];
      }
      /**
       * Add a new interceptor to the stack
       *
       * @param {Function} fulfilled The function to handle `then` for a `Promise`
       * @param {Function} rejected The function to handle `reject` for a `Promise`
       *
       * @return {Number} An ID used to remove interceptor later
       */
      use(fulfilled, rejected, options) {
        this.handlers.push({
          fulfilled,
          rejected,
          synchronous: options ? options.synchronous : false,
          runWhen: options ? options.runWhen : null
        });
        return this.handlers.length - 1;
      }
      /**
       * Remove an interceptor from the stack
       *
       * @param {Number} id The ID that was returned by `use`
       *
       * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
       */
      eject(id) {
        if (this.handlers[id]) {
          this.handlers[id] = null;
        }
      }
      /**
       * Clear all interceptors from the stack
       *
       * @returns {void}
       */
      clear() {
        if (this.handlers) {
          this.handlers = [];
        }
      }
      /**
       * Iterate over all the registered interceptors
       *
       * This method is particularly useful for skipping over any
       * interceptors that may have become `null` calling `eject`.
       *
       * @param {Function} fn The function to call for each interceptor
       *
       * @returns {void}
       */
      forEach(fn) {
        utils$1.forEach(this.handlers, function forEachHandler(h) {
          if (h !== null) {
            fn(h);
          }
        });
      }
    };
    var InterceptorManager$1 = InterceptorManager;
    var transitionalDefaults = {
      silentJSONParsing: true,
      forcedJSONParsing: true,
      clarifyTimeoutError: false
    };
    var URLSearchParams$1 = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams;
    var FormData$1 = typeof FormData !== "undefined" ? FormData : null;
    var Blob$1 = typeof Blob !== "undefined" ? Blob : null;
    var platform$1 = {
      isBrowser: true,
      classes: {
        URLSearchParams: URLSearchParams$1,
        FormData: FormData$1,
        Blob: Blob$1
      },
      protocols: ["http", "https", "file", "blob", "url", "data"]
    };
    var hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
    var hasStandardBrowserEnv = ((product) => {
      return hasBrowserEnv && ["ReactNative", "NativeScript", "NS"].indexOf(product) < 0;
    })(typeof navigator !== "undefined" && navigator.product);
    var hasStandardBrowserWebWorkerEnv = (() => {
      return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
      self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
    })();
    var utils = Object.freeze({
      __proto__: null,
      hasBrowserEnv,
      hasStandardBrowserWebWorkerEnv,
      hasStandardBrowserEnv
    });
    var platform = {
      ...utils,
      ...platform$1
    };
    function toURLEncodedForm(data, options) {
      return toFormData(data, new platform.classes.URLSearchParams(), Object.assign({
        visitor: function(value, key, path, helpers) {
          if (platform.isNode && utils$1.isBuffer(value)) {
            this.append(key, value.toString("base64"));
            return false;
          }
          return helpers.defaultVisitor.apply(this, arguments);
        }
      }, options));
    }
    function parsePropPath(name) {
      return utils$1.matchAll(/\w+|\[(\w*)]/g, name).map((match) => {
        return match[0] === "[]" ? "" : match[1] || match[0];
      });
    }
    function arrayToObject(arr) {
      const obj = {};
      const keys = Object.keys(arr);
      let i;
      const len = keys.length;
      let key;
      for (i = 0; i < len; i++) {
        key = keys[i];
        obj[key] = arr[key];
      }
      return obj;
    }
    function formDataToJSON(formData) {
      function buildPath(path, value, target, index) {
        let name = path[index++];
        if (name === "__proto__")
          return true;
        const isNumericKey = Number.isFinite(+name);
        const isLast = index >= path.length;
        name = !name && utils$1.isArray(target) ? target.length : name;
        if (isLast) {
          if (utils$1.hasOwnProp(target, name)) {
            target[name] = [target[name], value];
          } else {
            target[name] = value;
          }
          return !isNumericKey;
        }
        if (!target[name] || !utils$1.isObject(target[name])) {
          target[name] = [];
        }
        const result = buildPath(path, value, target[name], index);
        if (result && utils$1.isArray(target[name])) {
          target[name] = arrayToObject(target[name]);
        }
        return !isNumericKey;
      }
      if (utils$1.isFormData(formData) && utils$1.isFunction(formData.entries)) {
        const obj = {};
        utils$1.forEachEntry(formData, (name, value) => {
          buildPath(parsePropPath(name), value, obj, 0);
        });
        return obj;
      }
      return null;
    }
    function stringifySafely(rawValue, parser, encoder) {
      if (utils$1.isString(rawValue)) {
        try {
          (parser || JSON.parse)(rawValue);
          return utils$1.trim(rawValue);
        } catch (e) {
          if (e.name !== "SyntaxError") {
            throw e;
          }
        }
      }
      return (encoder || JSON.stringify)(rawValue);
    }
    var defaults = {
      transitional: transitionalDefaults,
      adapter: ["xhr", "http"],
      transformRequest: [function transformRequest(data, headers) {
        const contentType = headers.getContentType() || "";
        const hasJSONContentType = contentType.indexOf("application/json") > -1;
        const isObjectPayload = utils$1.isObject(data);
        if (isObjectPayload && utils$1.isHTMLForm(data)) {
          data = new FormData(data);
        }
        const isFormData2 = utils$1.isFormData(data);
        if (isFormData2) {
          if (!hasJSONContentType) {
            return data;
          }
          return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;
        }
        if (utils$1.isArrayBuffer(data) || utils$1.isBuffer(data) || utils$1.isStream(data) || utils$1.isFile(data) || utils$1.isBlob(data)) {
          return data;
        }
        if (utils$1.isArrayBufferView(data)) {
          return data.buffer;
        }
        if (utils$1.isURLSearchParams(data)) {
          headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
          return data.toString();
        }
        let isFileList2;
        if (isObjectPayload) {
          if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
            return toURLEncodedForm(data, this.formSerializer).toString();
          }
          if ((isFileList2 = utils$1.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
            const _FormData = this.env && this.env.FormData;
            return toFormData(
              isFileList2 ? { "files[]": data } : data,
              _FormData && new _FormData(),
              this.formSerializer
            );
          }
        }
        if (isObjectPayload || hasJSONContentType) {
          headers.setContentType("application/json", false);
          return stringifySafely(data);
        }
        return data;
      }],
      transformResponse: [function transformResponse(data) {
        const transitional = this.transitional || defaults.transitional;
        const forcedJSONParsing = transitional && transitional.forcedJSONParsing;
        const JSONRequested = this.responseType === "json";
        if (data && utils$1.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
          const silentJSONParsing = transitional && transitional.silentJSONParsing;
          const strictJSONParsing = !silentJSONParsing && JSONRequested;
          try {
            return JSON.parse(data);
          } catch (e) {
            if (strictJSONParsing) {
              if (e.name === "SyntaxError") {
                throw AxiosError.from(e, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
              }
              throw e;
            }
          }
        }
        return data;
      }],
      /**
       * A timeout in milliseconds to abort a request. If set to 0 (default) a
       * timeout is not created.
       */
      timeout: 0,
      xsrfCookieName: "XSRF-TOKEN",
      xsrfHeaderName: "X-XSRF-TOKEN",
      maxContentLength: -1,
      maxBodyLength: -1,
      env: {
        FormData: platform.classes.FormData,
        Blob: platform.classes.Blob
      },
      validateStatus: function validateStatus(status) {
        return status >= 200 && status < 300;
      },
      headers: {
        common: {
          "Accept": "application/json, text/plain, */*",
          "Content-Type": void 0
        }
      }
    };
    utils$1.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
      defaults.headers[method] = {};
    });
    var defaults$1 = defaults;
    var ignoreDuplicateOf = utils$1.toObjectSet([
      "age",
      "authorization",
      "content-length",
      "content-type",
      "etag",
      "expires",
      "from",
      "host",
      "if-modified-since",
      "if-unmodified-since",
      "last-modified",
      "location",
      "max-forwards",
      "proxy-authorization",
      "referer",
      "retry-after",
      "user-agent"
    ]);
    var parseHeaders = (rawHeaders) => {
      const parsed = {};
      let key;
      let val;
      let i;
      rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
        i = line.indexOf(":");
        key = line.substring(0, i).trim().toLowerCase();
        val = line.substring(i + 1).trim();
        if (!key || parsed[key] && ignoreDuplicateOf[key]) {
          return;
        }
        if (key === "set-cookie") {
          if (parsed[key]) {
            parsed[key].push(val);
          } else {
            parsed[key] = [val];
          }
        } else {
          parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
        }
      });
      return parsed;
    };
    var $internals = Symbol("internals");
    function normalizeHeader(header) {
      return header && String(header).trim().toLowerCase();
    }
    function normalizeValue(value) {
      if (value === false || value == null) {
        return value;
      }
      return utils$1.isArray(value) ? value.map(normalizeValue) : String(value);
    }
    function parseTokens(str) {
      const tokens = /* @__PURE__ */ Object.create(null);
      const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
      let match;
      while (match = tokensRE.exec(str)) {
        tokens[match[1]] = match[2];
      }
      return tokens;
    }
    var isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
    function matchHeaderValue(context, value, header, filter, isHeaderNameFilter) {
      if (utils$1.isFunction(filter)) {
        return filter.call(this, value, header);
      }
      if (isHeaderNameFilter) {
        value = header;
      }
      if (!utils$1.isString(value))
        return;
      if (utils$1.isString(filter)) {
        return value.indexOf(filter) !== -1;
      }
      if (utils$1.isRegExp(filter)) {
        return filter.test(value);
      }
    }
    function formatHeader(header) {
      return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str) => {
        return char.toUpperCase() + str;
      });
    }
    function buildAccessors(obj, header) {
      const accessorName = utils$1.toCamelCase(" " + header);
      ["get", "set", "has"].forEach((methodName) => {
        Object.defineProperty(obj, methodName + accessorName, {
          value: function(arg1, arg2, arg3) {
            return this[methodName].call(this, header, arg1, arg2, arg3);
          },
          configurable: true
        });
      });
    }
    var AxiosHeaders = class {
      constructor(headers) {
        headers && this.set(headers);
      }
      set(header, valueOrRewrite, rewrite) {
        const self2 = this;
        function setHeader(_value, _header, _rewrite) {
          const lHeader = normalizeHeader(_header);
          if (!lHeader) {
            throw new Error("header name must be a non-empty string");
          }
          const key = utils$1.findKey(self2, lHeader);
          if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
            self2[key || _header] = normalizeValue(_value);
          }
        }
        const setHeaders = (headers, _rewrite) => utils$1.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
        if (utils$1.isPlainObject(header) || header instanceof this.constructor) {
          setHeaders(header, valueOrRewrite);
        } else if (utils$1.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
          setHeaders(parseHeaders(header), valueOrRewrite);
        } else {
          header != null && setHeader(valueOrRewrite, header, rewrite);
        }
        return this;
      }
      get(header, parser) {
        header = normalizeHeader(header);
        if (header) {
          const key = utils$1.findKey(this, header);
          if (key) {
            const value = this[key];
            if (!parser) {
              return value;
            }
            if (parser === true) {
              return parseTokens(value);
            }
            if (utils$1.isFunction(parser)) {
              return parser.call(this, value, key);
            }
            if (utils$1.isRegExp(parser)) {
              return parser.exec(value);
            }
            throw new TypeError("parser must be boolean|regexp|function");
          }
        }
      }
      has(header, matcher) {
        header = normalizeHeader(header);
        if (header) {
          const key = utils$1.findKey(this, header);
          return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
        }
        return false;
      }
      delete(header, matcher) {
        const self2 = this;
        let deleted = false;
        function deleteHeader(_header) {
          _header = normalizeHeader(_header);
          if (_header) {
            const key = utils$1.findKey(self2, _header);
            if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
              delete self2[key];
              deleted = true;
            }
          }
        }
        if (utils$1.isArray(header)) {
          header.forEach(deleteHeader);
        } else {
          deleteHeader(header);
        }
        return deleted;
      }
      clear(matcher) {
        const keys = Object.keys(this);
        let i = keys.length;
        let deleted = false;
        while (i--) {
          const key = keys[i];
          if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
            delete this[key];
            deleted = true;
          }
        }
        return deleted;
      }
      normalize(format) {
        const self2 = this;
        const headers = {};
        utils$1.forEach(this, (value, header) => {
          const key = utils$1.findKey(headers, header);
          if (key) {
            self2[key] = normalizeValue(value);
            delete self2[header];
            return;
          }
          const normalized = format ? formatHeader(header) : String(header).trim();
          if (normalized !== header) {
            delete self2[header];
          }
          self2[normalized] = normalizeValue(value);
          headers[normalized] = true;
        });
        return this;
      }
      concat(...targets) {
        return this.constructor.concat(this, ...targets);
      }
      toJSON(asStrings) {
        const obj = /* @__PURE__ */ Object.create(null);
        utils$1.forEach(this, (value, header) => {
          value != null && value !== false && (obj[header] = asStrings && utils$1.isArray(value) ? value.join(", ") : value);
        });
        return obj;
      }
      [Symbol.iterator]() {
        return Object.entries(this.toJSON())[Symbol.iterator]();
      }
      toString() {
        return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
      }
      get [Symbol.toStringTag]() {
        return "AxiosHeaders";
      }
      static from(thing) {
        return thing instanceof this ? thing : new this(thing);
      }
      static concat(first, ...targets) {
        const computed = new this(first);
        targets.forEach((target) => computed.set(target));
        return computed;
      }
      static accessor(header) {
        const internals = this[$internals] = this[$internals] = {
          accessors: {}
        };
        const accessors = internals.accessors;
        const prototype2 = this.prototype;
        function defineAccessor(_header) {
          const lHeader = normalizeHeader(_header);
          if (!accessors[lHeader]) {
            buildAccessors(prototype2, _header);
            accessors[lHeader] = true;
          }
        }
        utils$1.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
        return this;
      }
    };
    AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
    utils$1.reduceDescriptors(AxiosHeaders.prototype, ({ value }, key) => {
      let mapped = key[0].toUpperCase() + key.slice(1);
      return {
        get: () => value,
        set(headerValue) {
          this[mapped] = headerValue;
        }
      };
    });
    utils$1.freezeMethods(AxiosHeaders);
    var AxiosHeaders$1 = AxiosHeaders;
    function transformData(fns, response) {
      const config2 = this || defaults$1;
      const context = response || config2;
      const headers = AxiosHeaders$1.from(context.headers);
      let data = context.data;
      utils$1.forEach(fns, function transform(fn) {
        data = fn.call(config2, data, headers.normalize(), response ? response.status : void 0);
      });
      headers.normalize();
      return data;
    }
    function isCancel(value) {
      return !!(value && value.__CANCEL__);
    }
    function CanceledError(message, config2, request) {
      AxiosError.call(this, message == null ? "canceled" : message, AxiosError.ERR_CANCELED, config2, request);
      this.name = "CanceledError";
    }
    utils$1.inherits(CanceledError, AxiosError, {
      __CANCEL__: true
    });
    function settle(resolve, reject, response) {
      const validateStatus = response.config.validateStatus;
      if (!response.status || !validateStatus || validateStatus(response.status)) {
        resolve(response);
      } else {
        reject(new AxiosError(
          "Request failed with status code " + response.status,
          [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
          response.config,
          response.request,
          response
        ));
      }
    }
    var cookies = platform.hasStandardBrowserEnv ? (
      // Standard browser envs support document.cookie
      {
        write(name, value, expires, path, domain, secure) {
          const cookie = [name + "=" + encodeURIComponent(value)];
          utils$1.isNumber(expires) && cookie.push("expires=" + new Date(expires).toGMTString());
          utils$1.isString(path) && cookie.push("path=" + path);
          utils$1.isString(domain) && cookie.push("domain=" + domain);
          secure === true && cookie.push("secure");
          document.cookie = cookie.join("; ");
        },
        read(name) {
          const match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
          return match ? decodeURIComponent(match[3]) : null;
        },
        remove(name) {
          this.write(name, "", Date.now() - 864e5);
        }
      }
    ) : (
      // Non-standard browser env (web workers, react-native) lack needed support.
      {
        write() {
        },
        read() {
          return null;
        },
        remove() {
        }
      }
    );
    function isAbsoluteURL(url) {
      return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
    }
    function combineURLs(baseURL, relativeURL) {
      return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
    }
    function buildFullPath(baseURL, requestedURL) {
      if (baseURL && !isAbsoluteURL(requestedURL)) {
        return combineURLs(baseURL, requestedURL);
      }
      return requestedURL;
    }
    var isURLSameOrigin = platform.hasStandardBrowserEnv ? (
      // Standard browser envs have full support of the APIs needed to test
      // whether the request URL is of the same origin as current location.
      function standardBrowserEnv() {
        const msie = /(msie|trident)/i.test(navigator.userAgent);
        const urlParsingNode = document.createElement("a");
        let originURL;
        function resolveURL(url) {
          let href = url;
          if (msie) {
            urlParsingNode.setAttribute("href", href);
            href = urlParsingNode.href;
          }
          urlParsingNode.setAttribute("href", href);
          return {
            href: urlParsingNode.href,
            protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
            host: urlParsingNode.host,
            search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
            hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
            hostname: urlParsingNode.hostname,
            port: urlParsingNode.port,
            pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
          };
        }
        originURL = resolveURL(window.location.href);
        return function isURLSameOrigin2(requestURL) {
          const parsed = utils$1.isString(requestURL) ? resolveURL(requestURL) : requestURL;
          return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
        };
      }()
    ) : (
      // Non standard browser envs (web workers, react-native) lack needed support.
      /* @__PURE__ */ function nonStandardBrowserEnv() {
        return function isURLSameOrigin2() {
          return true;
        };
      }()
    );
    function parseProtocol(url) {
      const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
      return match && match[1] || "";
    }
    function speedometer(samplesCount, min) {
      samplesCount = samplesCount || 10;
      const bytes = new Array(samplesCount);
      const timestamps = new Array(samplesCount);
      let head = 0;
      let tail = 0;
      let firstSampleTS;
      min = min !== void 0 ? min : 1e3;
      return function push(chunkLength) {
        const now = Date.now();
        const startedAt = timestamps[tail];
        if (!firstSampleTS) {
          firstSampleTS = now;
        }
        bytes[head] = chunkLength;
        timestamps[head] = now;
        let i = tail;
        let bytesCount = 0;
        while (i !== head) {
          bytesCount += bytes[i++];
          i = i % samplesCount;
        }
        head = (head + 1) % samplesCount;
        if (head === tail) {
          tail = (tail + 1) % samplesCount;
        }
        if (now - firstSampleTS < min) {
          return;
        }
        const passed = startedAt && now - startedAt;
        return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
      };
    }
    function progressEventReducer(listener, isDownloadStream) {
      let bytesNotified = 0;
      const _speedometer = speedometer(50, 250);
      return (e) => {
        const loaded = e.loaded;
        const total = e.lengthComputable ? e.total : void 0;
        const progressBytes = loaded - bytesNotified;
        const rate = _speedometer(progressBytes);
        const inRange = loaded <= total;
        bytesNotified = loaded;
        const data = {
          loaded,
          total,
          progress: total ? loaded / total : void 0,
          bytes: progressBytes,
          rate: rate ? rate : void 0,
          estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
          event: e
        };
        data[isDownloadStream ? "download" : "upload"] = true;
        listener(data);
      };
    }
    var isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
    var xhrAdapter = isXHRAdapterSupported && function(config2) {
      return new Promise(function dispatchXhrRequest(resolve, reject) {
        let requestData = config2.data;
        const requestHeaders = AxiosHeaders$1.from(config2.headers).normalize();
        let { responseType, withXSRFToken } = config2;
        let onCanceled;
        function done() {
          if (config2.cancelToken) {
            config2.cancelToken.unsubscribe(onCanceled);
          }
          if (config2.signal) {
            config2.signal.removeEventListener("abort", onCanceled);
          }
        }
        let contentType;
        if (utils$1.isFormData(requestData)) {
          if (platform.hasStandardBrowserEnv || platform.hasStandardBrowserWebWorkerEnv) {
            requestHeaders.setContentType(false);
          } else if ((contentType = requestHeaders.getContentType()) !== false) {
            const [type, ...tokens] = contentType ? contentType.split(";").map((token) => token.trim()).filter(Boolean) : [];
            requestHeaders.setContentType([type || "multipart/form-data", ...tokens].join("; "));
          }
        }
        let request = new XMLHttpRequest();
        if (config2.auth) {
          const username = config2.auth.username || "";
          const password = config2.auth.password ? unescape(encodeURIComponent(config2.auth.password)) : "";
          requestHeaders.set("Authorization", "Basic " + btoa(username + ":" + password));
        }
        const fullPath = buildFullPath(config2.baseURL, config2.url);
        request.open(config2.method.toUpperCase(), buildURL(fullPath, config2.params, config2.paramsSerializer), true);
        request.timeout = config2.timeout;
        function onloadend() {
          if (!request) {
            return;
          }
          const responseHeaders = AxiosHeaders$1.from(
            "getAllResponseHeaders" in request && request.getAllResponseHeaders()
          );
          const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
          const response = {
            data: responseData,
            status: request.status,
            statusText: request.statusText,
            headers: responseHeaders,
            config: config2,
            request
          };
          settle(function _resolve(value) {
            resolve(value);
            done();
          }, function _reject(err) {
            reject(err);
            done();
          }, response);
          request = null;
        }
        if ("onloadend" in request) {
          request.onloadend = onloadend;
        } else {
          request.onreadystatechange = function handleLoad() {
            if (!request || request.readyState !== 4) {
              return;
            }
            if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
              return;
            }
            setTimeout(onloadend);
          };
        }
        request.onabort = function handleAbort() {
          if (!request) {
            return;
          }
          reject(new AxiosError("Request aborted", AxiosError.ECONNABORTED, config2, request));
          request = null;
        };
        request.onerror = function handleError() {
          reject(new AxiosError("Network Error", AxiosError.ERR_NETWORK, config2, request));
          request = null;
        };
        request.ontimeout = function handleTimeout() {
          let timeoutErrorMessage = config2.timeout ? "timeout of " + config2.timeout + "ms exceeded" : "timeout exceeded";
          const transitional = config2.transitional || transitionalDefaults;
          if (config2.timeoutErrorMessage) {
            timeoutErrorMessage = config2.timeoutErrorMessage;
          }
          reject(new AxiosError(
            timeoutErrorMessage,
            transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
            config2,
            request
          ));
          request = null;
        };
        if (platform.hasStandardBrowserEnv) {
          withXSRFToken && utils$1.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(config2));
          if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin(fullPath)) {
            const xsrfValue = config2.xsrfHeaderName && config2.xsrfCookieName && cookies.read(config2.xsrfCookieName);
            if (xsrfValue) {
              requestHeaders.set(config2.xsrfHeaderName, xsrfValue);
            }
          }
        }
        requestData === void 0 && requestHeaders.setContentType(null);
        if ("setRequestHeader" in request) {
          utils$1.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
            request.setRequestHeader(key, val);
          });
        }
        if (!utils$1.isUndefined(config2.withCredentials)) {
          request.withCredentials = !!config2.withCredentials;
        }
        if (responseType && responseType !== "json") {
          request.responseType = config2.responseType;
        }
        if (typeof config2.onDownloadProgress === "function") {
          request.addEventListener("progress", progressEventReducer(config2.onDownloadProgress, true));
        }
        if (typeof config2.onUploadProgress === "function" && request.upload) {
          request.upload.addEventListener("progress", progressEventReducer(config2.onUploadProgress));
        }
        if (config2.cancelToken || config2.signal) {
          onCanceled = (cancel) => {
            if (!request) {
              return;
            }
            reject(!cancel || cancel.type ? new CanceledError(null, config2, request) : cancel);
            request.abort();
            request = null;
          };
          config2.cancelToken && config2.cancelToken.subscribe(onCanceled);
          if (config2.signal) {
            config2.signal.aborted ? onCanceled() : config2.signal.addEventListener("abort", onCanceled);
          }
        }
        const protocol = parseProtocol(fullPath);
        if (protocol && platform.protocols.indexOf(protocol) === -1) {
          reject(new AxiosError("Unsupported protocol " + protocol + ":", AxiosError.ERR_BAD_REQUEST, config2));
          return;
        }
        request.send(requestData || null);
      });
    };
    var knownAdapters = {
      http: httpAdapter,
      xhr: xhrAdapter
    };
    utils$1.forEach(knownAdapters, (fn, value) => {
      if (fn) {
        try {
          Object.defineProperty(fn, "name", { value });
        } catch (e) {
        }
        Object.defineProperty(fn, "adapterName", { value });
      }
    });
    var renderReason = (reason) => `- ${reason}`;
    var isResolvedHandle = (adapter) => utils$1.isFunction(adapter) || adapter === null || adapter === false;
    var adapters = {
      getAdapter: (adapters2) => {
        adapters2 = utils$1.isArray(adapters2) ? adapters2 : [adapters2];
        const { length } = adapters2;
        let nameOrAdapter;
        let adapter;
        const rejectedReasons = {};
        for (let i = 0; i < length; i++) {
          nameOrAdapter = adapters2[i];
          let id;
          adapter = nameOrAdapter;
          if (!isResolvedHandle(nameOrAdapter)) {
            adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];
            if (adapter === void 0) {
              throw new AxiosError(`Unknown adapter '${id}'`);
            }
          }
          if (adapter) {
            break;
          }
          rejectedReasons[id || "#" + i] = adapter;
        }
        if (!adapter) {
          const reasons = Object.entries(rejectedReasons).map(
            ([id, state]) => `adapter ${id} ` + (state === false ? "is not supported by the environment" : "is not available in the build")
          );
          let s = length ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
          throw new AxiosError(
            `There is no suitable adapter to dispatch the request ` + s,
            "ERR_NOT_SUPPORT"
          );
        }
        return adapter;
      },
      adapters: knownAdapters
    };
    function throwIfCancellationRequested(config2) {
      if (config2.cancelToken) {
        config2.cancelToken.throwIfRequested();
      }
      if (config2.signal && config2.signal.aborted) {
        throw new CanceledError(null, config2);
      }
    }
    function dispatchRequest(config2) {
      throwIfCancellationRequested(config2);
      config2.headers = AxiosHeaders$1.from(config2.headers);
      config2.data = transformData.call(
        config2,
        config2.transformRequest
      );
      if (["post", "put", "patch"].indexOf(config2.method) !== -1) {
        config2.headers.setContentType("application/x-www-form-urlencoded", false);
      }
      const adapter = adapters.getAdapter(config2.adapter || defaults$1.adapter);
      return adapter(config2).then(function onAdapterResolution(response) {
        throwIfCancellationRequested(config2);
        response.data = transformData.call(
          config2,
          config2.transformResponse,
          response
        );
        response.headers = AxiosHeaders$1.from(response.headers);
        return response;
      }, function onAdapterRejection(reason) {
        if (!isCancel(reason)) {
          throwIfCancellationRequested(config2);
          if (reason && reason.response) {
            reason.response.data = transformData.call(
              config2,
              config2.transformResponse,
              reason.response
            );
            reason.response.headers = AxiosHeaders$1.from(reason.response.headers);
          }
        }
        return Promise.reject(reason);
      });
    }
    var headersToObject = (thing) => thing instanceof AxiosHeaders$1 ? thing.toJSON() : thing;
    function mergeConfig(config1, config2) {
      config2 = config2 || {};
      const config3 = {};
      function getMergedValue(target, source, caseless) {
        if (utils$1.isPlainObject(target) && utils$1.isPlainObject(source)) {
          return utils$1.merge.call({ caseless }, target, source);
        } else if (utils$1.isPlainObject(source)) {
          return utils$1.merge({}, source);
        } else if (utils$1.isArray(source)) {
          return source.slice();
        }
        return source;
      }
      function mergeDeepProperties(a, b, caseless) {
        if (!utils$1.isUndefined(b)) {
          return getMergedValue(a, b, caseless);
        } else if (!utils$1.isUndefined(a)) {
          return getMergedValue(void 0, a, caseless);
        }
      }
      function valueFromConfig2(a, b) {
        if (!utils$1.isUndefined(b)) {
          return getMergedValue(void 0, b);
        }
      }
      function defaultToConfig2(a, b) {
        if (!utils$1.isUndefined(b)) {
          return getMergedValue(void 0, b);
        } else if (!utils$1.isUndefined(a)) {
          return getMergedValue(void 0, a);
        }
      }
      function mergeDirectKeys(a, b, prop) {
        if (prop in config2) {
          return getMergedValue(a, b);
        } else if (prop in config1) {
          return getMergedValue(void 0, a);
        }
      }
      const mergeMap = {
        url: valueFromConfig2,
        method: valueFromConfig2,
        data: valueFromConfig2,
        baseURL: defaultToConfig2,
        transformRequest: defaultToConfig2,
        transformResponse: defaultToConfig2,
        paramsSerializer: defaultToConfig2,
        timeout: defaultToConfig2,
        timeoutMessage: defaultToConfig2,
        withCredentials: defaultToConfig2,
        withXSRFToken: defaultToConfig2,
        adapter: defaultToConfig2,
        responseType: defaultToConfig2,
        xsrfCookieName: defaultToConfig2,
        xsrfHeaderName: defaultToConfig2,
        onUploadProgress: defaultToConfig2,
        onDownloadProgress: defaultToConfig2,
        decompress: defaultToConfig2,
        maxContentLength: defaultToConfig2,
        maxBodyLength: defaultToConfig2,
        beforeRedirect: defaultToConfig2,
        transport: defaultToConfig2,
        httpAgent: defaultToConfig2,
        httpsAgent: defaultToConfig2,
        cancelToken: defaultToConfig2,
        socketPath: defaultToConfig2,
        responseEncoding: defaultToConfig2,
        validateStatus: mergeDirectKeys,
        headers: (a, b) => mergeDeepProperties(headersToObject(a), headersToObject(b), true)
      };
      utils$1.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
        const merge2 = mergeMap[prop] || mergeDeepProperties;
        const configValue = merge2(config1[prop], config2[prop], prop);
        utils$1.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config3[prop] = configValue);
      });
      return config3;
    }
    var VERSION = "1.6.5";
    var validators$1 = {};
    ["object", "boolean", "number", "function", "string", "symbol"].forEach((type, i) => {
      validators$1[type] = function validator2(thing) {
        return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
      };
    });
    var deprecatedWarnings = {};
    validators$1.transitional = function transitional(validator2, version, message) {
      function formatMessage(opt, desc) {
        return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
      }
      return (value, opt, opts) => {
        if (validator2 === false) {
          throw new AxiosError(
            formatMessage(opt, " has been removed" + (version ? " in " + version : "")),
            AxiosError.ERR_DEPRECATED
          );
        }
        if (version && !deprecatedWarnings[opt]) {
          deprecatedWarnings[opt] = true;
          console.warn(
            formatMessage(
              opt,
              " has been deprecated since v" + version + " and will be removed in the near future"
            )
          );
        }
        return validator2 ? validator2(value, opt, opts) : true;
      };
    };
    function assertOptions(options, schema, allowUnknown) {
      if (typeof options !== "object") {
        throw new AxiosError("options must be an object", AxiosError.ERR_BAD_OPTION_VALUE);
      }
      const keys = Object.keys(options);
      let i = keys.length;
      while (i-- > 0) {
        const opt = keys[i];
        const validator2 = schema[opt];
        if (validator2) {
          const value = options[opt];
          const result = value === void 0 || validator2(value, opt, options);
          if (result !== true) {
            throw new AxiosError("option " + opt + " must be " + result, AxiosError.ERR_BAD_OPTION_VALUE);
          }
          continue;
        }
        if (allowUnknown !== true) {
          throw new AxiosError("Unknown option " + opt, AxiosError.ERR_BAD_OPTION);
        }
      }
    }
    var validator = {
      assertOptions,
      validators: validators$1
    };
    var validators = validator.validators;
    var Axios = class {
      constructor(instanceConfig) {
        this.defaults = instanceConfig;
        this.interceptors = {
          request: new InterceptorManager$1(),
          response: new InterceptorManager$1()
        };
      }
      /**
       * Dispatch a request
       *
       * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
       * @param {?Object} config
       *
       * @returns {Promise} The Promise to be fulfilled
       */
      request(configOrUrl, config2) {
        if (typeof configOrUrl === "string") {
          config2 = config2 || {};
          config2.url = configOrUrl;
        } else {
          config2 = configOrUrl || {};
        }
        config2 = mergeConfig(this.defaults, config2);
        const { transitional, paramsSerializer, headers } = config2;
        if (transitional !== void 0) {
          validator.assertOptions(transitional, {
            silentJSONParsing: validators.transitional(validators.boolean),
            forcedJSONParsing: validators.transitional(validators.boolean),
            clarifyTimeoutError: validators.transitional(validators.boolean)
          }, false);
        }
        if (paramsSerializer != null) {
          if (utils$1.isFunction(paramsSerializer)) {
            config2.paramsSerializer = {
              serialize: paramsSerializer
            };
          } else {
            validator.assertOptions(paramsSerializer, {
              encode: validators.function,
              serialize: validators.function
            }, true);
          }
        }
        config2.method = (config2.method || this.defaults.method || "get").toLowerCase();
        let contextHeaders = headers && utils$1.merge(
          headers.common,
          headers[config2.method]
        );
        headers && utils$1.forEach(
          ["delete", "get", "head", "post", "put", "patch", "common"],
          (method) => {
            delete headers[method];
          }
        );
        config2.headers = AxiosHeaders$1.concat(contextHeaders, headers);
        const requestInterceptorChain = [];
        let synchronousRequestInterceptors = true;
        this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
          if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config2) === false) {
            return;
          }
          synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
          requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
        });
        const responseInterceptorChain = [];
        this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
          responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
        });
        let promise;
        let i = 0;
        let len;
        if (!synchronousRequestInterceptors) {
          const chain = [dispatchRequest.bind(this), void 0];
          chain.unshift.apply(chain, requestInterceptorChain);
          chain.push.apply(chain, responseInterceptorChain);
          len = chain.length;
          promise = Promise.resolve(config2);
          while (i < len) {
            promise = promise.then(chain[i++], chain[i++]);
          }
          return promise;
        }
        len = requestInterceptorChain.length;
        let newConfig = config2;
        i = 0;
        while (i < len) {
          const onFulfilled = requestInterceptorChain[i++];
          const onRejected = requestInterceptorChain[i++];
          try {
            newConfig = onFulfilled(newConfig);
          } catch (error) {
            onRejected.call(this, error);
            break;
          }
        }
        try {
          promise = dispatchRequest.call(this, newConfig);
        } catch (error) {
          return Promise.reject(error);
        }
        i = 0;
        len = responseInterceptorChain.length;
        while (i < len) {
          promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
        }
        return promise;
      }
      getUri(config2) {
        config2 = mergeConfig(this.defaults, config2);
        const fullPath = buildFullPath(config2.baseURL, config2.url);
        return buildURL(fullPath, config2.params, config2.paramsSerializer);
      }
    };
    utils$1.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
      Axios.prototype[method] = function(url, config2) {
        return this.request(mergeConfig(config2 || {}, {
          method,
          url,
          data: (config2 || {}).data
        }));
      };
    });
    utils$1.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      function generateHTTPMethod(isForm) {
        return function httpMethod(url, data, config2) {
          return this.request(mergeConfig(config2 || {}, {
            method,
            headers: isForm ? {
              "Content-Type": "multipart/form-data"
            } : {},
            url,
            data
          }));
        };
      }
      Axios.prototype[method] = generateHTTPMethod();
      Axios.prototype[method + "Form"] = generateHTTPMethod(true);
    });
    var Axios$1 = Axios;
    var CancelToken = class _CancelToken {
      constructor(executor) {
        if (typeof executor !== "function") {
          throw new TypeError("executor must be a function.");
        }
        let resolvePromise;
        this.promise = new Promise(function promiseExecutor(resolve) {
          resolvePromise = resolve;
        });
        const token = this;
        this.promise.then((cancel) => {
          if (!token._listeners)
            return;
          let i = token._listeners.length;
          while (i-- > 0) {
            token._listeners[i](cancel);
          }
          token._listeners = null;
        });
        this.promise.then = (onfulfilled) => {
          let _resolve;
          const promise = new Promise((resolve) => {
            token.subscribe(resolve);
            _resolve = resolve;
          }).then(onfulfilled);
          promise.cancel = function reject() {
            token.unsubscribe(_resolve);
          };
          return promise;
        };
        executor(function cancel(message, config2, request) {
          if (token.reason) {
            return;
          }
          token.reason = new CanceledError(message, config2, request);
          resolvePromise(token.reason);
        });
      }
      /**
       * Throws a `CanceledError` if cancellation has been requested.
       */
      throwIfRequested() {
        if (this.reason) {
          throw this.reason;
        }
      }
      /**
       * Subscribe to the cancel signal
       */
      subscribe(listener) {
        if (this.reason) {
          listener(this.reason);
          return;
        }
        if (this._listeners) {
          this._listeners.push(listener);
        } else {
          this._listeners = [listener];
        }
      }
      /**
       * Unsubscribe from the cancel signal
       */
      unsubscribe(listener) {
        if (!this._listeners) {
          return;
        }
        const index = this._listeners.indexOf(listener);
        if (index !== -1) {
          this._listeners.splice(index, 1);
        }
      }
      /**
       * Returns an object that contains a new `CancelToken` and a function that, when called,
       * cancels the `CancelToken`.
       */
      static source() {
        let cancel;
        const token = new _CancelToken(function executor(c) {
          cancel = c;
        });
        return {
          token,
          cancel
        };
      }
    };
    var CancelToken$1 = CancelToken;
    function spread(callback) {
      return function wrap(arr) {
        return callback.apply(null, arr);
      };
    }
    function isAxiosError(payload) {
      return utils$1.isObject(payload) && payload.isAxiosError === true;
    }
    var HttpStatusCode = {
      Continue: 100,
      SwitchingProtocols: 101,
      Processing: 102,
      EarlyHints: 103,
      Ok: 200,
      Created: 201,
      Accepted: 202,
      NonAuthoritativeInformation: 203,
      NoContent: 204,
      ResetContent: 205,
      PartialContent: 206,
      MultiStatus: 207,
      AlreadyReported: 208,
      ImUsed: 226,
      MultipleChoices: 300,
      MovedPermanently: 301,
      Found: 302,
      SeeOther: 303,
      NotModified: 304,
      UseProxy: 305,
      Unused: 306,
      TemporaryRedirect: 307,
      PermanentRedirect: 308,
      BadRequest: 400,
      Unauthorized: 401,
      PaymentRequired: 402,
      Forbidden: 403,
      NotFound: 404,
      MethodNotAllowed: 405,
      NotAcceptable: 406,
      ProxyAuthenticationRequired: 407,
      RequestTimeout: 408,
      Conflict: 409,
      Gone: 410,
      LengthRequired: 411,
      PreconditionFailed: 412,
      PayloadTooLarge: 413,
      UriTooLong: 414,
      UnsupportedMediaType: 415,
      RangeNotSatisfiable: 416,
      ExpectationFailed: 417,
      ImATeapot: 418,
      MisdirectedRequest: 421,
      UnprocessableEntity: 422,
      Locked: 423,
      FailedDependency: 424,
      TooEarly: 425,
      UpgradeRequired: 426,
      PreconditionRequired: 428,
      TooManyRequests: 429,
      RequestHeaderFieldsTooLarge: 431,
      UnavailableForLegalReasons: 451,
      InternalServerError: 500,
      NotImplemented: 501,
      BadGateway: 502,
      ServiceUnavailable: 503,
      GatewayTimeout: 504,
      HttpVersionNotSupported: 505,
      VariantAlsoNegotiates: 506,
      InsufficientStorage: 507,
      LoopDetected: 508,
      NotExtended: 510,
      NetworkAuthenticationRequired: 511
    };
    Object.entries(HttpStatusCode).forEach(([key, value]) => {
      HttpStatusCode[value] = key;
    });
    var HttpStatusCode$1 = HttpStatusCode;
    function createInstance(defaultConfig) {
      const context = new Axios$1(defaultConfig);
      const instance = bind(Axios$1.prototype.request, context);
      utils$1.extend(instance, Axios$1.prototype, context, { allOwnKeys: true });
      utils$1.extend(instance, context, null, { allOwnKeys: true });
      instance.create = function create(instanceConfig) {
        return createInstance(mergeConfig(defaultConfig, instanceConfig));
      };
      return instance;
    }
    var axios = createInstance(defaults$1);
    axios.Axios = Axios$1;
    axios.CanceledError = CanceledError;
    axios.CancelToken = CancelToken$1;
    axios.isCancel = isCancel;
    axios.VERSION = VERSION;
    axios.toFormData = toFormData;
    axios.AxiosError = AxiosError;
    axios.Cancel = axios.CanceledError;
    axios.all = function all(promises) {
      return Promise.all(promises);
    };
    axios.spread = spread;
    axios.isAxiosError = isAxiosError;
    axios.mergeConfig = mergeConfig;
    axios.AxiosHeaders = AxiosHeaders$1;
    axios.formToJSON = (thing) => formDataToJSON(utils$1.isHTMLForm(thing) ? new FormData(thing) : thing);
    axios.getAdapter = adapters.getAdapter;
    axios.HttpStatusCode = HttpStatusCode$1;
    axios.default = axios;
    module.exports = axios;
  }
});

// node_modules/@squidcloud/client/dist/cjs/index.js
var require_cjs2 = __commonJS({
  "node_modules/@squidcloud/client/dist/cjs/index.js"(exports) {
    (() => {
      var __webpack_modules__ = {
        /***/
        8278: (
          /***/
          (__unused_webpack_module, exports2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
          }
        ),
        /***/
        3910: (
          /***/
          function(__unused_webpack_module, exports2, __webpack_require__2) {
            "use strict";
            var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
              if (k2 === void 0)
                k2 = k;
              var desc = Object.getOwnPropertyDescriptor(m, k);
              if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
                desc = { enumerable: true, get: function() {
                  return m[k];
                } };
              }
              Object.defineProperty(o, k2, desc);
            } : function(o, m, k, k2) {
              if (k2 === void 0)
                k2 = k;
              o[k2] = m[k];
            });
            var __exportStar = this && this.__exportStar || function(m, exports3) {
              for (var p in m)
                if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
                  __createBinding(exports3, m, p);
            };
            Object.defineProperty(exports2, "__esModule", { value: true });
            const promise_pool_1 = __webpack_require__2(8599);
            exports2["default"] = promise_pool_1.PromisePool;
            __exportStar(__webpack_require__2(8278), exports2);
            __exportStar(__webpack_require__2(8599), exports2);
            __exportStar(__webpack_require__2(5607), exports2);
            __exportStar(__webpack_require__2(6784), exports2);
            __exportStar(__webpack_require__2(9446), exports2);
            __exportStar(__webpack_require__2(4204), exports2);
          }
        ),
        /***/
        5607: (
          /***/
          (__unused_webpack_module, exports2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.PromisePoolError = void 0;
            class PromisePoolError extends Error {
              /**
               * Create a new instance for the given `message` and `item`.
               *
               * @param error  The original error
               * @param item   The item causing the error
               */
              constructor(error, item) {
                super();
                this.raw = error;
                this.item = item;
                this.name = this.constructor.name;
                this.message = this.messageFrom(error);
                Error.captureStackTrace(this, this.constructor);
              }
              /**
               * Returns a new promise pool error instance wrapping the `error` and `item`.
               *
               * @param {*} error
               * @param {*} item
               *
               * @returns {PromisePoolError}
               */
              static createFrom(error, item) {
                return new this(error, item);
              }
              /**
               * Returns the error message from the given `error`.
               *
               * @param {*} error
               *
               * @returns {String}
               */
              messageFrom(error) {
                if (error instanceof Error) {
                  return error.message;
                }
                if (typeof error === "object") {
                  return error.message;
                }
                if (typeof error === "string" || typeof error === "number") {
                  return error.toString();
                }
                return "";
              }
            }
            exports2.PromisePoolError = PromisePoolError;
          }
        ),
        /***/
        4027: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.PromisePoolExecutor = void 0;
            const promise_pool_1 = __webpack_require__2(8599);
            const promise_pool_error_1 = __webpack_require__2(5607);
            const stop_the_promise_pool_error_1 = __webpack_require__2(9446);
            const validation_error_1 = __webpack_require__2(4204);
            class PromisePoolExecutor {
              /**
               * Creates a new promise pool executer instance with a default concurrency of 10.
               */
              constructor() {
                this.meta = {
                  tasks: [],
                  items: [],
                  errors: [],
                  results: [],
                  stopped: false,
                  concurrency: 10,
                  shouldResultsCorrespond: false,
                  processedItems: [],
                  taskTimeout: 0
                };
                this.handler = () => {
                };
                this.errorHandler = void 0;
                this.onTaskStartedHandlers = [];
                this.onTaskFinishedHandlers = [];
              }
              /**
               * Set the number of tasks to process concurrently the promise pool.
               *
               * @param {Integer} concurrency
               *
               * @returns {PromisePoolExecutor}
               */
              useConcurrency(concurrency) {
                if (!this.isValidConcurrency(concurrency)) {
                  throw validation_error_1.ValidationError.createFrom(`"concurrency" must be a number, 1 or up. Received "${concurrency}" (${typeof concurrency})`);
                }
                this.meta.concurrency = concurrency;
                return this;
              }
              /**
               * Determine whether the given `concurrency` value is valid.
               *
               * @param {Number} concurrency
               *
               * @returns {Boolean}
               */
              isValidConcurrency(concurrency) {
                return typeof concurrency === "number" && concurrency >= 1;
              }
              /**
               * Set the timeout in ms for the pool handler
               *
               * @param {Number} timeout
               *
               * @returns {PromisePool}
               */
              withTaskTimeout(timeout) {
                this.meta.taskTimeout = timeout;
                return this;
              }
              /**
               * Returns the number of concurrently processed tasks.
               *
               * @returns {Number}
               */
              concurrency() {
                return this.meta.concurrency;
              }
              /**
               * Assign whether to keep corresponding results between source items and resulting tasks.
               */
              useCorrespondingResults(shouldResultsCorrespond) {
                this.meta.shouldResultsCorrespond = shouldResultsCorrespond;
                return this;
              }
              /**
               * Determine whether to keep corresponding results between source items and resulting tasks.
               */
              shouldUseCorrespondingResults() {
                return this.meta.shouldResultsCorrespond;
              }
              /**
               * Returns the task timeout in milliseconds.
               */
              taskTimeout() {
                return this.meta.taskTimeout;
              }
              /**
               * Set the items to be processed in the promise pool.
               *
               * @param {Array} items
               *
               * @returns {PromisePoolExecutor}
               */
              for(items) {
                this.meta.items = items;
                return this;
              }
              /**
               * Returns the list of items to process.
               *
               * @returns {T[]}
               */
              items() {
                return this.meta.items;
              }
              /**
               * Returns the number of items to process.
               *
               * @returns {Number}
               */
              itemsCount() {
                return this.items().length;
              }
              /**
               * Returns the list of active tasks.
               *
               * @returns {Array}
               */
              tasks() {
                return this.meta.tasks;
              }
              /**
               * Returns the number of currently active tasks.
               *
               * @returns {Number}
               *
               * @deprecated use the `activeTasksCount()` method (plural naming) instead
               */
              activeTaskCount() {
                return this.activeTasksCount();
              }
              /**
               * Returns the number of currently active tasks.
               *
               * @returns {Number}
               */
              activeTasksCount() {
                return this.tasks().length;
              }
              /**
               * Returns the list of processed items.
               *
               * @returns {T[]}
               */
              processedItems() {
                return this.meta.processedItems;
              }
              /**
               * Returns the number of processed items.
               *
               * @returns {Number}
               */
              processedCount() {
                return this.processedItems().length;
              }
              /**
               * Returns the percentage progress of items that have been processed.
               */
              processedPercentage() {
                return this.processedCount() / this.itemsCount() * 100;
              }
              /**
               * Returns the list of results.
               *
               * @returns {R[]}
               */
              results() {
                return this.meta.results;
              }
              /**
               * Returns the list of errors.
               *
               * @returns {Array<PromisePoolError<T>>}
               */
              errors() {
                return this.meta.errors;
              }
              /**
               * Set the handler that is applied to each item.
               *
               * @param {Function} action
               *
               * @returns {PromisePoolExecutor}
               */
              withHandler(action) {
                this.handler = action;
                return this;
              }
              /**
               * Determine whether a custom error handle is available.
               *
               * @returns {Boolean}
               */
              hasErrorHandler() {
                return !!this.errorHandler;
              }
              /**
               * Set the error handler function to execute when an error occurs.
               *
               * @param {Function} errorHandler
               *
               * @returns {PromisePoolExecutor}
               */
              handleError(handler) {
                this.errorHandler = handler;
                return this;
              }
              /**
               * Set the handler function to execute when started a task.
               *
               * @param {Function} handler
               *
               * @returns {this}
               */
              onTaskStarted(handlers) {
                this.onTaskStartedHandlers = handlers;
                return this;
              }
              /**
                * Assign the given callback `handler` function to run when a task finished.
               *
               * @param {OnProgressCallback<T>} handlers
               *
               * @returns {this}
               */
              onTaskFinished(handlers) {
                this.onTaskFinishedHandlers = handlers;
                return this;
              }
              /**
               * Determines whether the number of active tasks is greater or equal to the concurrency limit.
               *
               * @returns {Boolean}
               */
              hasReachedConcurrencyLimit() {
                return this.activeTasksCount() >= this.concurrency();
              }
              /**
               * Stop a promise pool processing.
               */
              stop() {
                this.markAsStopped();
                throw new stop_the_promise_pool_error_1.StopThePromisePoolError();
              }
              /**
               * Mark the promise pool as stopped.
               *
               * @returns {PromisePoolExecutor}
               */
              markAsStopped() {
                this.meta.stopped = true;
                return this;
              }
              /**
               * Determine whether the pool is stopped.
               *
               * @returns {Boolean}
               */
              isStopped() {
                return this.meta.stopped;
              }
              /**
               * Start processing the promise pool.
               *
               * @returns {ReturnValue}
               */
              async start() {
                return await this.validateInputs().prepareResultsArray().process();
              }
              /**
               * Determine whether the pool should stop.
               *
               * @returns {PromisePoolExecutor}
               *
               * @throws
               */
              validateInputs() {
                if (typeof this.handler !== "function") {
                  throw validation_error_1.ValidationError.createFrom("The first parameter for the .process(fn) method must be a function");
                }
                const timeout = this.taskTimeout();
                if (!(timeout == null || typeof timeout === "number" && timeout >= 0)) {
                  throw validation_error_1.ValidationError.createFrom(`"timeout" must be undefined or a number. A number must be 0 or up. Received "${String(timeout)}" (${typeof timeout})`);
                }
                if (!Array.isArray(this.items())) {
                  throw validation_error_1.ValidationError.createFrom(`"items" must be an array. Received "${typeof this.items()}"`);
                }
                if (this.errorHandler && typeof this.errorHandler !== "function") {
                  throw validation_error_1.ValidationError.createFrom(`The error handler must be a function. Received "${typeof this.errorHandler}"`);
                }
                this.onTaskStartedHandlers.forEach((handler) => {
                  if (handler && typeof handler !== "function") {
                    throw validation_error_1.ValidationError.createFrom(`The onTaskStarted handler must be a function. Received "${typeof handler}"`);
                  }
                });
                this.onTaskFinishedHandlers.forEach((handler) => {
                  if (handler && typeof handler !== "function") {
                    throw validation_error_1.ValidationError.createFrom(`The error handler must be a function. Received "${typeof handler}"`);
                  }
                });
                return this;
              }
              /**
               * Prefill the results array with `notRun` symbol values if results should correspond.
               */
              prepareResultsArray() {
                if (this.shouldUseCorrespondingResults()) {
                  this.meta.results = Array(this.items().length).fill(promise_pool_1.PromisePool.notRun);
                }
                return this;
              }
              /**
               * Starts processing the promise pool by iterating over the items
               * and running each item through the async `callback` function.
               *
               * @param {Function} callback
               *
               * @returns {Promise}
               */
              async process() {
                for (const [index, item] of this.items().entries()) {
                  if (this.isStopped()) {
                    break;
                  }
                  await this.waitForProcessingSlot();
                  this.startProcessing(item, index);
                }
                return await this.drained();
              }
              /**
               * Wait for one of the active tasks to finish processing.
               */
              async waitForProcessingSlot() {
                while (this.hasReachedConcurrencyLimit()) {
                  await this.waitForActiveTaskToFinish();
                }
              }
              /**
               * Wait for the next, currently active task to finish processing.
               */
              async waitForActiveTaskToFinish() {
                await Promise.race(this.tasks());
              }
              /**
               * Create a processing function for the given `item`.
               *
               * @param {T} item
               * @param {number} index
               */
              startProcessing(item, index) {
                const task = this.createTaskFor(item, index).then((result) => {
                  this.save(result, index).removeActive(task);
                }).catch(async (error) => {
                  await this.handleErrorFor(error, item, index);
                  this.removeActive(task);
                }).finally(() => {
                  this.processedItems().push(item);
                  this.runOnTaskFinishedHandlers(item);
                });
                this.tasks().push(task);
                this.runOnTaskStartedHandlers(item);
              }
              /**
               * Ensures a returned promise for the processing of the given `item`.
               *
               * @param {T} item
               * @param {number} index
               *
               * @returns {*}
               */
              async createTaskFor(item, index) {
                if (this.taskTimeout() === void 0) {
                  return this.handler(item, index, this);
                }
                return Promise.race([
                  this.handler(item, index, this),
                  this.createTaskTimeout(item)
                ]);
              }
              /**
               * Returns a promise that times-out after the configured task timeout.
               */
              async createTaskTimeout(item) {
                return new Promise((_resolve, reject) => {
                  setTimeout(() => {
                    reject(new promise_pool_error_1.PromisePoolError(`Promise in pool timed out after ${this.taskTimeout()}ms`, item));
                  }, this.taskTimeout());
                });
              }
              /**
               * Save the given calculation `result`, possibly at the provided `position`.
               *
               * @param {*} result
               * @param {number} position
               *
               * @returns {PromisePoolExecutor}
               */
              save(result, position) {
                this.shouldUseCorrespondingResults() ? this.results()[position] = result : this.results().push(result);
                return this;
              }
              /**
               * Remove the given `task` from the list of active tasks.
               *
               * @param {Promise} task
               */
              removeActive(task) {
                this.tasks().splice(this.tasks().indexOf(task), 1);
                return this;
              }
              /**
               * Create and save an error for the the given `item`.
               *
               * @param {Error} error
               * @param {T} item
               * @param {number} index
               */
              async handleErrorFor(error, item, index) {
                if (this.shouldUseCorrespondingResults()) {
                  this.results()[index] = promise_pool_1.PromisePool.failed;
                }
                if (this.isStoppingThePoolError(error)) {
                  return;
                }
                if (this.isValidationError(error)) {
                  this.markAsStopped();
                  throw error;
                }
                this.hasErrorHandler() ? await this.runErrorHandlerFor(error, item) : this.saveErrorFor(error, item);
              }
              /**
               * Determine whether the given `error` is a `StopThePromisePoolError` instance.
               *
               * @param {Error} error
               *
               * @returns {Boolean}
               */
              isStoppingThePoolError(error) {
                return error instanceof stop_the_promise_pool_error_1.StopThePromisePoolError;
              }
              /**
               * Determine whether the given `error` is a `ValidationError` instance.
               *
               * @param {Error} error
               *
               * @returns {Boolean}
               */
              isValidationError(error) {
                return error instanceof validation_error_1.ValidationError;
              }
              /**
               * Run the users error handler, if available.
               *
               * @param {Error} processingError
               * @param {T} item
               */
              async runErrorHandlerFor(processingError, item) {
                var _a;
                try {
                  await ((_a = this.errorHandler) === null || _a === void 0 ? void 0 : _a.call(this, processingError, item, this));
                } catch (error) {
                  this.rethrowIfNotStoppingThePool(error);
                }
              }
              /**
               * Run the onTaskStarted handlers.
               */
              runOnTaskStartedHandlers(item) {
                this.onTaskStartedHandlers.forEach((handler) => {
                  handler(item, this);
                });
              }
              /**
               * Run the onTaskFinished handlers.
               */
              runOnTaskFinishedHandlers(item) {
                this.onTaskFinishedHandlers.forEach((handler) => {
                  handler(item, this);
                });
              }
              /**
               * Rethrow the given `error` if its not an instance of `StopThePromisePoolError`.
               *
               * @param {Error} error
               */
              rethrowIfNotStoppingThePool(error) {
                if (this.isStoppingThePoolError(error)) {
                  return;
                }
                throw error;
              }
              /**
               * Create and save an error for the the given `item`.
               *
               * @param {T} item
               */
              saveErrorFor(error, item) {
                this.errors().push(promise_pool_error_1.PromisePoolError.createFrom(error, item));
              }
              /**
               * Wait for all active tasks to finish. Once all the tasks finished
               * processing, returns an object containing the results and errors.
               *
               * @returns {Object}
               */
              async drained() {
                await this.drainActiveTasks();
                return {
                  errors: this.errors(),
                  results: this.results()
                };
              }
              /**
               * Wait for all of the active tasks to finish processing.
               */
              async drainActiveTasks() {
                await Promise.all(this.tasks());
              }
            }
            exports2.PromisePoolExecutor = PromisePoolExecutor;
          }
        ),
        /***/
        8599: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.PromisePool = void 0;
            const promise_pool_executor_1 = __webpack_require__2(4027);
            class PromisePool {
              /**
               * Instantiates a new promise pool with a default `concurrency: 10` and `items: []`.
               *
               * @param {Object} options
               */
              constructor(items) {
                this.timeout = void 0;
                this.concurrency = 10;
                this.shouldResultsCorrespond = false;
                this.items = items !== null && items !== void 0 ? items : [];
                this.errorHandler = void 0;
                this.onTaskStartedHandlers = [];
                this.onTaskFinishedHandlers = [];
              }
              /**
               * Set the number of tasks to process concurrently in the promise pool.
               *
               * @param {Integer} concurrency
               *
               * @returns {PromisePool}
               */
              withConcurrency(concurrency) {
                this.concurrency = concurrency;
                return this;
              }
              /**
               * Set the number of tasks to process concurrently in the promise pool.
               *
               * @param {Number} concurrency
               *
               * @returns {PromisePool}
               */
              static withConcurrency(concurrency) {
                return new this().withConcurrency(concurrency);
              }
              /**
               * Set the timeout in milliseconds for the pool handler.
               *
               * @param {Number} timeout
               *
               * @returns {PromisePool}
               */
              withTaskTimeout(timeout) {
                this.timeout = timeout;
                return this;
              }
              /**
               * Set the timeout in milliseconds for the pool handler.
               *
               * @param {Number} timeout
               *
               * @returns {PromisePool}
               */
              static withTaskTimeout(timeout) {
                return new this().withTaskTimeout(timeout);
              }
              /**
               * Set the items to be processed in the promise pool.
               *
               * @param {T[]} items
               *
               * @returns {PromisePool}
               */
              for(items) {
                return typeof this.timeout === "number" ? new PromisePool(items).withConcurrency(this.concurrency).withTaskTimeout(this.timeout) : new PromisePool(items).withConcurrency(this.concurrency);
              }
              /**
               * Set the items to be processed in the promise pool.
               *
               * @param {T[]} items
               *
               * @returns {PromisePool}
               */
              static for(items) {
                return new this().for(items);
              }
              /**
               * Set the error handler function to execute when an error occurs.
               *
               * @param {ErrorHandler<T>} handler
               *
               * @returns {PromisePool}
               */
              handleError(handler) {
                this.errorHandler = handler;
                return this;
              }
              /**
               * Assign the given callback `handler` function to run when a task starts.
               *
               * @param {OnProgressCallback<T>} handler
               *
               * @returns {PromisePool}
               */
              onTaskStarted(handler) {
                this.onTaskStartedHandlers.push(handler);
                return this;
              }
              /**
               * Assign the given callback `handler` function to run when a task finished.
               *
               * @param {OnProgressCallback<T>} handler
               *
               * @returns {PromisePool}
               */
              onTaskFinished(handler) {
                this.onTaskFinishedHandlers.push(handler);
                return this;
              }
              /**
               * Assign whether to keep corresponding results between source items and resulting tasks.
               */
              useCorrespondingResults() {
                this.shouldResultsCorrespond = true;
                return this;
              }
              /**
               * Starts processing the promise pool by iterating over the items
               * and running each item through the async `callback` function.
               *
               * @param {ProcessHandler} The async processing function receiving each item from the `items` array.
               *
               * @returns Promise<{ results, errors }>
               */
              async process(callback) {
                return new promise_pool_executor_1.PromisePoolExecutor().useConcurrency(this.concurrency).useCorrespondingResults(this.shouldResultsCorrespond).withTaskTimeout(this.timeout).withHandler(callback).handleError(this.errorHandler).onTaskStarted(this.onTaskStartedHandlers).onTaskFinished(this.onTaskFinishedHandlers).for(this.items).start();
              }
            }
            exports2.PromisePool = PromisePool;
            PromisePool.notRun = Symbol("notRun");
            PromisePool.failed = Symbol("failed");
          }
        ),
        /***/
        6784: (
          /***/
          (__unused_webpack_module, exports2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
          }
        ),
        /***/
        9446: (
          /***/
          (__unused_webpack_module, exports2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.StopThePromisePoolError = void 0;
            class StopThePromisePoolError extends Error {
            }
            exports2.StopThePromisePoolError = StopThePromisePoolError;
          }
        ),
        /***/
        4204: (
          /***/
          (__unused_webpack_module, exports2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.ValidationError = void 0;
            class ValidationError2 extends Error {
              /**
               * Create a new instance for the given `message`.
               *
               * @param message  The error message
               */
              constructor(message) {
                super(message);
                Error.captureStackTrace(this, this.constructor);
              }
              /**
               * Returns a validation error with the given `message`.
               */
              static createFrom(message) {
                return new this(message);
              }
            }
            exports2.ValidationError = ValidationError2;
          }
        ),
        /***/
        8975: (
          /***/
          function(__unused_webpack_module, exports2, __webpack_require__2) {
            "use strict";
            var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
              if (k2 === void 0)
                k2 = k;
              var desc = Object.getOwnPropertyDescriptor(m, k);
              if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
                desc = { enumerable: true, get: function() {
                  return m[k];
                } };
              }
              Object.defineProperty(o, k2, desc);
            } : function(o, m, k, k2) {
              if (k2 === void 0)
                k2 = k;
              o[k2] = m[k];
            });
            var __exportStar = this && this.__exportStar || function(m, exports3) {
              for (var p in m)
                if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
                  __createBinding(exports3, m, p);
            };
            Object.defineProperty(exports2, "__esModule", { value: true });
            __exportStar(__webpack_require__2(3355), exports2);
          }
        ),
        /***/
        6676: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.callValueAssertion = exports2.assertRecord = exports2.assertArray = exports2.assertObject = exports2.getErrorMessage = exports2.getAssertionErrorFromProvider = exports2.fail = exports2.truthy = exports2.assertTruthy = void 0;
            const ChecksLib_1 = __webpack_require__2(9862);
            const AssertionsLib_1 = __webpack_require__2(4356);
            function assertTruthy2(value, error) {
              if (!value) {
                fail(error);
              }
            }
            exports2.assertTruthy = assertTruthy2;
            function truthy2(value, error) {
              assertTruthy2(value, error);
              return value;
            }
            exports2.truthy = truthy2;
            function fail(error) {
              const errorMessage = getAssertionErrorFromProvider(error);
              if (typeof errorMessage === "object") {
                throw errorMessage;
              }
              throw new Error(errorMessage || "Assertion error");
            }
            exports2.fail = fail;
            function getAssertionErrorFromProvider(errorProvider) {
              if (errorProvider === void 0) {
                return "";
              }
              if (typeof errorProvider === "string") {
                return errorProvider;
              }
              return errorProvider();
            }
            exports2.getAssertionErrorFromProvider = getAssertionErrorFromProvider;
            function getErrorMessage(errorProvider) {
              const error = getAssertionErrorFromProvider(errorProvider);
              return typeof error === "string" ? error : error.message || "<no error message>";
            }
            exports2.getErrorMessage = getErrorMessage;
            function assertObject(value, objectAssertion, errorContextProvider = void 0, constraints = {}) {
              const ctx = () => {
                return getErrorMessage(errorContextProvider);
              };
              const errorWithContext = (message) => {
                const context = ctx();
                return context.length === 0 ? message : `${context} ${message}`;
              };
              assertTruthy2(typeof value === "object", () => errorWithContext(`is not an object: ${typeof value}`));
              assertTruthy2(value !== void 0, () => errorWithContext(`is not defined`));
              assertTruthy2(value !== null, () => errorWithContext(`is null`));
              assertTruthy2(!Array.isArray(value), () => errorWithContext(`is an array.`));
              const assertionEntries = Object.entries(objectAssertion);
              if (constraints.failOnUnknownFields) {
                const allowedUnknownFieldNames = constraints.allowedUnknownFieldNames || [];
                for (const objectFieldName in value) {
                  const skipUnknownFieldCheck = allowedUnknownFieldNames.includes(objectFieldName);
                  assertTruthy2(skipUnknownFieldCheck || assertionEntries.some(([assertionFieldName]) => objectFieldName === assertionFieldName), errorWithContext(`property can't be checked: ${objectFieldName}`));
                }
              }
              let $o;
              for (const [fieldKey, fieldAssertion] of assertionEntries) {
                assertTruthy2(typeof fieldAssertion === "function" || typeof fieldAssertion === "object" && fieldAssertion !== null, () => `${ctx()}.${fieldKey} assertion is not an object or a function: ${typeof fieldAssertion}`);
                const fieldValue = value[fieldKey];
                const fieldCtx = () => `${ctx()}.${fieldKey}`;
                if (typeof fieldAssertion === "object") {
                  assertTruthy2(!Array.isArray(fieldValue), () => `${ctx()}.${fieldCtx()} use arrayAssertion() to create a ValueAssertion for an array`);
                  assertObject(fieldValue, fieldAssertion, fieldCtx);
                } else {
                  assertTruthy2(typeof fieldAssertion === "function", () => `${ctx()}.${fieldCtx()} assertion is not a function`);
                  if (fieldKey === "$o") {
                    $o = fieldAssertion;
                  } else {
                    const checkResult = fieldAssertion(fieldValue, fieldCtx);
                    assertTruthy2(checkResult === void 0, `Assertion function must assert (void) but it returns a value: ${checkResult}. Wrap with $u()?`);
                  }
                }
              }
              if ($o) {
                $o(value, errorContextProvider);
              }
            }
            exports2.assertObject = assertObject;
            function assertArray(value, elementAssertion, constraints = {}, errorContextProvider = void 0) {
              var _a, _b;
              const ctx = createChildNodeContextProvider(errorContextProvider);
              assertTruthy2(Array.isArray(value), () => `${ctx()}value is not an array: ${value}`);
              const minLength = (_a = constraints.minLength) !== null && _a !== void 0 ? _a : 0;
              const maxLength = (_b = constraints.maxLength) !== null && _b !== void 0 ? _b : Infinity;
              assertTruthy2(value.length >= minLength, () => `${ctx()}array length < minLength. Array length: ${value.length}, minLength: ${minLength}`);
              assertTruthy2(value.length <= maxLength, () => `${ctx()}array length > maxLength. Array length: ${value.length}, maxLength: ${maxLength}`);
              if (constraints.uniqueByIdentity) {
                assertTruthy2((0, ChecksLib_1.checkArrayHasUniqueElements)(value, constraints.uniqueByIdentity), () => `${ctx()}array contains non-unique elements`);
              }
              let i2 = 0;
              const elementErrorProvider = () => `${ctx("no-space-separator")}[${i2}]`;
              for (; i2 < value.length; i2++) {
                const element = value[i2];
                assertChildValue(element, elementAssertion, elementErrorProvider);
              }
            }
            exports2.assertArray = assertArray;
            function assertRecord(value, valueAssertion, constraints = {}, errorContextProvider = void 0) {
              const ctx = createChildNodeContextProvider(errorContextProvider);
              assertTruthy2(typeof value === "object", () => `${ctx()}value is not an object: ${(0, AssertionsLib_1.formatValue)(value)}`);
              assertTruthy2(value !== null, () => `${ctx()}value is null`);
              assertTruthy2(!Array.isArray(value), () => `${ctx()}the value is not a record, but is an array`);
              for (const [k, v] of Object.entries(value)) {
                const keyCtx = () => `${ctx("no-space-separator")}['${k}']`;
                if (constraints.keyAssertion) {
                  assertChildValue(k, constraints.keyAssertion, () => `${keyCtx()}, key assertion failed:`);
                }
                assertChildValue(v, valueAssertion, keyCtx);
                const { keyField } = constraints;
                if (keyField) {
                  assertTruthy2(typeof v == "object" && v !== null, () => `${keyCtx()} is not an object: ${(0, AssertionsLib_1.formatValue)(v)}`);
                  const kv = v[keyField];
                  assertTruthy2(kv === k, () => `${keyCtx()} key value does not match object field '${keyField}' value: ${(0, AssertionsLib_1.formatValue)(kv)}`);
                }
              }
              if (constraints.$o) {
                constraints.$o(value, errorContextProvider);
              }
            }
            exports2.assertRecord = assertRecord;
            function callValueAssertion(value, valueAssertion, errorContextProvider) {
              valueAssertion(value, errorContextProvider);
            }
            exports2.callValueAssertion = callValueAssertion;
            function createChildNodeContextProvider(errorContextProvider) {
              return (mode = "with-space-separator") => {
                const text = getErrorMessage(errorContextProvider);
                return text ? `${text}${mode === "with-space-separator" ? " " : ""}` : "";
              };
            }
            function assertChildValue(value, assertion, elementErrorProvider) {
              if (typeof assertion === "object") {
                assertTruthy2(!Array.isArray(value), () => `${elementErrorProvider}: use arrayAssertion() to create a ValueAssertion for an array`);
                assertObject(value, assertion, elementErrorProvider);
              } else {
                callValueAssertion(value, assertion, elementErrorProvider);
              }
            }
          }
        ),
        /***/
        4810: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.stringAssertion = exports2.nullOr = exports2.undefinedOr = exports2.valueOr = exports2.$u = exports2.$a = exports2.recordAssertion = exports2.arrayAssertion = exports2.objectAssertion = void 0;
            const Assertion_1 = __webpack_require__2(6676);
            const AssertionsLib_1 = __webpack_require__2(4356);
            function objectAssertion(objectTypeAssertion, errorContextProvider = void 0) {
              return (o) => (0, Assertion_1.assertObject)(o, objectTypeAssertion, errorContextProvider);
            }
            exports2.objectAssertion = objectAssertion;
            function arrayAssertion(elementAssertion, constraints = {}) {
              const { minLength, maxLength } = constraints;
              (0, Assertion_1.assertTruthy)((minLength !== null && minLength !== void 0 ? minLength : 0) <= (maxLength !== null && maxLength !== void 0 ? maxLength : Infinity), `minLength must be < maxLength! minLength ${minLength}, maxLength: ${maxLength}`);
              (0, Assertion_1.assertTruthy)((minLength !== null && minLength !== void 0 ? minLength : 0) >= 0, `minLength must be a positive number: ${minLength}`);
              (0, Assertion_1.assertTruthy)((maxLength !== null && maxLength !== void 0 ? maxLength : 0) >= 0, `maxLength must be a positive number: ${maxLength}`);
              return (array, errorContextProvider = void 0) => {
                (0, Assertion_1.assertArray)(array, elementAssertion, constraints, errorContextProvider);
              };
            }
            exports2.arrayAssertion = arrayAssertion;
            function recordAssertion(valueAssertion, constraints = {}) {
              return (value, errorContextProvider = void 0) => {
                (0, Assertion_1.assertRecord)(value, valueAssertion, constraints, errorContextProvider);
              };
            }
            exports2.recordAssertion = recordAssertion;
            function $a(check, errorMessageProvider) {
              (0, Assertion_1.assertTruthy)(typeof check === "function", `"check" is not a function: ${check}`);
              return (value, errorContextProvider = void 0) => (0, Assertion_1.assertTruthy)(check(value), () => {
                let errorContext = (0, Assertion_1.getErrorMessage)(errorContextProvider) || "Check is failed";
                if (!errorContext.endsWith(":")) {
                  errorContext += ":";
                }
                const errorMessage = (0, Assertion_1.getErrorMessage)(errorMessageProvider);
                return `${errorContext} ${errorMessage || (typeof value === "object" ? "[object]" : `'${value}'`)}`;
              });
            }
            exports2.$a = $a;
            function $u(check, errorMessageProvider) {
              return $a(check, errorMessageProvider);
            }
            exports2.$u = $u;
            function valueOr(expectedValue, orAssertion) {
              return (value, errorContextProvider = void 0) => {
                if (value === expectedValue)
                  return;
                if (typeof orAssertion === "object") {
                  (0, Assertion_1.assertObject)(value, orAssertion, errorContextProvider);
                } else {
                  (0, Assertion_1.callValueAssertion)(value, orAssertion, errorContextProvider);
                }
              };
            }
            exports2.valueOr = valueOr;
            function undefinedOr(orAssertion) {
              return valueOr(void 0, orAssertion);
            }
            exports2.undefinedOr = undefinedOr;
            function nullOr(orAssertion) {
              return valueOr(null, orAssertion);
            }
            exports2.nullOr = nullOr;
            const stringAssertion = (constraints) => (value, context = void 0) => {
              var _a, _b;
              (0, AssertionsLib_1.assertString)(value, context);
              (0, Assertion_1.assertTruthy)(value.length >= ((_a = constraints.minLength) !== null && _a !== void 0 ? _a : 0), `${(0, Assertion_1.getErrorMessage)(context)} length is too small: ${value.length} < ${constraints.minLength}`);
              (0, Assertion_1.assertTruthy)(value.length <= ((_b = constraints.maxLength) !== null && _b !== void 0 ? _b : Infinity), `${(0, Assertion_1.getErrorMessage)(context)} length is too large ${value.length} > ${constraints.maxLength}`);
            };
            exports2.stringAssertion = stringAssertion;
          }
        ),
        /***/
        4356: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.assertNonNullable = exports2.assertDate = exports2.assertEmail = exports2.assertHexString = exports2.assertUuid = exports2.assertBoolean = exports2.assertNumber = exports2.assertString = exports2.formatError = exports2.formatValue = void 0;
            const Assertion_1 = __webpack_require__2(6676);
            const ChecksLib_1 = __webpack_require__2(9862);
            function formatValue(value) {
              return value === void 0 ? "<undefined>" : typeof value === "symbol" ? value.toString() : value === null ? "<null>" : `<${typeof value}:${value}>`;
            }
            exports2.formatValue = formatValue;
            function formatError(contextProvider, message, value) {
              const context = (0, Assertion_1.getAssertionErrorFromProvider)(contextProvider);
              if (typeof context === "object") {
                throw context;
              }
              const renderedValue = formatValue(value);
              return `${context ? `${context}: ` : ""}${message} ${renderedValue}`;
            }
            exports2.formatError = formatError;
            const assertString = (value, context = void 0) => {
              (0, Assertion_1.assertTruthy)((0, ChecksLib_1.isString)(value), () => formatError(context, "Not a string", value));
            };
            exports2.assertString = assertString;
            const assertNumber = (value, context = void 0) => {
              (0, Assertion_1.assertTruthy)((0, ChecksLib_1.isNumber)(value), () => formatError(context, "Not a number", value));
            };
            exports2.assertNumber = assertNumber;
            const assertBoolean = (value, context = void 0) => {
              (0, Assertion_1.assertTruthy)((0, ChecksLib_1.isBoolean)(value), () => formatError(context, "Not a boolean", value));
            };
            exports2.assertBoolean = assertBoolean;
            const assertUuid = (value, context = void 0) => {
              (0, Assertion_1.assertTruthy)((0, ChecksLib_1.isUuid)(value), () => formatError(context, "Invalid uuid", value));
            };
            exports2.assertUuid = assertUuid;
            const assertHexString = (value, context = void 0) => {
              (0, Assertion_1.assertTruthy)((0, ChecksLib_1.isHexString)(value), () => formatError(context, "Invalid hex string", value));
            };
            exports2.assertHexString = assertHexString;
            const assertEmail = (value, context = void 0) => {
              (0, Assertion_1.assertTruthy)((0, ChecksLib_1.isEmail)(value), () => formatError(context, "Invalid email", value));
            };
            exports2.assertEmail = assertEmail;
            const assertDate = (value, context = void 0) => {
              (0, Assertion_1.assertTruthy)(value instanceof Date, () => formatError(context, "Invalid Date", value));
            };
            exports2.assertDate = assertDate;
            function assertNonNullable(value, context) {
              (0, Assertion_1.assertTruthy)((0, ChecksLib_1.isNonNullable)(value), () => formatError(context, `Value is ${value === void 0 ? "undefined" : "null"}`, value));
            }
            exports2.assertNonNullable = assertNonNullable;
          }
        ),
        /***/
        9862: (
          /***/
          (__unused_webpack_module, exports2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.isNonNullable = exports2.isHexString = exports2.isUuid = exports2.isEmail = exports2.checkArraysHasEqualElementsByComparator = exports2.checkArraysHaveEqualElements = exports2.checkArrayHasUniqueElements = exports2.isDate = exports2.isNumber = exports2.isString = exports2.isBoolean = void 0;
            function isBoolean(value) {
              return typeof value === "boolean";
            }
            exports2.isBoolean = isBoolean;
            function isString(value) {
              return typeof value === "string";
            }
            exports2.isString = isString;
            function isNumber(value) {
              return typeof value === "number";
            }
            exports2.isNumber = isNumber;
            function isDate(value) {
              return value instanceof Date;
            }
            exports2.isDate = isDate;
            function checkArrayHasUniqueElements(array, identity) {
              if (array.length <= 1) {
                return true;
              }
              const set = /* @__PURE__ */ new Set();
              for (const e of array) {
                const id = identity(e);
                if (set.has(id)) {
                  return false;
                }
                set.add(id);
              }
              return true;
            }
            exports2.checkArrayHasUniqueElements = checkArrayHasUniqueElements;
            function checkArraysHaveEqualElements(array1, array2) {
              return checkArraysHasEqualElementsByComparator(array1, array2, (e1, e2) => e1 === e2);
            }
            exports2.checkArraysHaveEqualElements = checkArraysHaveEqualElements;
            function checkArraysHasEqualElementsByComparator(array1, array2, comparator) {
              if (array1 === array2) {
                return true;
              }
              if (!array1 || !array2) {
                return false;
              }
              if (array1.length !== array2.length) {
                return false;
              }
              for (let i2 = 0; i2 < array1.length; i2++) {
                if (!comparator(array1[i2], array2[i2])) {
                  return false;
                }
              }
              return true;
            }
            exports2.checkArraysHasEqualElementsByComparator = checkArraysHasEqualElementsByComparator;
            const EMAIL_REGEX_REGULAR = /^[-!#$%&'*+/\d=?A-Z^_a-z{|}~](\.?[-!#$%&'*+/\d=?A-Z^_a-z`{|}~])*@[a-zA-Z0-9](-*\.?[a-zA-Z\d])*\.[a-zA-Z](-?[a-zA-Z\d])+$/;
            const EMAIL_REGEX_INTERNATIONAL = (
              // eslint-disable-next-line no-misleading-character-class
              /^(?!\.)((?!.*\.{2})[a-zA-Z0-9\u0080-\u00FF\u0100-\u017F\u0180-\u024F\u0250-\u02AF\u0300-\u036F\u0370-\u03FF\u0400-\u04FF\u0500-\u052F\u0530-\u058F\u0590-\u05FF\u0600-\u06FF\u0700-\u074F\u0750-\u077F\u0780-\u07BF\u07C0-\u07FF\u0900-\u097F\u0980-\u09FF\u0A00-\u0A7F\u0A80-\u0AFF\u0B00-\u0B7F\u0B80-\u0BFF\u0C00-\u0C7F\u0C80-\u0CFF\u0D00-\u0D7F\u0D80-\u0DFF\u0E00-\u0E7F\u0E80-\u0EFF\u0F00-\u0FFF\u1000-\u109F\u10A0-\u10FF\u1100-\u11FF\u1200-\u137F\u1380-\u139F\u13A0-\u13FF\u1400-\u167F\u1680-\u169F\u16A0-\u16FF\u1700-\u171F\u1720-\u173F\u1740-\u175F\u1760-\u177F\u1780-\u17FF\u1800-\u18AF\u1900-\u194F\u1950-\u197F\u1980-\u19DF\u19E0-\u19FF\u1A00-\u1A1F\u1B00-\u1B7F\u1D00-\u1D7F\u1D80-\u1DBF\u1DC0-\u1DFF\u1E00-\u1EFF\u1F00-\u1FFF\u20D0-\u20FF\u2100-\u214F\u2C00-\u2C5F\u2C60-\u2C7F\u2C80-\u2CFF\u2D00-\u2D2F\u2D30-\u2D7F\u2D80-\u2DDF\u2F00-\u2FDF\u2FF0-\u2FFF\u3040-\u309F\u30A0-\u30FF\u3100-\u312F\u3130-\u318F\u3190-\u319F\u31C0-\u31EF\u31F0-\u31FF\u3200-\u32FF\u3300-\u33FF\u3400-\u4DBF\u4DC0-\u4DFF\u4E00-\u9FFF\uA000-\uA48F\uA490-\uA4CF\uA700-\uA71F\uA800-\uA82F\uA840-\uA87F\uAC00-\uD7AF\uF900-\uFAFF.!#$%&'*+-/=?^_`{|}~\-\d]+)@(?!\.)([a-zA-Z0-9\u0080-\u00FF\u0100-\u017F\u0180-\u024F\u0250-\u02AF\u0300-\u036F\u0370-\u03FF\u0400-\u04FF\u0500-\u052F\u0530-\u058F\u0590-\u05FF\u0600-\u06FF\u0700-\u074F\u0750-\u077F\u0780-\u07BF\u07C0-\u07FF\u0900-\u097F\u0980-\u09FF\u0A00-\u0A7F\u0A80-\u0AFF\u0B00-\u0B7F\u0B80-\u0BFF\u0C00-\u0C7F\u0C80-\u0CFF\u0D00-\u0D7F\u0D80-\u0DFF\u0E00-\u0E7F\u0E80-\u0EFF\u0F00-\u0FFF\u1000-\u109F\u10A0-\u10FF\u1100-\u11FF\u1200-\u137F\u1380-\u139F\u13A0-\u13FF\u1400-\u167F\u1680-\u169F\u16A0-\u16FF\u1700-\u171F\u1720-\u173F\u1740-\u175F\u1760-\u177F\u1780-\u17FF\u1800-\u18AF\u1900-\u194F\u1950-\u197F\u1980-\u19DF\u19E0-\u19FF\u1A00-\u1A1F\u1B00-\u1B7F\u1D00-\u1D7F\u1D80-\u1DBF\u1DC0-\u1DFF\u1E00-\u1EFF\u1F00-\u1FFF\u20D0-\u20FF\u2100-\u214F\u2C00-\u2C5F\u2C60-\u2C7F\u2C80-\u2CFF\u2D00-\u2D2F\u2D30-\u2D7F\u2D80-\u2DDF\u2F00-\u2FDF\u2FF0-\u2FFF\u3040-\u309F\u30A0-\u30FF\u3100-\u312F\u3130-\u318F\u3190-\u319F\u31C0-\u31EF\u31F0-\u31FF\u3200-\u32FF\u3300-\u33FF\u3400-\u4DBF\u4DC0-\u4DFF\u4E00-\u9FFF\uA000-\uA48F\uA490-\uA4CF\uA700-\uA71F\uA800-\uA82F\uA840-\uA87F\uAC00-\uD7AF\uF900-\uFAFF\-.\d]+)((\.([a-zA-Z\u0080-\u00FF\u0100-\u017F\u0180-\u024F\u0250-\u02AF\u0300-\u036F\u0370-\u03FF\u0400-\u04FF\u0500-\u052F\u0530-\u058F\u0590-\u05FF\u0600-\u06FF\u0700-\u074F\u0750-\u077F\u0780-\u07BF\u07C0-\u07FF\u0900-\u097F\u0980-\u09FF\u0A00-\u0A7F\u0A80-\u0AFF\u0B00-\u0B7F\u0B80-\u0BFF\u0C00-\u0C7F\u0C80-\u0CFF\u0D00-\u0D7F\u0D80-\u0DFF\u0E00-\u0E7F\u0E80-\u0EFF\u0F00-\u0FFF\u1000-\u109F\u10A0-\u10FF\u1100-\u11FF\u1200-\u137F\u1380-\u139F\u13A0-\u13FF\u1400-\u167F\u1680-\u169F\u16A0-\u16FF\u1700-\u171F\u1720-\u173F\u1740-\u175F\u1760-\u177F\u1780-\u17FF\u1800-\u18AF\u1900-\u194F\u1950-\u197F\u1980-\u19DF\u19E0-\u19FF\u1A00-\u1A1F\u1B00-\u1B7F\u1D00-\u1D7F\u1D80-\u1DBF\u1DC0-\u1DFF\u1E00-\u1EFF\u1F00-\u1FFF\u20D0-\u20FF\u2100-\u214F\u2C00-\u2C5F\u2C60-\u2C7F\u2C80-\u2CFF\u2D00-\u2D2F\u2D30-\u2D7F\u2D80-\u2DDF\u2F00-\u2FDF\u2FF0-\u2FFF\u3040-\u309F\u30A0-\u30FF\u3100-\u312F\u3130-\u318F\u3190-\u319F\u31C0-\u31EF\u31F0-\u31FF\u3200-\u32FF\u3300-\u33FF\u3400-\u4DBF\u4DC0-\u4DFF\u4E00-\u9FFF\uA000-\uA48F\uA490-\uA4CF\uA700-\uA71F\uA800-\uA82F\uA840-\uA87F\uAC00-\uD7AF\uF900-\uFAFF]){2,63})+)$/i
            );
            function isEmail(email, constraints = { allowInternationalDomains: false }) {
              if (!isString(email) || email.length === 0 || email.length > 254) {
                return false;
              }
              const regex = constraints.allowInternationalDomains ? EMAIL_REGEX_INTERNATIONAL : EMAIL_REGEX_REGULAR;
              if (!regex.test(email)) {
                return false;
              }
              const parts = email.split("@");
              if (parts[0].length > 64) {
                return false;
              }
              const domainParts = parts[1].split(".");
              return !domainParts.some((part) => part.length > 63);
            }
            exports2.isEmail = isEmail;
            const UUID_REGEX = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
            function isUuid(value) {
              return isString(value) && UUID_REGEX.test(value);
            }
            exports2.isUuid = isUuid;
            const HEX_STRING_REGEX = /^[0-9a-fA-F]*$/;
            function isHexString(value) {
              return isString(value) && HEX_STRING_REGEX.test(value);
            }
            exports2.isHexString = isHexString;
            function isNonNullable(value) {
              return value !== null && value !== void 0;
            }
            exports2.isNonNullable = isNonNullable;
          }
        ),
        /***/
        3355: (
          /***/
          function(__unused_webpack_module, exports2, __webpack_require__2) {
            "use strict";
            var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
              if (k2 === void 0)
                k2 = k;
              var desc = Object.getOwnPropertyDescriptor(m, k);
              if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
                desc = { enumerable: true, get: function() {
                  return m[k];
                } };
              }
              Object.defineProperty(o, k2, desc);
            } : function(o, m, k, k2) {
              if (k2 === void 0)
                k2 = k;
              o[k2] = m[k];
            });
            var __exportStar = this && this.__exportStar || function(m, exports3) {
              for (var p in m)
                if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
                  __createBinding(exports3, m, p);
            };
            Object.defineProperty(exports2, "__esModule", { value: true });
            __exportStar(__webpack_require__2(6676), exports2);
            __exportStar(__webpack_require__2(4810), exports2);
            __exportStar(__webpack_require__2(4356), exports2);
            __exportStar(__webpack_require__2(9862), exports2);
          }
        ),
        /***/
        9372: (
          /***/
          function(module2, exports2) {
            var global2 = typeof self !== "undefined" ? self : this;
            var __self__ = function() {
              function F() {
                this.fetch = false;
                this.DOMException = global2.DOMException;
              }
              F.prototype = global2;
              return new F();
            }();
            (function(self2) {
              var irrelevant = function(exports3) {
                var support = {
                  searchParams: "URLSearchParams" in self2,
                  iterable: "Symbol" in self2 && "iterator" in Symbol,
                  blob: "FileReader" in self2 && "Blob" in self2 && function() {
                    try {
                      new Blob();
                      return true;
                    } catch (e) {
                      return false;
                    }
                  }(),
                  formData: "FormData" in self2,
                  arrayBuffer: "ArrayBuffer" in self2
                };
                function isDataView(obj) {
                  return obj && DataView.prototype.isPrototypeOf(obj);
                }
                if (support.arrayBuffer) {
                  var viewClasses = [
                    "[object Int8Array]",
                    "[object Uint8Array]",
                    "[object Uint8ClampedArray]",
                    "[object Int16Array]",
                    "[object Uint16Array]",
                    "[object Int32Array]",
                    "[object Uint32Array]",
                    "[object Float32Array]",
                    "[object Float64Array]"
                  ];
                  var isArrayBufferView = ArrayBuffer.isView || function(obj) {
                    return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
                  };
                }
                function normalizeName(name) {
                  if (typeof name !== "string") {
                    name = String(name);
                  }
                  if (/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(name)) {
                    throw new TypeError("Invalid character in header field name");
                  }
                  return name.toLowerCase();
                }
                function normalizeValue(value) {
                  if (typeof value !== "string") {
                    value = String(value);
                  }
                  return value;
                }
                function iteratorFor(items) {
                  var iterator = {
                    next: function() {
                      var value = items.shift();
                      return { done: value === void 0, value };
                    }
                  };
                  if (support.iterable) {
                    iterator[Symbol.iterator] = function() {
                      return iterator;
                    };
                  }
                  return iterator;
                }
                function Headers(headers) {
                  this.map = {};
                  if (headers instanceof Headers) {
                    headers.forEach(function(value, name) {
                      this.append(name, value);
                    }, this);
                  } else if (Array.isArray(headers)) {
                    headers.forEach(function(header) {
                      this.append(header[0], header[1]);
                    }, this);
                  } else if (headers) {
                    Object.getOwnPropertyNames(headers).forEach(function(name) {
                      this.append(name, headers[name]);
                    }, this);
                  }
                }
                Headers.prototype.append = function(name, value) {
                  name = normalizeName(name);
                  value = normalizeValue(value);
                  var oldValue = this.map[name];
                  this.map[name] = oldValue ? oldValue + ", " + value : value;
                };
                Headers.prototype["delete"] = function(name) {
                  delete this.map[normalizeName(name)];
                };
                Headers.prototype.get = function(name) {
                  name = normalizeName(name);
                  return this.has(name) ? this.map[name] : null;
                };
                Headers.prototype.has = function(name) {
                  return this.map.hasOwnProperty(normalizeName(name));
                };
                Headers.prototype.set = function(name, value) {
                  this.map[normalizeName(name)] = normalizeValue(value);
                };
                Headers.prototype.forEach = function(callback, thisArg) {
                  for (var name in this.map) {
                    if (this.map.hasOwnProperty(name)) {
                      callback.call(thisArg, this.map[name], name, this);
                    }
                  }
                };
                Headers.prototype.keys = function() {
                  var items = [];
                  this.forEach(function(value, name) {
                    items.push(name);
                  });
                  return iteratorFor(items);
                };
                Headers.prototype.values = function() {
                  var items = [];
                  this.forEach(function(value) {
                    items.push(value);
                  });
                  return iteratorFor(items);
                };
                Headers.prototype.entries = function() {
                  var items = [];
                  this.forEach(function(value, name) {
                    items.push([name, value]);
                  });
                  return iteratorFor(items);
                };
                if (support.iterable) {
                  Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
                }
                function consumed(body) {
                  if (body.bodyUsed) {
                    return Promise.reject(new TypeError("Already read"));
                  }
                  body.bodyUsed = true;
                }
                function fileReaderReady(reader) {
                  return new Promise(function(resolve, reject) {
                    reader.onload = function() {
                      resolve(reader.result);
                    };
                    reader.onerror = function() {
                      reject(reader.error);
                    };
                  });
                }
                function readBlobAsArrayBuffer(blob) {
                  var reader = new FileReader();
                  var promise = fileReaderReady(reader);
                  reader.readAsArrayBuffer(blob);
                  return promise;
                }
                function readBlobAsText(blob) {
                  var reader = new FileReader();
                  var promise = fileReaderReady(reader);
                  reader.readAsText(blob);
                  return promise;
                }
                function readArrayBufferAsText(buf) {
                  var view = new Uint8Array(buf);
                  var chars = new Array(view.length);
                  for (var i2 = 0; i2 < view.length; i2++) {
                    chars[i2] = String.fromCharCode(view[i2]);
                  }
                  return chars.join("");
                }
                function bufferClone(buf) {
                  if (buf.slice) {
                    return buf.slice(0);
                  } else {
                    var view = new Uint8Array(buf.byteLength);
                    view.set(new Uint8Array(buf));
                    return view.buffer;
                  }
                }
                function Body() {
                  this.bodyUsed = false;
                  this._initBody = function(body) {
                    this._bodyInit = body;
                    if (!body) {
                      this._bodyText = "";
                    } else if (typeof body === "string") {
                      this._bodyText = body;
                    } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
                      this._bodyBlob = body;
                    } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
                      this._bodyFormData = body;
                    } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                      this._bodyText = body.toString();
                    } else if (support.arrayBuffer && support.blob && isDataView(body)) {
                      this._bodyArrayBuffer = bufferClone(body.buffer);
                      this._bodyInit = new Blob([this._bodyArrayBuffer]);
                    } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
                      this._bodyArrayBuffer = bufferClone(body);
                    } else {
                      this._bodyText = body = Object.prototype.toString.call(body);
                    }
                    if (!this.headers.get("content-type")) {
                      if (typeof body === "string") {
                        this.headers.set("content-type", "text/plain;charset=UTF-8");
                      } else if (this._bodyBlob && this._bodyBlob.type) {
                        this.headers.set("content-type", this._bodyBlob.type);
                      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                        this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
                      }
                    }
                  };
                  if (support.blob) {
                    this.blob = function() {
                      var rejected = consumed(this);
                      if (rejected) {
                        return rejected;
                      }
                      if (this._bodyBlob) {
                        return Promise.resolve(this._bodyBlob);
                      } else if (this._bodyArrayBuffer) {
                        return Promise.resolve(new Blob([this._bodyArrayBuffer]));
                      } else if (this._bodyFormData) {
                        throw new Error("could not read FormData body as blob");
                      } else {
                        return Promise.resolve(new Blob([this._bodyText]));
                      }
                    };
                    this.arrayBuffer = function() {
                      if (this._bodyArrayBuffer) {
                        return consumed(this) || Promise.resolve(this._bodyArrayBuffer);
                      } else {
                        return this.blob().then(readBlobAsArrayBuffer);
                      }
                    };
                  }
                  this.text = function() {
                    var rejected = consumed(this);
                    if (rejected) {
                      return rejected;
                    }
                    if (this._bodyBlob) {
                      return readBlobAsText(this._bodyBlob);
                    } else if (this._bodyArrayBuffer) {
                      return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
                    } else if (this._bodyFormData) {
                      throw new Error("could not read FormData body as text");
                    } else {
                      return Promise.resolve(this._bodyText);
                    }
                  };
                  if (support.formData) {
                    this.formData = function() {
                      return this.text().then(decode);
                    };
                  }
                  this.json = function() {
                    return this.text().then(JSON.parse);
                  };
                  return this;
                }
                var methods = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
                function normalizeMethod(method) {
                  var upcased = method.toUpperCase();
                  return methods.indexOf(upcased) > -1 ? upcased : method;
                }
                function Request(input, options) {
                  options = options || {};
                  var body = options.body;
                  if (input instanceof Request) {
                    if (input.bodyUsed) {
                      throw new TypeError("Already read");
                    }
                    this.url = input.url;
                    this.credentials = input.credentials;
                    if (!options.headers) {
                      this.headers = new Headers(input.headers);
                    }
                    this.method = input.method;
                    this.mode = input.mode;
                    this.signal = input.signal;
                    if (!body && input._bodyInit != null) {
                      body = input._bodyInit;
                      input.bodyUsed = true;
                    }
                  } else {
                    this.url = String(input);
                  }
                  this.credentials = options.credentials || this.credentials || "same-origin";
                  if (options.headers || !this.headers) {
                    this.headers = new Headers(options.headers);
                  }
                  this.method = normalizeMethod(options.method || this.method || "GET");
                  this.mode = options.mode || this.mode || null;
                  this.signal = options.signal || this.signal;
                  this.referrer = null;
                  if ((this.method === "GET" || this.method === "HEAD") && body) {
                    throw new TypeError("Body not allowed for GET or HEAD requests");
                  }
                  this._initBody(body);
                }
                Request.prototype.clone = function() {
                  return new Request(this, { body: this._bodyInit });
                };
                function decode(body) {
                  var form = new FormData();
                  body.trim().split("&").forEach(function(bytes) {
                    if (bytes) {
                      var split = bytes.split("=");
                      var name = split.shift().replace(/\+/g, " ");
                      var value = split.join("=").replace(/\+/g, " ");
                      form.append(decodeURIComponent(name), decodeURIComponent(value));
                    }
                  });
                  return form;
                }
                function parseHeaders(rawHeaders) {
                  var headers = new Headers();
                  var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
                  preProcessedHeaders.split(/\r?\n/).forEach(function(line) {
                    var parts = line.split(":");
                    var key = parts.shift().trim();
                    if (key) {
                      var value = parts.join(":").trim();
                      headers.append(key, value);
                    }
                  });
                  return headers;
                }
                Body.call(Request.prototype);
                function Response(bodyInit, options) {
                  if (!options) {
                    options = {};
                  }
                  this.type = "default";
                  this.status = options.status === void 0 ? 200 : options.status;
                  this.ok = this.status >= 200 && this.status < 300;
                  this.statusText = "statusText" in options ? options.statusText : "OK";
                  this.headers = new Headers(options.headers);
                  this.url = options.url || "";
                  this._initBody(bodyInit);
                }
                Body.call(Response.prototype);
                Response.prototype.clone = function() {
                  return new Response(this._bodyInit, {
                    status: this.status,
                    statusText: this.statusText,
                    headers: new Headers(this.headers),
                    url: this.url
                  });
                };
                Response.error = function() {
                  var response = new Response(null, { status: 0, statusText: "" });
                  response.type = "error";
                  return response;
                };
                var redirectStatuses = [301, 302, 303, 307, 308];
                Response.redirect = function(url, status) {
                  if (redirectStatuses.indexOf(status) === -1) {
                    throw new RangeError("Invalid status code");
                  }
                  return new Response(null, { status, headers: { location: url } });
                };
                exports3.DOMException = self2.DOMException;
                try {
                  new exports3.DOMException();
                } catch (err) {
                  exports3.DOMException = function(message, name) {
                    this.message = message;
                    this.name = name;
                    var error = Error(message);
                    this.stack = error.stack;
                  };
                  exports3.DOMException.prototype = Object.create(Error.prototype);
                  exports3.DOMException.prototype.constructor = exports3.DOMException;
                }
                function fetch2(input, init) {
                  return new Promise(function(resolve, reject) {
                    var request = new Request(input, init);
                    if (request.signal && request.signal.aborted) {
                      return reject(new exports3.DOMException("Aborted", "AbortError"));
                    }
                    var xhr = new XMLHttpRequest();
                    function abortXhr() {
                      xhr.abort();
                    }
                    xhr.onload = function() {
                      var options = {
                        status: xhr.status,
                        statusText: xhr.statusText,
                        headers: parseHeaders(xhr.getAllResponseHeaders() || "")
                      };
                      options.url = "responseURL" in xhr ? xhr.responseURL : options.headers.get("X-Request-URL");
                      var body = "response" in xhr ? xhr.response : xhr.responseText;
                      resolve(new Response(body, options));
                    };
                    xhr.onerror = function() {
                      reject(new TypeError("Network request failed"));
                    };
                    xhr.ontimeout = function() {
                      reject(new TypeError("Network request failed"));
                    };
                    xhr.onabort = function() {
                      reject(new exports3.DOMException("Aborted", "AbortError"));
                    };
                    xhr.open(request.method, request.url, true);
                    if (request.credentials === "include") {
                      xhr.withCredentials = true;
                    } else if (request.credentials === "omit") {
                      xhr.withCredentials = false;
                    }
                    if ("responseType" in xhr && support.blob) {
                      xhr.responseType = "blob";
                    }
                    request.headers.forEach(function(value, name) {
                      xhr.setRequestHeader(name, value);
                    });
                    if (request.signal) {
                      request.signal.addEventListener("abort", abortXhr);
                      xhr.onreadystatechange = function() {
                        if (xhr.readyState === 4) {
                          request.signal.removeEventListener("abort", abortXhr);
                        }
                      };
                    }
                    xhr.send(typeof request._bodyInit === "undefined" ? null : request._bodyInit);
                  });
                }
                fetch2.polyfill = true;
                if (!self2.fetch) {
                  self2.fetch = fetch2;
                  self2.Headers = Headers;
                  self2.Request = Request;
                  self2.Response = Response;
                }
                exports3.Headers = Headers;
                exports3.Request = Request;
                exports3.Response = Response;
                exports3.fetch = fetch2;
                Object.defineProperty(exports3, "__esModule", { value: true });
                return exports3;
              }({});
            })(__self__);
            __self__.fetch.ponyfill = true;
            delete __self__.fetch.polyfill;
            var ctx = __self__;
            exports2 = ctx.fetch;
            exports2["default"] = ctx.fetch;
            exports2.fetch = ctx.fetch;
            exports2.Headers = ctx.Headers;
            exports2.Request = ctx.Request;
            exports2.Response = ctx.Response;
            module2.exports = exports2;
          }
        ),
        /***/
        2091: (
          /***/
          function(module2, exports2, __webpack_require__2) {
            var __WEBPACK_AMD_DEFINE_RESULT__;
            ;
            (function(root, factory) {
              var deepDiff = factory(root);
              if (true) {
                !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
                  return deepDiff;
                }).call(exports2, __webpack_require__2, exports2, module2), __WEBPACK_AMD_DEFINE_RESULT__ !== void 0 && (module2.exports = __WEBPACK_AMD_DEFINE_RESULT__));
              } else {
                var _deepdiff;
              }
            })(this, function(root) {
              var validKinds = ["N", "E", "A", "D"];
              function inherits(ctor, superCtor) {
                ctor.super_ = superCtor;
                ctor.prototype = Object.create(superCtor.prototype, {
                  constructor: {
                    value: ctor,
                    enumerable: false,
                    writable: true,
                    configurable: true
                  }
                });
              }
              function Diff(kind, path) {
                Object.defineProperty(this, "kind", {
                  value: kind,
                  enumerable: true
                });
                if (path && path.length) {
                  Object.defineProperty(this, "path", {
                    value: path,
                    enumerable: true
                  });
                }
              }
              function DiffEdit(path, origin, value) {
                DiffEdit.super_.call(this, "E", path);
                Object.defineProperty(this, "lhs", {
                  value: origin,
                  enumerable: true
                });
                Object.defineProperty(this, "rhs", {
                  value,
                  enumerable: true
                });
              }
              inherits(DiffEdit, Diff);
              function DiffNew(path, value) {
                DiffNew.super_.call(this, "N", path);
                Object.defineProperty(this, "rhs", {
                  value,
                  enumerable: true
                });
              }
              inherits(DiffNew, Diff);
              function DiffDeleted(path, value) {
                DiffDeleted.super_.call(this, "D", path);
                Object.defineProperty(this, "lhs", {
                  value,
                  enumerable: true
                });
              }
              inherits(DiffDeleted, Diff);
              function DiffArray(path, index, item) {
                DiffArray.super_.call(this, "A", path);
                Object.defineProperty(this, "index", {
                  value: index,
                  enumerable: true
                });
                Object.defineProperty(this, "item", {
                  value: item,
                  enumerable: true
                });
              }
              inherits(DiffArray, Diff);
              function arrayRemove(arr, from, to) {
                var rest = arr.slice((to || from) + 1 || arr.length);
                arr.length = from < 0 ? arr.length + from : from;
                arr.push.apply(arr, rest);
                return arr;
              }
              function realTypeOf(subject) {
                var type = typeof subject;
                if (type !== "object") {
                  return type;
                }
                if (subject === Math) {
                  return "math";
                } else if (subject === null) {
                  return "null";
                } else if (Array.isArray(subject)) {
                  return "array";
                } else if (Object.prototype.toString.call(subject) === "[object Date]") {
                  return "date";
                } else if (typeof subject.toString === "function" && /^\/.*\//.test(subject.toString())) {
                  return "regexp";
                }
                return "object";
              }
              function hashThisString(string) {
                var hash = 0;
                if (string.length === 0) {
                  return hash;
                }
                for (var i2 = 0; i2 < string.length; i2++) {
                  var char = string.charCodeAt(i2);
                  hash = (hash << 5) - hash + char;
                  hash = hash & hash;
                }
                return hash;
              }
              function getOrderIndependentHash(object) {
                var accum = 0;
                var type = realTypeOf(object);
                if (type === "array") {
                  object.forEach(function(item) {
                    accum += getOrderIndependentHash(item);
                  });
                  var arrayString = "[type: array, hash: " + accum + "]";
                  return accum + hashThisString(arrayString);
                }
                if (type === "object") {
                  for (var key in object) {
                    if (object.hasOwnProperty(key)) {
                      var keyValueString = "[ type: object, key: " + key + ", value hash: " + getOrderIndependentHash(object[key]) + "]";
                      accum += hashThisString(keyValueString);
                    }
                  }
                  return accum;
                }
                var stringToHash = "[ type: " + type + " ; value: " + object + "]";
                return accum + hashThisString(stringToHash);
              }
              function deepDiff(lhs, rhs, changes, prefilter, path, key, stack, orderIndependent) {
                changes = changes || [];
                path = path || [];
                stack = stack || [];
                var currentPath = path.slice(0);
                if (typeof key !== "undefined" && key !== null) {
                  if (prefilter) {
                    if (typeof prefilter === "function" && prefilter(currentPath, key)) {
                      return;
                    } else if (typeof prefilter === "object") {
                      if (prefilter.prefilter && prefilter.prefilter(currentPath, key)) {
                        return;
                      }
                      if (prefilter.normalize) {
                        var alt = prefilter.normalize(currentPath, key, lhs, rhs);
                        if (alt) {
                          lhs = alt[0];
                          rhs = alt[1];
                        }
                      }
                    }
                  }
                  currentPath.push(key);
                }
                if (realTypeOf(lhs) === "regexp" && realTypeOf(rhs) === "regexp") {
                  lhs = lhs.toString();
                  rhs = rhs.toString();
                }
                var ltype = typeof lhs;
                var rtype = typeof rhs;
                var i2, j, k, other;
                var ldefined = ltype !== "undefined" || stack && stack.length > 0 && stack[stack.length - 1].lhs && Object.getOwnPropertyDescriptor(stack[stack.length - 1].lhs, key);
                var rdefined = rtype !== "undefined" || stack && stack.length > 0 && stack[stack.length - 1].rhs && Object.getOwnPropertyDescriptor(stack[stack.length - 1].rhs, key);
                if (!ldefined && rdefined) {
                  changes.push(new DiffNew(currentPath, rhs));
                } else if (!rdefined && ldefined) {
                  changes.push(new DiffDeleted(currentPath, lhs));
                } else if (realTypeOf(lhs) !== realTypeOf(rhs)) {
                  changes.push(new DiffEdit(currentPath, lhs, rhs));
                } else if (realTypeOf(lhs) === "date" && lhs - rhs !== 0) {
                  changes.push(new DiffEdit(currentPath, lhs, rhs));
                } else if (ltype === "object" && lhs !== null && rhs !== null) {
                  for (i2 = stack.length - 1; i2 > -1; --i2) {
                    if (stack[i2].lhs === lhs) {
                      other = true;
                      break;
                    }
                  }
                  if (!other) {
                    stack.push({ lhs, rhs });
                    if (Array.isArray(lhs)) {
                      if (orderIndependent) {
                        lhs.sort(function(a, b) {
                          return getOrderIndependentHash(a) - getOrderIndependentHash(b);
                        });
                        rhs.sort(function(a, b) {
                          return getOrderIndependentHash(a) - getOrderIndependentHash(b);
                        });
                      }
                      i2 = rhs.length - 1;
                      j = lhs.length - 1;
                      while (i2 > j) {
                        changes.push(new DiffArray(currentPath, i2, new DiffNew(void 0, rhs[i2--])));
                      }
                      while (j > i2) {
                        changes.push(new DiffArray(currentPath, j, new DiffDeleted(void 0, lhs[j--])));
                      }
                      for (; i2 >= 0; --i2) {
                        deepDiff(lhs[i2], rhs[i2], changes, prefilter, currentPath, i2, stack, orderIndependent);
                      }
                    } else {
                      var akeys = Object.keys(lhs);
                      var pkeys = Object.keys(rhs);
                      for (i2 = 0; i2 < akeys.length; ++i2) {
                        k = akeys[i2];
                        other = pkeys.indexOf(k);
                        if (other >= 0) {
                          deepDiff(lhs[k], rhs[k], changes, prefilter, currentPath, k, stack, orderIndependent);
                          pkeys[other] = null;
                        } else {
                          deepDiff(lhs[k], void 0, changes, prefilter, currentPath, k, stack, orderIndependent);
                        }
                      }
                      for (i2 = 0; i2 < pkeys.length; ++i2) {
                        k = pkeys[i2];
                        if (k) {
                          deepDiff(void 0, rhs[k], changes, prefilter, currentPath, k, stack, orderIndependent);
                        }
                      }
                    }
                    stack.length = stack.length - 1;
                  } else if (lhs !== rhs) {
                    changes.push(new DiffEdit(currentPath, lhs, rhs));
                  }
                } else if (lhs !== rhs) {
                  if (!(ltype === "number" && isNaN(lhs) && isNaN(rhs))) {
                    changes.push(new DiffEdit(currentPath, lhs, rhs));
                  }
                }
              }
              function observableDiff(lhs, rhs, observer, prefilter, orderIndependent) {
                var changes = [];
                deepDiff(lhs, rhs, changes, prefilter, null, null, null, orderIndependent);
                if (observer) {
                  for (var i2 = 0; i2 < changes.length; ++i2) {
                    observer(changes[i2]);
                  }
                }
                return changes;
              }
              function orderIndependentDeepDiff(lhs, rhs, changes, prefilter, path, key, stack) {
                return deepDiff(lhs, rhs, changes, prefilter, path, key, stack, true);
              }
              function accumulateDiff(lhs, rhs, prefilter, accum) {
                var observer = accum ? function(difference) {
                  if (difference) {
                    accum.push(difference);
                  }
                } : void 0;
                var changes = observableDiff(lhs, rhs, observer, prefilter);
                return accum ? accum : changes.length ? changes : void 0;
              }
              function accumulateOrderIndependentDiff(lhs, rhs, prefilter, accum) {
                var observer = accum ? function(difference) {
                  if (difference) {
                    accum.push(difference);
                  }
                } : void 0;
                var changes = observableDiff(lhs, rhs, observer, prefilter, true);
                return accum ? accum : changes.length ? changes : void 0;
              }
              function applyArrayChange(arr, index, change) {
                if (change.path && change.path.length) {
                  var it = arr[index], i2, u = change.path.length - 1;
                  for (i2 = 0; i2 < u; i2++) {
                    it = it[change.path[i2]];
                  }
                  switch (change.kind) {
                    case "A":
                      applyArrayChange(it[change.path[i2]], change.index, change.item);
                      break;
                    case "D":
                      delete it[change.path[i2]];
                      break;
                    case "E":
                    case "N":
                      it[change.path[i2]] = change.rhs;
                      break;
                  }
                } else {
                  switch (change.kind) {
                    case "A":
                      applyArrayChange(arr[index], change.index, change.item);
                      break;
                    case "D":
                      arr = arrayRemove(arr, index);
                      break;
                    case "E":
                    case "N":
                      arr[index] = change.rhs;
                      break;
                  }
                }
                return arr;
              }
              function applyChange(target, source, change) {
                if (typeof change === "undefined" && source && ~validKinds.indexOf(source.kind)) {
                  change = source;
                }
                if (target && change && change.kind) {
                  var it = target, i2 = -1, last = change.path ? change.path.length - 1 : 0;
                  while (++i2 < last) {
                    if (typeof it[change.path[i2]] === "undefined") {
                      it[change.path[i2]] = typeof change.path[i2 + 1] !== "undefined" && typeof change.path[i2 + 1] === "number" ? [] : {};
                    }
                    it = it[change.path[i2]];
                  }
                  switch (change.kind) {
                    case "A":
                      if (change.path && typeof it[change.path[i2]] === "undefined") {
                        it[change.path[i2]] = [];
                      }
                      applyArrayChange(change.path ? it[change.path[i2]] : it, change.index, change.item);
                      break;
                    case "D":
                      delete it[change.path[i2]];
                      break;
                    case "E":
                    case "N":
                      it[change.path[i2]] = change.rhs;
                      break;
                  }
                }
              }
              function revertArrayChange(arr, index, change) {
                if (change.path && change.path.length) {
                  var it = arr[index], i2, u = change.path.length - 1;
                  for (i2 = 0; i2 < u; i2++) {
                    it = it[change.path[i2]];
                  }
                  switch (change.kind) {
                    case "A":
                      revertArrayChange(it[change.path[i2]], change.index, change.item);
                      break;
                    case "D":
                      it[change.path[i2]] = change.lhs;
                      break;
                    case "E":
                      it[change.path[i2]] = change.lhs;
                      break;
                    case "N":
                      delete it[change.path[i2]];
                      break;
                  }
                } else {
                  switch (change.kind) {
                    case "A":
                      revertArrayChange(arr[index], change.index, change.item);
                      break;
                    case "D":
                      arr[index] = change.lhs;
                      break;
                    case "E":
                      arr[index] = change.lhs;
                      break;
                    case "N":
                      arr = arrayRemove(arr, index);
                      break;
                  }
                }
                return arr;
              }
              function revertChange(target, source, change) {
                if (target && source && change && change.kind) {
                  var it = target, i2, u;
                  u = change.path.length - 1;
                  for (i2 = 0; i2 < u; i2++) {
                    if (typeof it[change.path[i2]] === "undefined") {
                      it[change.path[i2]] = {};
                    }
                    it = it[change.path[i2]];
                  }
                  switch (change.kind) {
                    case "A":
                      revertArrayChange(it[change.path[i2]], change.index, change.item);
                      break;
                    case "D":
                      it[change.path[i2]] = change.lhs;
                      break;
                    case "E":
                      it[change.path[i2]] = change.lhs;
                      break;
                    case "N":
                      delete it[change.path[i2]];
                      break;
                  }
                }
              }
              function applyDiff(target, source, filter) {
                if (target && source) {
                  var onChange = function(change) {
                    if (!filter || filter(target, source, change)) {
                      applyChange(target, source, change);
                    }
                  };
                  observableDiff(target, source, onChange);
                }
              }
              Object.defineProperties(accumulateDiff, {
                diff: {
                  value: accumulateDiff,
                  enumerable: true
                },
                orderIndependentDiff: {
                  value: accumulateOrderIndependentDiff,
                  enumerable: true
                },
                observableDiff: {
                  value: observableDiff,
                  enumerable: true
                },
                orderIndependentObservableDiff: {
                  value: orderIndependentDeepDiff,
                  enumerable: true
                },
                orderIndepHash: {
                  value: getOrderIndependentHash,
                  enumerable: true
                },
                applyDiff: {
                  value: applyDiff,
                  enumerable: true
                },
                applyChange: {
                  value: applyChange,
                  enumerable: true
                },
                revertChange: {
                  value: revertChange,
                  enumerable: true
                },
                isConflict: {
                  value: function() {
                    return typeof $conflict !== "undefined";
                  },
                  enumerable: true
                }
              });
              accumulateDiff.DeepDiff = accumulateDiff;
              if (root) {
                root.DeepDiff = accumulateDiff;
              }
              return accumulateDiff;
            });
          }
        ),
        /***/
        8784: (
          /***/
          function(module2, exports2, __webpack_require__2) {
            module2 = __webpack_require__2.nmd(module2);
            var __WEBPACK_AMD_DEFINE_RESULT__;
            ;
            (function() {
              var undefined2;
              var VERSION = "4.17.21";
              var LARGE_ARRAY_SIZE = 200;
              var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
              var HASH_UNDEFINED = "__lodash_hash_undefined__";
              var MAX_MEMOIZE_SIZE = 500;
              var PLACEHOLDER = "__lodash_placeholder__";
              var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
              var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
              var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
              var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
              var HOT_COUNT = 800, HOT_SPAN = 16;
              var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
              var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
              var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
              var wrapFlags = [
                ["ary", WRAP_ARY_FLAG],
                ["bind", WRAP_BIND_FLAG],
                ["bindKey", WRAP_BIND_KEY_FLAG],
                ["curry", WRAP_CURRY_FLAG],
                ["curryRight", WRAP_CURRY_RIGHT_FLAG],
                ["flip", WRAP_FLIP_FLAG],
                ["partial", WRAP_PARTIAL_FLAG],
                ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
                ["rearg", WRAP_REARG_FLAG]
              ];
              var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
              var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
              var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
              var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
              var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
              var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
              var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
              var reTrimStart = /^\s+/;
              var reWhitespace = /\s/;
              var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
              var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
              var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
              var reEscapeChar = /\\(\\)?/g;
              var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
              var reFlags = /\w*$/;
              var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
              var reIsBinary = /^0b[01]+$/i;
              var reIsHostCtor = /^\[object .+?Constructor\]$/;
              var reIsOctal = /^0o[0-7]+$/i;
              var reIsUint = /^(?:0|[1-9]\d*)$/;
              var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
              var reNoMatch = /($^)/;
              var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
              var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
              var rsApos = "[']", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
              var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
              var reApos = RegExp(rsApos, "g");
              var reComboMark = RegExp(rsCombo, "g");
              var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
              var reUnicodeWord = RegExp([
                rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
                rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
                rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
                rsUpper + "+" + rsOptContrUpper,
                rsOrdUpper,
                rsOrdLower,
                rsDigits,
                rsEmoji
              ].join("|"), "g");
              var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
              var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
              var contextProps = [
                "Array",
                "Buffer",
                "DataView",
                "Date",
                "Error",
                "Float32Array",
                "Float64Array",
                "Function",
                "Int8Array",
                "Int16Array",
                "Int32Array",
                "Map",
                "Math",
                "Object",
                "Promise",
                "RegExp",
                "Set",
                "String",
                "Symbol",
                "TypeError",
                "Uint8Array",
                "Uint8ClampedArray",
                "Uint16Array",
                "Uint32Array",
                "WeakMap",
                "_",
                "clearTimeout",
                "isFinite",
                "parseInt",
                "setTimeout"
              ];
              var templateCounter = -1;
              var typedArrayTags = {};
              typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
              typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
              var cloneableTags = {};
              cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
              cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
              var deburredLetters = {
                // Latin-1 Supplement block.
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "C",
                "": "c",
                "": "D",
                "": "d",
                "": "E",
                "": "E",
                "": "E",
                "": "E",
                "": "e",
                "": "e",
                "": "e",
                "": "e",
                "": "I",
                "": "I",
                "": "I",
                "": "I",
                "": "i",
                "": "i",
                "": "i",
                "": "i",
                "": "N",
                "": "n",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "Y",
                "": "y",
                "": "y",
                "": "Ae",
                "": "ae",
                "": "Th",
                "": "th",
                "": "ss",
                // Latin Extended-A block.
                "": "A",
                "": "A",
                "": "A",
                "": "a",
                "": "a",
                "": "a",
                "": "C",
                "": "C",
                "": "C",
                "": "C",
                "": "c",
                "": "c",
                "": "c",
                "": "c",
                "": "D",
                "": "D",
                "": "d",
                "": "d",
                "": "E",
                "": "E",
                "": "E",
                "": "E",
                "": "E",
                "": "e",
                "": "e",
                "": "e",
                "": "e",
                "": "e",
                "": "G",
                "": "G",
                "": "G",
                "": "G",
                "": "g",
                "": "g",
                "": "g",
                "": "g",
                "": "H",
                "": "H",
                "": "h",
                "": "h",
                "": "I",
                "": "I",
                "": "I",
                "": "I",
                "": "I",
                "": "i",
                "": "i",
                "": "i",
                "": "i",
                "": "i",
                "": "J",
                "": "j",
                "": "K",
                "": "k",
                "": "k",
                "": "L",
                "": "L",
                "": "L",
                "": "L",
                "": "L",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "N",
                "": "N",
                "": "N",
                "": "N",
                "": "n",
                "": "n",
                "": "n",
                "": "n",
                "": "O",
                "": "O",
                "": "O",
                "": "o",
                "": "o",
                "": "o",
                "": "R",
                "": "R",
                "": "R",
                "": "r",
                "": "r",
                "": "r",
                "": "S",
                "": "S",
                "": "S",
                "": "S",
                "": "s",
                "": "s",
                "": "s",
                "": "s",
                "": "T",
                "": "T",
                "": "T",
                "": "t",
                "": "t",
                "": "t",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "W",
                "": "w",
                "": "Y",
                "": "y",
                "": "Y",
                "": "Z",
                "": "Z",
                "": "Z",
                "": "z",
                "": "z",
                "": "z",
                "": "IJ",
                "": "ij",
                "": "Oe",
                "": "oe",
                "": "'n",
                "": "s"
              };
              var htmlEscapes = {
                "&": "&amp;",
                "<": "&lt;",
                ">": "&gt;",
                '"': "&quot;",
                "'": "&#39;"
              };
              var htmlUnescapes = {
                "&amp;": "&",
                "&lt;": "<",
                "&gt;": ">",
                "&quot;": '"',
                "&#39;": "'"
              };
              var stringEscapes = {
                "\\": "\\",
                "'": "'",
                "\n": "n",
                "\r": "r",
                "\u2028": "u2028",
                "\u2029": "u2029"
              };
              var freeParseFloat = parseFloat, freeParseInt = parseInt;
              var freeGlobal = typeof __webpack_require__2.g == "object" && __webpack_require__2.g && __webpack_require__2.g.Object === Object && __webpack_require__2.g;
              var freeSelf = typeof self == "object" && self && self.Object === Object && self;
              var root = freeGlobal || freeSelf || Function("return this")();
              var freeExports = exports2 && !exports2.nodeType && exports2;
              var freeModule = freeExports && true && module2 && !module2.nodeType && module2;
              var moduleExports = freeModule && freeModule.exports === freeExports;
              var freeProcess = moduleExports && freeGlobal.process;
              var nodeUtil = function() {
                try {
                  var types = freeModule && freeModule.require && freeModule.require("util").types;
                  if (types) {
                    return types;
                  }
                  return freeProcess && freeProcess.binding && freeProcess.binding("util");
                } catch (e) {
                }
              }();
              var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
              function apply(func, thisArg, args) {
                switch (args.length) {
                  case 0:
                    return func.call(thisArg);
                  case 1:
                    return func.call(thisArg, args[0]);
                  case 2:
                    return func.call(thisArg, args[0], args[1]);
                  case 3:
                    return func.call(thisArg, args[0], args[1], args[2]);
                }
                return func.apply(thisArg, args);
              }
              function arrayAggregator(array, setter, iteratee, accumulator) {
                var index = -1, length = array == null ? 0 : array.length;
                while (++index < length) {
                  var value = array[index];
                  setter(accumulator, value, iteratee(value), array);
                }
                return accumulator;
              }
              function arrayEach(array, iteratee) {
                var index = -1, length = array == null ? 0 : array.length;
                while (++index < length) {
                  if (iteratee(array[index], index, array) === false) {
                    break;
                  }
                }
                return array;
              }
              function arrayEachRight(array, iteratee) {
                var length = array == null ? 0 : array.length;
                while (length--) {
                  if (iteratee(array[length], length, array) === false) {
                    break;
                  }
                }
                return array;
              }
              function arrayEvery(array, predicate) {
                var index = -1, length = array == null ? 0 : array.length;
                while (++index < length) {
                  if (!predicate(array[index], index, array)) {
                    return false;
                  }
                }
                return true;
              }
              function arrayFilter(array, predicate) {
                var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
                while (++index < length) {
                  var value = array[index];
                  if (predicate(value, index, array)) {
                    result[resIndex++] = value;
                  }
                }
                return result;
              }
              function arrayIncludes(array, value) {
                var length = array == null ? 0 : array.length;
                return !!length && baseIndexOf(array, value, 0) > -1;
              }
              function arrayIncludesWith(array, value, comparator) {
                var index = -1, length = array == null ? 0 : array.length;
                while (++index < length) {
                  if (comparator(value, array[index])) {
                    return true;
                  }
                }
                return false;
              }
              function arrayMap(array, iteratee) {
                var index = -1, length = array == null ? 0 : array.length, result = Array(length);
                while (++index < length) {
                  result[index] = iteratee(array[index], index, array);
                }
                return result;
              }
              function arrayPush(array, values) {
                var index = -1, length = values.length, offset = array.length;
                while (++index < length) {
                  array[offset + index] = values[index];
                }
                return array;
              }
              function arrayReduce(array, iteratee, accumulator, initAccum) {
                var index = -1, length = array == null ? 0 : array.length;
                if (initAccum && length) {
                  accumulator = array[++index];
                }
                while (++index < length) {
                  accumulator = iteratee(accumulator, array[index], index, array);
                }
                return accumulator;
              }
              function arrayReduceRight(array, iteratee, accumulator, initAccum) {
                var length = array == null ? 0 : array.length;
                if (initAccum && length) {
                  accumulator = array[--length];
                }
                while (length--) {
                  accumulator = iteratee(accumulator, array[length], length, array);
                }
                return accumulator;
              }
              function arraySome(array, predicate) {
                var index = -1, length = array == null ? 0 : array.length;
                while (++index < length) {
                  if (predicate(array[index], index, array)) {
                    return true;
                  }
                }
                return false;
              }
              var asciiSize = baseProperty("length");
              function asciiToArray(string) {
                return string.split("");
              }
              function asciiWords(string) {
                return string.match(reAsciiWord) || [];
              }
              function baseFindKey(collection, predicate, eachFunc) {
                var result;
                eachFunc(collection, function(value, key, collection2) {
                  if (predicate(value, key, collection2)) {
                    result = key;
                    return false;
                  }
                });
                return result;
              }
              function baseFindIndex(array, predicate, fromIndex, fromRight) {
                var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
                while (fromRight ? index-- : ++index < length) {
                  if (predicate(array[index], index, array)) {
                    return index;
                  }
                }
                return -1;
              }
              function baseIndexOf(array, value, fromIndex) {
                return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
              }
              function baseIndexOfWith(array, value, fromIndex, comparator) {
                var index = fromIndex - 1, length = array.length;
                while (++index < length) {
                  if (comparator(array[index], value)) {
                    return index;
                  }
                }
                return -1;
              }
              function baseIsNaN(value) {
                return value !== value;
              }
              function baseMean(array, iteratee) {
                var length = array == null ? 0 : array.length;
                return length ? baseSum(array, iteratee) / length : NAN;
              }
              function baseProperty(key) {
                return function(object) {
                  return object == null ? undefined2 : object[key];
                };
              }
              function basePropertyOf(object) {
                return function(key) {
                  return object == null ? undefined2 : object[key];
                };
              }
              function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
                eachFunc(collection, function(value, index, collection2) {
                  accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection2);
                });
                return accumulator;
              }
              function baseSortBy(array, comparer) {
                var length = array.length;
                array.sort(comparer);
                while (length--) {
                  array[length] = array[length].value;
                }
                return array;
              }
              function baseSum(array, iteratee) {
                var result, index = -1, length = array.length;
                while (++index < length) {
                  var current = iteratee(array[index]);
                  if (current !== undefined2) {
                    result = result === undefined2 ? current : result + current;
                  }
                }
                return result;
              }
              function baseTimes(n, iteratee) {
                var index = -1, result = Array(n);
                while (++index < n) {
                  result[index] = iteratee(index);
                }
                return result;
              }
              function baseToPairs(object, props) {
                return arrayMap(props, function(key) {
                  return [key, object[key]];
                });
              }
              function baseTrim(string) {
                return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
              }
              function baseUnary(func) {
                return function(value) {
                  return func(value);
                };
              }
              function baseValues(object, props) {
                return arrayMap(props, function(key) {
                  return object[key];
                });
              }
              function cacheHas(cache, key) {
                return cache.has(key);
              }
              function charsStartIndex(strSymbols, chrSymbols) {
                var index = -1, length = strSymbols.length;
                while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
                }
                return index;
              }
              function charsEndIndex(strSymbols, chrSymbols) {
                var index = strSymbols.length;
                while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
                }
                return index;
              }
              function countHolders(array, placeholder) {
                var length = array.length, result = 0;
                while (length--) {
                  if (array[length] === placeholder) {
                    ++result;
                  }
                }
                return result;
              }
              var deburrLetter = basePropertyOf(deburredLetters);
              var escapeHtmlChar = basePropertyOf(htmlEscapes);
              function escapeStringChar(chr) {
                return "\\" + stringEscapes[chr];
              }
              function getValue(object, key) {
                return object == null ? undefined2 : object[key];
              }
              function hasUnicode(string) {
                return reHasUnicode.test(string);
              }
              function hasUnicodeWord(string) {
                return reHasUnicodeWord.test(string);
              }
              function iteratorToArray(iterator) {
                var data, result = [];
                while (!(data = iterator.next()).done) {
                  result.push(data.value);
                }
                return result;
              }
              function mapToArray(map) {
                var index = -1, result = Array(map.size);
                map.forEach(function(value, key) {
                  result[++index] = [key, value];
                });
                return result;
              }
              function overArg(func, transform) {
                return function(arg) {
                  return func(transform(arg));
                };
              }
              function replaceHolders(array, placeholder) {
                var index = -1, length = array.length, resIndex = 0, result = [];
                while (++index < length) {
                  var value = array[index];
                  if (value === placeholder || value === PLACEHOLDER) {
                    array[index] = PLACEHOLDER;
                    result[resIndex++] = index;
                  }
                }
                return result;
              }
              function setToArray(set) {
                var index = -1, result = Array(set.size);
                set.forEach(function(value) {
                  result[++index] = value;
                });
                return result;
              }
              function setToPairs(set) {
                var index = -1, result = Array(set.size);
                set.forEach(function(value) {
                  result[++index] = [value, value];
                });
                return result;
              }
              function strictIndexOf(array, value, fromIndex) {
                var index = fromIndex - 1, length = array.length;
                while (++index < length) {
                  if (array[index] === value) {
                    return index;
                  }
                }
                return -1;
              }
              function strictLastIndexOf(array, value, fromIndex) {
                var index = fromIndex + 1;
                while (index--) {
                  if (array[index] === value) {
                    return index;
                  }
                }
                return index;
              }
              function stringSize(string) {
                return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
              }
              function stringToArray(string) {
                return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
              }
              function trimmedEndIndex(string) {
                var index = string.length;
                while (index-- && reWhitespace.test(string.charAt(index))) {
                }
                return index;
              }
              var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
              function unicodeSize(string) {
                var result = reUnicode.lastIndex = 0;
                while (reUnicode.test(string)) {
                  ++result;
                }
                return result;
              }
              function unicodeToArray(string) {
                return string.match(reUnicode) || [];
              }
              function unicodeWords(string) {
                return string.match(reUnicodeWord) || [];
              }
              var runInContext = function runInContext2(context) {
                context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));
                var Array2 = context.Array, Date2 = context.Date, Error2 = context.Error, Function2 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError;
                var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype;
                var coreJsData = context["__core-js_shared__"];
                var funcToString = funcProto.toString;
                var hasOwnProperty = objectProto.hasOwnProperty;
                var idCounter = 0;
                var maskSrcKey = function() {
                  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
                  return uid ? "Symbol(src)_1." + uid : "";
                }();
                var nativeObjectToString = objectProto.toString;
                var objectCtorString = funcToString.call(Object2);
                var oldDash = root._;
                var reIsNative = RegExp2(
                  "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
                );
                var Buffer2 = moduleExports ? context.Buffer : undefined2, Symbol2 = context.Symbol, Uint8Array2 = context.Uint8Array, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : undefined2, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined2, symIterator = Symbol2 ? Symbol2.iterator : undefined2, symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined2;
                var defineProperty = function() {
                  try {
                    var func = getNative(Object2, "defineProperty");
                    func({}, "", {});
                    return func;
                  } catch (e) {
                  }
                }();
                var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;
                var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined2, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
                var DataView2 = getNative(context, "DataView"), Map2 = getNative(context, "Map"), Promise2 = getNative(context, "Promise"), Set2 = getNative(context, "Set"), WeakMap2 = getNative(context, "WeakMap"), nativeCreate = getNative(Object2, "create");
                var metaMap = WeakMap2 && new WeakMap2();
                var realNames = {};
                var dataViewCtorString = toSource(DataView2), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
                var symbolProto = Symbol2 ? Symbol2.prototype : undefined2, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined2, symbolToString = symbolProto ? symbolProto.toString : undefined2;
                function lodash(value) {
                  if (isObjectLike(value) && !isArray2(value) && !(value instanceof LazyWrapper)) {
                    if (value instanceof LodashWrapper) {
                      return value;
                    }
                    if (hasOwnProperty.call(value, "__wrapped__")) {
                      return wrapperClone(value);
                    }
                  }
                  return new LodashWrapper(value);
                }
                var baseCreate = /* @__PURE__ */ function() {
                  function object() {
                  }
                  return function(proto) {
                    if (!isObject(proto)) {
                      return {};
                    }
                    if (objectCreate) {
                      return objectCreate(proto);
                    }
                    object.prototype = proto;
                    var result2 = new object();
                    object.prototype = undefined2;
                    return result2;
                  };
                }();
                function baseLodash() {
                }
                function LodashWrapper(value, chainAll) {
                  this.__wrapped__ = value;
                  this.__actions__ = [];
                  this.__chain__ = !!chainAll;
                  this.__index__ = 0;
                  this.__values__ = undefined2;
                }
                lodash.templateSettings = {
                  /**
                   * Used to detect `data` property values to be HTML-escaped.
                   *
                   * @memberOf _.templateSettings
                   * @type {RegExp}
                   */
                  "escape": reEscape,
                  /**
                   * Used to detect code to be evaluated.
                   *
                   * @memberOf _.templateSettings
                   * @type {RegExp}
                   */
                  "evaluate": reEvaluate,
                  /**
                   * Used to detect `data` property values to inject.
                   *
                   * @memberOf _.templateSettings
                   * @type {RegExp}
                   */
                  "interpolate": reInterpolate,
                  /**
                   * Used to reference the data object in the template text.
                   *
                   * @memberOf _.templateSettings
                   * @type {string}
                   */
                  "variable": "",
                  /**
                   * Used to import variables into the compiled template.
                   *
                   * @memberOf _.templateSettings
                   * @type {Object}
                   */
                  "imports": {
                    /**
                     * A reference to the `lodash` function.
                     *
                     * @memberOf _.templateSettings.imports
                     * @type {Function}
                     */
                    "_": lodash
                  }
                };
                lodash.prototype = baseLodash.prototype;
                lodash.prototype.constructor = lodash;
                LodashWrapper.prototype = baseCreate(baseLodash.prototype);
                LodashWrapper.prototype.constructor = LodashWrapper;
                function LazyWrapper(value) {
                  this.__wrapped__ = value;
                  this.__actions__ = [];
                  this.__dir__ = 1;
                  this.__filtered__ = false;
                  this.__iteratees__ = [];
                  this.__takeCount__ = MAX_ARRAY_LENGTH;
                  this.__views__ = [];
                }
                function lazyClone() {
                  var result2 = new LazyWrapper(this.__wrapped__);
                  result2.__actions__ = copyArray(this.__actions__);
                  result2.__dir__ = this.__dir__;
                  result2.__filtered__ = this.__filtered__;
                  result2.__iteratees__ = copyArray(this.__iteratees__);
                  result2.__takeCount__ = this.__takeCount__;
                  result2.__views__ = copyArray(this.__views__);
                  return result2;
                }
                function lazyReverse() {
                  if (this.__filtered__) {
                    var result2 = new LazyWrapper(this);
                    result2.__dir__ = -1;
                    result2.__filtered__ = true;
                  } else {
                    result2 = this.clone();
                    result2.__dir__ *= -1;
                  }
                  return result2;
                }
                function lazyValue() {
                  var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray2(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
                  if (!isArr || !isRight && arrLength == length && takeCount == length) {
                    return baseWrapperValue(array, this.__actions__);
                  }
                  var result2 = [];
                  outer:
                    while (length-- && resIndex < takeCount) {
                      index += dir;
                      var iterIndex = -1, value = array[index];
                      while (++iterIndex < iterLength) {
                        var data = iteratees[iterIndex], iteratee2 = data.iteratee, type = data.type, computed = iteratee2(value);
                        if (type == LAZY_MAP_FLAG) {
                          value = computed;
                        } else if (!computed) {
                          if (type == LAZY_FILTER_FLAG) {
                            continue outer;
                          } else {
                            break outer;
                          }
                        }
                      }
                      result2[resIndex++] = value;
                    }
                  return result2;
                }
                LazyWrapper.prototype = baseCreate(baseLodash.prototype);
                LazyWrapper.prototype.constructor = LazyWrapper;
                function Hash(entries) {
                  var index = -1, length = entries == null ? 0 : entries.length;
                  this.clear();
                  while (++index < length) {
                    var entry = entries[index];
                    this.set(entry[0], entry[1]);
                  }
                }
                function hashClear() {
                  this.__data__ = nativeCreate ? nativeCreate(null) : {};
                  this.size = 0;
                }
                function hashDelete(key) {
                  var result2 = this.has(key) && delete this.__data__[key];
                  this.size -= result2 ? 1 : 0;
                  return result2;
                }
                function hashGet(key) {
                  var data = this.__data__;
                  if (nativeCreate) {
                    var result2 = data[key];
                    return result2 === HASH_UNDEFINED ? undefined2 : result2;
                  }
                  return hasOwnProperty.call(data, key) ? data[key] : undefined2;
                }
                function hashHas(key) {
                  var data = this.__data__;
                  return nativeCreate ? data[key] !== undefined2 : hasOwnProperty.call(data, key);
                }
                function hashSet(key, value) {
                  var data = this.__data__;
                  this.size += this.has(key) ? 0 : 1;
                  data[key] = nativeCreate && value === undefined2 ? HASH_UNDEFINED : value;
                  return this;
                }
                Hash.prototype.clear = hashClear;
                Hash.prototype["delete"] = hashDelete;
                Hash.prototype.get = hashGet;
                Hash.prototype.has = hashHas;
                Hash.prototype.set = hashSet;
                function ListCache(entries) {
                  var index = -1, length = entries == null ? 0 : entries.length;
                  this.clear();
                  while (++index < length) {
                    var entry = entries[index];
                    this.set(entry[0], entry[1]);
                  }
                }
                function listCacheClear() {
                  this.__data__ = [];
                  this.size = 0;
                }
                function listCacheDelete(key) {
                  var data = this.__data__, index = assocIndexOf(data, key);
                  if (index < 0) {
                    return false;
                  }
                  var lastIndex = data.length - 1;
                  if (index == lastIndex) {
                    data.pop();
                  } else {
                    splice.call(data, index, 1);
                  }
                  --this.size;
                  return true;
                }
                function listCacheGet(key) {
                  var data = this.__data__, index = assocIndexOf(data, key);
                  return index < 0 ? undefined2 : data[index][1];
                }
                function listCacheHas(key) {
                  return assocIndexOf(this.__data__, key) > -1;
                }
                function listCacheSet(key, value) {
                  var data = this.__data__, index = assocIndexOf(data, key);
                  if (index < 0) {
                    ++this.size;
                    data.push([key, value]);
                  } else {
                    data[index][1] = value;
                  }
                  return this;
                }
                ListCache.prototype.clear = listCacheClear;
                ListCache.prototype["delete"] = listCacheDelete;
                ListCache.prototype.get = listCacheGet;
                ListCache.prototype.has = listCacheHas;
                ListCache.prototype.set = listCacheSet;
                function MapCache(entries) {
                  var index = -1, length = entries == null ? 0 : entries.length;
                  this.clear();
                  while (++index < length) {
                    var entry = entries[index];
                    this.set(entry[0], entry[1]);
                  }
                }
                function mapCacheClear() {
                  this.size = 0;
                  this.__data__ = {
                    "hash": new Hash(),
                    "map": new (Map2 || ListCache)(),
                    "string": new Hash()
                  };
                }
                function mapCacheDelete(key) {
                  var result2 = getMapData(this, key)["delete"](key);
                  this.size -= result2 ? 1 : 0;
                  return result2;
                }
                function mapCacheGet(key) {
                  return getMapData(this, key).get(key);
                }
                function mapCacheHas(key) {
                  return getMapData(this, key).has(key);
                }
                function mapCacheSet(key, value) {
                  var data = getMapData(this, key), size2 = data.size;
                  data.set(key, value);
                  this.size += data.size == size2 ? 0 : 1;
                  return this;
                }
                MapCache.prototype.clear = mapCacheClear;
                MapCache.prototype["delete"] = mapCacheDelete;
                MapCache.prototype.get = mapCacheGet;
                MapCache.prototype.has = mapCacheHas;
                MapCache.prototype.set = mapCacheSet;
                function SetCache(values2) {
                  var index = -1, length = values2 == null ? 0 : values2.length;
                  this.__data__ = new MapCache();
                  while (++index < length) {
                    this.add(values2[index]);
                  }
                }
                function setCacheAdd(value) {
                  this.__data__.set(value, HASH_UNDEFINED);
                  return this;
                }
                function setCacheHas(value) {
                  return this.__data__.has(value);
                }
                SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
                SetCache.prototype.has = setCacheHas;
                function Stack(entries) {
                  var data = this.__data__ = new ListCache(entries);
                  this.size = data.size;
                }
                function stackClear() {
                  this.__data__ = new ListCache();
                  this.size = 0;
                }
                function stackDelete(key) {
                  var data = this.__data__, result2 = data["delete"](key);
                  this.size = data.size;
                  return result2;
                }
                function stackGet(key) {
                  return this.__data__.get(key);
                }
                function stackHas(key) {
                  return this.__data__.has(key);
                }
                function stackSet(key, value) {
                  var data = this.__data__;
                  if (data instanceof ListCache) {
                    var pairs = data.__data__;
                    if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
                      pairs.push([key, value]);
                      this.size = ++data.size;
                      return this;
                    }
                    data = this.__data__ = new MapCache(pairs);
                  }
                  data.set(key, value);
                  this.size = data.size;
                  return this;
                }
                Stack.prototype.clear = stackClear;
                Stack.prototype["delete"] = stackDelete;
                Stack.prototype.get = stackGet;
                Stack.prototype.has = stackHas;
                Stack.prototype.set = stackSet;
                function arrayLikeKeys(value, inherited) {
                  var isArr = isArray2(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String2) : [], length = result2.length;
                  for (var key in value) {
                    if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
                    (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
                    isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
                    isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
                    isIndex(key, length)))) {
                      result2.push(key);
                    }
                  }
                  return result2;
                }
                function arraySample(array) {
                  var length = array.length;
                  return length ? array[baseRandom(0, length - 1)] : undefined2;
                }
                function arraySampleSize(array, n) {
                  return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
                }
                function arrayShuffle(array) {
                  return shuffleSelf(copyArray(array));
                }
                function assignMergeValue(object, key, value) {
                  if (value !== undefined2 && !eq(object[key], value) || value === undefined2 && !(key in object)) {
                    baseAssignValue(object, key, value);
                  }
                }
                function assignValue(object, key, value) {
                  var objValue = object[key];
                  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined2 && !(key in object)) {
                    baseAssignValue(object, key, value);
                  }
                }
                function assocIndexOf(array, key) {
                  var length = array.length;
                  while (length--) {
                    if (eq(array[length][0], key)) {
                      return length;
                    }
                  }
                  return -1;
                }
                function baseAggregator(collection, setter, iteratee2, accumulator) {
                  baseEach(collection, function(value, key, collection2) {
                    setter(accumulator, value, iteratee2(value), collection2);
                  });
                  return accumulator;
                }
                function baseAssign(object, source) {
                  return object && copyObject(source, keys(source), object);
                }
                function baseAssignIn(object, source) {
                  return object && copyObject(source, keysIn(source), object);
                }
                function baseAssignValue(object, key, value) {
                  if (key == "__proto__" && defineProperty) {
                    defineProperty(object, key, {
                      "configurable": true,
                      "enumerable": true,
                      "value": value,
                      "writable": true
                    });
                  } else {
                    object[key] = value;
                  }
                }
                function baseAt(object, paths) {
                  var index = -1, length = paths.length, result2 = Array2(length), skip = object == null;
                  while (++index < length) {
                    result2[index] = skip ? undefined2 : get(object, paths[index]);
                  }
                  return result2;
                }
                function baseClamp(number, lower, upper) {
                  if (number === number) {
                    if (upper !== undefined2) {
                      number = number <= upper ? number : upper;
                    }
                    if (lower !== undefined2) {
                      number = number >= lower ? number : lower;
                    }
                  }
                  return number;
                }
                function baseClone(value, bitmask, customizer, key, object, stack) {
                  var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
                  if (customizer) {
                    result2 = object ? customizer(value, key, object, stack) : customizer(value);
                  }
                  if (result2 !== undefined2) {
                    return result2;
                  }
                  if (!isObject(value)) {
                    return value;
                  }
                  var isArr = isArray2(value);
                  if (isArr) {
                    result2 = initCloneArray(value);
                    if (!isDeep) {
                      return copyArray(value, result2);
                    }
                  } else {
                    var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
                    if (isBuffer(value)) {
                      return cloneBuffer(value, isDeep);
                    }
                    if (tag == objectTag || tag == argsTag || isFunc && !object) {
                      result2 = isFlat || isFunc ? {} : initCloneObject(value);
                      if (!isDeep) {
                        return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
                      }
                    } else {
                      if (!cloneableTags[tag]) {
                        return object ? value : {};
                      }
                      result2 = initCloneByTag(value, tag, isDeep);
                    }
                  }
                  stack || (stack = new Stack());
                  var stacked = stack.get(value);
                  if (stacked) {
                    return stacked;
                  }
                  stack.set(value, result2);
                  if (isSet(value)) {
                    value.forEach(function(subValue) {
                      result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
                    });
                  } else if (isMap(value)) {
                    value.forEach(function(subValue, key2) {
                      result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
                    });
                  }
                  var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
                  var props = isArr ? undefined2 : keysFunc(value);
                  arrayEach(props || value, function(subValue, key2) {
                    if (props) {
                      key2 = subValue;
                      subValue = value[key2];
                    }
                    assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
                  });
                  return result2;
                }
                function baseConforms(source) {
                  var props = keys(source);
                  return function(object) {
                    return baseConformsTo(object, source, props);
                  };
                }
                function baseConformsTo(object, source, props) {
                  var length = props.length;
                  if (object == null) {
                    return !length;
                  }
                  object = Object2(object);
                  while (length--) {
                    var key = props[length], predicate = source[key], value = object[key];
                    if (value === undefined2 && !(key in object) || !predicate(value)) {
                      return false;
                    }
                  }
                  return true;
                }
                function baseDelay(func, wait, args) {
                  if (typeof func != "function") {
                    throw new TypeError2(FUNC_ERROR_TEXT);
                  }
                  return setTimeout2(function() {
                    func.apply(undefined2, args);
                  }, wait);
                }
                function baseDifference(array, values2, iteratee2, comparator) {
                  var index = -1, includes2 = arrayIncludes, isCommon = true, length = array.length, result2 = [], valuesLength = values2.length;
                  if (!length) {
                    return result2;
                  }
                  if (iteratee2) {
                    values2 = arrayMap(values2, baseUnary(iteratee2));
                  }
                  if (comparator) {
                    includes2 = arrayIncludesWith;
                    isCommon = false;
                  } else if (values2.length >= LARGE_ARRAY_SIZE) {
                    includes2 = cacheHas;
                    isCommon = false;
                    values2 = new SetCache(values2);
                  }
                  outer:
                    while (++index < length) {
                      var value = array[index], computed = iteratee2 == null ? value : iteratee2(value);
                      value = comparator || value !== 0 ? value : 0;
                      if (isCommon && computed === computed) {
                        var valuesIndex = valuesLength;
                        while (valuesIndex--) {
                          if (values2[valuesIndex] === computed) {
                            continue outer;
                          }
                        }
                        result2.push(value);
                      } else if (!includes2(values2, computed, comparator)) {
                        result2.push(value);
                      }
                    }
                  return result2;
                }
                var baseEach = createBaseEach(baseForOwn);
                var baseEachRight = createBaseEach(baseForOwnRight, true);
                function baseEvery(collection, predicate) {
                  var result2 = true;
                  baseEach(collection, function(value, index, collection2) {
                    result2 = !!predicate(value, index, collection2);
                    return result2;
                  });
                  return result2;
                }
                function baseExtremum(array, iteratee2, comparator) {
                  var index = -1, length = array.length;
                  while (++index < length) {
                    var value = array[index], current = iteratee2(value);
                    if (current != null && (computed === undefined2 ? current === current && !isSymbol(current) : comparator(current, computed))) {
                      var computed = current, result2 = value;
                    }
                  }
                  return result2;
                }
                function baseFill(array, value, start, end) {
                  var length = array.length;
                  start = toInteger(start);
                  if (start < 0) {
                    start = -start > length ? 0 : length + start;
                  }
                  end = end === undefined2 || end > length ? length : toInteger(end);
                  if (end < 0) {
                    end += length;
                  }
                  end = start > end ? 0 : toLength(end);
                  while (start < end) {
                    array[start++] = value;
                  }
                  return array;
                }
                function baseFilter(collection, predicate) {
                  var result2 = [];
                  baseEach(collection, function(value, index, collection2) {
                    if (predicate(value, index, collection2)) {
                      result2.push(value);
                    }
                  });
                  return result2;
                }
                function baseFlatten(array, depth, predicate, isStrict, result2) {
                  var index = -1, length = array.length;
                  predicate || (predicate = isFlattenable);
                  result2 || (result2 = []);
                  while (++index < length) {
                    var value = array[index];
                    if (depth > 0 && predicate(value)) {
                      if (depth > 1) {
                        baseFlatten(value, depth - 1, predicate, isStrict, result2);
                      } else {
                        arrayPush(result2, value);
                      }
                    } else if (!isStrict) {
                      result2[result2.length] = value;
                    }
                  }
                  return result2;
                }
                var baseFor = createBaseFor();
                var baseForRight = createBaseFor(true);
                function baseForOwn(object, iteratee2) {
                  return object && baseFor(object, iteratee2, keys);
                }
                function baseForOwnRight(object, iteratee2) {
                  return object && baseForRight(object, iteratee2, keys);
                }
                function baseFunctions(object, props) {
                  return arrayFilter(props, function(key) {
                    return isFunction(object[key]);
                  });
                }
                function baseGet(object, path) {
                  path = castPath(path, object);
                  var index = 0, length = path.length;
                  while (object != null && index < length) {
                    object = object[toKey(path[index++])];
                  }
                  return index && index == length ? object : undefined2;
                }
                function baseGetAllKeys(object, keysFunc, symbolsFunc) {
                  var result2 = keysFunc(object);
                  return isArray2(object) ? result2 : arrayPush(result2, symbolsFunc(object));
                }
                function baseGetTag(value) {
                  if (value == null) {
                    return value === undefined2 ? undefinedTag : nullTag;
                  }
                  return symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString(value);
                }
                function baseGt(value, other) {
                  return value > other;
                }
                function baseHas(object, key) {
                  return object != null && hasOwnProperty.call(object, key);
                }
                function baseHasIn(object, key) {
                  return object != null && key in Object2(object);
                }
                function baseInRange(number, start, end) {
                  return number >= nativeMin(start, end) && number < nativeMax(start, end);
                }
                function baseIntersection(arrays, iteratee2, comparator) {
                  var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
                  while (othIndex--) {
                    var array = arrays[othIndex];
                    if (othIndex && iteratee2) {
                      array = arrayMap(array, baseUnary(iteratee2));
                    }
                    maxLength = nativeMin(array.length, maxLength);
                    caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined2;
                  }
                  array = arrays[0];
                  var index = -1, seen = caches[0];
                  outer:
                    while (++index < length && result2.length < maxLength) {
                      var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
                      value = comparator || value !== 0 ? value : 0;
                      if (!(seen ? cacheHas(seen, computed) : includes2(result2, computed, comparator))) {
                        othIndex = othLength;
                        while (--othIndex) {
                          var cache = caches[othIndex];
                          if (!(cache ? cacheHas(cache, computed) : includes2(arrays[othIndex], computed, comparator))) {
                            continue outer;
                          }
                        }
                        if (seen) {
                          seen.push(computed);
                        }
                        result2.push(value);
                      }
                    }
                  return result2;
                }
                function baseInverter(object, setter, iteratee2, accumulator) {
                  baseForOwn(object, function(value, key, object2) {
                    setter(accumulator, iteratee2(value), key, object2);
                  });
                  return accumulator;
                }
                function baseInvoke(object, path, args) {
                  path = castPath(path, object);
                  object = parent(object, path);
                  var func = object == null ? object : object[toKey(last(path))];
                  return func == null ? undefined2 : apply(func, object, args);
                }
                function baseIsArguments(value) {
                  return isObjectLike(value) && baseGetTag(value) == argsTag;
                }
                function baseIsArrayBuffer(value) {
                  return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
                }
                function baseIsDate(value) {
                  return isObjectLike(value) && baseGetTag(value) == dateTag;
                }
                function baseIsEqual(value, other, bitmask, customizer, stack) {
                  if (value === other) {
                    return true;
                  }
                  if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
                    return value !== value && other !== other;
                  }
                  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
                }
                function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
                  var objIsArr = isArray2(object), othIsArr = isArray2(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
                  objTag = objTag == argsTag ? objectTag : objTag;
                  othTag = othTag == argsTag ? objectTag : othTag;
                  var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
                  if (isSameTag && isBuffer(object)) {
                    if (!isBuffer(other)) {
                      return false;
                    }
                    objIsArr = true;
                    objIsObj = false;
                  }
                  if (isSameTag && !objIsObj) {
                    stack || (stack = new Stack());
                    return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
                  }
                  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
                    var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
                    if (objIsWrapped || othIsWrapped) {
                      var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
                      stack || (stack = new Stack());
                      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
                    }
                  }
                  if (!isSameTag) {
                    return false;
                  }
                  stack || (stack = new Stack());
                  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
                }
                function baseIsMap(value) {
                  return isObjectLike(value) && getTag(value) == mapTag;
                }
                function baseIsMatch(object, source, matchData, customizer) {
                  var index = matchData.length, length = index, noCustomizer = !customizer;
                  if (object == null) {
                    return !length;
                  }
                  object = Object2(object);
                  while (index--) {
                    var data = matchData[index];
                    if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
                      return false;
                    }
                  }
                  while (++index < length) {
                    data = matchData[index];
                    var key = data[0], objValue = object[key], srcValue = data[1];
                    if (noCustomizer && data[2]) {
                      if (objValue === undefined2 && !(key in object)) {
                        return false;
                      }
                    } else {
                      var stack = new Stack();
                      if (customizer) {
                        var result2 = customizer(objValue, srcValue, key, object, source, stack);
                      }
                      if (!(result2 === undefined2 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result2)) {
                        return false;
                      }
                    }
                  }
                  return true;
                }
                function baseIsNative(value) {
                  if (!isObject(value) || isMasked(value)) {
                    return false;
                  }
                  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
                  return pattern.test(toSource(value));
                }
                function baseIsRegExp(value) {
                  return isObjectLike(value) && baseGetTag(value) == regexpTag;
                }
                function baseIsSet(value) {
                  return isObjectLike(value) && getTag(value) == setTag;
                }
                function baseIsTypedArray(value) {
                  return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
                }
                function baseIteratee(value) {
                  if (typeof value == "function") {
                    return value;
                  }
                  if (value == null) {
                    return identity;
                  }
                  if (typeof value == "object") {
                    return isArray2(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
                  }
                  return property(value);
                }
                function baseKeys(object) {
                  if (!isPrototype(object)) {
                    return nativeKeys(object);
                  }
                  var result2 = [];
                  for (var key in Object2(object)) {
                    if (hasOwnProperty.call(object, key) && key != "constructor") {
                      result2.push(key);
                    }
                  }
                  return result2;
                }
                function baseKeysIn(object) {
                  if (!isObject(object)) {
                    return nativeKeysIn(object);
                  }
                  var isProto = isPrototype(object), result2 = [];
                  for (var key in object) {
                    if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
                      result2.push(key);
                    }
                  }
                  return result2;
                }
                function baseLt(value, other) {
                  return value < other;
                }
                function baseMap(collection, iteratee2) {
                  var index = -1, result2 = isArrayLike(collection) ? Array2(collection.length) : [];
                  baseEach(collection, function(value, key, collection2) {
                    result2[++index] = iteratee2(value, key, collection2);
                  });
                  return result2;
                }
                function baseMatches(source) {
                  var matchData = getMatchData(source);
                  if (matchData.length == 1 && matchData[0][2]) {
                    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
                  }
                  return function(object) {
                    return object === source || baseIsMatch(object, source, matchData);
                  };
                }
                function baseMatchesProperty(path, srcValue) {
                  if (isKey(path) && isStrictComparable(srcValue)) {
                    return matchesStrictComparable(toKey(path), srcValue);
                  }
                  return function(object) {
                    var objValue = get(object, path);
                    return objValue === undefined2 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
                  };
                }
                function baseMerge(object, source, srcIndex, customizer, stack) {
                  if (object === source) {
                    return;
                  }
                  baseFor(source, function(srcValue, key) {
                    stack || (stack = new Stack());
                    if (isObject(srcValue)) {
                      baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
                    } else {
                      var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : undefined2;
                      if (newValue === undefined2) {
                        newValue = srcValue;
                      }
                      assignMergeValue(object, key, newValue);
                    }
                  }, keysIn);
                }
                function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
                  var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
                  if (stacked) {
                    assignMergeValue(object, key, stacked);
                    return;
                  }
                  var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : undefined2;
                  var isCommon = newValue === undefined2;
                  if (isCommon) {
                    var isArr = isArray2(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
                    newValue = srcValue;
                    if (isArr || isBuff || isTyped) {
                      if (isArray2(objValue)) {
                        newValue = objValue;
                      } else if (isArrayLikeObject(objValue)) {
                        newValue = copyArray(objValue);
                      } else if (isBuff) {
                        isCommon = false;
                        newValue = cloneBuffer(srcValue, true);
                      } else if (isTyped) {
                        isCommon = false;
                        newValue = cloneTypedArray(srcValue, true);
                      } else {
                        newValue = [];
                      }
                    } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
                      newValue = objValue;
                      if (isArguments(objValue)) {
                        newValue = toPlainObject(objValue);
                      } else if (!isObject(objValue) || isFunction(objValue)) {
                        newValue = initCloneObject(srcValue);
                      }
                    } else {
                      isCommon = false;
                    }
                  }
                  if (isCommon) {
                    stack.set(srcValue, newValue);
                    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
                    stack["delete"](srcValue);
                  }
                  assignMergeValue(object, key, newValue);
                }
                function baseNth(array, n) {
                  var length = array.length;
                  if (!length) {
                    return;
                  }
                  n += n < 0 ? length : 0;
                  return isIndex(n, length) ? array[n] : undefined2;
                }
                function baseOrderBy(collection, iteratees, orders) {
                  if (iteratees.length) {
                    iteratees = arrayMap(iteratees, function(iteratee2) {
                      if (isArray2(iteratee2)) {
                        return function(value) {
                          return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
                        };
                      }
                      return iteratee2;
                    });
                  } else {
                    iteratees = [identity];
                  }
                  var index = -1;
                  iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
                  var result2 = baseMap(collection, function(value, key, collection2) {
                    var criteria = arrayMap(iteratees, function(iteratee2) {
                      return iteratee2(value);
                    });
                    return { "criteria": criteria, "index": ++index, "value": value };
                  });
                  return baseSortBy(result2, function(object, other) {
                    return compareMultiple(object, other, orders);
                  });
                }
                function basePick(object, paths) {
                  return basePickBy(object, paths, function(value, path) {
                    return hasIn(object, path);
                  });
                }
                function basePickBy(object, paths, predicate) {
                  var index = -1, length = paths.length, result2 = {};
                  while (++index < length) {
                    var path = paths[index], value = baseGet(object, path);
                    if (predicate(value, path)) {
                      baseSet(result2, castPath(path, object), value);
                    }
                  }
                  return result2;
                }
                function basePropertyDeep(path) {
                  return function(object) {
                    return baseGet(object, path);
                  };
                }
                function basePullAll(array, values2, iteratee2, comparator) {
                  var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length = values2.length, seen = array;
                  if (array === values2) {
                    values2 = copyArray(values2);
                  }
                  if (iteratee2) {
                    seen = arrayMap(array, baseUnary(iteratee2));
                  }
                  while (++index < length) {
                    var fromIndex = 0, value = values2[index], computed = iteratee2 ? iteratee2(value) : value;
                    while ((fromIndex = indexOf2(seen, computed, fromIndex, comparator)) > -1) {
                      if (seen !== array) {
                        splice.call(seen, fromIndex, 1);
                      }
                      splice.call(array, fromIndex, 1);
                    }
                  }
                  return array;
                }
                function basePullAt(array, indexes) {
                  var length = array ? indexes.length : 0, lastIndex = length - 1;
                  while (length--) {
                    var index = indexes[length];
                    if (length == lastIndex || index !== previous) {
                      var previous = index;
                      if (isIndex(index)) {
                        splice.call(array, index, 1);
                      } else {
                        baseUnset(array, index);
                      }
                    }
                  }
                  return array;
                }
                function baseRandom(lower, upper) {
                  return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
                }
                function baseRange(start, end, step, fromRight) {
                  var index = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result2 = Array2(length);
                  while (length--) {
                    result2[fromRight ? length : ++index] = start;
                    start += step;
                  }
                  return result2;
                }
                function baseRepeat(string, n) {
                  var result2 = "";
                  if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
                    return result2;
                  }
                  do {
                    if (n % 2) {
                      result2 += string;
                    }
                    n = nativeFloor(n / 2);
                    if (n) {
                      string += string;
                    }
                  } while (n);
                  return result2;
                }
                function baseRest(func, start) {
                  return setToString(overRest(func, start, identity), func + "");
                }
                function baseSample(collection) {
                  return arraySample(values(collection));
                }
                function baseSampleSize(collection, n) {
                  var array = values(collection);
                  return shuffleSelf(array, baseClamp(n, 0, array.length));
                }
                function baseSet(object, path, value, customizer) {
                  if (!isObject(object)) {
                    return object;
                  }
                  path = castPath(path, object);
                  var index = -1, length = path.length, lastIndex = length - 1, nested = object;
                  while (nested != null && ++index < length) {
                    var key = toKey(path[index]), newValue = value;
                    if (key === "__proto__" || key === "constructor" || key === "prototype") {
                      return object;
                    }
                    if (index != lastIndex) {
                      var objValue = nested[key];
                      newValue = customizer ? customizer(objValue, key, nested) : undefined2;
                      if (newValue === undefined2) {
                        newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
                      }
                    }
                    assignValue(nested, key, newValue);
                    nested = nested[key];
                  }
                  return object;
                }
                var baseSetData = !metaMap ? identity : function(func, data) {
                  metaMap.set(func, data);
                  return func;
                };
                var baseSetToString = !defineProperty ? identity : function(func, string) {
                  return defineProperty(func, "toString", {
                    "configurable": true,
                    "enumerable": false,
                    "value": constant(string),
                    "writable": true
                  });
                };
                function baseShuffle(collection) {
                  return shuffleSelf(values(collection));
                }
                function baseSlice(array, start, end) {
                  var index = -1, length = array.length;
                  if (start < 0) {
                    start = -start > length ? 0 : length + start;
                  }
                  end = end > length ? length : end;
                  if (end < 0) {
                    end += length;
                  }
                  length = start > end ? 0 : end - start >>> 0;
                  start >>>= 0;
                  var result2 = Array2(length);
                  while (++index < length) {
                    result2[index] = array[index + start];
                  }
                  return result2;
                }
                function baseSome(collection, predicate) {
                  var result2;
                  baseEach(collection, function(value, index, collection2) {
                    result2 = predicate(value, index, collection2);
                    return !result2;
                  });
                  return !!result2;
                }
                function baseSortedIndex(array, value, retHighest) {
                  var low = 0, high = array == null ? low : array.length;
                  if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
                    while (low < high) {
                      var mid = low + high >>> 1, computed = array[mid];
                      if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)) {
                        low = mid + 1;
                      } else {
                        high = mid;
                      }
                    }
                    return high;
                  }
                  return baseSortedIndexBy(array, value, identity, retHighest);
                }
                function baseSortedIndexBy(array, value, iteratee2, retHighest) {
                  var low = 0, high = array == null ? 0 : array.length;
                  if (high === 0) {
                    return 0;
                  }
                  value = iteratee2(value);
                  var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined2;
                  while (low < high) {
                    var mid = nativeFloor((low + high) / 2), computed = iteratee2(array[mid]), othIsDefined = computed !== undefined2, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
                    if (valIsNaN) {
                      var setLow = retHighest || othIsReflexive;
                    } else if (valIsUndefined) {
                      setLow = othIsReflexive && (retHighest || othIsDefined);
                    } else if (valIsNull) {
                      setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
                    } else if (valIsSymbol) {
                      setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
                    } else if (othIsNull || othIsSymbol) {
                      setLow = false;
                    } else {
                      setLow = retHighest ? computed <= value : computed < value;
                    }
                    if (setLow) {
                      low = mid + 1;
                    } else {
                      high = mid;
                    }
                  }
                  return nativeMin(high, MAX_ARRAY_INDEX);
                }
                function baseSortedUniq(array, iteratee2) {
                  var index = -1, length = array.length, resIndex = 0, result2 = [];
                  while (++index < length) {
                    var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
                    if (!index || !eq(computed, seen)) {
                      var seen = computed;
                      result2[resIndex++] = value === 0 ? 0 : value;
                    }
                  }
                  return result2;
                }
                function baseToNumber(value) {
                  if (typeof value == "number") {
                    return value;
                  }
                  if (isSymbol(value)) {
                    return NAN;
                  }
                  return +value;
                }
                function baseToString(value) {
                  if (typeof value == "string") {
                    return value;
                  }
                  if (isArray2(value)) {
                    return arrayMap(value, baseToString) + "";
                  }
                  if (isSymbol(value)) {
                    return symbolToString ? symbolToString.call(value) : "";
                  }
                  var result2 = value + "";
                  return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
                }
                function baseUniq(array, iteratee2, comparator) {
                  var index = -1, includes2 = arrayIncludes, length = array.length, isCommon = true, result2 = [], seen = result2;
                  if (comparator) {
                    isCommon = false;
                    includes2 = arrayIncludesWith;
                  } else if (length >= LARGE_ARRAY_SIZE) {
                    var set2 = iteratee2 ? null : createSet(array);
                    if (set2) {
                      return setToArray(set2);
                    }
                    isCommon = false;
                    includes2 = cacheHas;
                    seen = new SetCache();
                  } else {
                    seen = iteratee2 ? [] : result2;
                  }
                  outer:
                    while (++index < length) {
                      var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
                      value = comparator || value !== 0 ? value : 0;
                      if (isCommon && computed === computed) {
                        var seenIndex = seen.length;
                        while (seenIndex--) {
                          if (seen[seenIndex] === computed) {
                            continue outer;
                          }
                        }
                        if (iteratee2) {
                          seen.push(computed);
                        }
                        result2.push(value);
                      } else if (!includes2(seen, computed, comparator)) {
                        if (seen !== result2) {
                          seen.push(computed);
                        }
                        result2.push(value);
                      }
                    }
                  return result2;
                }
                function baseUnset(object, path) {
                  path = castPath(path, object);
                  object = parent(object, path);
                  return object == null || delete object[toKey(last(path))];
                }
                function baseUpdate(object, path, updater, customizer) {
                  return baseSet(object, path, updater(baseGet(object, path)), customizer);
                }
                function baseWhile(array, predicate, isDrop, fromRight) {
                  var length = array.length, index = fromRight ? length : -1;
                  while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {
                  }
                  return isDrop ? baseSlice(array, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array, fromRight ? index + 1 : 0, fromRight ? length : index);
                }
                function baseWrapperValue(value, actions) {
                  var result2 = value;
                  if (result2 instanceof LazyWrapper) {
                    result2 = result2.value();
                  }
                  return arrayReduce(actions, function(result3, action) {
                    return action.func.apply(action.thisArg, arrayPush([result3], action.args));
                  }, result2);
                }
                function baseXor(arrays, iteratee2, comparator) {
                  var length = arrays.length;
                  if (length < 2) {
                    return length ? baseUniq(arrays[0]) : [];
                  }
                  var index = -1, result2 = Array2(length);
                  while (++index < length) {
                    var array = arrays[index], othIndex = -1;
                    while (++othIndex < length) {
                      if (othIndex != index) {
                        result2[index] = baseDifference(result2[index] || array, arrays[othIndex], iteratee2, comparator);
                      }
                    }
                  }
                  return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
                }
                function baseZipObject(props, values2, assignFunc) {
                  var index = -1, length = props.length, valsLength = values2.length, result2 = {};
                  while (++index < length) {
                    var value = index < valsLength ? values2[index] : undefined2;
                    assignFunc(result2, props[index], value);
                  }
                  return result2;
                }
                function castArrayLikeObject(value) {
                  return isArrayLikeObject(value) ? value : [];
                }
                function castFunction(value) {
                  return typeof value == "function" ? value : identity;
                }
                function castPath(value, object) {
                  if (isArray2(value)) {
                    return value;
                  }
                  return isKey(value, object) ? [value] : stringToPath(toString(value));
                }
                var castRest = baseRest;
                function castSlice(array, start, end) {
                  var length = array.length;
                  end = end === undefined2 ? length : end;
                  return !start && end >= length ? array : baseSlice(array, start, end);
                }
                var clearTimeout2 = ctxClearTimeout || function(id) {
                  return root.clearTimeout(id);
                };
                function cloneBuffer(buffer, isDeep) {
                  if (isDeep) {
                    return buffer.slice();
                  }
                  var length = buffer.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
                  buffer.copy(result2);
                  return result2;
                }
                function cloneArrayBuffer(arrayBuffer) {
                  var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
                  new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
                  return result2;
                }
                function cloneDataView(dataView, isDeep) {
                  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
                  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
                }
                function cloneRegExp(regexp) {
                  var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
                  result2.lastIndex = regexp.lastIndex;
                  return result2;
                }
                function cloneSymbol(symbol) {
                  return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
                }
                function cloneTypedArray(typedArray, isDeep) {
                  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
                  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
                }
                function compareAscending(value, other) {
                  if (value !== other) {
                    var valIsDefined = value !== undefined2, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
                    var othIsDefined = other !== undefined2, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
                    if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
                      return 1;
                    }
                    if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
                      return -1;
                    }
                  }
                  return 0;
                }
                function compareMultiple(object, other, orders) {
                  var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
                  while (++index < length) {
                    var result2 = compareAscending(objCriteria[index], othCriteria[index]);
                    if (result2) {
                      if (index >= ordersLength) {
                        return result2;
                      }
                      var order = orders[index];
                      return result2 * (order == "desc" ? -1 : 1);
                    }
                  }
                  return object.index - other.index;
                }
                function composeArgs(args, partials, holders, isCurried) {
                  var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
                  while (++leftIndex < leftLength) {
                    result2[leftIndex] = partials[leftIndex];
                  }
                  while (++argsIndex < holdersLength) {
                    if (isUncurried || argsIndex < argsLength) {
                      result2[holders[argsIndex]] = args[argsIndex];
                    }
                  }
                  while (rangeLength--) {
                    result2[leftIndex++] = args[argsIndex++];
                  }
                  return result2;
                }
                function composeArgsRight(args, partials, holders, isCurried) {
                  var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
                  while (++argsIndex < rangeLength) {
                    result2[argsIndex] = args[argsIndex];
                  }
                  var offset = argsIndex;
                  while (++rightIndex < rightLength) {
                    result2[offset + rightIndex] = partials[rightIndex];
                  }
                  while (++holdersIndex < holdersLength) {
                    if (isUncurried || argsIndex < argsLength) {
                      result2[offset + holders[holdersIndex]] = args[argsIndex++];
                    }
                  }
                  return result2;
                }
                function copyArray(source, array) {
                  var index = -1, length = source.length;
                  array || (array = Array2(length));
                  while (++index < length) {
                    array[index] = source[index];
                  }
                  return array;
                }
                function copyObject(source, props, object, customizer) {
                  var isNew = !object;
                  object || (object = {});
                  var index = -1, length = props.length;
                  while (++index < length) {
                    var key = props[index];
                    var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined2;
                    if (newValue === undefined2) {
                      newValue = source[key];
                    }
                    if (isNew) {
                      baseAssignValue(object, key, newValue);
                    } else {
                      assignValue(object, key, newValue);
                    }
                  }
                  return object;
                }
                function copySymbols(source, object) {
                  return copyObject(source, getSymbols(source), object);
                }
                function copySymbolsIn(source, object) {
                  return copyObject(source, getSymbolsIn(source), object);
                }
                function createAggregator(setter, initializer) {
                  return function(collection, iteratee2) {
                    var func = isArray2(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
                    return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
                  };
                }
                function createAssigner(assigner) {
                  return baseRest(function(object, sources) {
                    var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined2, guard = length > 2 ? sources[2] : undefined2;
                    customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined2;
                    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
                      customizer = length < 3 ? undefined2 : customizer;
                      length = 1;
                    }
                    object = Object2(object);
                    while (++index < length) {
                      var source = sources[index];
                      if (source) {
                        assigner(object, source, index, customizer);
                      }
                    }
                    return object;
                  });
                }
                function createBaseEach(eachFunc, fromRight) {
                  return function(collection, iteratee2) {
                    if (collection == null) {
                      return collection;
                    }
                    if (!isArrayLike(collection)) {
                      return eachFunc(collection, iteratee2);
                    }
                    var length = collection.length, index = fromRight ? length : -1, iterable = Object2(collection);
                    while (fromRight ? index-- : ++index < length) {
                      if (iteratee2(iterable[index], index, iterable) === false) {
                        break;
                      }
                    }
                    return collection;
                  };
                }
                function createBaseFor(fromRight) {
                  return function(object, iteratee2, keysFunc) {
                    var index = -1, iterable = Object2(object), props = keysFunc(object), length = props.length;
                    while (length--) {
                      var key = props[fromRight ? length : ++index];
                      if (iteratee2(iterable[key], key, iterable) === false) {
                        break;
                      }
                    }
                    return object;
                  };
                }
                function createBind(func, bitmask, thisArg) {
                  var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
                  function wrapper() {
                    var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
                    return fn.apply(isBind ? thisArg : this, arguments);
                  }
                  return wrapper;
                }
                function createCaseFirst(methodName) {
                  return function(string) {
                    string = toString(string);
                    var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined2;
                    var chr = strSymbols ? strSymbols[0] : string.charAt(0);
                    var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
                    return chr[methodName]() + trailing;
                  };
                }
                function createCompounder(callback) {
                  return function(string) {
                    return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
                  };
                }
                function createCtor(Ctor) {
                  return function() {
                    var args = arguments;
                    switch (args.length) {
                      case 0:
                        return new Ctor();
                      case 1:
                        return new Ctor(args[0]);
                      case 2:
                        return new Ctor(args[0], args[1]);
                      case 3:
                        return new Ctor(args[0], args[1], args[2]);
                      case 4:
                        return new Ctor(args[0], args[1], args[2], args[3]);
                      case 5:
                        return new Ctor(args[0], args[1], args[2], args[3], args[4]);
                      case 6:
                        return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
                      case 7:
                        return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
                    }
                    var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
                    return isObject(result2) ? result2 : thisBinding;
                  };
                }
                function createCurry(func, bitmask, arity) {
                  var Ctor = createCtor(func);
                  function wrapper() {
                    var length = arguments.length, args = Array2(length), index = length, placeholder = getHolder(wrapper);
                    while (index--) {
                      args[index] = arguments[index];
                    }
                    var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
                    length -= holders.length;
                    if (length < arity) {
                      return createRecurry(
                        func,
                        bitmask,
                        createHybrid,
                        wrapper.placeholder,
                        undefined2,
                        args,
                        holders,
                        undefined2,
                        undefined2,
                        arity - length
                      );
                    }
                    var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
                    return apply(fn, this, args);
                  }
                  return wrapper;
                }
                function createFind(findIndexFunc) {
                  return function(collection, predicate, fromIndex) {
                    var iterable = Object2(collection);
                    if (!isArrayLike(collection)) {
                      var iteratee2 = getIteratee(predicate, 3);
                      collection = keys(collection);
                      predicate = function(key) {
                        return iteratee2(iterable[key], key, iterable);
                      };
                    }
                    var index = findIndexFunc(collection, predicate, fromIndex);
                    return index > -1 ? iterable[iteratee2 ? collection[index] : index] : undefined2;
                  };
                }
                function createFlow(fromRight) {
                  return flatRest(function(funcs) {
                    var length = funcs.length, index = length, prereq = LodashWrapper.prototype.thru;
                    if (fromRight) {
                      funcs.reverse();
                    }
                    while (index--) {
                      var func = funcs[index];
                      if (typeof func != "function") {
                        throw new TypeError2(FUNC_ERROR_TEXT);
                      }
                      if (prereq && !wrapper && getFuncName(func) == "wrapper") {
                        var wrapper = new LodashWrapper([], true);
                      }
                    }
                    index = wrapper ? index : length;
                    while (++index < length) {
                      func = funcs[index];
                      var funcName = getFuncName(func), data = funcName == "wrapper" ? getData(func) : undefined2;
                      if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
                        wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
                      } else {
                        wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
                      }
                    }
                    return function() {
                      var args = arguments, value = args[0];
                      if (wrapper && args.length == 1 && isArray2(value)) {
                        return wrapper.plant(value).value();
                      }
                      var index2 = 0, result2 = length ? funcs[index2].apply(this, args) : value;
                      while (++index2 < length) {
                        result2 = funcs[index2].call(this, result2);
                      }
                      return result2;
                    };
                  });
                }
                function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
                  var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined2 : createCtor(func);
                  function wrapper() {
                    var length = arguments.length, args = Array2(length), index = length;
                    while (index--) {
                      args[index] = arguments[index];
                    }
                    if (isCurried) {
                      var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
                    }
                    if (partials) {
                      args = composeArgs(args, partials, holders, isCurried);
                    }
                    if (partialsRight) {
                      args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
                    }
                    length -= holdersCount;
                    if (isCurried && length < arity) {
                      var newHolders = replaceHolders(args, placeholder);
                      return createRecurry(
                        func,
                        bitmask,
                        createHybrid,
                        wrapper.placeholder,
                        thisArg,
                        args,
                        newHolders,
                        argPos,
                        ary2,
                        arity - length
                      );
                    }
                    var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
                    length = args.length;
                    if (argPos) {
                      args = reorder(args, argPos);
                    } else if (isFlip && length > 1) {
                      args.reverse();
                    }
                    if (isAry && ary2 < length) {
                      args.length = ary2;
                    }
                    if (this && this !== root && this instanceof wrapper) {
                      fn = Ctor || createCtor(fn);
                    }
                    return fn.apply(thisBinding, args);
                  }
                  return wrapper;
                }
                function createInverter(setter, toIteratee) {
                  return function(object, iteratee2) {
                    return baseInverter(object, setter, toIteratee(iteratee2), {});
                  };
                }
                function createMathOperation(operator, defaultValue) {
                  return function(value, other) {
                    var result2;
                    if (value === undefined2 && other === undefined2) {
                      return defaultValue;
                    }
                    if (value !== undefined2) {
                      result2 = value;
                    }
                    if (other !== undefined2) {
                      if (result2 === undefined2) {
                        return other;
                      }
                      if (typeof value == "string" || typeof other == "string") {
                        value = baseToString(value);
                        other = baseToString(other);
                      } else {
                        value = baseToNumber(value);
                        other = baseToNumber(other);
                      }
                      result2 = operator(value, other);
                    }
                    return result2;
                  };
                }
                function createOver(arrayFunc) {
                  return flatRest(function(iteratees) {
                    iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
                    return baseRest(function(args) {
                      var thisArg = this;
                      return arrayFunc(iteratees, function(iteratee2) {
                        return apply(iteratee2, thisArg, args);
                      });
                    });
                  });
                }
                function createPadding(length, chars) {
                  chars = chars === undefined2 ? " " : baseToString(chars);
                  var charsLength = chars.length;
                  if (charsLength < 2) {
                    return charsLength ? baseRepeat(chars, length) : chars;
                  }
                  var result2 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
                  return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length).join("") : result2.slice(0, length);
                }
                function createPartial(func, bitmask, thisArg, partials) {
                  var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
                  function wrapper() {
                    var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root && this instanceof wrapper ? Ctor : func;
                    while (++leftIndex < leftLength) {
                      args[leftIndex] = partials[leftIndex];
                    }
                    while (argsLength--) {
                      args[leftIndex++] = arguments[++argsIndex];
                    }
                    return apply(fn, isBind ? thisArg : this, args);
                  }
                  return wrapper;
                }
                function createRange(fromRight) {
                  return function(start, end, step) {
                    if (step && typeof step != "number" && isIterateeCall(start, end, step)) {
                      end = step = undefined2;
                    }
                    start = toFinite(start);
                    if (end === undefined2) {
                      end = start;
                      start = 0;
                    } else {
                      end = toFinite(end);
                    }
                    step = step === undefined2 ? start < end ? 1 : -1 : toFinite(step);
                    return baseRange(start, end, step, fromRight);
                  };
                }
                function createRelationalOperation(operator) {
                  return function(value, other) {
                    if (!(typeof value == "string" && typeof other == "string")) {
                      value = toNumber(value);
                      other = toNumber(other);
                    }
                    return operator(value, other);
                  };
                }
                function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
                  var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined2, newHoldersRight = isCurry ? undefined2 : holders, newPartials = isCurry ? partials : undefined2, newPartialsRight = isCurry ? undefined2 : partials;
                  bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
                  bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
                  if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
                    bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
                  }
                  var newData = [
                    func,
                    bitmask,
                    thisArg,
                    newPartials,
                    newHolders,
                    newPartialsRight,
                    newHoldersRight,
                    argPos,
                    ary2,
                    arity
                  ];
                  var result2 = wrapFunc.apply(undefined2, newData);
                  if (isLaziable(func)) {
                    setData(result2, newData);
                  }
                  result2.placeholder = placeholder;
                  return setWrapToString(result2, func, bitmask);
                }
                function createRound(methodName) {
                  var func = Math2[methodName];
                  return function(number, precision) {
                    number = toNumber(number);
                    precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
                    if (precision && nativeIsFinite(number)) {
                      var pair = (toString(number) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
                      pair = (toString(value) + "e").split("e");
                      return +(pair[0] + "e" + (+pair[1] - precision));
                    }
                    return func(number);
                  };
                }
                var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop : function(values2) {
                  return new Set2(values2);
                };
                function createToPairs(keysFunc) {
                  return function(object) {
                    var tag = getTag(object);
                    if (tag == mapTag) {
                      return mapToArray(object);
                    }
                    if (tag == setTag) {
                      return setToPairs(object);
                    }
                    return baseToPairs(object, keysFunc(object));
                  };
                }
                function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
                  var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
                  if (!isBindKey && typeof func != "function") {
                    throw new TypeError2(FUNC_ERROR_TEXT);
                  }
                  var length = partials ? partials.length : 0;
                  if (!length) {
                    bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
                    partials = holders = undefined2;
                  }
                  ary2 = ary2 === undefined2 ? ary2 : nativeMax(toInteger(ary2), 0);
                  arity = arity === undefined2 ? arity : toInteger(arity);
                  length -= holders ? holders.length : 0;
                  if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
                    var partialsRight = partials, holdersRight = holders;
                    partials = holders = undefined2;
                  }
                  var data = isBindKey ? undefined2 : getData(func);
                  var newData = [
                    func,
                    bitmask,
                    thisArg,
                    partials,
                    holders,
                    partialsRight,
                    holdersRight,
                    argPos,
                    ary2,
                    arity
                  ];
                  if (data) {
                    mergeData(newData, data);
                  }
                  func = newData[0];
                  bitmask = newData[1];
                  thisArg = newData[2];
                  partials = newData[3];
                  holders = newData[4];
                  arity = newData[9] = newData[9] === undefined2 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
                  if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
                    bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
                  }
                  if (!bitmask || bitmask == WRAP_BIND_FLAG) {
                    var result2 = createBind(func, bitmask, thisArg);
                  } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
                    result2 = createCurry(func, bitmask, arity);
                  } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
                    result2 = createPartial(func, bitmask, thisArg, partials);
                  } else {
                    result2 = createHybrid.apply(undefined2, newData);
                  }
                  var setter = data ? baseSetData : setData;
                  return setWrapToString(setter(result2, newData), func, bitmask);
                }
                function customDefaultsAssignIn(objValue, srcValue, key, object) {
                  if (objValue === undefined2 || eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key)) {
                    return srcValue;
                  }
                  return objValue;
                }
                function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
                  if (isObject(objValue) && isObject(srcValue)) {
                    stack.set(srcValue, objValue);
                    baseMerge(objValue, srcValue, undefined2, customDefaultsMerge, stack);
                    stack["delete"](srcValue);
                  }
                  return objValue;
                }
                function customOmitClone(value) {
                  return isPlainObject(value) ? undefined2 : value;
                }
                function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
                  var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
                  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
                    return false;
                  }
                  var arrStacked = stack.get(array);
                  var othStacked = stack.get(other);
                  if (arrStacked && othStacked) {
                    return arrStacked == other && othStacked == array;
                  }
                  var index = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined2;
                  stack.set(array, other);
                  stack.set(other, array);
                  while (++index < arrLength) {
                    var arrValue = array[index], othValue = other[index];
                    if (customizer) {
                      var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
                    }
                    if (compared !== undefined2) {
                      if (compared) {
                        continue;
                      }
                      result2 = false;
                      break;
                    }
                    if (seen) {
                      if (!arraySome(other, function(othValue2, othIndex) {
                        if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                          return seen.push(othIndex);
                        }
                      })) {
                        result2 = false;
                        break;
                      }
                    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                      result2 = false;
                      break;
                    }
                  }
                  stack["delete"](array);
                  stack["delete"](other);
                  return result2;
                }
                function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
                  switch (tag) {
                    case dataViewTag:
                      if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
                        return false;
                      }
                      object = object.buffer;
                      other = other.buffer;
                    case arrayBufferTag:
                      if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
                        return false;
                      }
                      return true;
                    case boolTag:
                    case dateTag:
                    case numberTag:
                      return eq(+object, +other);
                    case errorTag:
                      return object.name == other.name && object.message == other.message;
                    case regexpTag:
                    case stringTag:
                      return object == other + "";
                    case mapTag:
                      var convert = mapToArray;
                    case setTag:
                      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
                      convert || (convert = setToArray);
                      if (object.size != other.size && !isPartial) {
                        return false;
                      }
                      var stacked = stack.get(object);
                      if (stacked) {
                        return stacked == other;
                      }
                      bitmask |= COMPARE_UNORDERED_FLAG;
                      stack.set(object, other);
                      var result2 = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
                      stack["delete"](object);
                      return result2;
                    case symbolTag:
                      if (symbolValueOf) {
                        return symbolValueOf.call(object) == symbolValueOf.call(other);
                      }
                  }
                  return false;
                }
                function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
                  var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
                  if (objLength != othLength && !isPartial) {
                    return false;
                  }
                  var index = objLength;
                  while (index--) {
                    var key = objProps[index];
                    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
                      return false;
                    }
                  }
                  var objStacked = stack.get(object);
                  var othStacked = stack.get(other);
                  if (objStacked && othStacked) {
                    return objStacked == other && othStacked == object;
                  }
                  var result2 = true;
                  stack.set(object, other);
                  stack.set(other, object);
                  var skipCtor = isPartial;
                  while (++index < objLength) {
                    key = objProps[index];
                    var objValue = object[key], othValue = other[key];
                    if (customizer) {
                      var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
                    }
                    if (!(compared === undefined2 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
                      result2 = false;
                      break;
                    }
                    skipCtor || (skipCtor = key == "constructor");
                  }
                  if (result2 && !skipCtor) {
                    var objCtor = object.constructor, othCtor = other.constructor;
                    if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
                      result2 = false;
                    }
                  }
                  stack["delete"](object);
                  stack["delete"](other);
                  return result2;
                }
                function flatRest(func) {
                  return setToString(overRest(func, undefined2, flatten), func + "");
                }
                function getAllKeys(object) {
                  return baseGetAllKeys(object, keys, getSymbols);
                }
                function getAllKeysIn(object) {
                  return baseGetAllKeys(object, keysIn, getSymbolsIn);
                }
                var getData = !metaMap ? noop : function(func) {
                  return metaMap.get(func);
                };
                function getFuncName(func) {
                  var result2 = func.name + "", array = realNames[result2], length = hasOwnProperty.call(realNames, result2) ? array.length : 0;
                  while (length--) {
                    var data = array[length], otherFunc = data.func;
                    if (otherFunc == null || otherFunc == func) {
                      return data.name;
                    }
                  }
                  return result2;
                }
                function getHolder(func) {
                  var object = hasOwnProperty.call(lodash, "placeholder") ? lodash : func;
                  return object.placeholder;
                }
                function getIteratee() {
                  var result2 = lodash.iteratee || iteratee;
                  result2 = result2 === iteratee ? baseIteratee : result2;
                  return arguments.length ? result2(arguments[0], arguments[1]) : result2;
                }
                function getMapData(map2, key) {
                  var data = map2.__data__;
                  return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
                }
                function getMatchData(object) {
                  var result2 = keys(object), length = result2.length;
                  while (length--) {
                    var key = result2[length], value = object[key];
                    result2[length] = [key, value, isStrictComparable(value)];
                  }
                  return result2;
                }
                function getNative(object, key) {
                  var value = getValue(object, key);
                  return baseIsNative(value) ? value : undefined2;
                }
                function getRawTag(value) {
                  var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
                  try {
                    value[symToStringTag] = undefined2;
                    var unmasked = true;
                  } catch (e) {
                  }
                  var result2 = nativeObjectToString.call(value);
                  if (unmasked) {
                    if (isOwn) {
                      value[symToStringTag] = tag;
                    } else {
                      delete value[symToStringTag];
                    }
                  }
                  return result2;
                }
                var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
                  if (object == null) {
                    return [];
                  }
                  object = Object2(object);
                  return arrayFilter(nativeGetSymbols(object), function(symbol) {
                    return propertyIsEnumerable.call(object, symbol);
                  });
                };
                var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
                  var result2 = [];
                  while (object) {
                    arrayPush(result2, getSymbols(object));
                    object = getPrototype(object);
                  }
                  return result2;
                };
                var getTag = baseGetTag;
                if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
                  getTag = function(value) {
                    var result2 = baseGetTag(value), Ctor = result2 == objectTag ? value.constructor : undefined2, ctorString = Ctor ? toSource(Ctor) : "";
                    if (ctorString) {
                      switch (ctorString) {
                        case dataViewCtorString:
                          return dataViewTag;
                        case mapCtorString:
                          return mapTag;
                        case promiseCtorString:
                          return promiseTag;
                        case setCtorString:
                          return setTag;
                        case weakMapCtorString:
                          return weakMapTag;
                      }
                    }
                    return result2;
                  };
                }
                function getView(start, end, transforms) {
                  var index = -1, length = transforms.length;
                  while (++index < length) {
                    var data = transforms[index], size2 = data.size;
                    switch (data.type) {
                      case "drop":
                        start += size2;
                        break;
                      case "dropRight":
                        end -= size2;
                        break;
                      case "take":
                        end = nativeMin(end, start + size2);
                        break;
                      case "takeRight":
                        start = nativeMax(start, end - size2);
                        break;
                    }
                  }
                  return { "start": start, "end": end };
                }
                function getWrapDetails(source) {
                  var match = source.match(reWrapDetails);
                  return match ? match[1].split(reSplitDetails) : [];
                }
                function hasPath(object, path, hasFunc) {
                  path = castPath(path, object);
                  var index = -1, length = path.length, result2 = false;
                  while (++index < length) {
                    var key = toKey(path[index]);
                    if (!(result2 = object != null && hasFunc(object, key))) {
                      break;
                    }
                    object = object[key];
                  }
                  if (result2 || ++index != length) {
                    return result2;
                  }
                  length = object == null ? 0 : object.length;
                  return !!length && isLength(length) && isIndex(key, length) && (isArray2(object) || isArguments(object));
                }
                function initCloneArray(array) {
                  var length = array.length, result2 = new array.constructor(length);
                  if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
                    result2.index = array.index;
                    result2.input = array.input;
                  }
                  return result2;
                }
                function initCloneObject(object) {
                  return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
                }
                function initCloneByTag(object, tag, isDeep) {
                  var Ctor = object.constructor;
                  switch (tag) {
                    case arrayBufferTag:
                      return cloneArrayBuffer(object);
                    case boolTag:
                    case dateTag:
                      return new Ctor(+object);
                    case dataViewTag:
                      return cloneDataView(object, isDeep);
                    case float32Tag:
                    case float64Tag:
                    case int8Tag:
                    case int16Tag:
                    case int32Tag:
                    case uint8Tag:
                    case uint8ClampedTag:
                    case uint16Tag:
                    case uint32Tag:
                      return cloneTypedArray(object, isDeep);
                    case mapTag:
                      return new Ctor();
                    case numberTag:
                    case stringTag:
                      return new Ctor(object);
                    case regexpTag:
                      return cloneRegExp(object);
                    case setTag:
                      return new Ctor();
                    case symbolTag:
                      return cloneSymbol(object);
                  }
                }
                function insertWrapDetails(source, details) {
                  var length = details.length;
                  if (!length) {
                    return source;
                  }
                  var lastIndex = length - 1;
                  details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
                  details = details.join(length > 2 ? ", " : " ");
                  return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
                }
                function isFlattenable(value) {
                  return isArray2(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
                }
                function isIndex(value, length) {
                  var type = typeof value;
                  length = length == null ? MAX_SAFE_INTEGER : length;
                  return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
                }
                function isIterateeCall(value, index, object) {
                  if (!isObject(object)) {
                    return false;
                  }
                  var type = typeof index;
                  if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
                    return eq(object[index], value);
                  }
                  return false;
                }
                function isKey(value, object) {
                  if (isArray2(value)) {
                    return false;
                  }
                  var type = typeof value;
                  if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
                    return true;
                  }
                  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object2(object);
                }
                function isKeyable(value) {
                  var type = typeof value;
                  return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
                }
                function isLaziable(func) {
                  var funcName = getFuncName(func), other = lodash[funcName];
                  if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
                    return false;
                  }
                  if (func === other) {
                    return true;
                  }
                  var data = getData(other);
                  return !!data && func === data[0];
                }
                function isMasked(func) {
                  return !!maskSrcKey && maskSrcKey in func;
                }
                var isMaskable = coreJsData ? isFunction : stubFalse;
                function isPrototype(value) {
                  var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
                  return value === proto;
                }
                function isStrictComparable(value) {
                  return value === value && !isObject(value);
                }
                function matchesStrictComparable(key, srcValue) {
                  return function(object) {
                    if (object == null) {
                      return false;
                    }
                    return object[key] === srcValue && (srcValue !== undefined2 || key in Object2(object));
                  };
                }
                function memoizeCapped(func) {
                  var result2 = memoize(func, function(key) {
                    if (cache.size === MAX_MEMOIZE_SIZE) {
                      cache.clear();
                    }
                    return key;
                  });
                  var cache = result2.cache;
                  return result2;
                }
                function mergeData(data, source) {
                  var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
                  var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
                  if (!(isCommon || isCombo)) {
                    return data;
                  }
                  if (srcBitmask & WRAP_BIND_FLAG) {
                    data[2] = source[2];
                    newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
                  }
                  var value = source[3];
                  if (value) {
                    var partials = data[3];
                    data[3] = partials ? composeArgs(partials, value, source[4]) : value;
                    data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
                  }
                  value = source[5];
                  if (value) {
                    partials = data[5];
                    data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
                    data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
                  }
                  value = source[7];
                  if (value) {
                    data[7] = value;
                  }
                  if (srcBitmask & WRAP_ARY_FLAG) {
                    data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
                  }
                  if (data[9] == null) {
                    data[9] = source[9];
                  }
                  data[0] = source[0];
                  data[1] = newBitmask;
                  return data;
                }
                function nativeKeysIn(object) {
                  var result2 = [];
                  if (object != null) {
                    for (var key in Object2(object)) {
                      result2.push(key);
                    }
                  }
                  return result2;
                }
                function objectToString(value) {
                  return nativeObjectToString.call(value);
                }
                function overRest(func, start, transform2) {
                  start = nativeMax(start === undefined2 ? func.length - 1 : start, 0);
                  return function() {
                    var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array2(length);
                    while (++index < length) {
                      array[index] = args[start + index];
                    }
                    index = -1;
                    var otherArgs = Array2(start + 1);
                    while (++index < start) {
                      otherArgs[index] = args[index];
                    }
                    otherArgs[start] = transform2(array);
                    return apply(func, this, otherArgs);
                  };
                }
                function parent(object, path) {
                  return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
                }
                function reorder(array, indexes) {
                  var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);
                  while (length--) {
                    var index = indexes[length];
                    array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined2;
                  }
                  return array;
                }
                function safeGet(object, key) {
                  if (key === "constructor" && typeof object[key] === "function") {
                    return;
                  }
                  if (key == "__proto__") {
                    return;
                  }
                  return object[key];
                }
                var setData = shortOut(baseSetData);
                var setTimeout2 = ctxSetTimeout || function(func, wait) {
                  return root.setTimeout(func, wait);
                };
                var setToString = shortOut(baseSetToString);
                function setWrapToString(wrapper, reference, bitmask) {
                  var source = reference + "";
                  return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
                }
                function shortOut(func) {
                  var count = 0, lastCalled = 0;
                  return function() {
                    var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
                    lastCalled = stamp;
                    if (remaining > 0) {
                      if (++count >= HOT_COUNT) {
                        return arguments[0];
                      }
                    } else {
                      count = 0;
                    }
                    return func.apply(undefined2, arguments);
                  };
                }
                function shuffleSelf(array, size2) {
                  var index = -1, length = array.length, lastIndex = length - 1;
                  size2 = size2 === undefined2 ? length : size2;
                  while (++index < size2) {
                    var rand = baseRandom(index, lastIndex), value = array[rand];
                    array[rand] = array[index];
                    array[index] = value;
                  }
                  array.length = size2;
                  return array;
                }
                var stringToPath = memoizeCapped(function(string) {
                  var result2 = [];
                  if (string.charCodeAt(0) === 46) {
                    result2.push("");
                  }
                  string.replace(rePropName, function(match, number, quote, subString) {
                    result2.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
                  });
                  return result2;
                });
                function toKey(value) {
                  if (typeof value == "string" || isSymbol(value)) {
                    return value;
                  }
                  var result2 = value + "";
                  return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
                }
                function toSource(func) {
                  if (func != null) {
                    try {
                      return funcToString.call(func);
                    } catch (e) {
                    }
                    try {
                      return func + "";
                    } catch (e) {
                    }
                  }
                  return "";
                }
                function updateWrapDetails(details, bitmask) {
                  arrayEach(wrapFlags, function(pair) {
                    var value = "_." + pair[0];
                    if (bitmask & pair[1] && !arrayIncludes(details, value)) {
                      details.push(value);
                    }
                  });
                  return details.sort();
                }
                function wrapperClone(wrapper) {
                  if (wrapper instanceof LazyWrapper) {
                    return wrapper.clone();
                  }
                  var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
                  result2.__actions__ = copyArray(wrapper.__actions__);
                  result2.__index__ = wrapper.__index__;
                  result2.__values__ = wrapper.__values__;
                  return result2;
                }
                function chunk(array, size2, guard) {
                  if (guard ? isIterateeCall(array, size2, guard) : size2 === undefined2) {
                    size2 = 1;
                  } else {
                    size2 = nativeMax(toInteger(size2), 0);
                  }
                  var length = array == null ? 0 : array.length;
                  if (!length || size2 < 1) {
                    return [];
                  }
                  var index = 0, resIndex = 0, result2 = Array2(nativeCeil(length / size2));
                  while (index < length) {
                    result2[resIndex++] = baseSlice(array, index, index += size2);
                  }
                  return result2;
                }
                function compact(array) {
                  var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result2 = [];
                  while (++index < length) {
                    var value = array[index];
                    if (value) {
                      result2[resIndex++] = value;
                    }
                  }
                  return result2;
                }
                function concat() {
                  var length = arguments.length;
                  if (!length) {
                    return [];
                  }
                  var args = Array2(length - 1), array = arguments[0], index = length;
                  while (index--) {
                    args[index - 1] = arguments[index];
                  }
                  return arrayPush(isArray2(array) ? copyArray(array) : [array], baseFlatten(args, 1));
                }
                var difference = baseRest(function(array, values2) {
                  return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true)) : [];
                });
                var differenceBy = baseRest(function(array, values2) {
                  var iteratee2 = last(values2);
                  if (isArrayLikeObject(iteratee2)) {
                    iteratee2 = undefined2;
                  }
                  return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
                });
                var differenceWith = baseRest(function(array, values2) {
                  var comparator = last(values2);
                  if (isArrayLikeObject(comparator)) {
                    comparator = undefined2;
                  }
                  return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), undefined2, comparator) : [];
                });
                function drop(array, n, guard) {
                  var length = array == null ? 0 : array.length;
                  if (!length) {
                    return [];
                  }
                  n = guard || n === undefined2 ? 1 : toInteger(n);
                  return baseSlice(array, n < 0 ? 0 : n, length);
                }
                function dropRight(array, n, guard) {
                  var length = array == null ? 0 : array.length;
                  if (!length) {
                    return [];
                  }
                  n = guard || n === undefined2 ? 1 : toInteger(n);
                  n = length - n;
                  return baseSlice(array, 0, n < 0 ? 0 : n);
                }
                function dropRightWhile(array, predicate) {
                  return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
                }
                function dropWhile(array, predicate) {
                  return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
                }
                function fill(array, value, start, end) {
                  var length = array == null ? 0 : array.length;
                  if (!length) {
                    return [];
                  }
                  if (start && typeof start != "number" && isIterateeCall(array, value, start)) {
                    start = 0;
                    end = length;
                  }
                  return baseFill(array, value, start, end);
                }
                function findIndex(array, predicate, fromIndex) {
                  var length = array == null ? 0 : array.length;
                  if (!length) {
                    return -1;
                  }
                  var index = fromIndex == null ? 0 : toInteger(fromIndex);
                  if (index < 0) {
                    index = nativeMax(length + index, 0);
                  }
                  return baseFindIndex(array, getIteratee(predicate, 3), index);
                }
                function findLastIndex(array, predicate, fromIndex) {
                  var length = array == null ? 0 : array.length;
                  if (!length) {
                    return -1;
                  }
                  var index = length - 1;
                  if (fromIndex !== undefined2) {
                    index = toInteger(fromIndex);
                    index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
                  }
                  return baseFindIndex(array, getIteratee(predicate, 3), index, true);
                }
                function flatten(array) {
                  var length = array == null ? 0 : array.length;
                  return length ? baseFlatten(array, 1) : [];
                }
                function flattenDeep(array) {
                  var length = array == null ? 0 : array.length;
                  return length ? baseFlatten(array, INFINITY) : [];
                }
                function flattenDepth(array, depth) {
                  var length = array == null ? 0 : array.length;
                  if (!length) {
                    return [];
                  }
                  depth = depth === undefined2 ? 1 : toInteger(depth);
                  return baseFlatten(array, depth);
                }
                function fromPairs(pairs) {
                  var index = -1, length = pairs == null ? 0 : pairs.length, result2 = {};
                  while (++index < length) {
                    var pair = pairs[index];
                    result2[pair[0]] = pair[1];
                  }
                  return result2;
                }
                function head(array) {
                  return array && array.length ? array[0] : undefined2;
                }
                function indexOf(array, value, fromIndex) {
                  var length = array == null ? 0 : array.length;
                  if (!length) {
                    return -1;
                  }
                  var index = fromIndex == null ? 0 : toInteger(fromIndex);
                  if (index < 0) {
                    index = nativeMax(length + index, 0);
                  }
                  return baseIndexOf(array, value, index);
                }
                function initial(array) {
                  var length = array == null ? 0 : array.length;
                  return length ? baseSlice(array, 0, -1) : [];
                }
                var intersection = baseRest(function(arrays) {
                  var mapped = arrayMap(arrays, castArrayLikeObject);
                  return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
                });
                var intersectionBy = baseRest(function(arrays) {
                  var iteratee2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
                  if (iteratee2 === last(mapped)) {
                    iteratee2 = undefined2;
                  } else {
                    mapped.pop();
                  }
                  return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
                });
                var intersectionWith = baseRest(function(arrays) {
                  var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
                  comparator = typeof comparator == "function" ? comparator : undefined2;
                  if (comparator) {
                    mapped.pop();
                  }
                  return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined2, comparator) : [];
                });
                function join(array, separator) {
                  return array == null ? "" : nativeJoin.call(array, separator);
                }
                function last(array) {
                  var length = array == null ? 0 : array.length;
                  return length ? array[length - 1] : undefined2;
                }
                function lastIndexOf(array, value, fromIndex) {
                  var length = array == null ? 0 : array.length;
                  if (!length) {
                    return -1;
                  }
                  var index = length;
                  if (fromIndex !== undefined2) {
                    index = toInteger(fromIndex);
                    index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
                  }
                  return value === value ? strictLastIndexOf(array, value, index) : baseFindIndex(array, baseIsNaN, index, true);
                }
                function nth(array, n) {
                  return array && array.length ? baseNth(array, toInteger(n)) : undefined2;
                }
                var pull = baseRest(pullAll);
                function pullAll(array, values2) {
                  return array && array.length && values2 && values2.length ? basePullAll(array, values2) : array;
                }
                function pullAllBy(array, values2, iteratee2) {
                  return array && array.length && values2 && values2.length ? basePullAll(array, values2, getIteratee(iteratee2, 2)) : array;
                }
                function pullAllWith(array, values2, comparator) {
                  return array && array.length && values2 && values2.length ? basePullAll(array, values2, undefined2, comparator) : array;
                }
                var pullAt = flatRest(function(array, indexes) {
                  var length = array == null ? 0 : array.length, result2 = baseAt(array, indexes);
                  basePullAt(array, arrayMap(indexes, function(index) {
                    return isIndex(index, length) ? +index : index;
                  }).sort(compareAscending));
                  return result2;
                });
                function remove(array, predicate) {
                  var result2 = [];
                  if (!(array && array.length)) {
                    return result2;
                  }
                  var index = -1, indexes = [], length = array.length;
                  predicate = getIteratee(predicate, 3);
                  while (++index < length) {
                    var value = array[index];
                    if (predicate(value, index, array)) {
                      result2.push(value);
                      indexes.push(index);
                    }
                  }
                  basePullAt(array, indexes);
                  return result2;
                }
                function reverse(array) {
                  return array == null ? array : nativeReverse.call(array);
                }
                function slice(array, start, end) {
                  var length = array == null ? 0 : array.length;
                  if (!length) {
                    return [];
                  }
                  if (end && typeof end != "number" && isIterateeCall(array, start, end)) {
                    start = 0;
                    end = length;
                  } else {
                    start = start == null ? 0 : toInteger(start);
                    end = end === undefined2 ? length : toInteger(end);
                  }
                  return baseSlice(array, start, end);
                }
                function sortedIndex(array, value) {
                  return baseSortedIndex(array, value);
                }
                function sortedIndexBy(array, value, iteratee2) {
                  return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2));
                }
                function sortedIndexOf(array, value) {
                  var length = array == null ? 0 : array.length;
                  if (length) {
                    var index = baseSortedIndex(array, value);
                    if (index < length && eq(array[index], value)) {
                      return index;
                    }
                  }
                  return -1;
                }
                function sortedLastIndex(array, value) {
                  return baseSortedIndex(array, value, true);
                }
                function sortedLastIndexBy(array, value, iteratee2) {
                  return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2), true);
                }
                function sortedLastIndexOf(array, value) {
                  var length = array == null ? 0 : array.length;
                  if (length) {
                    var index = baseSortedIndex(array, value, true) - 1;
                    if (eq(array[index], value)) {
                      return index;
                    }
                  }
                  return -1;
                }
                function sortedUniq(array) {
                  return array && array.length ? baseSortedUniq(array) : [];
                }
                function sortedUniqBy(array, iteratee2) {
                  return array && array.length ? baseSortedUniq(array, getIteratee(iteratee2, 2)) : [];
                }
                function tail(array) {
                  var length = array == null ? 0 : array.length;
                  return length ? baseSlice(array, 1, length) : [];
                }
                function take(array, n, guard) {
                  if (!(array && array.length)) {
                    return [];
                  }
                  n = guard || n === undefined2 ? 1 : toInteger(n);
                  return baseSlice(array, 0, n < 0 ? 0 : n);
                }
                function takeRight(array, n, guard) {
                  var length = array == null ? 0 : array.length;
                  if (!length) {
                    return [];
                  }
                  n = guard || n === undefined2 ? 1 : toInteger(n);
                  n = length - n;
                  return baseSlice(array, n < 0 ? 0 : n, length);
                }
                function takeRightWhile(array, predicate) {
                  return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
                }
                function takeWhile(array, predicate) {
                  return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
                }
                var union = baseRest(function(arrays) {
                  return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
                });
                var unionBy = baseRest(function(arrays) {
                  var iteratee2 = last(arrays);
                  if (isArrayLikeObject(iteratee2)) {
                    iteratee2 = undefined2;
                  }
                  return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
                });
                var unionWith = baseRest(function(arrays) {
                  var comparator = last(arrays);
                  comparator = typeof comparator == "function" ? comparator : undefined2;
                  return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined2, comparator);
                });
                function uniq(array) {
                  return array && array.length ? baseUniq(array) : [];
                }
                function uniqBy(array, iteratee2) {
                  return array && array.length ? baseUniq(array, getIteratee(iteratee2, 2)) : [];
                }
                function uniqWith(array, comparator) {
                  comparator = typeof comparator == "function" ? comparator : undefined2;
                  return array && array.length ? baseUniq(array, undefined2, comparator) : [];
                }
                function unzip(array) {
                  if (!(array && array.length)) {
                    return [];
                  }
                  var length = 0;
                  array = arrayFilter(array, function(group) {
                    if (isArrayLikeObject(group)) {
                      length = nativeMax(group.length, length);
                      return true;
                    }
                  });
                  return baseTimes(length, function(index) {
                    return arrayMap(array, baseProperty(index));
                  });
                }
                function unzipWith(array, iteratee2) {
                  if (!(array && array.length)) {
                    return [];
                  }
                  var result2 = unzip(array);
                  if (iteratee2 == null) {
                    return result2;
                  }
                  return arrayMap(result2, function(group) {
                    return apply(iteratee2, undefined2, group);
                  });
                }
                var without = baseRest(function(array, values2) {
                  return isArrayLikeObject(array) ? baseDifference(array, values2) : [];
                });
                var xor = baseRest(function(arrays) {
                  return baseXor(arrayFilter(arrays, isArrayLikeObject));
                });
                var xorBy = baseRest(function(arrays) {
                  var iteratee2 = last(arrays);
                  if (isArrayLikeObject(iteratee2)) {
                    iteratee2 = undefined2;
                  }
                  return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
                });
                var xorWith = baseRest(function(arrays) {
                  var comparator = last(arrays);
                  comparator = typeof comparator == "function" ? comparator : undefined2;
                  return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined2, comparator);
                });
                var zip = baseRest(unzip);
                function zipObject(props, values2) {
                  return baseZipObject(props || [], values2 || [], assignValue);
                }
                function zipObjectDeep(props, values2) {
                  return baseZipObject(props || [], values2 || [], baseSet);
                }
                var zipWith = baseRest(function(arrays) {
                  var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined2;
                  iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined2;
                  return unzipWith(arrays, iteratee2);
                });
                function chain(value) {
                  var result2 = lodash(value);
                  result2.__chain__ = true;
                  return result2;
                }
                function tap(value, interceptor) {
                  interceptor(value);
                  return value;
                }
                function thru(value, interceptor) {
                  return interceptor(value);
                }
                var wrapperAt = flatRest(function(paths) {
                  var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
                    return baseAt(object, paths);
                  };
                  if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) {
                    return this.thru(interceptor);
                  }
                  value = value.slice(start, +start + (length ? 1 : 0));
                  value.__actions__.push({
                    "func": thru,
                    "args": [interceptor],
                    "thisArg": undefined2
                  });
                  return new LodashWrapper(value, this.__chain__).thru(function(array) {
                    if (length && !array.length) {
                      array.push(undefined2);
                    }
                    return array;
                  });
                });
                function wrapperChain() {
                  return chain(this);
                }
                function wrapperCommit() {
                  return new LodashWrapper(this.value(), this.__chain__);
                }
                function wrapperNext() {
                  if (this.__values__ === undefined2) {
                    this.__values__ = toArray(this.value());
                  }
                  var done = this.__index__ >= this.__values__.length, value = done ? undefined2 : this.__values__[this.__index__++];
                  return { "done": done, "value": value };
                }
                function wrapperToIterator() {
                  return this;
                }
                function wrapperPlant(value) {
                  var result2, parent2 = this;
                  while (parent2 instanceof baseLodash) {
                    var clone2 = wrapperClone(parent2);
                    clone2.__index__ = 0;
                    clone2.__values__ = undefined2;
                    if (result2) {
                      previous.__wrapped__ = clone2;
                    } else {
                      result2 = clone2;
                    }
                    var previous = clone2;
                    parent2 = parent2.__wrapped__;
                  }
                  previous.__wrapped__ = value;
                  return result2;
                }
                function wrapperReverse() {
                  var value = this.__wrapped__;
                  if (value instanceof LazyWrapper) {
                    var wrapped = value;
                    if (this.__actions__.length) {
                      wrapped = new LazyWrapper(this);
                    }
                    wrapped = wrapped.reverse();
                    wrapped.__actions__.push({
                      "func": thru,
                      "args": [reverse],
                      "thisArg": undefined2
                    });
                    return new LodashWrapper(wrapped, this.__chain__);
                  }
                  return this.thru(reverse);
                }
                function wrapperValue() {
                  return baseWrapperValue(this.__wrapped__, this.__actions__);
                }
                var countBy = createAggregator(function(result2, value, key) {
                  if (hasOwnProperty.call(result2, key)) {
                    ++result2[key];
                  } else {
                    baseAssignValue(result2, key, 1);
                  }
                });
                function every(collection, predicate, guard) {
                  var func = isArray2(collection) ? arrayEvery : baseEvery;
                  if (guard && isIterateeCall(collection, predicate, guard)) {
                    predicate = undefined2;
                  }
                  return func(collection, getIteratee(predicate, 3));
                }
                function filter(collection, predicate) {
                  var func = isArray2(collection) ? arrayFilter : baseFilter;
                  return func(collection, getIteratee(predicate, 3));
                }
                var find = createFind(findIndex);
                var findLast = createFind(findLastIndex);
                function flatMap(collection, iteratee2) {
                  return baseFlatten(map(collection, iteratee2), 1);
                }
                function flatMapDeep(collection, iteratee2) {
                  return baseFlatten(map(collection, iteratee2), INFINITY);
                }
                function flatMapDepth(collection, iteratee2, depth) {
                  depth = depth === undefined2 ? 1 : toInteger(depth);
                  return baseFlatten(map(collection, iteratee2), depth);
                }
                function forEach(collection, iteratee2) {
                  var func = isArray2(collection) ? arrayEach : baseEach;
                  return func(collection, getIteratee(iteratee2, 3));
                }
                function forEachRight(collection, iteratee2) {
                  var func = isArray2(collection) ? arrayEachRight : baseEachRight;
                  return func(collection, getIteratee(iteratee2, 3));
                }
                var groupBy = createAggregator(function(result2, value, key) {
                  if (hasOwnProperty.call(result2, key)) {
                    result2[key].push(value);
                  } else {
                    baseAssignValue(result2, key, [value]);
                  }
                });
                function includes(collection, value, fromIndex, guard) {
                  collection = isArrayLike(collection) ? collection : values(collection);
                  fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
                  var length = collection.length;
                  if (fromIndex < 0) {
                    fromIndex = nativeMax(length + fromIndex, 0);
                  }
                  return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
                }
                var invokeMap = baseRest(function(collection, path, args) {
                  var index = -1, isFunc = typeof path == "function", result2 = isArrayLike(collection) ? Array2(collection.length) : [];
                  baseEach(collection, function(value) {
                    result2[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
                  });
                  return result2;
                });
                var keyBy = createAggregator(function(result2, value, key) {
                  baseAssignValue(result2, key, value);
                });
                function map(collection, iteratee2) {
                  var func = isArray2(collection) ? arrayMap : baseMap;
                  return func(collection, getIteratee(iteratee2, 3));
                }
                function orderBy(collection, iteratees, orders, guard) {
                  if (collection == null) {
                    return [];
                  }
                  if (!isArray2(iteratees)) {
                    iteratees = iteratees == null ? [] : [iteratees];
                  }
                  orders = guard ? undefined2 : orders;
                  if (!isArray2(orders)) {
                    orders = orders == null ? [] : [orders];
                  }
                  return baseOrderBy(collection, iteratees, orders);
                }
                var partition = createAggregator(function(result2, value, key) {
                  result2[key ? 0 : 1].push(value);
                }, function() {
                  return [[], []];
                });
                function reduce(collection, iteratee2, accumulator) {
                  var func = isArray2(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
                  return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
                }
                function reduceRight(collection, iteratee2, accumulator) {
                  var func = isArray2(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
                  return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
                }
                function reject(collection, predicate) {
                  var func = isArray2(collection) ? arrayFilter : baseFilter;
                  return func(collection, negate(getIteratee(predicate, 3)));
                }
                function sample(collection) {
                  var func = isArray2(collection) ? arraySample : baseSample;
                  return func(collection);
                }
                function sampleSize(collection, n, guard) {
                  if (guard ? isIterateeCall(collection, n, guard) : n === undefined2) {
                    n = 1;
                  } else {
                    n = toInteger(n);
                  }
                  var func = isArray2(collection) ? arraySampleSize : baseSampleSize;
                  return func(collection, n);
                }
                function shuffle(collection) {
                  var func = isArray2(collection) ? arrayShuffle : baseShuffle;
                  return func(collection);
                }
                function size(collection) {
                  if (collection == null) {
                    return 0;
                  }
                  if (isArrayLike(collection)) {
                    return isString(collection) ? stringSize(collection) : collection.length;
                  }
                  var tag = getTag(collection);
                  if (tag == mapTag || tag == setTag) {
                    return collection.size;
                  }
                  return baseKeys(collection).length;
                }
                function some(collection, predicate, guard) {
                  var func = isArray2(collection) ? arraySome : baseSome;
                  if (guard && isIterateeCall(collection, predicate, guard)) {
                    predicate = undefined2;
                  }
                  return func(collection, getIteratee(predicate, 3));
                }
                var sortBy = baseRest(function(collection, iteratees) {
                  if (collection == null) {
                    return [];
                  }
                  var length = iteratees.length;
                  if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
                    iteratees = [];
                  } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
                    iteratees = [iteratees[0]];
                  }
                  return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
                });
                var now = ctxNow || function() {
                  return root.Date.now();
                };
                function after(n, func) {
                  if (typeof func != "function") {
                    throw new TypeError2(FUNC_ERROR_TEXT);
                  }
                  n = toInteger(n);
                  return function() {
                    if (--n < 1) {
                      return func.apply(this, arguments);
                    }
                  };
                }
                function ary(func, n, guard) {
                  n = guard ? undefined2 : n;
                  n = func && n == null ? func.length : n;
                  return createWrap(func, WRAP_ARY_FLAG, undefined2, undefined2, undefined2, undefined2, n);
                }
                function before(n, func) {
                  var result2;
                  if (typeof func != "function") {
                    throw new TypeError2(FUNC_ERROR_TEXT);
                  }
                  n = toInteger(n);
                  return function() {
                    if (--n > 0) {
                      result2 = func.apply(this, arguments);
                    }
                    if (n <= 1) {
                      func = undefined2;
                    }
                    return result2;
                  };
                }
                var bind = baseRest(function(func, thisArg, partials) {
                  var bitmask = WRAP_BIND_FLAG;
                  if (partials.length) {
                    var holders = replaceHolders(partials, getHolder(bind));
                    bitmask |= WRAP_PARTIAL_FLAG;
                  }
                  return createWrap(func, bitmask, thisArg, partials, holders);
                });
                var bindKey = baseRest(function(object, key, partials) {
                  var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
                  if (partials.length) {
                    var holders = replaceHolders(partials, getHolder(bindKey));
                    bitmask |= WRAP_PARTIAL_FLAG;
                  }
                  return createWrap(key, bitmask, object, partials, holders);
                });
                function curry(func, arity, guard) {
                  arity = guard ? undefined2 : arity;
                  var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
                  result2.placeholder = curry.placeholder;
                  return result2;
                }
                function curryRight(func, arity, guard) {
                  arity = guard ? undefined2 : arity;
                  var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
                  result2.placeholder = curryRight.placeholder;
                  return result2;
                }
                function debounce(func, wait, options) {
                  var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
                  if (typeof func != "function") {
                    throw new TypeError2(FUNC_ERROR_TEXT);
                  }
                  wait = toNumber(wait) || 0;
                  if (isObject(options)) {
                    leading = !!options.leading;
                    maxing = "maxWait" in options;
                    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
                    trailing = "trailing" in options ? !!options.trailing : trailing;
                  }
                  function invokeFunc(time) {
                    var args = lastArgs, thisArg = lastThis;
                    lastArgs = lastThis = undefined2;
                    lastInvokeTime = time;
                    result2 = func.apply(thisArg, args);
                    return result2;
                  }
                  function leadingEdge(time) {
                    lastInvokeTime = time;
                    timerId = setTimeout2(timerExpired, wait);
                    return leading ? invokeFunc(time) : result2;
                  }
                  function remainingWait(time) {
                    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
                    return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
                  }
                  function shouldInvoke(time) {
                    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
                    return lastCallTime === undefined2 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
                  }
                  function timerExpired() {
                    var time = now();
                    if (shouldInvoke(time)) {
                      return trailingEdge(time);
                    }
                    timerId = setTimeout2(timerExpired, remainingWait(time));
                  }
                  function trailingEdge(time) {
                    timerId = undefined2;
                    if (trailing && lastArgs) {
                      return invokeFunc(time);
                    }
                    lastArgs = lastThis = undefined2;
                    return result2;
                  }
                  function cancel() {
                    if (timerId !== undefined2) {
                      clearTimeout2(timerId);
                    }
                    lastInvokeTime = 0;
                    lastArgs = lastCallTime = lastThis = timerId = undefined2;
                  }
                  function flush() {
                    return timerId === undefined2 ? result2 : trailingEdge(now());
                  }
                  function debounced() {
                    var time = now(), isInvoking = shouldInvoke(time);
                    lastArgs = arguments;
                    lastThis = this;
                    lastCallTime = time;
                    if (isInvoking) {
                      if (timerId === undefined2) {
                        return leadingEdge(lastCallTime);
                      }
                      if (maxing) {
                        clearTimeout2(timerId);
                        timerId = setTimeout2(timerExpired, wait);
                        return invokeFunc(lastCallTime);
                      }
                    }
                    if (timerId === undefined2) {
                      timerId = setTimeout2(timerExpired, wait);
                    }
                    return result2;
                  }
                  debounced.cancel = cancel;
                  debounced.flush = flush;
                  return debounced;
                }
                var defer = baseRest(function(func, args) {
                  return baseDelay(func, 1, args);
                });
                var delay = baseRest(function(func, wait, args) {
                  return baseDelay(func, toNumber(wait) || 0, args);
                });
                function flip(func) {
                  return createWrap(func, WRAP_FLIP_FLAG);
                }
                function memoize(func, resolver) {
                  if (typeof func != "function" || resolver != null && typeof resolver != "function") {
                    throw new TypeError2(FUNC_ERROR_TEXT);
                  }
                  var memoized = function() {
                    var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
                    if (cache.has(key)) {
                      return cache.get(key);
                    }
                    var result2 = func.apply(this, args);
                    memoized.cache = cache.set(key, result2) || cache;
                    return result2;
                  };
                  memoized.cache = new (memoize.Cache || MapCache)();
                  return memoized;
                }
                memoize.Cache = MapCache;
                function negate(predicate) {
                  if (typeof predicate != "function") {
                    throw new TypeError2(FUNC_ERROR_TEXT);
                  }
                  return function() {
                    var args = arguments;
                    switch (args.length) {
                      case 0:
                        return !predicate.call(this);
                      case 1:
                        return !predicate.call(this, args[0]);
                      case 2:
                        return !predicate.call(this, args[0], args[1]);
                      case 3:
                        return !predicate.call(this, args[0], args[1], args[2]);
                    }
                    return !predicate.apply(this, args);
                  };
                }
                function once(func) {
                  return before(2, func);
                }
                var overArgs = castRest(function(func, transforms) {
                  transforms = transforms.length == 1 && isArray2(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
                  var funcsLength = transforms.length;
                  return baseRest(function(args) {
                    var index = -1, length = nativeMin(args.length, funcsLength);
                    while (++index < length) {
                      args[index] = transforms[index].call(this, args[index]);
                    }
                    return apply(func, this, args);
                  });
                });
                var partial = baseRest(function(func, partials) {
                  var holders = replaceHolders(partials, getHolder(partial));
                  return createWrap(func, WRAP_PARTIAL_FLAG, undefined2, partials, holders);
                });
                var partialRight = baseRest(function(func, partials) {
                  var holders = replaceHolders(partials, getHolder(partialRight));
                  return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined2, partials, holders);
                });
                var rearg = flatRest(function(func, indexes) {
                  return createWrap(func, WRAP_REARG_FLAG, undefined2, undefined2, undefined2, indexes);
                });
                function rest(func, start) {
                  if (typeof func != "function") {
                    throw new TypeError2(FUNC_ERROR_TEXT);
                  }
                  start = start === undefined2 ? start : toInteger(start);
                  return baseRest(func, start);
                }
                function spread(func, start) {
                  if (typeof func != "function") {
                    throw new TypeError2(FUNC_ERROR_TEXT);
                  }
                  start = start == null ? 0 : nativeMax(toInteger(start), 0);
                  return baseRest(function(args) {
                    var array = args[start], otherArgs = castSlice(args, 0, start);
                    if (array) {
                      arrayPush(otherArgs, array);
                    }
                    return apply(func, this, otherArgs);
                  });
                }
                function throttle(func, wait, options) {
                  var leading = true, trailing = true;
                  if (typeof func != "function") {
                    throw new TypeError2(FUNC_ERROR_TEXT);
                  }
                  if (isObject(options)) {
                    leading = "leading" in options ? !!options.leading : leading;
                    trailing = "trailing" in options ? !!options.trailing : trailing;
                  }
                  return debounce(func, wait, {
                    "leading": leading,
                    "maxWait": wait,
                    "trailing": trailing
                  });
                }
                function unary(func) {
                  return ary(func, 1);
                }
                function wrap(value, wrapper) {
                  return partial(castFunction(wrapper), value);
                }
                function castArray() {
                  if (!arguments.length) {
                    return [];
                  }
                  var value = arguments[0];
                  return isArray2(value) ? value : [value];
                }
                function clone(value) {
                  return baseClone(value, CLONE_SYMBOLS_FLAG);
                }
                function cloneWith(value, customizer) {
                  customizer = typeof customizer == "function" ? customizer : undefined2;
                  return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
                }
                function cloneDeep(value) {
                  return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
                }
                function cloneDeepWith(value, customizer) {
                  customizer = typeof customizer == "function" ? customizer : undefined2;
                  return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
                }
                function conformsTo(object, source) {
                  return source == null || baseConformsTo(object, source, keys(source));
                }
                function eq(value, other) {
                  return value === other || value !== value && other !== other;
                }
                var gt = createRelationalOperation(baseGt);
                var gte = createRelationalOperation(function(value, other) {
                  return value >= other;
                });
                var isArguments = baseIsArguments(/* @__PURE__ */ function() {
                  return arguments;
                }()) ? baseIsArguments : function(value) {
                  return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
                };
                var isArray2 = Array2.isArray;
                var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
                function isArrayLike(value) {
                  return value != null && isLength(value.length) && !isFunction(value);
                }
                function isArrayLikeObject(value) {
                  return isObjectLike(value) && isArrayLike(value);
                }
                function isBoolean(value) {
                  return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
                }
                var isBuffer = nativeIsBuffer || stubFalse;
                var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
                function isElement(value) {
                  return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
                }
                function isEmpty(value) {
                  if (value == null) {
                    return true;
                  }
                  if (isArrayLike(value) && (isArray2(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
                    return !value.length;
                  }
                  var tag = getTag(value);
                  if (tag == mapTag || tag == setTag) {
                    return !value.size;
                  }
                  if (isPrototype(value)) {
                    return !baseKeys(value).length;
                  }
                  for (var key in value) {
                    if (hasOwnProperty.call(value, key)) {
                      return false;
                    }
                  }
                  return true;
                }
                function isEqual(value, other) {
                  return baseIsEqual(value, other);
                }
                function isEqualWith(value, other, customizer) {
                  customizer = typeof customizer == "function" ? customizer : undefined2;
                  var result2 = customizer ? customizer(value, other) : undefined2;
                  return result2 === undefined2 ? baseIsEqual(value, other, undefined2, customizer) : !!result2;
                }
                function isError(value) {
                  if (!isObjectLike(value)) {
                    return false;
                  }
                  var tag = baseGetTag(value);
                  return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject(value);
                }
                function isFinite(value) {
                  return typeof value == "number" && nativeIsFinite(value);
                }
                function isFunction(value) {
                  if (!isObject(value)) {
                    return false;
                  }
                  var tag = baseGetTag(value);
                  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
                }
                function isInteger(value) {
                  return typeof value == "number" && value == toInteger(value);
                }
                function isLength(value) {
                  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
                }
                function isObject(value) {
                  var type = typeof value;
                  return value != null && (type == "object" || type == "function");
                }
                function isObjectLike(value) {
                  return value != null && typeof value == "object";
                }
                var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
                function isMatch(object, source) {
                  return object === source || baseIsMatch(object, source, getMatchData(source));
                }
                function isMatchWith(object, source, customizer) {
                  customizer = typeof customizer == "function" ? customizer : undefined2;
                  return baseIsMatch(object, source, getMatchData(source), customizer);
                }
                function isNaN2(value) {
                  return isNumber(value) && value != +value;
                }
                function isNative(value) {
                  if (isMaskable(value)) {
                    throw new Error2(CORE_ERROR_TEXT);
                  }
                  return baseIsNative(value);
                }
                function isNull(value) {
                  return value === null;
                }
                function isNil(value) {
                  return value == null;
                }
                function isNumber(value) {
                  return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
                }
                function isPlainObject(value) {
                  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
                    return false;
                  }
                  var proto = getPrototype(value);
                  if (proto === null) {
                    return true;
                  }
                  var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
                  return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
                }
                var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
                function isSafeInteger(value) {
                  return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
                }
                var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
                function isString(value) {
                  return typeof value == "string" || !isArray2(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
                }
                function isSymbol(value) {
                  return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
                }
                var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
                function isUndefined(value) {
                  return value === undefined2;
                }
                function isWeakMap(value) {
                  return isObjectLike(value) && getTag(value) == weakMapTag;
                }
                function isWeakSet(value) {
                  return isObjectLike(value) && baseGetTag(value) == weakSetTag;
                }
                var lt = createRelationalOperation(baseLt);
                var lte = createRelationalOperation(function(value, other) {
                  return value <= other;
                });
                function toArray(value) {
                  if (!value) {
                    return [];
                  }
                  if (isArrayLike(value)) {
                    return isString(value) ? stringToArray(value) : copyArray(value);
                  }
                  if (symIterator && value[symIterator]) {
                    return iteratorToArray(value[symIterator]());
                  }
                  var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
                  return func(value);
                }
                function toFinite(value) {
                  if (!value) {
                    return value === 0 ? value : 0;
                  }
                  value = toNumber(value);
                  if (value === INFINITY || value === -INFINITY) {
                    var sign = value < 0 ? -1 : 1;
                    return sign * MAX_INTEGER;
                  }
                  return value === value ? value : 0;
                }
                function toInteger(value) {
                  var result2 = toFinite(value), remainder = result2 % 1;
                  return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
                }
                function toLength(value) {
                  return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
                }
                function toNumber(value) {
                  if (typeof value == "number") {
                    return value;
                  }
                  if (isSymbol(value)) {
                    return NAN;
                  }
                  if (isObject(value)) {
                    var other = typeof value.valueOf == "function" ? value.valueOf() : value;
                    value = isObject(other) ? other + "" : other;
                  }
                  if (typeof value != "string") {
                    return value === 0 ? value : +value;
                  }
                  value = baseTrim(value);
                  var isBinary = reIsBinary.test(value);
                  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
                }
                function toPlainObject(value) {
                  return copyObject(value, keysIn(value));
                }
                function toSafeInteger(value) {
                  return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
                }
                function toString(value) {
                  return value == null ? "" : baseToString(value);
                }
                var assign = createAssigner(function(object, source) {
                  if (isPrototype(source) || isArrayLike(source)) {
                    copyObject(source, keys(source), object);
                    return;
                  }
                  for (var key in source) {
                    if (hasOwnProperty.call(source, key)) {
                      assignValue(object, key, source[key]);
                    }
                  }
                });
                var assignIn = createAssigner(function(object, source) {
                  copyObject(source, keysIn(source), object);
                });
                var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
                  copyObject(source, keysIn(source), object, customizer);
                });
                var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
                  copyObject(source, keys(source), object, customizer);
                });
                var at = flatRest(baseAt);
                function create(prototype, properties) {
                  var result2 = baseCreate(prototype);
                  return properties == null ? result2 : baseAssign(result2, properties);
                }
                var defaults = baseRest(function(object, sources) {
                  object = Object2(object);
                  var index = -1;
                  var length = sources.length;
                  var guard = length > 2 ? sources[2] : undefined2;
                  if (guard && isIterateeCall(sources[0], sources[1], guard)) {
                    length = 1;
                  }
                  while (++index < length) {
                    var source = sources[index];
                    var props = keysIn(source);
                    var propsIndex = -1;
                    var propsLength = props.length;
                    while (++propsIndex < propsLength) {
                      var key = props[propsIndex];
                      var value = object[key];
                      if (value === undefined2 || eq(value, objectProto[key]) && !hasOwnProperty.call(object, key)) {
                        object[key] = source[key];
                      }
                    }
                  }
                  return object;
                });
                var defaultsDeep = baseRest(function(args) {
                  args.push(undefined2, customDefaultsMerge);
                  return apply(mergeWith, undefined2, args);
                });
                function findKey(object, predicate) {
                  return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
                }
                function findLastKey(object, predicate) {
                  return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
                }
                function forIn(object, iteratee2) {
                  return object == null ? object : baseFor(object, getIteratee(iteratee2, 3), keysIn);
                }
                function forInRight(object, iteratee2) {
                  return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn);
                }
                function forOwn(object, iteratee2) {
                  return object && baseForOwn(object, getIteratee(iteratee2, 3));
                }
                function forOwnRight(object, iteratee2) {
                  return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
                }
                function functions(object) {
                  return object == null ? [] : baseFunctions(object, keys(object));
                }
                function functionsIn(object) {
                  return object == null ? [] : baseFunctions(object, keysIn(object));
                }
                function get(object, path, defaultValue) {
                  var result2 = object == null ? undefined2 : baseGet(object, path);
                  return result2 === undefined2 ? defaultValue : result2;
                }
                function has(object, path) {
                  return object != null && hasPath(object, path, baseHas);
                }
                function hasIn(object, path) {
                  return object != null && hasPath(object, path, baseHasIn);
                }
                var invert = createInverter(function(result2, value, key) {
                  if (value != null && typeof value.toString != "function") {
                    value = nativeObjectToString.call(value);
                  }
                  result2[value] = key;
                }, constant(identity));
                var invertBy = createInverter(function(result2, value, key) {
                  if (value != null && typeof value.toString != "function") {
                    value = nativeObjectToString.call(value);
                  }
                  if (hasOwnProperty.call(result2, value)) {
                    result2[value].push(key);
                  } else {
                    result2[value] = [key];
                  }
                }, getIteratee);
                var invoke = baseRest(baseInvoke);
                function keys(object) {
                  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
                }
                function keysIn(object) {
                  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
                }
                function mapKeys(object, iteratee2) {
                  var result2 = {};
                  iteratee2 = getIteratee(iteratee2, 3);
                  baseForOwn(object, function(value, key, object2) {
                    baseAssignValue(result2, iteratee2(value, key, object2), value);
                  });
                  return result2;
                }
                function mapValues(object, iteratee2) {
                  var result2 = {};
                  iteratee2 = getIteratee(iteratee2, 3);
                  baseForOwn(object, function(value, key, object2) {
                    baseAssignValue(result2, key, iteratee2(value, key, object2));
                  });
                  return result2;
                }
                var merge = createAssigner(function(object, source, srcIndex) {
                  baseMerge(object, source, srcIndex);
                });
                var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
                  baseMerge(object, source, srcIndex, customizer);
                });
                var omit = flatRest(function(object, paths) {
                  var result2 = {};
                  if (object == null) {
                    return result2;
                  }
                  var isDeep = false;
                  paths = arrayMap(paths, function(path) {
                    path = castPath(path, object);
                    isDeep || (isDeep = path.length > 1);
                    return path;
                  });
                  copyObject(object, getAllKeysIn(object), result2);
                  if (isDeep) {
                    result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
                  }
                  var length = paths.length;
                  while (length--) {
                    baseUnset(result2, paths[length]);
                  }
                  return result2;
                });
                function omitBy(object, predicate) {
                  return pickBy(object, negate(getIteratee(predicate)));
                }
                var pick = flatRest(function(object, paths) {
                  return object == null ? {} : basePick(object, paths);
                });
                function pickBy(object, predicate) {
                  if (object == null) {
                    return {};
                  }
                  var props = arrayMap(getAllKeysIn(object), function(prop) {
                    return [prop];
                  });
                  predicate = getIteratee(predicate);
                  return basePickBy(object, props, function(value, path) {
                    return predicate(value, path[0]);
                  });
                }
                function result(object, path, defaultValue) {
                  path = castPath(path, object);
                  var index = -1, length = path.length;
                  if (!length) {
                    length = 1;
                    object = undefined2;
                  }
                  while (++index < length) {
                    var value = object == null ? undefined2 : object[toKey(path[index])];
                    if (value === undefined2) {
                      index = length;
                      value = defaultValue;
                    }
                    object = isFunction(value) ? value.call(object) : value;
                  }
                  return object;
                }
                function set(object, path, value) {
                  return object == null ? object : baseSet(object, path, value);
                }
                function setWith(object, path, value, customizer) {
                  customizer = typeof customizer == "function" ? customizer : undefined2;
                  return object == null ? object : baseSet(object, path, value, customizer);
                }
                var toPairs = createToPairs(keys);
                var toPairsIn = createToPairs(keysIn);
                function transform(object, iteratee2, accumulator) {
                  var isArr = isArray2(object), isArrLike = isArr || isBuffer(object) || isTypedArray(object);
                  iteratee2 = getIteratee(iteratee2, 4);
                  if (accumulator == null) {
                    var Ctor = object && object.constructor;
                    if (isArrLike) {
                      accumulator = isArr ? new Ctor() : [];
                    } else if (isObject(object)) {
                      accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
                    } else {
                      accumulator = {};
                    }
                  }
                  (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object2) {
                    return iteratee2(accumulator, value, index, object2);
                  });
                  return accumulator;
                }
                function unset(object, path) {
                  return object == null ? true : baseUnset(object, path);
                }
                function update(object, path, updater) {
                  return object == null ? object : baseUpdate(object, path, castFunction(updater));
                }
                function updateWith(object, path, updater, customizer) {
                  customizer = typeof customizer == "function" ? customizer : undefined2;
                  return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
                }
                function values(object) {
                  return object == null ? [] : baseValues(object, keys(object));
                }
                function valuesIn(object) {
                  return object == null ? [] : baseValues(object, keysIn(object));
                }
                function clamp(number, lower, upper) {
                  if (upper === undefined2) {
                    upper = lower;
                    lower = undefined2;
                  }
                  if (upper !== undefined2) {
                    upper = toNumber(upper);
                    upper = upper === upper ? upper : 0;
                  }
                  if (lower !== undefined2) {
                    lower = toNumber(lower);
                    lower = lower === lower ? lower : 0;
                  }
                  return baseClamp(toNumber(number), lower, upper);
                }
                function inRange(number, start, end) {
                  start = toFinite(start);
                  if (end === undefined2) {
                    end = start;
                    start = 0;
                  } else {
                    end = toFinite(end);
                  }
                  number = toNumber(number);
                  return baseInRange(number, start, end);
                }
                function random(lower, upper, floating) {
                  if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
                    upper = floating = undefined2;
                  }
                  if (floating === undefined2) {
                    if (typeof upper == "boolean") {
                      floating = upper;
                      upper = undefined2;
                    } else if (typeof lower == "boolean") {
                      floating = lower;
                      lower = undefined2;
                    }
                  }
                  if (lower === undefined2 && upper === undefined2) {
                    lower = 0;
                    upper = 1;
                  } else {
                    lower = toFinite(lower);
                    if (upper === undefined2) {
                      upper = lower;
                      lower = 0;
                    } else {
                      upper = toFinite(upper);
                    }
                  }
                  if (lower > upper) {
                    var temp = lower;
                    lower = upper;
                    upper = temp;
                  }
                  if (floating || lower % 1 || upper % 1) {
                    var rand = nativeRandom();
                    return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
                  }
                  return baseRandom(lower, upper);
                }
                var camelCase = createCompounder(function(result2, word, index) {
                  word = word.toLowerCase();
                  return result2 + (index ? capitalize(word) : word);
                });
                function capitalize(string) {
                  return upperFirst(toString(string).toLowerCase());
                }
                function deburr(string) {
                  string = toString(string);
                  return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
                }
                function endsWith(string, target, position) {
                  string = toString(string);
                  target = baseToString(target);
                  var length = string.length;
                  position = position === undefined2 ? length : baseClamp(toInteger(position), 0, length);
                  var end = position;
                  position -= target.length;
                  return position >= 0 && string.slice(position, end) == target;
                }
                function escape(string) {
                  string = toString(string);
                  return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
                }
                function escapeRegExp(string) {
                  string = toString(string);
                  return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
                }
                var kebabCase = createCompounder(function(result2, word, index) {
                  return result2 + (index ? "-" : "") + word.toLowerCase();
                });
                var lowerCase = createCompounder(function(result2, word, index) {
                  return result2 + (index ? " " : "") + word.toLowerCase();
                });
                var lowerFirst = createCaseFirst("toLowerCase");
                function pad(string, length, chars) {
                  string = toString(string);
                  length = toInteger(length);
                  var strLength = length ? stringSize(string) : 0;
                  if (!length || strLength >= length) {
                    return string;
                  }
                  var mid = (length - strLength) / 2;
                  return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
                }
                function padEnd(string, length, chars) {
                  string = toString(string);
                  length = toInteger(length);
                  var strLength = length ? stringSize(string) : 0;
                  return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
                }
                function padStart(string, length, chars) {
                  string = toString(string);
                  length = toInteger(length);
                  var strLength = length ? stringSize(string) : 0;
                  return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
                }
                function parseInt2(string, radix, guard) {
                  if (guard || radix == null) {
                    radix = 0;
                  } else if (radix) {
                    radix = +radix;
                  }
                  return nativeParseInt(toString(string).replace(reTrimStart, ""), radix || 0);
                }
                function repeat(string, n, guard) {
                  if (guard ? isIterateeCall(string, n, guard) : n === undefined2) {
                    n = 1;
                  } else {
                    n = toInteger(n);
                  }
                  return baseRepeat(toString(string), n);
                }
                function replace() {
                  var args = arguments, string = toString(args[0]);
                  return args.length < 3 ? string : string.replace(args[1], args[2]);
                }
                var snakeCase = createCompounder(function(result2, word, index) {
                  return result2 + (index ? "_" : "") + word.toLowerCase();
                });
                function split(string, separator, limit) {
                  if (limit && typeof limit != "number" && isIterateeCall(string, separator, limit)) {
                    separator = limit = undefined2;
                  }
                  limit = limit === undefined2 ? MAX_ARRAY_LENGTH : limit >>> 0;
                  if (!limit) {
                    return [];
                  }
                  string = toString(string);
                  if (string && (typeof separator == "string" || separator != null && !isRegExp(separator))) {
                    separator = baseToString(separator);
                    if (!separator && hasUnicode(string)) {
                      return castSlice(stringToArray(string), 0, limit);
                    }
                  }
                  return string.split(separator, limit);
                }
                var startCase = createCompounder(function(result2, word, index) {
                  return result2 + (index ? " " : "") + upperFirst(word);
                });
                function startsWith(string, target, position) {
                  string = toString(string);
                  position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length);
                  target = baseToString(target);
                  return string.slice(position, position + target.length) == target;
                }
                function template(string, options, guard) {
                  var settings = lodash.templateSettings;
                  if (guard && isIterateeCall(string, options, guard)) {
                    options = undefined2;
                  }
                  string = toString(string);
                  options = assignInWith({}, options, settings, customDefaultsAssignIn);
                  var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
                  var isEscaping, isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
                  var reDelimiters = RegExp2(
                    (options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$",
                    "g"
                  );
                  var sourceURL = "//# sourceURL=" + (hasOwnProperty.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
                  string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
                    interpolateValue || (interpolateValue = esTemplateValue);
                    source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);
                    if (escapeValue) {
                      isEscaping = true;
                      source += "' +\n__e(" + escapeValue + ") +\n'";
                    }
                    if (evaluateValue) {
                      isEvaluating = true;
                      source += "';\n" + evaluateValue + ";\n__p += '";
                    }
                    if (interpolateValue) {
                      source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
                    }
                    index = offset + match.length;
                    return match;
                  });
                  source += "';\n";
                  var variable = hasOwnProperty.call(options, "variable") && options.variable;
                  if (!variable) {
                    source = "with (obj) {\n" + source + "\n}\n";
                  } else if (reForbiddenIdentifierChars.test(variable)) {
                    throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
                  }
                  source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
                  source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
                  var result2 = attempt(function() {
                    return Function2(importsKeys, sourceURL + "return " + source).apply(undefined2, importsValues);
                  });
                  result2.source = source;
                  if (isError(result2)) {
                    throw result2;
                  }
                  return result2;
                }
                function toLower(value) {
                  return toString(value).toLowerCase();
                }
                function toUpper(value) {
                  return toString(value).toUpperCase();
                }
                function trim(string, chars, guard) {
                  string = toString(string);
                  if (string && (guard || chars === undefined2)) {
                    return baseTrim(string);
                  }
                  if (!string || !(chars = baseToString(chars))) {
                    return string;
                  }
                  var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
                  return castSlice(strSymbols, start, end).join("");
                }
                function trimEnd(string, chars, guard) {
                  string = toString(string);
                  if (string && (guard || chars === undefined2)) {
                    return string.slice(0, trimmedEndIndex(string) + 1);
                  }
                  if (!string || !(chars = baseToString(chars))) {
                    return string;
                  }
                  var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
                  return castSlice(strSymbols, 0, end).join("");
                }
                function trimStart(string, chars, guard) {
                  string = toString(string);
                  if (string && (guard || chars === undefined2)) {
                    return string.replace(reTrimStart, "");
                  }
                  if (!string || !(chars = baseToString(chars))) {
                    return string;
                  }
                  var strSymbols = stringToArray(string), start = charsStartIndex(strSymbols, stringToArray(chars));
                  return castSlice(strSymbols, start).join("");
                }
                function truncate(string, options) {
                  var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
                  if (isObject(options)) {
                    var separator = "separator" in options ? options.separator : separator;
                    length = "length" in options ? toInteger(options.length) : length;
                    omission = "omission" in options ? baseToString(options.omission) : omission;
                  }
                  string = toString(string);
                  var strLength = string.length;
                  if (hasUnicode(string)) {
                    var strSymbols = stringToArray(string);
                    strLength = strSymbols.length;
                  }
                  if (length >= strLength) {
                    return string;
                  }
                  var end = length - stringSize(omission);
                  if (end < 1) {
                    return omission;
                  }
                  var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string.slice(0, end);
                  if (separator === undefined2) {
                    return result2 + omission;
                  }
                  if (strSymbols) {
                    end += result2.length - end;
                  }
                  if (isRegExp(separator)) {
                    if (string.slice(end).search(separator)) {
                      var match, substring = result2;
                      if (!separator.global) {
                        separator = RegExp2(separator.source, toString(reFlags.exec(separator)) + "g");
                      }
                      separator.lastIndex = 0;
                      while (match = separator.exec(substring)) {
                        var newEnd = match.index;
                      }
                      result2 = result2.slice(0, newEnd === undefined2 ? end : newEnd);
                    }
                  } else if (string.indexOf(baseToString(separator), end) != end) {
                    var index = result2.lastIndexOf(separator);
                    if (index > -1) {
                      result2 = result2.slice(0, index);
                    }
                  }
                  return result2 + omission;
                }
                function unescape2(string) {
                  string = toString(string);
                  return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
                }
                var upperCase = createCompounder(function(result2, word, index) {
                  return result2 + (index ? " " : "") + word.toUpperCase();
                });
                var upperFirst = createCaseFirst("toUpperCase");
                function words(string, pattern, guard) {
                  string = toString(string);
                  pattern = guard ? undefined2 : pattern;
                  if (pattern === undefined2) {
                    return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
                  }
                  return string.match(pattern) || [];
                }
                var attempt = baseRest(function(func, args) {
                  try {
                    return apply(func, undefined2, args);
                  } catch (e) {
                    return isError(e) ? e : new Error2(e);
                  }
                });
                var bindAll = flatRest(function(object, methodNames) {
                  arrayEach(methodNames, function(key) {
                    key = toKey(key);
                    baseAssignValue(object, key, bind(object[key], object));
                  });
                  return object;
                });
                function cond(pairs) {
                  var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
                  pairs = !length ? [] : arrayMap(pairs, function(pair) {
                    if (typeof pair[1] != "function") {
                      throw new TypeError2(FUNC_ERROR_TEXT);
                    }
                    return [toIteratee(pair[0]), pair[1]];
                  });
                  return baseRest(function(args) {
                    var index = -1;
                    while (++index < length) {
                      var pair = pairs[index];
                      if (apply(pair[0], this, args)) {
                        return apply(pair[1], this, args);
                      }
                    }
                  });
                }
                function conforms(source) {
                  return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
                }
                function constant(value) {
                  return function() {
                    return value;
                  };
                }
                function defaultTo(value, defaultValue) {
                  return value == null || value !== value ? defaultValue : value;
                }
                var flow = createFlow();
                var flowRight = createFlow(true);
                function identity(value) {
                  return value;
                }
                function iteratee(func) {
                  return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
                }
                function matches(source) {
                  return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
                }
                function matchesProperty(path, srcValue) {
                  return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
                }
                var method = baseRest(function(path, args) {
                  return function(object) {
                    return baseInvoke(object, path, args);
                  };
                });
                var methodOf = baseRest(function(object, args) {
                  return function(path) {
                    return baseInvoke(object, path, args);
                  };
                });
                function mixin(object, source, options) {
                  var props = keys(source), methodNames = baseFunctions(source, props);
                  if (options == null && !(isObject(source) && (methodNames.length || !props.length))) {
                    options = source;
                    source = object;
                    object = this;
                    methodNames = baseFunctions(source, keys(source));
                  }
                  var chain2 = !(isObject(options) && "chain" in options) || !!options.chain, isFunc = isFunction(object);
                  arrayEach(methodNames, function(methodName) {
                    var func = source[methodName];
                    object[methodName] = func;
                    if (isFunc) {
                      object.prototype[methodName] = function() {
                        var chainAll = this.__chain__;
                        if (chain2 || chainAll) {
                          var result2 = object(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);
                          actions.push({ "func": func, "args": arguments, "thisArg": object });
                          result2.__chain__ = chainAll;
                          return result2;
                        }
                        return func.apply(object, arrayPush([this.value()], arguments));
                      };
                    }
                  });
                  return object;
                }
                function noConflict() {
                  if (root._ === this) {
                    root._ = oldDash;
                  }
                  return this;
                }
                function noop() {
                }
                function nthArg(n) {
                  n = toInteger(n);
                  return baseRest(function(args) {
                    return baseNth(args, n);
                  });
                }
                var over = createOver(arrayMap);
                var overEvery = createOver(arrayEvery);
                var overSome = createOver(arraySome);
                function property(path) {
                  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
                }
                function propertyOf(object) {
                  return function(path) {
                    return object == null ? undefined2 : baseGet(object, path);
                  };
                }
                var range = createRange();
                var rangeRight = createRange(true);
                function stubArray() {
                  return [];
                }
                function stubFalse() {
                  return false;
                }
                function stubObject() {
                  return {};
                }
                function stubString() {
                  return "";
                }
                function stubTrue() {
                  return true;
                }
                function times(n, iteratee2) {
                  n = toInteger(n);
                  if (n < 1 || n > MAX_SAFE_INTEGER) {
                    return [];
                  }
                  var index = MAX_ARRAY_LENGTH, length = nativeMin(n, MAX_ARRAY_LENGTH);
                  iteratee2 = getIteratee(iteratee2);
                  n -= MAX_ARRAY_LENGTH;
                  var result2 = baseTimes(length, iteratee2);
                  while (++index < n) {
                    iteratee2(index);
                  }
                  return result2;
                }
                function toPath(value) {
                  if (isArray2(value)) {
                    return arrayMap(value, toKey);
                  }
                  return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
                }
                function uniqueId(prefix) {
                  var id = ++idCounter;
                  return toString(prefix) + id;
                }
                var add = createMathOperation(function(augend, addend) {
                  return augend + addend;
                }, 0);
                var ceil = createRound("ceil");
                var divide = createMathOperation(function(dividend, divisor) {
                  return dividend / divisor;
                }, 1);
                var floor = createRound("floor");
                function max(array) {
                  return array && array.length ? baseExtremum(array, identity, baseGt) : undefined2;
                }
                function maxBy(array, iteratee2) {
                  return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseGt) : undefined2;
                }
                function mean(array) {
                  return baseMean(array, identity);
                }
                function meanBy(array, iteratee2) {
                  return baseMean(array, getIteratee(iteratee2, 2));
                }
                function min(array) {
                  return array && array.length ? baseExtremum(array, identity, baseLt) : undefined2;
                }
                function minBy(array, iteratee2) {
                  return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseLt) : undefined2;
                }
                var multiply = createMathOperation(function(multiplier, multiplicand) {
                  return multiplier * multiplicand;
                }, 1);
                var round = createRound("round");
                var subtract = createMathOperation(function(minuend, subtrahend) {
                  return minuend - subtrahend;
                }, 0);
                function sum(array) {
                  return array && array.length ? baseSum(array, identity) : 0;
                }
                function sumBy(array, iteratee2) {
                  return array && array.length ? baseSum(array, getIteratee(iteratee2, 2)) : 0;
                }
                lodash.after = after;
                lodash.ary = ary;
                lodash.assign = assign;
                lodash.assignIn = assignIn;
                lodash.assignInWith = assignInWith;
                lodash.assignWith = assignWith;
                lodash.at = at;
                lodash.before = before;
                lodash.bind = bind;
                lodash.bindAll = bindAll;
                lodash.bindKey = bindKey;
                lodash.castArray = castArray;
                lodash.chain = chain;
                lodash.chunk = chunk;
                lodash.compact = compact;
                lodash.concat = concat;
                lodash.cond = cond;
                lodash.conforms = conforms;
                lodash.constant = constant;
                lodash.countBy = countBy;
                lodash.create = create;
                lodash.curry = curry;
                lodash.curryRight = curryRight;
                lodash.debounce = debounce;
                lodash.defaults = defaults;
                lodash.defaultsDeep = defaultsDeep;
                lodash.defer = defer;
                lodash.delay = delay;
                lodash.difference = difference;
                lodash.differenceBy = differenceBy;
                lodash.differenceWith = differenceWith;
                lodash.drop = drop;
                lodash.dropRight = dropRight;
                lodash.dropRightWhile = dropRightWhile;
                lodash.dropWhile = dropWhile;
                lodash.fill = fill;
                lodash.filter = filter;
                lodash.flatMap = flatMap;
                lodash.flatMapDeep = flatMapDeep;
                lodash.flatMapDepth = flatMapDepth;
                lodash.flatten = flatten;
                lodash.flattenDeep = flattenDeep;
                lodash.flattenDepth = flattenDepth;
                lodash.flip = flip;
                lodash.flow = flow;
                lodash.flowRight = flowRight;
                lodash.fromPairs = fromPairs;
                lodash.functions = functions;
                lodash.functionsIn = functionsIn;
                lodash.groupBy = groupBy;
                lodash.initial = initial;
                lodash.intersection = intersection;
                lodash.intersectionBy = intersectionBy;
                lodash.intersectionWith = intersectionWith;
                lodash.invert = invert;
                lodash.invertBy = invertBy;
                lodash.invokeMap = invokeMap;
                lodash.iteratee = iteratee;
                lodash.keyBy = keyBy;
                lodash.keys = keys;
                lodash.keysIn = keysIn;
                lodash.map = map;
                lodash.mapKeys = mapKeys;
                lodash.mapValues = mapValues;
                lodash.matches = matches;
                lodash.matchesProperty = matchesProperty;
                lodash.memoize = memoize;
                lodash.merge = merge;
                lodash.mergeWith = mergeWith;
                lodash.method = method;
                lodash.methodOf = methodOf;
                lodash.mixin = mixin;
                lodash.negate = negate;
                lodash.nthArg = nthArg;
                lodash.omit = omit;
                lodash.omitBy = omitBy;
                lodash.once = once;
                lodash.orderBy = orderBy;
                lodash.over = over;
                lodash.overArgs = overArgs;
                lodash.overEvery = overEvery;
                lodash.overSome = overSome;
                lodash.partial = partial;
                lodash.partialRight = partialRight;
                lodash.partition = partition;
                lodash.pick = pick;
                lodash.pickBy = pickBy;
                lodash.property = property;
                lodash.propertyOf = propertyOf;
                lodash.pull = pull;
                lodash.pullAll = pullAll;
                lodash.pullAllBy = pullAllBy;
                lodash.pullAllWith = pullAllWith;
                lodash.pullAt = pullAt;
                lodash.range = range;
                lodash.rangeRight = rangeRight;
                lodash.rearg = rearg;
                lodash.reject = reject;
                lodash.remove = remove;
                lodash.rest = rest;
                lodash.reverse = reverse;
                lodash.sampleSize = sampleSize;
                lodash.set = set;
                lodash.setWith = setWith;
                lodash.shuffle = shuffle;
                lodash.slice = slice;
                lodash.sortBy = sortBy;
                lodash.sortedUniq = sortedUniq;
                lodash.sortedUniqBy = sortedUniqBy;
                lodash.split = split;
                lodash.spread = spread;
                lodash.tail = tail;
                lodash.take = take;
                lodash.takeRight = takeRight;
                lodash.takeRightWhile = takeRightWhile;
                lodash.takeWhile = takeWhile;
                lodash.tap = tap;
                lodash.throttle = throttle;
                lodash.thru = thru;
                lodash.toArray = toArray;
                lodash.toPairs = toPairs;
                lodash.toPairsIn = toPairsIn;
                lodash.toPath = toPath;
                lodash.toPlainObject = toPlainObject;
                lodash.transform = transform;
                lodash.unary = unary;
                lodash.union = union;
                lodash.unionBy = unionBy;
                lodash.unionWith = unionWith;
                lodash.uniq = uniq;
                lodash.uniqBy = uniqBy;
                lodash.uniqWith = uniqWith;
                lodash.unset = unset;
                lodash.unzip = unzip;
                lodash.unzipWith = unzipWith;
                lodash.update = update;
                lodash.updateWith = updateWith;
                lodash.values = values;
                lodash.valuesIn = valuesIn;
                lodash.without = without;
                lodash.words = words;
                lodash.wrap = wrap;
                lodash.xor = xor;
                lodash.xorBy = xorBy;
                lodash.xorWith = xorWith;
                lodash.zip = zip;
                lodash.zipObject = zipObject;
                lodash.zipObjectDeep = zipObjectDeep;
                lodash.zipWith = zipWith;
                lodash.entries = toPairs;
                lodash.entriesIn = toPairsIn;
                lodash.extend = assignIn;
                lodash.extendWith = assignInWith;
                mixin(lodash, lodash);
                lodash.add = add;
                lodash.attempt = attempt;
                lodash.camelCase = camelCase;
                lodash.capitalize = capitalize;
                lodash.ceil = ceil;
                lodash.clamp = clamp;
                lodash.clone = clone;
                lodash.cloneDeep = cloneDeep;
                lodash.cloneDeepWith = cloneDeepWith;
                lodash.cloneWith = cloneWith;
                lodash.conformsTo = conformsTo;
                lodash.deburr = deburr;
                lodash.defaultTo = defaultTo;
                lodash.divide = divide;
                lodash.endsWith = endsWith;
                lodash.eq = eq;
                lodash.escape = escape;
                lodash.escapeRegExp = escapeRegExp;
                lodash.every = every;
                lodash.find = find;
                lodash.findIndex = findIndex;
                lodash.findKey = findKey;
                lodash.findLast = findLast;
                lodash.findLastIndex = findLastIndex;
                lodash.findLastKey = findLastKey;
                lodash.floor = floor;
                lodash.forEach = forEach;
                lodash.forEachRight = forEachRight;
                lodash.forIn = forIn;
                lodash.forInRight = forInRight;
                lodash.forOwn = forOwn;
                lodash.forOwnRight = forOwnRight;
                lodash.get = get;
                lodash.gt = gt;
                lodash.gte = gte;
                lodash.has = has;
                lodash.hasIn = hasIn;
                lodash.head = head;
                lodash.identity = identity;
                lodash.includes = includes;
                lodash.indexOf = indexOf;
                lodash.inRange = inRange;
                lodash.invoke = invoke;
                lodash.isArguments = isArguments;
                lodash.isArray = isArray2;
                lodash.isArrayBuffer = isArrayBuffer;
                lodash.isArrayLike = isArrayLike;
                lodash.isArrayLikeObject = isArrayLikeObject;
                lodash.isBoolean = isBoolean;
                lodash.isBuffer = isBuffer;
                lodash.isDate = isDate;
                lodash.isElement = isElement;
                lodash.isEmpty = isEmpty;
                lodash.isEqual = isEqual;
                lodash.isEqualWith = isEqualWith;
                lodash.isError = isError;
                lodash.isFinite = isFinite;
                lodash.isFunction = isFunction;
                lodash.isInteger = isInteger;
                lodash.isLength = isLength;
                lodash.isMap = isMap;
                lodash.isMatch = isMatch;
                lodash.isMatchWith = isMatchWith;
                lodash.isNaN = isNaN2;
                lodash.isNative = isNative;
                lodash.isNil = isNil;
                lodash.isNull = isNull;
                lodash.isNumber = isNumber;
                lodash.isObject = isObject;
                lodash.isObjectLike = isObjectLike;
                lodash.isPlainObject = isPlainObject;
                lodash.isRegExp = isRegExp;
                lodash.isSafeInteger = isSafeInteger;
                lodash.isSet = isSet;
                lodash.isString = isString;
                lodash.isSymbol = isSymbol;
                lodash.isTypedArray = isTypedArray;
                lodash.isUndefined = isUndefined;
                lodash.isWeakMap = isWeakMap;
                lodash.isWeakSet = isWeakSet;
                lodash.join = join;
                lodash.kebabCase = kebabCase;
                lodash.last = last;
                lodash.lastIndexOf = lastIndexOf;
                lodash.lowerCase = lowerCase;
                lodash.lowerFirst = lowerFirst;
                lodash.lt = lt;
                lodash.lte = lte;
                lodash.max = max;
                lodash.maxBy = maxBy;
                lodash.mean = mean;
                lodash.meanBy = meanBy;
                lodash.min = min;
                lodash.minBy = minBy;
                lodash.stubArray = stubArray;
                lodash.stubFalse = stubFalse;
                lodash.stubObject = stubObject;
                lodash.stubString = stubString;
                lodash.stubTrue = stubTrue;
                lodash.multiply = multiply;
                lodash.nth = nth;
                lodash.noConflict = noConflict;
                lodash.noop = noop;
                lodash.now = now;
                lodash.pad = pad;
                lodash.padEnd = padEnd;
                lodash.padStart = padStart;
                lodash.parseInt = parseInt2;
                lodash.random = random;
                lodash.reduce = reduce;
                lodash.reduceRight = reduceRight;
                lodash.repeat = repeat;
                lodash.replace = replace;
                lodash.result = result;
                lodash.round = round;
                lodash.runInContext = runInContext2;
                lodash.sample = sample;
                lodash.size = size;
                lodash.snakeCase = snakeCase;
                lodash.some = some;
                lodash.sortedIndex = sortedIndex;
                lodash.sortedIndexBy = sortedIndexBy;
                lodash.sortedIndexOf = sortedIndexOf;
                lodash.sortedLastIndex = sortedLastIndex;
                lodash.sortedLastIndexBy = sortedLastIndexBy;
                lodash.sortedLastIndexOf = sortedLastIndexOf;
                lodash.startCase = startCase;
                lodash.startsWith = startsWith;
                lodash.subtract = subtract;
                lodash.sum = sum;
                lodash.sumBy = sumBy;
                lodash.template = template;
                lodash.times = times;
                lodash.toFinite = toFinite;
                lodash.toInteger = toInteger;
                lodash.toLength = toLength;
                lodash.toLower = toLower;
                lodash.toNumber = toNumber;
                lodash.toSafeInteger = toSafeInteger;
                lodash.toString = toString;
                lodash.toUpper = toUpper;
                lodash.trim = trim;
                lodash.trimEnd = trimEnd;
                lodash.trimStart = trimStart;
                lodash.truncate = truncate;
                lodash.unescape = unescape2;
                lodash.uniqueId = uniqueId;
                lodash.upperCase = upperCase;
                lodash.upperFirst = upperFirst;
                lodash.each = forEach;
                lodash.eachRight = forEachRight;
                lodash.first = head;
                mixin(lodash, function() {
                  var source = {};
                  baseForOwn(lodash, function(func, methodName) {
                    if (!hasOwnProperty.call(lodash.prototype, methodName)) {
                      source[methodName] = func;
                    }
                  });
                  return source;
                }(), { "chain": false });
                lodash.VERSION = VERSION;
                arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
                  lodash[methodName].placeholder = lodash;
                });
                arrayEach(["drop", "take"], function(methodName, index) {
                  LazyWrapper.prototype[methodName] = function(n) {
                    n = n === undefined2 ? 1 : nativeMax(toInteger(n), 0);
                    var result2 = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();
                    if (result2.__filtered__) {
                      result2.__takeCount__ = nativeMin(n, result2.__takeCount__);
                    } else {
                      result2.__views__.push({
                        "size": nativeMin(n, MAX_ARRAY_LENGTH),
                        "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
                      });
                    }
                    return result2;
                  };
                  LazyWrapper.prototype[methodName + "Right"] = function(n) {
                    return this.reverse()[methodName](n).reverse();
                  };
                });
                arrayEach(["filter", "map", "takeWhile"], function(methodName, index) {
                  var type = index + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
                  LazyWrapper.prototype[methodName] = function(iteratee2) {
                    var result2 = this.clone();
                    result2.__iteratees__.push({
                      "iteratee": getIteratee(iteratee2, 3),
                      "type": type
                    });
                    result2.__filtered__ = result2.__filtered__ || isFilter;
                    return result2;
                  };
                });
                arrayEach(["head", "last"], function(methodName, index) {
                  var takeName = "take" + (index ? "Right" : "");
                  LazyWrapper.prototype[methodName] = function() {
                    return this[takeName](1).value()[0];
                  };
                });
                arrayEach(["initial", "tail"], function(methodName, index) {
                  var dropName = "drop" + (index ? "" : "Right");
                  LazyWrapper.prototype[methodName] = function() {
                    return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
                  };
                });
                LazyWrapper.prototype.compact = function() {
                  return this.filter(identity);
                };
                LazyWrapper.prototype.find = function(predicate) {
                  return this.filter(predicate).head();
                };
                LazyWrapper.prototype.findLast = function(predicate) {
                  return this.reverse().find(predicate);
                };
                LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
                  if (typeof path == "function") {
                    return new LazyWrapper(this);
                  }
                  return this.map(function(value) {
                    return baseInvoke(value, path, args);
                  });
                });
                LazyWrapper.prototype.reject = function(predicate) {
                  return this.filter(negate(getIteratee(predicate)));
                };
                LazyWrapper.prototype.slice = function(start, end) {
                  start = toInteger(start);
                  var result2 = this;
                  if (result2.__filtered__ && (start > 0 || end < 0)) {
                    return new LazyWrapper(result2);
                  }
                  if (start < 0) {
                    result2 = result2.takeRight(-start);
                  } else if (start) {
                    result2 = result2.drop(start);
                  }
                  if (end !== undefined2) {
                    end = toInteger(end);
                    result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start);
                  }
                  return result2;
                };
                LazyWrapper.prototype.takeRightWhile = function(predicate) {
                  return this.reverse().takeWhile(predicate).reverse();
                };
                LazyWrapper.prototype.toArray = function() {
                  return this.take(MAX_ARRAY_LENGTH);
                };
                baseForOwn(LazyWrapper.prototype, function(func, methodName) {
                  var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
                  if (!lodashFunc) {
                    return;
                  }
                  lodash.prototype[methodName] = function() {
                    var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray2(value);
                    var interceptor = function(value2) {
                      var result3 = lodashFunc.apply(lodash, arrayPush([value2], args));
                      return isTaker && chainAll ? result3[0] : result3;
                    };
                    if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
                      isLazy = useLazy = false;
                    }
                    var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
                    if (!retUnwrapped && useLazy) {
                      value = onlyLazy ? value : new LazyWrapper(this);
                      var result2 = func.apply(value, args);
                      result2.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": undefined2 });
                      return new LodashWrapper(result2, chainAll);
                    }
                    if (isUnwrapped && onlyLazy) {
                      return func.apply(this, args);
                    }
                    result2 = this.thru(interceptor);
                    return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
                  };
                });
                arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
                  var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
                  lodash.prototype[methodName] = function() {
                    var args = arguments;
                    if (retUnwrapped && !this.__chain__) {
                      var value = this.value();
                      return func.apply(isArray2(value) ? value : [], args);
                    }
                    return this[chainName](function(value2) {
                      return func.apply(isArray2(value2) ? value2 : [], args);
                    });
                  };
                });
                baseForOwn(LazyWrapper.prototype, function(func, methodName) {
                  var lodashFunc = lodash[methodName];
                  if (lodashFunc) {
                    var key = lodashFunc.name + "";
                    if (!hasOwnProperty.call(realNames, key)) {
                      realNames[key] = [];
                    }
                    realNames[key].push({ "name": methodName, "func": lodashFunc });
                  }
                });
                realNames[createHybrid(undefined2, WRAP_BIND_KEY_FLAG).name] = [{
                  "name": "wrapper",
                  "func": undefined2
                }];
                LazyWrapper.prototype.clone = lazyClone;
                LazyWrapper.prototype.reverse = lazyReverse;
                LazyWrapper.prototype.value = lazyValue;
                lodash.prototype.at = wrapperAt;
                lodash.prototype.chain = wrapperChain;
                lodash.prototype.commit = wrapperCommit;
                lodash.prototype.next = wrapperNext;
                lodash.prototype.plant = wrapperPlant;
                lodash.prototype.reverse = wrapperReverse;
                lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
                lodash.prototype.first = lodash.prototype.head;
                if (symIterator) {
                  lodash.prototype[symIterator] = wrapperToIterator;
                }
                return lodash;
              };
              var _ = runInContext();
              if (true) {
                root._ = _;
                !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
                  return _;
                }).call(exports2, __webpack_require__2, exports2, module2), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined2 && (module2.exports = __WEBPACK_AMD_DEFINE_RESULT__));
              } else {
              }
            }).call(this);
          }
        ),
        /***/
        511: (
          /***/
          function(__unused_webpack_module, exports2, __webpack_require__2) {
            "use strict";
            var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
              if (k2 === void 0)
                k2 = k;
              var desc = Object.getOwnPropertyDescriptor(m, k);
              if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
                desc = { enumerable: true, get: function() {
                  return m[k];
                } };
              }
              Object.defineProperty(o, k2, desc);
            } : function(o, m, k, k2) {
              if (k2 === void 0)
                k2 = k;
              o[k2] = m[k];
            });
            var __exportStar = this && this.__exportStar || function(m, exports3) {
              for (var p in m)
                if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
                  __createBinding(exports3, m, p);
            };
            Object.defineProperty(exports2, "__esModule", { value: true });
            __exportStar(__webpack_require__2(7965), exports2);
          }
        ),
        /***/
        7965: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.TrieStore = void 0;
            const Utils_1 = __webpack_require__2(74);
            const rxjs_1 = __webpack_require__2(1964);
            const operators_1 = __webpack_require__2(9978);
            const ptrie_1 = __webpack_require__2(4843);
            class ObserversTrieSubject extends rxjs_1.Subject {
              constructor() {
                super(...arguments);
                this.isAllDetailsMode = false;
              }
            }
            class TrieStore {
              constructor(rootState) {
                this.rootState = rootState;
                this.observersTrie = new ptrie_1.Trie();
                this.batchDepth = 0;
                this.appliedBatchActions = [];
                this.rootStateBeforeBatchStart = this.rootState;
                this.stubForUnusedPaths = [];
              }
              /**
               * Returns current store state for the root path.
               * Note: it is unsafe to modify the returned state because the store and observers
               * will not be aware of the modifications and this can lead to undefined behavior.
               */
              get state() {
                return this.rootState;
              }
              get state$() {
                return this.observe([]);
              }
              /**
               * Returns a state value stored in the path.
               * If there is no value associated with the path returns `undefined`.
               */
              get(path) {
                return this._get(this.rootState, path);
              }
              /** Creates an observable to monitor current value on the specified path and all subpaths. */
              observe(path, pathsToExclude = []) {
                return this._observeChanges(path, pathsToExclude, "new-value-only").pipe((0, operators_1.map)((v) => v.value));
              }
              /** Creates an observable to monitor changes on the specified path and all subpaths. */
              observeChanges(path, pathsToExclude = []) {
                return this._observeChanges(path, pathsToExclude, "all-details");
              }
              /**
               * Sets a new state to the path.
               * If the state contains a referentially equal value at the path does nothing.
               *
               * The `compareFn` compares an old and new values before the action:
               * if the values are equal (`true` is returned), the operation makes no changes to the state.
               *
               * As a result of this operation, the store state is affected immediately.
               * If there is no active batch operation, the observers receive a notification immediately.
               * Otherwise, a notification will be sent after the top-level batch function completes.
               */
              set(path, value, compareFn) {
                if (!(compareFn === null || compareFn === void 0 ? void 0 : compareFn(this.get(path), value, path))) {
                  this._apply({ type: "set", path, value });
                }
              }
              /**
               * Deletes a value in `path`. The path must be non-empty.
               * Results to no-op if there is no value stored under `path` .
               *
               * As a result of this operation, the store state is affected immediately.
               * If there is no active batch operation, the observers receive a notification immediately.
               * Otherwise, a notification will be sent after the top-level batch function completes.
               */
              delete(path) {
                this._apply({ type: "delete", path });
              }
              /**
               * Completes and removes all subscriptions and resets the store state.
               * No update is sent to any observers as the result of this operation: all subscriptions are completed before the cleanup.
               */
              reset(newState) {
                this.observersTrie.visitDfs("pre-order", (subject) => subject === null || subject === void 0 ? void 0 : subject.complete());
                this.observersTrie.delete([]);
                this.rootState = newState;
              }
              /**
               * Runs a `batchFn` code within a batch.
               *
               * All changes done to store inside `batchFn` state are applied immediately,
               * but will be delivered to observers only after `batchFn` is finished.
               *
               * The store state and notifications do not depend on `batchFn` result:
               * the changes are made, and notifications are sent even if the `batchFn` completes with an Error.
               */
              runInBatch(batchFn) {
                this.batchDepth++;
                try {
                  batchFn();
                } finally {
                  this.batchDepth--;
                  if (this.batchDepth === 0 && this.appliedBatchActions.length > 0) {
                    const batchAction = { type: "batch", actions: this.appliedBatchActions };
                    this.appliedBatchActions = [];
                    this._notify(batchAction);
                  }
                }
              }
              /**
               * Applies changes to the store state immediately, but delays observer
               * notification until all active batch operations are completed.
               */
              _apply(action) {
                if (this.batchDepth === 0) {
                  this.rootStateBeforeBatchStart = this.rootState;
                }
                this.rootState = (0, Utils_1.apply)(this.rootState, action);
                if (this.rootState === this.rootStateBeforeBatchStart || this.observersTrie.isEmpty) {
                  return;
                }
                if (this.batchDepth > 0) {
                  this.appliedBatchActions.push(action);
                  return;
                }
                this._notify(action);
              }
              /** Notifies all pending observers selected by the action path. */
              _notify(action) {
                const uniquePathsInActions = (0, Utils_1.extractPaths)(action, "unique-and-sorted");
                const childPathsWithObservers = this.selectChildPathsWithObservers(uniquePathsInActions);
                const pathsToNotify = (0, Utils_1.selectUniquePaths)([...uniquePathsInActions, ...childPathsWithObservers]);
                const updateTrie = new ptrie_1.Trie();
                for (const path of pathsToNotify) {
                  updateTrie.fillPath(path, () => true);
                }
                updateTrie.visitDfs("pre-order", (_, path) => {
                  const subject = this.observersTrie.get(path);
                  if (subject) {
                    const value = this.get(path);
                    const oldValue = subject.isAllDetailsMode ? this._get(this.rootStateBeforeBatchStart, path) : void 0;
                    subject.next({ action, value, oldValue });
                  }
                });
              }
              /** Creates an observable to monitor changes on the specified path and all sub-paths. */
              _observeChanges(path, pathsToExclude = [], changeDetailsFlag) {
                const excludeTrie = pathsToExclude.length === 0 ? void 0 : new ptrie_1.Trie();
                for (const pathToExclude of pathsToExclude) {
                  excludeTrie === null || excludeTrie === void 0 ? void 0 : excludeTrie.set(pathToExclude, true);
                }
                return new rxjs_1.Observable((observer) => {
                  const subject = this.observersTrie.getOrSet(path, () => new ObserversTrieSubject());
                  subject.isAllDetailsMode = subject.isAllDetailsMode || changeDetailsFlag === "all-details";
                  const initialChange = { oldValue: void 0, value: this.get(path), paths: [[]] };
                  observer.next(initialChange);
                  const subscription = subject.pipe(
                    // Remove `pathsToExclude`.
                    (0, operators_1.filter)(({ action }) => excludeTrie === void 0 || (0, Utils_1.extractPaths)(action, "as-is").some((path2) => !excludeTrie.get(path2))),
                    // Extract `StateChange` from `ObserversTrieSubjectData` observable and send it to the observer.
                    (0, operators_1.map)(({ action, value, oldValue }) => {
                      let paths = this.stubForUnusedPaths;
                      if (subject.isAllDetailsMode) {
                        const fullPaths = (0, Utils_1.extractPaths)(action, "as-is");
                        const subPaths = path.length > 0 ? fullPaths.filter((fullPath) => (0, Utils_1.isPathPrefix)(fullPath, path)).map((fullPath) => fullPath.slice(path.length)) : fullPaths;
                        paths = (0, Utils_1.selectUniquePathPrefixes)(subPaths);
                      }
                      return { value, oldValue, paths };
                    })
                  ).subscribe(observer);
                  return () => {
                    subscription.unsubscribe();
                    if (!subject.observed) {
                      this.observersTrie.delete(path);
                    }
                  };
                });
              }
              /** Returns state value for the given root state and path. */
              _get(customRootState, path) {
                let result = customRootState;
                for (let i2 = 0; i2 < path.length && result !== void 0; i2++) {
                  const key = path[i2];
                  result = result === null || result === void 0 ? void 0 : result[key];
                }
                return result;
              }
              selectChildPathsWithObservers(parentPaths) {
                const childPaths = [];
                for (const path of parentPaths) {
                  const childrenWithObserver = this.observersTrie.count(path, "children-only");
                  if (childrenWithObserver > 0) {
                    this.observersTrie.visitDfs("pre-order", (trieSubject, childPath) => {
                      if (trieSubject) {
                        childPaths.push([...childPath]);
                      }
                    }, path);
                  }
                }
                return childPaths;
              }
            }
            exports2.TrieStore = TrieStore;
          }
        ),
        /***/
        74: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.selectUniquePaths = exports2.selectUniquePathPrefixes = exports2.sortPaths = exports2.isPathPrefix = exports2.extractPaths = exports2.deepCloneOnPath = exports2.deleteInPath = exports2.setInPath = exports2.apply = void 0;
            const assertic_1 = __webpack_require__2(8975);
            function apply(state, action) {
              switch (action.type) {
                case "set":
                  return setInPath(state, action.path, action.value);
                case "delete":
                  return deleteInPath(state, action.path);
                case "batch":
                  return action.actions.reduce((result, actionInBatch) => apply(result, actionInBatch), state);
              }
            }
            exports2.apply = apply;
            function setInPath(state, path, newValue) {
              if (newValue === void 0) {
                return deleteInPath(state, path);
              }
              if (path.length === 0) {
                (0, assertic_1.assertTruthy)(typeof newValue === "object" && newValue !== null && !Array.isArray(newValue), () => `Root state must be a record. Trying to set '${newValue}', type: ${typeof newValue}`);
                return newValue;
              }
              function isValidArrayIndex(key) {
                const index = Number(key);
                return !isNaN(index) && index >= 0 && index !== Infinity;
              }
              let subState = state;
              for (let i2 = 0; i2 < path.length - 1 && subState !== void 0; i2++) {
                const key = path[i2];
                (0, assertic_1.assertTruthy)(!Array.isArray(subState) || isValidArrayIndex(key), () => `Invalid array index. Path: '${path.slice(0, i2 + 1)}', index: '${key}'`);
                subState = subState[key];
                (0, assertic_1.assertTruthy)(subState === void 0 || typeof subState === "object" && subState !== null, () => `Cannot set a property to a non-record parent. Path: '${path.slice(0, i2 + 1)}', type: '${subState === null ? "<null>" : typeof subState}'`);
              }
              const leafKey = path[path.length - 1];
              (0, assertic_1.assertTruthy)(!Array.isArray(subState) || isValidArrayIndex(leafKey), () => `Invalid array index Path: '${path}`);
              return (subState === null || subState === void 0 ? void 0 : subState[leafKey]) === newValue ? state : deepCloneOnPath(state, path, newValue);
            }
            exports2.setInPath = setInPath;
            function deleteInPath(state, path) {
              (0, assertic_1.assertTruthy)(path.length !== 0, `Can't delete an empty path`);
              let subState = state;
              for (let i2 = 0; i2 < path.length - 1; i2++) {
                const key = path[i2];
                subState = subState[key];
                if (subState === void 0) {
                  return state;
                }
                (0, assertic_1.assertTruthy)(typeof subState === "object" && subState !== null, () => `Cannot delete a property from a non-record parent. Path: '${path.slice(0, i2 + 1)}', type: ${subState === null ? "<null>" : typeof subState}`);
              }
              const leafKey = path[path.length - 1];
              return subState[leafKey] === void 0 ? state : deepCloneOnPath(state, path, void 0);
            }
            exports2.deleteInPath = deleteInPath;
            function deepCloneOnPath(originalState, path, patchValue) {
              function deleteKey(stateRecord, key) {
                (0, assertic_1.assertTruthy)(!Array.isArray(stateRecord), () => `Can't delete element of array. Path: '${path}'`);
                delete stateRecord[key];
              }
              const result = Object.assign({}, originalState);
              let clonedState = result;
              for (let i2 = 0; i2 < path.length - 1; i2++) {
                const key = path[i2];
                const sharedSubState = clonedState[key];
                (0, assertic_1.assertTruthy)(sharedSubState === void 0 || typeof sharedSubState === "object" && sharedSubState !== null, () => `Internal error: sub-path has an invalid type and can't be patched: '${path.slice(0, i2 + 1)}', type: '${sharedSubState === null ? null : typeof sharedSubState}'`);
                const clonedSubState = sharedSubState === void 0 ? patchValue === void 0 ? void 0 : {} : Array.isArray(sharedSubState) ? [...sharedSubState] : Object.assign({}, sharedSubState);
                if (clonedSubState === void 0) {
                  deleteKey(clonedState, key);
                  return clonedState;
                }
                clonedState[key] = clonedSubState;
                clonedState = clonedSubState;
              }
              const leafKey = path[path.length - 1];
              if (patchValue === void 0) {
                deleteKey(clonedState, leafKey);
              } else {
                clonedState[leafKey] = patchValue;
              }
              return result;
            }
            exports2.deepCloneOnPath = deepCloneOnPath;
            function extractPaths(action, mode) {
              const result = [];
              if (action.type === "set" || action.type === "delete") {
                result.push(action.path);
              } else if (action.type === "batch") {
                for (const nestedAction of action.actions) {
                  result.push(...extractPaths(nestedAction, "as-is"));
                }
              }
              return mode === "unique-and-sorted" ? selectUniquePaths(result) : result;
            }
            exports2.extractPaths = extractPaths;
            function isPathPrefix(path, prefixPath) {
              if (path.length < prefixPath.length) {
                return false;
              }
              for (let i2 = 0; i2 < prefixPath.length; i2++) {
                if (path[i2] !== prefixPath[i2]) {
                  return false;
                }
              }
              return true;
            }
            exports2.isPathPrefix = isPathPrefix;
            function sortPaths(paths) {
              const sortedPaths = [...paths];
              sortedPaths.sort((p1, p2) => {
                for (let i2 = 0; i2 < p1.length; i2++) {
                  if (i2 === p2.length) {
                    return 1;
                  }
                  const delta = p1[i2].localeCompare(p2[i2]);
                  if (delta !== 0) {
                    return delta;
                  }
                }
                return p1.length - p2.length;
              });
              return sortedPaths;
            }
            exports2.sortPaths = sortPaths;
            function selectUniquePathPrefixes(paths) {
              if (paths.length === 1) {
                return [...paths];
              }
              if (paths.some((p) => p.length === 0)) {
                return [[]];
              }
              const sortedPaths = sortPaths(paths);
              const filteredSubPaths = sortedPaths;
              for (let i2 = 0; i2 < filteredSubPaths.length - 1; i2++) {
                const shortParentPath = sortedPaths[i2];
                for (let j = i2 + 1; j < sortedPaths.length; j++) {
                  const longChildPath = sortedPaths[j];
                  if (isPathPrefix(longChildPath, shortParentPath)) {
                    filteredSubPaths[j] = void 0;
                    i2++;
                  }
                }
              }
              return filteredSubPaths.filter((p) => p !== void 0);
            }
            exports2.selectUniquePathPrefixes = selectUniquePathPrefixes;
            function selectUniquePaths(paths) {
              const sortedPaths = sortPaths(paths);
              const uniquePaths = sortedPaths;
              for (let i2 = 0; i2 < sortedPaths.length - 1; i2++) {
                const pi = sortedPaths[i2];
                for (let j = i2 + 1; j < sortedPaths.length; j++) {
                  const pj = sortedPaths[j];
                  if (pi.length === pj.length && isPathPrefix(pi, pj)) {
                    uniquePaths[j] = void 0;
                    i2++;
                  }
                }
              }
              return uniquePaths.filter((p) => p !== void 0);
            }
            exports2.selectUniquePaths = selectUniquePaths;
          }
        ),
        /***/
        4843: (
          /***/
          function(__unused_webpack_module, exports2, __webpack_require__2) {
            "use strict";
            var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
              if (k2 === void 0)
                k2 = k;
              var desc = Object.getOwnPropertyDescriptor(m, k);
              if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
                desc = { enumerable: true, get: function() {
                  return m[k];
                } };
              }
              Object.defineProperty(o, k2, desc);
            } : function(o, m, k, k2) {
              if (k2 === void 0)
                k2 = k;
              o[k2] = m[k];
            });
            var __exportStar = this && this.__exportStar || function(m, exports3) {
              for (var p in m)
                if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
                  __createBinding(exports3, m, p);
            };
            Object.defineProperty(exports2, "__esModule", { value: true });
            __exportStar(__webpack_require__2(1419), exports2);
          }
        ),
        /***/
        1419: (
          /***/
          (__unused_webpack_module, exports2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.Trie = void 0;
            class Trie {
              constructor() {
                this.root = { children: /* @__PURE__ */ new Map(), childrenWithValue: 0 };
              }
              /** Returns a value stored under the given path. */
              get(path) {
                var _a;
                return (_a = this.getNode(path)) === null || _a === void 0 ? void 0 : _a.value;
              }
              /**
               * Returns a value assigned to the path.
               * If there is no node found of the node value is `undefined`,
               * the method calls the provider for the new value.
               */
              getOrSet(path, valueProvider) {
                const node = this._buildPath(path);
                if (node.value !== void 0) {
                  return node.value;
                }
                const newValue = valueProvider(path);
                this._setNodeValue(node, newValue, newValue === void 0);
                return newValue;
              }
              /** Sets node value. */
              set(path, value) {
                const node = value === void 0 ? this._findNode(path) : this._buildPath(path);
                if (node) {
                  this._setNodeValue(node, value, true);
                }
              }
              /** Removes the node under the path and all its children from the tree. */
              delete(path) {
                const node = this._findNode(path);
                if (node === void 0) {
                  return;
                }
                if (node.parent === void 0) {
                  if (node !== this.root) {
                    throw new Error("Only root node can have no parent.");
                  }
                  this.root.value = void 0;
                  this.root.children.clear();
                  this.root.childrenWithValue = 0;
                  return;
                }
                const delta = (node.value === void 0 ? 0 : 1) + node.childrenWithValue;
                if (delta > 0) {
                  this._updateChildrenWithValue(node, -delta);
                }
                node.parent.children.delete(path[path.length - 1]);
                this._runGc(node.parent);
              }
              /** Clears the trie: remove all nodes from the trie. */
              clear() {
                this.delete([]);
              }
              /**
               * Returns a count of all child nodes (any depth) with non-undefined
               * values under the `path` including the node pointed by the path if `mode` is `node-and-children`.
               *
               * A call with no arguments will return a total count of all values in the trie.
               */
              count(path = [], mode = "node-and-children") {
                const node = this.getNode(path);
                if (node === void 0) {
                  return 0;
                }
                return node.childrenWithValue + (mode === "node-and-children" && node.value !== void 0 ? 1 : 0);
              }
              /** Returns true if the trie has no nodes with non-undefined values. */
              get isEmpty() {
                return this.count() === 0;
              }
              /**
               * Fills a path with a values provided by the `TriePathValueProvider`.
               * The fill is started from the top level path elements.
               * The `provider` is called for every element in the path.
               * The fill operation stops if `provider` returns Trie.StopFillToken.
               */
              fillPath(path, valueProvider) {
                const currentPath = [];
                let node = this.root;
                let newValue = valueProvider(node.value, currentPath);
                if (newValue === Trie.StopFillToken) {
                  return;
                }
                this._setNodeValue(node, newValue, false);
                for (let i2 = 0; i2 < path.length; i2++) {
                  const key = path[i2];
                  currentPath.push(key);
                  let child = node.children.get(key);
                  newValue = valueProvider(child === null || child === void 0 ? void 0 : child.value, currentPath);
                  if (newValue === Trie.StopFillToken) {
                    break;
                  }
                  if (!child) {
                    child = { children: /* @__PURE__ */ new Map(), parent: node, childrenWithValue: 0 };
                    node.children.set(key, child);
                  }
                  this._setNodeValue(child, newValue, false);
                  node = child;
                }
                this._runGc(node);
              }
              /**
               * Visits the tree in a DFS order.
               * Starts with a `subtreeRootPath` node.
               * All nodes are reported: even with an undefined value.
               * If the callback returns false, it will not iterate into the children of the current node.
               */
              visitDfs(order, visitorFn, subtreeRootPath = []) {
                const node = this.getNode(subtreeRootPath);
                if (node === void 0) {
                  return;
                }
                this._visitDfs(order, node, visitorFn, [...subtreeRootPath]);
              }
              _visitDfs(order, node, visitor, path) {
                if (order === "pre-order") {
                  if (visitor(node.value, path) === false) {
                    return false;
                  }
                }
                for (const [childKey, childNode] of node.children) {
                  path.push(childKey);
                  if (!this._visitDfs(order, childNode, visitor, path)) {
                    return false;
                  }
                  path.pop();
                }
                if (order === "in-order") {
                  if (visitor(node.value, path) === false) {
                    return false;
                  }
                }
                return true;
              }
              /**
               * Returns a node by the given path.
               * This method is not designed to be a part of the public API because it exposes internal trie details.
               * It exists for testing only.
               * Use with care: trie guarantees a consistent TrieNode hierarchy only at the moment of the method call
               * and may replace/remove nodes as the result of any other method call.
               */
              getNode(path) {
                return this._getNode(path);
              }
              _getNode(path) {
                let node = this.root;
                for (const key of path) {
                  node = node.children.get(key);
                  if (!node) {
                    return void 0;
                  }
                }
                return node;
              }
              /** Finds a node with the given path. */
              _findNode(path) {
                let node = this.root;
                for (let i2 = 0; i2 < path.length && node; i2++) {
                  node = node.children.get(path[i2]);
                }
                return node;
              }
              /**
               * Creates a path with new nodes holding `undefined` value.
               * Reuses current nodes if found.
               */
              _buildPath(path) {
                let node = this.root;
                for (let i2 = 0; i2 < path.length; i2++) {
                  const key = path[i2];
                  let child = node.children.get(key);
                  if (!child) {
                    child = { children: /* @__PURE__ */ new Map(), parent: node, childrenWithValue: 0 };
                    node.children.set(key, child);
                  }
                  node = child;
                }
                return node;
              }
              /** Updates node value and `childrenWithValue` counter. Does not clean up the tree. */
              _setNodeValue(node, newValue, runGc) {
                if (node.value !== newValue) {
                  const delta = newValue === void 0 ? -1 : node.value === void 0 ? 1 : 0;
                  node.value = newValue;
                  this._updateChildrenWithValue(node, delta);
                }
                if (runGc) {
                  this._runGc(node);
                }
              }
              /** Updates all parent nodes of the node: adds `delta` to their `childrenWithValue` field. */
              _updateChildrenWithValue(node, delta) {
                if (delta === 0) {
                  return;
                }
                for (let parent = node.parent; parent; parent = parent.parent) {
                  parent.childrenWithValue += delta;
                  if (parent.childrenWithValue < 0) {
                    throw new Error("Internal error: negative counter value!");
                  }
                }
              }
              /**
               *  Cleanups the trie starting from the current node.
               *  Runs the cleanup only if `node.value` is undefined.
               */
              _runGc(node) {
                if (node.value !== void 0) {
                  return;
                }
                if (node.childrenWithValue === 0) {
                  node.children.clear();
                }
                if (node.parent) {
                  this._runGc(node.parent);
                }
              }
            }
            exports2.Trie = Trie;
            Trie.StopFillToken = Symbol("Trie.StopFillToken");
          }
        ),
        /***/
        7257: (
          /***/
          function(__unused_webpack_module, exports2, __webpack_require__2) {
            "use strict";
            var __extends = this && this.__extends || /* @__PURE__ */ function() {
              var extendStatics = function(d, b) {
                extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                  d2.__proto__ = b2;
                } || function(d2, b2) {
                  for (var p in b2)
                    if (Object.prototype.hasOwnProperty.call(b2, p))
                      d2[p] = b2[p];
                };
                return extendStatics(d, b);
              };
              return function(d, b) {
                if (typeof b !== "function" && b !== null)
                  throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
                extendStatics(d, b);
                function __() {
                  this.constructor = d;
                }
                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
              };
            }();
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.AsyncSubject = void 0;
            var Subject_1 = __webpack_require__2(9520);
            var AsyncSubject = function(_super) {
              __extends(AsyncSubject2, _super);
              function AsyncSubject2() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this._value = null;
                _this._hasValue = false;
                _this._isComplete = false;
                return _this;
              }
              AsyncSubject2.prototype._checkFinalizedStatuses = function(subscriber) {
                var _a = this, hasError = _a.hasError, _hasValue = _a._hasValue, _value = _a._value, thrownError = _a.thrownError, isStopped = _a.isStopped, _isComplete = _a._isComplete;
                if (hasError) {
                  subscriber.error(thrownError);
                } else if (isStopped || _isComplete) {
                  _hasValue && subscriber.next(_value);
                  subscriber.complete();
                }
              };
              AsyncSubject2.prototype.next = function(value) {
                if (!this.isStopped) {
                  this._value = value;
                  this._hasValue = true;
                }
              };
              AsyncSubject2.prototype.complete = function() {
                var _a = this, _hasValue = _a._hasValue, _value = _a._value, _isComplete = _a._isComplete;
                if (!_isComplete) {
                  this._isComplete = true;
                  _hasValue && _super.prototype.next.call(this, _value);
                  _super.prototype.complete.call(this);
                }
              };
              return AsyncSubject2;
            }(Subject_1.Subject);
            exports2.AsyncSubject = AsyncSubject;
          }
        ),
        /***/
        8042: (
          /***/
          function(__unused_webpack_module, exports2, __webpack_require__2) {
            "use strict";
            var __extends = this && this.__extends || /* @__PURE__ */ function() {
              var extendStatics = function(d, b) {
                extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                  d2.__proto__ = b2;
                } || function(d2, b2) {
                  for (var p in b2)
                    if (Object.prototype.hasOwnProperty.call(b2, p))
                      d2[p] = b2[p];
                };
                return extendStatics(d, b);
              };
              return function(d, b) {
                if (typeof b !== "function" && b !== null)
                  throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
                extendStatics(d, b);
                function __() {
                  this.constructor = d;
                }
                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
              };
            }();
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.BehaviorSubject = void 0;
            var Subject_1 = __webpack_require__2(9520);
            var BehaviorSubject = function(_super) {
              __extends(BehaviorSubject2, _super);
              function BehaviorSubject2(_value) {
                var _this = _super.call(this) || this;
                _this._value = _value;
                return _this;
              }
              Object.defineProperty(BehaviorSubject2.prototype, "value", {
                get: function() {
                  return this.getValue();
                },
                enumerable: false,
                configurable: true
              });
              BehaviorSubject2.prototype._subscribe = function(subscriber) {
                var subscription = _super.prototype._subscribe.call(this, subscriber);
                !subscription.closed && subscriber.next(this._value);
                return subscription;
              };
              BehaviorSubject2.prototype.getValue = function() {
                var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, _value = _a._value;
                if (hasError) {
                  throw thrownError;
                }
                this._throwIfClosed();
                return _value;
              };
              BehaviorSubject2.prototype.next = function(value) {
                _super.prototype.next.call(this, this._value = value);
              };
              return BehaviorSubject2;
            }(Subject_1.Subject);
            exports2.BehaviorSubject = BehaviorSubject;
          }
        ),
        /***/
        3868: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.observeNotification = exports2.Notification = exports2.NotificationKind = void 0;
            var empty_1 = __webpack_require__2(1727);
            var of_1 = __webpack_require__2(7443);
            var throwError_1 = __webpack_require__2(859);
            var isFunction_1 = __webpack_require__2(4432);
            var NotificationKind;
            (function(NotificationKind2) {
              NotificationKind2["NEXT"] = "N";
              NotificationKind2["ERROR"] = "E";
              NotificationKind2["COMPLETE"] = "C";
            })(NotificationKind = exports2.NotificationKind || (exports2.NotificationKind = {}));
            var Notification = function() {
              function Notification2(kind, value, error) {
                this.kind = kind;
                this.value = value;
                this.error = error;
                this.hasValue = kind === "N";
              }
              Notification2.prototype.observe = function(observer) {
                return observeNotification(this, observer);
              };
              Notification2.prototype.do = function(nextHandler, errorHandler, completeHandler) {
                var _a = this, kind = _a.kind, value = _a.value, error = _a.error;
                return kind === "N" ? nextHandler === null || nextHandler === void 0 ? void 0 : nextHandler(value) : kind === "E" ? errorHandler === null || errorHandler === void 0 ? void 0 : errorHandler(error) : completeHandler === null || completeHandler === void 0 ? void 0 : completeHandler();
              };
              Notification2.prototype.accept = function(nextOrObserver, error, complete) {
                var _a;
                return isFunction_1.isFunction((_a = nextOrObserver) === null || _a === void 0 ? void 0 : _a.next) ? this.observe(nextOrObserver) : this.do(nextOrObserver, error, complete);
              };
              Notification2.prototype.toObservable = function() {
                var _a = this, kind = _a.kind, value = _a.value, error = _a.error;
                var result = kind === "N" ? of_1.of(value) : kind === "E" ? throwError_1.throwError(function() {
                  return error;
                }) : kind === "C" ? empty_1.EMPTY : 0;
                if (!result) {
                  throw new TypeError("Unexpected notification kind " + kind);
                }
                return result;
              };
              Notification2.createNext = function(value) {
                return new Notification2("N", value);
              };
              Notification2.createError = function(err) {
                return new Notification2("E", void 0, err);
              };
              Notification2.createComplete = function() {
                return Notification2.completeNotification;
              };
              Notification2.completeNotification = new Notification2("C");
              return Notification2;
            }();
            exports2.Notification = Notification;
            function observeNotification(notification, observer) {
              var _a, _b, _c;
              var _d = notification, kind = _d.kind, value = _d.value, error = _d.error;
              if (typeof kind !== "string") {
                throw new TypeError('Invalid notification, missing "kind"');
              }
              kind === "N" ? (_a = observer.next) === null || _a === void 0 ? void 0 : _a.call(observer, value) : kind === "E" ? (_b = observer.error) === null || _b === void 0 ? void 0 : _b.call(observer, error) : (_c = observer.complete) === null || _c === void 0 ? void 0 : _c.call(observer);
            }
            exports2.observeNotification = observeNotification;
          }
        ),
        /***/
        3380: (
          /***/
          (__unused_webpack_module, exports2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.createNotification = exports2.nextNotification = exports2.errorNotification = exports2.COMPLETE_NOTIFICATION = void 0;
            exports2.COMPLETE_NOTIFICATION = function() {
              return createNotification("C", void 0, void 0);
            }();
            function errorNotification(error) {
              return createNotification("E", void 0, error);
            }
            exports2.errorNotification = errorNotification;
            function nextNotification(value) {
              return createNotification("N", value, void 0);
            }
            exports2.nextNotification = nextNotification;
            function createNotification(kind, value, error) {
              return {
                kind,
                value,
                error
              };
            }
            exports2.createNotification = createNotification;
          }
        ),
        /***/
        5271: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.Observable = void 0;
            var Subscriber_1 = __webpack_require__2(1403);
            var Subscription_1 = __webpack_require__2(7215);
            var observable_1 = __webpack_require__2(2138);
            var pipe_1 = __webpack_require__2(5966);
            var config_1 = __webpack_require__2(3782);
            var isFunction_1 = __webpack_require__2(4432);
            var errorContext_1 = __webpack_require__2(4770);
            var Observable = function() {
              function Observable2(subscribe) {
                if (subscribe) {
                  this._subscribe = subscribe;
                }
              }
              Observable2.prototype.lift = function(operator) {
                var observable = new Observable2();
                observable.source = this;
                observable.operator = operator;
                return observable;
              };
              Observable2.prototype.subscribe = function(observerOrNext, error, complete) {
                var _this = this;
                var subscriber = isSubscriber(observerOrNext) ? observerOrNext : new Subscriber_1.SafeSubscriber(observerOrNext, error, complete);
                errorContext_1.errorContext(function() {
                  var _a = _this, operator = _a.operator, source = _a.source;
                  subscriber.add(operator ? operator.call(subscriber, source) : source ? _this._subscribe(subscriber) : _this._trySubscribe(subscriber));
                });
                return subscriber;
              };
              Observable2.prototype._trySubscribe = function(sink) {
                try {
                  return this._subscribe(sink);
                } catch (err) {
                  sink.error(err);
                }
              };
              Observable2.prototype.forEach = function(next, promiseCtor) {
                var _this = this;
                promiseCtor = getPromiseCtor(promiseCtor);
                return new promiseCtor(function(resolve, reject) {
                  var subscriber = new Subscriber_1.SafeSubscriber({
                    next: function(value) {
                      try {
                        next(value);
                      } catch (err) {
                        reject(err);
                        subscriber.unsubscribe();
                      }
                    },
                    error: reject,
                    complete: resolve
                  });
                  _this.subscribe(subscriber);
                });
              };
              Observable2.prototype._subscribe = function(subscriber) {
                var _a;
                return (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber);
              };
              Observable2.prototype[observable_1.observable] = function() {
                return this;
              };
              Observable2.prototype.pipe = function() {
                var operations = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                  operations[_i] = arguments[_i];
                }
                return pipe_1.pipeFromArray(operations)(this);
              };
              Observable2.prototype.toPromise = function(promiseCtor) {
                var _this = this;
                promiseCtor = getPromiseCtor(promiseCtor);
                return new promiseCtor(function(resolve, reject) {
                  var value;
                  _this.subscribe(function(x) {
                    return value = x;
                  }, function(err) {
                    return reject(err);
                  }, function() {
                    return resolve(value);
                  });
                });
              };
              Observable2.create = function(subscribe) {
                return new Observable2(subscribe);
              };
              return Observable2;
            }();
            exports2.Observable = Observable;
            function getPromiseCtor(promiseCtor) {
              var _a;
              return (_a = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config_1.config.Promise) !== null && _a !== void 0 ? _a : Promise;
            }
            function isObserver(value) {
              return value && isFunction_1.isFunction(value.next) && isFunction_1.isFunction(value.error) && isFunction_1.isFunction(value.complete);
            }
            function isSubscriber(value) {
              return value && value instanceof Subscriber_1.Subscriber || isObserver(value) && Subscription_1.isSubscription(value);
            }
          }
        ),
        /***/
        216: (
          /***/
          function(__unused_webpack_module, exports2, __webpack_require__2) {
            "use strict";
            var __extends = this && this.__extends || /* @__PURE__ */ function() {
              var extendStatics = function(d, b) {
                extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                  d2.__proto__ = b2;
                } || function(d2, b2) {
                  for (var p in b2)
                    if (Object.prototype.hasOwnProperty.call(b2, p))
                      d2[p] = b2[p];
                };
                return extendStatics(d, b);
              };
              return function(d, b) {
                if (typeof b !== "function" && b !== null)
                  throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
                extendStatics(d, b);
                function __() {
                  this.constructor = d;
                }
                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
              };
            }();
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.ReplaySubject = void 0;
            var Subject_1 = __webpack_require__2(9520);
            var dateTimestampProvider_1 = __webpack_require__2(1713);
            var ReplaySubject = function(_super) {
              __extends(ReplaySubject2, _super);
              function ReplaySubject2(_bufferSize, _windowTime, _timestampProvider) {
                if (_bufferSize === void 0) {
                  _bufferSize = Infinity;
                }
                if (_windowTime === void 0) {
                  _windowTime = Infinity;
                }
                if (_timestampProvider === void 0) {
                  _timestampProvider = dateTimestampProvider_1.dateTimestampProvider;
                }
                var _this = _super.call(this) || this;
                _this._bufferSize = _bufferSize;
                _this._windowTime = _windowTime;
                _this._timestampProvider = _timestampProvider;
                _this._buffer = [];
                _this._infiniteTimeWindow = true;
                _this._infiniteTimeWindow = _windowTime === Infinity;
                _this._bufferSize = Math.max(1, _bufferSize);
                _this._windowTime = Math.max(1, _windowTime);
                return _this;
              }
              ReplaySubject2.prototype.next = function(value) {
                var _a = this, isStopped = _a.isStopped, _buffer = _a._buffer, _infiniteTimeWindow = _a._infiniteTimeWindow, _timestampProvider = _a._timestampProvider, _windowTime = _a._windowTime;
                if (!isStopped) {
                  _buffer.push(value);
                  !_infiniteTimeWindow && _buffer.push(_timestampProvider.now() + _windowTime);
                }
                this._trimBuffer();
                _super.prototype.next.call(this, value);
              };
              ReplaySubject2.prototype._subscribe = function(subscriber) {
                this._throwIfClosed();
                this._trimBuffer();
                var subscription = this._innerSubscribe(subscriber);
                var _a = this, _infiniteTimeWindow = _a._infiniteTimeWindow, _buffer = _a._buffer;
                var copy = _buffer.slice();
                for (var i2 = 0; i2 < copy.length && !subscriber.closed; i2 += _infiniteTimeWindow ? 1 : 2) {
                  subscriber.next(copy[i2]);
                }
                this._checkFinalizedStatuses(subscriber);
                return subscription;
              };
              ReplaySubject2.prototype._trimBuffer = function() {
                var _a = this, _bufferSize = _a._bufferSize, _timestampProvider = _a._timestampProvider, _buffer = _a._buffer, _infiniteTimeWindow = _a._infiniteTimeWindow;
                var adjustedBufferSize = (_infiniteTimeWindow ? 1 : 2) * _bufferSize;
                _bufferSize < Infinity && adjustedBufferSize < _buffer.length && _buffer.splice(0, _buffer.length - adjustedBufferSize);
                if (!_infiniteTimeWindow) {
                  var now = _timestampProvider.now();
                  var last = 0;
                  for (var i2 = 1; i2 < _buffer.length && _buffer[i2] <= now; i2 += 2) {
                    last = i2;
                  }
                  last && _buffer.splice(0, last + 1);
                }
              };
              return ReplaySubject2;
            }(Subject_1.Subject);
            exports2.ReplaySubject = ReplaySubject;
          }
        ),
        /***/
        3980: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.Scheduler = void 0;
            var dateTimestampProvider_1 = __webpack_require__2(1713);
            var Scheduler = function() {
              function Scheduler2(schedulerActionCtor, now) {
                if (now === void 0) {
                  now = Scheduler2.now;
                }
                this.schedulerActionCtor = schedulerActionCtor;
                this.now = now;
              }
              Scheduler2.prototype.schedule = function(work, delay, state) {
                if (delay === void 0) {
                  delay = 0;
                }
                return new this.schedulerActionCtor(this, work).schedule(state, delay);
              };
              Scheduler2.now = dateTimestampProvider_1.dateTimestampProvider.now;
              return Scheduler2;
            }();
            exports2.Scheduler = Scheduler;
          }
        ),
        /***/
        9520: (
          /***/
          function(__unused_webpack_module, exports2, __webpack_require__2) {
            "use strict";
            var __extends = this && this.__extends || /* @__PURE__ */ function() {
              var extendStatics = function(d, b) {
                extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                  d2.__proto__ = b2;
                } || function(d2, b2) {
                  for (var p in b2)
                    if (Object.prototype.hasOwnProperty.call(b2, p))
                      d2[p] = b2[p];
                };
                return extendStatics(d, b);
              };
              return function(d, b) {
                if (typeof b !== "function" && b !== null)
                  throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
                extendStatics(d, b);
                function __() {
                  this.constructor = d;
                }
                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
              };
            }();
            var __values = this && this.__values || function(o) {
              var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i2 = 0;
              if (m)
                return m.call(o);
              if (o && typeof o.length === "number")
                return {
                  next: function() {
                    if (o && i2 >= o.length)
                      o = void 0;
                    return { value: o && o[i2++], done: !o };
                  }
                };
              throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
            };
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.AnonymousSubject = exports2.Subject = void 0;
            var Observable_1 = __webpack_require__2(5271);
            var Subscription_1 = __webpack_require__2(7215);
            var ObjectUnsubscribedError_1 = __webpack_require__2(7392);
            var arrRemove_1 = __webpack_require__2(2447);
            var errorContext_1 = __webpack_require__2(4770);
            var Subject = function(_super) {
              __extends(Subject2, _super);
              function Subject2() {
                var _this = _super.call(this) || this;
                _this.closed = false;
                _this.currentObservers = null;
                _this.observers = [];
                _this.isStopped = false;
                _this.hasError = false;
                _this.thrownError = null;
                return _this;
              }
              Subject2.prototype.lift = function(operator) {
                var subject = new AnonymousSubject(this, this);
                subject.operator = operator;
                return subject;
              };
              Subject2.prototype._throwIfClosed = function() {
                if (this.closed) {
                  throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
                }
              };
              Subject2.prototype.next = function(value) {
                var _this = this;
                errorContext_1.errorContext(function() {
                  var e_1, _a;
                  _this._throwIfClosed();
                  if (!_this.isStopped) {
                    if (!_this.currentObservers) {
                      _this.currentObservers = Array.from(_this.observers);
                    }
                    try {
                      for (var _b = __values(_this.currentObservers), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var observer = _c.value;
                        observer.next(value);
                      }
                    } catch (e_1_1) {
                      e_1 = { error: e_1_1 };
                    } finally {
                      try {
                        if (_c && !_c.done && (_a = _b.return))
                          _a.call(_b);
                      } finally {
                        if (e_1)
                          throw e_1.error;
                      }
                    }
                  }
                });
              };
              Subject2.prototype.error = function(err) {
                var _this = this;
                errorContext_1.errorContext(function() {
                  _this._throwIfClosed();
                  if (!_this.isStopped) {
                    _this.hasError = _this.isStopped = true;
                    _this.thrownError = err;
                    var observers = _this.observers;
                    while (observers.length) {
                      observers.shift().error(err);
                    }
                  }
                });
              };
              Subject2.prototype.complete = function() {
                var _this = this;
                errorContext_1.errorContext(function() {
                  _this._throwIfClosed();
                  if (!_this.isStopped) {
                    _this.isStopped = true;
                    var observers = _this.observers;
                    while (observers.length) {
                      observers.shift().complete();
                    }
                  }
                });
              };
              Subject2.prototype.unsubscribe = function() {
                this.isStopped = this.closed = true;
                this.observers = this.currentObservers = null;
              };
              Object.defineProperty(Subject2.prototype, "observed", {
                get: function() {
                  var _a;
                  return ((_a = this.observers) === null || _a === void 0 ? void 0 : _a.length) > 0;
                },
                enumerable: false,
                configurable: true
              });
              Subject2.prototype._trySubscribe = function(subscriber) {
                this._throwIfClosed();
                return _super.prototype._trySubscribe.call(this, subscriber);
              };
              Subject2.prototype._subscribe = function(subscriber) {
                this._throwIfClosed();
                this._checkFinalizedStatuses(subscriber);
                return this._innerSubscribe(subscriber);
              };
              Subject2.prototype._innerSubscribe = function(subscriber) {
                var _this = this;
                var _a = this, hasError = _a.hasError, isStopped = _a.isStopped, observers = _a.observers;
                if (hasError || isStopped) {
                  return Subscription_1.EMPTY_SUBSCRIPTION;
                }
                this.currentObservers = null;
                observers.push(subscriber);
                return new Subscription_1.Subscription(function() {
                  _this.currentObservers = null;
                  arrRemove_1.arrRemove(observers, subscriber);
                });
              };
              Subject2.prototype._checkFinalizedStatuses = function(subscriber) {
                var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, isStopped = _a.isStopped;
                if (hasError) {
                  subscriber.error(thrownError);
                } else if (isStopped) {
                  subscriber.complete();
                }
              };
              Subject2.prototype.asObservable = function() {
                var observable = new Observable_1.Observable();
                observable.source = this;
                return observable;
              };
              Subject2.create = function(destination, source) {
                return new AnonymousSubject(destination, source);
              };
              return Subject2;
            }(Observable_1.Observable);
            exports2.Subject = Subject;
            var AnonymousSubject = function(_super) {
              __extends(AnonymousSubject2, _super);
              function AnonymousSubject2(destination, source) {
                var _this = _super.call(this) || this;
                _this.destination = destination;
                _this.source = source;
                return _this;
              }
              AnonymousSubject2.prototype.next = function(value) {
                var _a, _b;
                (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.next) === null || _b === void 0 ? void 0 : _b.call(_a, value);
              };
              AnonymousSubject2.prototype.error = function(err) {
                var _a, _b;
                (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.call(_a, err);
              };
              AnonymousSubject2.prototype.complete = function() {
                var _a, _b;
                (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.complete) === null || _b === void 0 ? void 0 : _b.call(_a);
              };
              AnonymousSubject2.prototype._subscribe = function(subscriber) {
                var _a, _b;
                return (_b = (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber)) !== null && _b !== void 0 ? _b : Subscription_1.EMPTY_SUBSCRIPTION;
              };
              return AnonymousSubject2;
            }(Subject);
            exports2.AnonymousSubject = AnonymousSubject;
          }
        ),
        /***/
        1403: (
          /***/
          function(__unused_webpack_module, exports2, __webpack_require__2) {
            "use strict";
            var __extends = this && this.__extends || /* @__PURE__ */ function() {
              var extendStatics = function(d, b) {
                extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                  d2.__proto__ = b2;
                } || function(d2, b2) {
                  for (var p in b2)
                    if (Object.prototype.hasOwnProperty.call(b2, p))
                      d2[p] = b2[p];
                };
                return extendStatics(d, b);
              };
              return function(d, b) {
                if (typeof b !== "function" && b !== null)
                  throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
                extendStatics(d, b);
                function __() {
                  this.constructor = d;
                }
                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
              };
            }();
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.EMPTY_OBSERVER = exports2.SafeSubscriber = exports2.Subscriber = void 0;
            var isFunction_1 = __webpack_require__2(4432);
            var Subscription_1 = __webpack_require__2(7215);
            var config_1 = __webpack_require__2(3782);
            var reportUnhandledError_1 = __webpack_require__2(7234);
            var noop_1 = __webpack_require__2(5729);
            var NotificationFactories_1 = __webpack_require__2(3380);
            var timeoutProvider_1 = __webpack_require__2(8972);
            var errorContext_1 = __webpack_require__2(4770);
            var Subscriber = function(_super) {
              __extends(Subscriber2, _super);
              function Subscriber2(destination) {
                var _this = _super.call(this) || this;
                _this.isStopped = false;
                if (destination) {
                  _this.destination = destination;
                  if (Subscription_1.isSubscription(destination)) {
                    destination.add(_this);
                  }
                } else {
                  _this.destination = exports2.EMPTY_OBSERVER;
                }
                return _this;
              }
              Subscriber2.create = function(next, error, complete) {
                return new SafeSubscriber(next, error, complete);
              };
              Subscriber2.prototype.next = function(value) {
                if (this.isStopped) {
                  handleStoppedNotification(NotificationFactories_1.nextNotification(value), this);
                } else {
                  this._next(value);
                }
              };
              Subscriber2.prototype.error = function(err) {
                if (this.isStopped) {
                  handleStoppedNotification(NotificationFactories_1.errorNotification(err), this);
                } else {
                  this.isStopped = true;
                  this._error(err);
                }
              };
              Subscriber2.prototype.complete = function() {
                if (this.isStopped) {
                  handleStoppedNotification(NotificationFactories_1.COMPLETE_NOTIFICATION, this);
                } else {
                  this.isStopped = true;
                  this._complete();
                }
              };
              Subscriber2.prototype.unsubscribe = function() {
                if (!this.closed) {
                  this.isStopped = true;
                  _super.prototype.unsubscribe.call(this);
                  this.destination = null;
                }
              };
              Subscriber2.prototype._next = function(value) {
                this.destination.next(value);
              };
              Subscriber2.prototype._error = function(err) {
                try {
                  this.destination.error(err);
                } finally {
                  this.unsubscribe();
                }
              };
              Subscriber2.prototype._complete = function() {
                try {
                  this.destination.complete();
                } finally {
                  this.unsubscribe();
                }
              };
              return Subscriber2;
            }(Subscription_1.Subscription);
            exports2.Subscriber = Subscriber;
            var _bind = Function.prototype.bind;
            function bind(fn, thisArg) {
              return _bind.call(fn, thisArg);
            }
            var ConsumerObserver = function() {
              function ConsumerObserver2(partialObserver) {
                this.partialObserver = partialObserver;
              }
              ConsumerObserver2.prototype.next = function(value) {
                var partialObserver = this.partialObserver;
                if (partialObserver.next) {
                  try {
                    partialObserver.next(value);
                  } catch (error) {
                    handleUnhandledError(error);
                  }
                }
              };
              ConsumerObserver2.prototype.error = function(err) {
                var partialObserver = this.partialObserver;
                if (partialObserver.error) {
                  try {
                    partialObserver.error(err);
                  } catch (error) {
                    handleUnhandledError(error);
                  }
                } else {
                  handleUnhandledError(err);
                }
              };
              ConsumerObserver2.prototype.complete = function() {
                var partialObserver = this.partialObserver;
                if (partialObserver.complete) {
                  try {
                    partialObserver.complete();
                  } catch (error) {
                    handleUnhandledError(error);
                  }
                }
              };
              return ConsumerObserver2;
            }();
            var SafeSubscriber = function(_super) {
              __extends(SafeSubscriber2, _super);
              function SafeSubscriber2(observerOrNext, error, complete) {
                var _this = _super.call(this) || this;
                var partialObserver;
                if (isFunction_1.isFunction(observerOrNext) || !observerOrNext) {
                  partialObserver = {
                    next: observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : void 0,
                    error: error !== null && error !== void 0 ? error : void 0,
                    complete: complete !== null && complete !== void 0 ? complete : void 0
                  };
                } else {
                  var context_1;
                  if (_this && config_1.config.useDeprecatedNextContext) {
                    context_1 = Object.create(observerOrNext);
                    context_1.unsubscribe = function() {
                      return _this.unsubscribe();
                    };
                    partialObserver = {
                      next: observerOrNext.next && bind(observerOrNext.next, context_1),
                      error: observerOrNext.error && bind(observerOrNext.error, context_1),
                      complete: observerOrNext.complete && bind(observerOrNext.complete, context_1)
                    };
                  } else {
                    partialObserver = observerOrNext;
                  }
                }
                _this.destination = new ConsumerObserver(partialObserver);
                return _this;
              }
              return SafeSubscriber2;
            }(Subscriber);
            exports2.SafeSubscriber = SafeSubscriber;
            function handleUnhandledError(error) {
              if (config_1.config.useDeprecatedSynchronousErrorHandling) {
                errorContext_1.captureError(error);
              } else {
                reportUnhandledError_1.reportUnhandledError(error);
              }
            }
            function defaultErrorHandler(err) {
              throw err;
            }
            function handleStoppedNotification(notification, subscriber) {
              var onStoppedNotification = config_1.config.onStoppedNotification;
              onStoppedNotification && timeoutProvider_1.timeoutProvider.setTimeout(function() {
                return onStoppedNotification(notification, subscriber);
              });
            }
            exports2.EMPTY_OBSERVER = {
              closed: true,
              next: noop_1.noop,
              error: defaultErrorHandler,
              complete: noop_1.noop
            };
          }
        ),
        /***/
        7215: (
          /***/
          function(__unused_webpack_module, exports2, __webpack_require__2) {
            "use strict";
            var __values = this && this.__values || function(o) {
              var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i2 = 0;
              if (m)
                return m.call(o);
              if (o && typeof o.length === "number")
                return {
                  next: function() {
                    if (o && i2 >= o.length)
                      o = void 0;
                    return { value: o && o[i2++], done: !o };
                  }
                };
              throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
            };
            var __read = this && this.__read || function(o, n) {
              var m = typeof Symbol === "function" && o[Symbol.iterator];
              if (!m)
                return o;
              var i2 = m.call(o), r, ar = [], e;
              try {
                while ((n === void 0 || n-- > 0) && !(r = i2.next()).done)
                  ar.push(r.value);
              } catch (error) {
                e = { error };
              } finally {
                try {
                  if (r && !r.done && (m = i2["return"]))
                    m.call(i2);
                } finally {
                  if (e)
                    throw e.error;
                }
              }
              return ar;
            };
            var __spreadArray2 = this && this.__spreadArray || function(to, from) {
              for (var i2 = 0, il = from.length, j = to.length; i2 < il; i2++, j++)
                to[j] = from[i2];
              return to;
            };
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.isSubscription = exports2.EMPTY_SUBSCRIPTION = exports2.Subscription = void 0;
            var isFunction_1 = __webpack_require__2(4432);
            var UnsubscriptionError_1 = __webpack_require__2(5463);
            var arrRemove_1 = __webpack_require__2(2447);
            var Subscription = function() {
              function Subscription2(initialTeardown) {
                this.initialTeardown = initialTeardown;
                this.closed = false;
                this._parentage = null;
                this._finalizers = null;
              }
              Subscription2.prototype.unsubscribe = function() {
                var e_1, _a, e_2, _b;
                var errors;
                if (!this.closed) {
                  this.closed = true;
                  var _parentage = this._parentage;
                  if (_parentage) {
                    this._parentage = null;
                    if (Array.isArray(_parentage)) {
                      try {
                        for (var _parentage_1 = __values(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {
                          var parent_1 = _parentage_1_1.value;
                          parent_1.remove(this);
                        }
                      } catch (e_1_1) {
                        e_1 = { error: e_1_1 };
                      } finally {
                        try {
                          if (_parentage_1_1 && !_parentage_1_1.done && (_a = _parentage_1.return))
                            _a.call(_parentage_1);
                        } finally {
                          if (e_1)
                            throw e_1.error;
                        }
                      }
                    } else {
                      _parentage.remove(this);
                    }
                  }
                  var initialFinalizer = this.initialTeardown;
                  if (isFunction_1.isFunction(initialFinalizer)) {
                    try {
                      initialFinalizer();
                    } catch (e) {
                      errors = e instanceof UnsubscriptionError_1.UnsubscriptionError ? e.errors : [e];
                    }
                  }
                  var _finalizers = this._finalizers;
                  if (_finalizers) {
                    this._finalizers = null;
                    try {
                      for (var _finalizers_1 = __values(_finalizers), _finalizers_1_1 = _finalizers_1.next(); !_finalizers_1_1.done; _finalizers_1_1 = _finalizers_1.next()) {
                        var finalizer = _finalizers_1_1.value;
                        try {
                          execFinalizer(finalizer);
                        } catch (err) {
                          errors = errors !== null && errors !== void 0 ? errors : [];
                          if (err instanceof UnsubscriptionError_1.UnsubscriptionError) {
                            errors = __spreadArray2(__spreadArray2([], __read(errors)), __read(err.errors));
                          } else {
                            errors.push(err);
                          }
                        }
                      }
                    } catch (e_2_1) {
                      e_2 = { error: e_2_1 };
                    } finally {
                      try {
                        if (_finalizers_1_1 && !_finalizers_1_1.done && (_b = _finalizers_1.return))
                          _b.call(_finalizers_1);
                      } finally {
                        if (e_2)
                          throw e_2.error;
                      }
                    }
                  }
                  if (errors) {
                    throw new UnsubscriptionError_1.UnsubscriptionError(errors);
                  }
                }
              };
              Subscription2.prototype.add = function(teardown) {
                var _a;
                if (teardown && teardown !== this) {
                  if (this.closed) {
                    execFinalizer(teardown);
                  } else {
                    if (teardown instanceof Subscription2) {
                      if (teardown.closed || teardown._hasParent(this)) {
                        return;
                      }
                      teardown._addParent(this);
                    }
                    (this._finalizers = (_a = this._finalizers) !== null && _a !== void 0 ? _a : []).push(teardown);
                  }
                }
              };
              Subscription2.prototype._hasParent = function(parent) {
                var _parentage = this._parentage;
                return _parentage === parent || Array.isArray(_parentage) && _parentage.includes(parent);
              };
              Subscription2.prototype._addParent = function(parent) {
                var _parentage = this._parentage;
                this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
              };
              Subscription2.prototype._removeParent = function(parent) {
                var _parentage = this._parentage;
                if (_parentage === parent) {
                  this._parentage = null;
                } else if (Array.isArray(_parentage)) {
                  arrRemove_1.arrRemove(_parentage, parent);
                }
              };
              Subscription2.prototype.remove = function(teardown) {
                var _finalizers = this._finalizers;
                _finalizers && arrRemove_1.arrRemove(_finalizers, teardown);
                if (teardown instanceof Subscription2) {
                  teardown._removeParent(this);
                }
              };
              Subscription2.EMPTY = function() {
                var empty = new Subscription2();
                empty.closed = true;
                return empty;
              }();
              return Subscription2;
            }();
            exports2.Subscription = Subscription;
            exports2.EMPTY_SUBSCRIPTION = Subscription.EMPTY;
            function isSubscription(value) {
              return value instanceof Subscription || value && "closed" in value && isFunction_1.isFunction(value.remove) && isFunction_1.isFunction(value.add) && isFunction_1.isFunction(value.unsubscribe);
            }
            exports2.isSubscription = isSubscription;
            function execFinalizer(finalizer) {
              if (isFunction_1.isFunction(finalizer)) {
                finalizer();
              } else {
                finalizer.unsubscribe();
              }
            }
          }
        ),
        /***/
        3782: (
          /***/
          (__unused_webpack_module, exports2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.config = void 0;
            exports2.config = {
              onUnhandledError: null,
              onStoppedNotification: null,
              Promise: void 0,
              useDeprecatedSynchronousErrorHandling: false,
              useDeprecatedNextContext: false
            };
          }
        ),
        /***/
        3739: (
          /***/
          function(__unused_webpack_module, exports2, __webpack_require__2) {
            "use strict";
            var __extends = this && this.__extends || /* @__PURE__ */ function() {
              var extendStatics = function(d, b) {
                extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                  d2.__proto__ = b2;
                } || function(d2, b2) {
                  for (var p in b2)
                    if (Object.prototype.hasOwnProperty.call(b2, p))
                      d2[p] = b2[p];
                };
                return extendStatics(d, b);
              };
              return function(d, b) {
                if (typeof b !== "function" && b !== null)
                  throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
                extendStatics(d, b);
                function __() {
                  this.constructor = d;
                }
                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
              };
            }();
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.ConnectableObservable = void 0;
            var Observable_1 = __webpack_require__2(5271);
            var Subscription_1 = __webpack_require__2(7215);
            var refCount_1 = __webpack_require__2(2711);
            var OperatorSubscriber_1 = __webpack_require__2(5079);
            var lift_1 = __webpack_require__2(4024);
            var ConnectableObservable = function(_super) {
              __extends(ConnectableObservable2, _super);
              function ConnectableObservable2(source, subjectFactory) {
                var _this = _super.call(this) || this;
                _this.source = source;
                _this.subjectFactory = subjectFactory;
                _this._subject = null;
                _this._refCount = 0;
                _this._connection = null;
                if (lift_1.hasLift(source)) {
                  _this.lift = source.lift;
                }
                return _this;
              }
              ConnectableObservable2.prototype._subscribe = function(subscriber) {
                return this.getSubject().subscribe(subscriber);
              };
              ConnectableObservable2.prototype.getSubject = function() {
                var subject = this._subject;
                if (!subject || subject.isStopped) {
                  this._subject = this.subjectFactory();
                }
                return this._subject;
              };
              ConnectableObservable2.prototype._teardown = function() {
                this._refCount = 0;
                var _connection = this._connection;
                this._subject = this._connection = null;
                _connection === null || _connection === void 0 ? void 0 : _connection.unsubscribe();
              };
              ConnectableObservable2.prototype.connect = function() {
                var _this = this;
                var connection = this._connection;
                if (!connection) {
                  connection = this._connection = new Subscription_1.Subscription();
                  var subject_1 = this.getSubject();
                  connection.add(this.source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subject_1, void 0, function() {
                    _this._teardown();
                    subject_1.complete();
                  }, function(err) {
                    _this._teardown();
                    subject_1.error(err);
                  }, function() {
                    return _this._teardown();
                  })));
                  if (connection.closed) {
                    this._connection = null;
                    connection = Subscription_1.Subscription.EMPTY;
                  }
                }
                return connection;
              };
              ConnectableObservable2.prototype.refCount = function() {
                return refCount_1.refCount()(this);
              };
              return ConnectableObservable2;
            }(Observable_1.Observable);
            exports2.ConnectableObservable = ConnectableObservable;
          }
        ),
        /***/
        1047: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.combineLatestInit = exports2.combineLatest = void 0;
            var Observable_1 = __webpack_require__2(5271);
            var argsArgArrayOrObject_1 = __webpack_require__2(4744);
            var from_1 = __webpack_require__2(6216);
            var identity_1 = __webpack_require__2(9144);
            var mapOneOrManyArgs_1 = __webpack_require__2(4666);
            var args_1 = __webpack_require__2(2619);
            var createObject_1 = __webpack_require__2(1589);
            var OperatorSubscriber_1 = __webpack_require__2(5079);
            var executeSchedule_1 = __webpack_require__2(5421);
            function combineLatest() {
              var args = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
              }
              var scheduler = args_1.popScheduler(args);
              var resultSelector = args_1.popResultSelector(args);
              var _a = argsArgArrayOrObject_1.argsArgArrayOrObject(args), observables = _a.args, keys = _a.keys;
              if (observables.length === 0) {
                return from_1.from([], scheduler);
              }
              var result = new Observable_1.Observable(combineLatestInit(observables, scheduler, keys ? function(values) {
                return createObject_1.createObject(keys, values);
              } : identity_1.identity));
              return resultSelector ? result.pipe(mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector)) : result;
            }
            exports2.combineLatest = combineLatest;
            function combineLatestInit(observables, scheduler, valueTransform) {
              if (valueTransform === void 0) {
                valueTransform = identity_1.identity;
              }
              return function(subscriber) {
                maybeSchedule(scheduler, function() {
                  var length = observables.length;
                  var values = new Array(length);
                  var active = length;
                  var remainingFirstValues = length;
                  var _loop_1 = function(i3) {
                    maybeSchedule(scheduler, function() {
                      var source = from_1.from(observables[i3], scheduler);
                      var hasFirstValue = false;
                      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
                        values[i3] = value;
                        if (!hasFirstValue) {
                          hasFirstValue = true;
                          remainingFirstValues--;
                        }
                        if (!remainingFirstValues) {
                          subscriber.next(valueTransform(values.slice()));
                        }
                      }, function() {
                        if (!--active) {
                          subscriber.complete();
                        }
                      }));
                    }, subscriber);
                  };
                  for (var i2 = 0; i2 < length; i2++) {
                    _loop_1(i2);
                  }
                }, subscriber);
              };
            }
            exports2.combineLatestInit = combineLatestInit;
            function maybeSchedule(scheduler, execute, subscription) {
              if (scheduler) {
                executeSchedule_1.executeSchedule(subscription, scheduler, execute);
              } else {
                execute();
              }
            }
          }
        ),
        /***/
        79: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.concat = void 0;
            var concatAll_1 = __webpack_require__2(4554);
            var args_1 = __webpack_require__2(2619);
            var from_1 = __webpack_require__2(6216);
            function concat() {
              var args = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
              }
              return concatAll_1.concatAll()(from_1.from(args, args_1.popScheduler(args)));
            }
            exports2.concat = concat;
          }
        ),
        /***/
        1727: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.empty = exports2.EMPTY = void 0;
            var Observable_1 = __webpack_require__2(5271);
            exports2.EMPTY = new Observable_1.Observable(function(subscriber) {
              return subscriber.complete();
            });
            function empty(scheduler) {
              return scheduler ? emptyScheduled(scheduler) : exports2.EMPTY;
            }
            exports2.empty = empty;
            function emptyScheduled(scheduler) {
              return new Observable_1.Observable(function(subscriber) {
                return scheduler.schedule(function() {
                  return subscriber.complete();
                });
              });
            }
          }
        ),
        /***/
        6216: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.from = void 0;
            var scheduled_1 = __webpack_require__2(3200);
            var innerFrom_1 = __webpack_require__2(9451);
            function from(input, scheduler) {
              return scheduler ? scheduled_1.scheduled(input, scheduler) : innerFrom_1.innerFrom(input);
            }
            exports2.from = from;
          }
        ),
        /***/
        2160: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.fromSubscribable = void 0;
            var Observable_1 = __webpack_require__2(5271);
            function fromSubscribable(subscribable) {
              return new Observable_1.Observable(function(subscriber) {
                return subscribable.subscribe(subscriber);
              });
            }
            exports2.fromSubscribable = fromSubscribable;
          }
        ),
        /***/
        9451: (
          /***/
          function(__unused_webpack_module, exports2, __webpack_require__2) {
            "use strict";
            var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
              function adopt(value) {
                return value instanceof P ? value : new P(function(resolve) {
                  resolve(value);
                });
              }
              return new (P || (P = Promise))(function(resolve, reject) {
                function fulfilled(value) {
                  try {
                    step(generator.next(value));
                  } catch (e) {
                    reject(e);
                  }
                }
                function rejected(value) {
                  try {
                    step(generator["throw"](value));
                  } catch (e) {
                    reject(e);
                  }
                }
                function step(result) {
                  result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
                }
                step((generator = generator.apply(thisArg, _arguments || [])).next());
              });
            };
            var __generator = this && this.__generator || function(thisArg, body) {
              var _ = { label: 0, sent: function() {
                if (t[0] & 1)
                  throw t[1];
                return t[1];
              }, trys: [], ops: [] }, f, y, t, g;
              return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
                return this;
              }), g;
              function verb(n) {
                return function(v) {
                  return step([n, v]);
                };
              }
              function step(op) {
                if (f)
                  throw new TypeError("Generator is already executing.");
                while (_)
                  try {
                    if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                      return t;
                    if (y = 0, t)
                      op = [op[0] & 2, t.value];
                    switch (op[0]) {
                      case 0:
                      case 1:
                        t = op;
                        break;
                      case 4:
                        _.label++;
                        return { value: op[1], done: false };
                      case 5:
                        _.label++;
                        y = op[1];
                        op = [0];
                        continue;
                      case 7:
                        op = _.ops.pop();
                        _.trys.pop();
                        continue;
                      default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                          _ = 0;
                          continue;
                        }
                        if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                          _.label = op[1];
                          break;
                        }
                        if (op[0] === 6 && _.label < t[1]) {
                          _.label = t[1];
                          t = op;
                          break;
                        }
                        if (t && _.label < t[2]) {
                          _.label = t[2];
                          _.ops.push(op);
                          break;
                        }
                        if (t[2])
                          _.ops.pop();
                        _.trys.pop();
                        continue;
                    }
                    op = body.call(thisArg, _);
                  } catch (e) {
                    op = [6, e];
                    y = 0;
                  } finally {
                    f = t = 0;
                  }
                if (op[0] & 5)
                  throw op[1];
                return { value: op[0] ? op[1] : void 0, done: true };
              }
            };
            var __asyncValues = this && this.__asyncValues || function(o) {
              if (!Symbol.asyncIterator)
                throw new TypeError("Symbol.asyncIterator is not defined.");
              var m = o[Symbol.asyncIterator], i2;
              return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
                return this;
              }, i2);
              function verb(n) {
                i2[n] = o[n] && function(v) {
                  return new Promise(function(resolve, reject) {
                    v = o[n](v), settle(resolve, reject, v.done, v.value);
                  });
                };
              }
              function settle(resolve, reject, d, v) {
                Promise.resolve(v).then(function(v2) {
                  resolve({ value: v2, done: d });
                }, reject);
              }
            };
            var __values = this && this.__values || function(o) {
              var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i2 = 0;
              if (m)
                return m.call(o);
              if (o && typeof o.length === "number")
                return {
                  next: function() {
                    if (o && i2 >= o.length)
                      o = void 0;
                    return { value: o && o[i2++], done: !o };
                  }
                };
              throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
            };
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.fromReadableStreamLike = exports2.fromAsyncIterable = exports2.fromIterable = exports2.fromPromise = exports2.fromArrayLike = exports2.fromInteropObservable = exports2.innerFrom = void 0;
            var isArrayLike_1 = __webpack_require__2(8219);
            var isPromise_1 = __webpack_require__2(2644);
            var Observable_1 = __webpack_require__2(5271);
            var isInteropObservable_1 = __webpack_require__2(3292);
            var isAsyncIterable_1 = __webpack_require__2(7707);
            var throwUnobservableError_1 = __webpack_require__2(4883);
            var isIterable_1 = __webpack_require__2(6380);
            var isReadableStreamLike_1 = __webpack_require__2(9266);
            var isFunction_1 = __webpack_require__2(4432);
            var reportUnhandledError_1 = __webpack_require__2(7234);
            var observable_1 = __webpack_require__2(2138);
            function innerFrom(input) {
              if (input instanceof Observable_1.Observable) {
                return input;
              }
              if (input != null) {
                if (isInteropObservable_1.isInteropObservable(input)) {
                  return fromInteropObservable(input);
                }
                if (isArrayLike_1.isArrayLike(input)) {
                  return fromArrayLike(input);
                }
                if (isPromise_1.isPromise(input)) {
                  return fromPromise(input);
                }
                if (isAsyncIterable_1.isAsyncIterable(input)) {
                  return fromAsyncIterable(input);
                }
                if (isIterable_1.isIterable(input)) {
                  return fromIterable(input);
                }
                if (isReadableStreamLike_1.isReadableStreamLike(input)) {
                  return fromReadableStreamLike(input);
                }
              }
              throw throwUnobservableError_1.createInvalidObservableTypeError(input);
            }
            exports2.innerFrom = innerFrom;
            function fromInteropObservable(obj) {
              return new Observable_1.Observable(function(subscriber) {
                var obs = obj[observable_1.observable]();
                if (isFunction_1.isFunction(obs.subscribe)) {
                  return obs.subscribe(subscriber);
                }
                throw new TypeError("Provided object does not correctly implement Symbol.observable");
              });
            }
            exports2.fromInteropObservable = fromInteropObservable;
            function fromArrayLike(array) {
              return new Observable_1.Observable(function(subscriber) {
                for (var i2 = 0; i2 < array.length && !subscriber.closed; i2++) {
                  subscriber.next(array[i2]);
                }
                subscriber.complete();
              });
            }
            exports2.fromArrayLike = fromArrayLike;
            function fromPromise(promise) {
              return new Observable_1.Observable(function(subscriber) {
                promise.then(function(value) {
                  if (!subscriber.closed) {
                    subscriber.next(value);
                    subscriber.complete();
                  }
                }, function(err) {
                  return subscriber.error(err);
                }).then(null, reportUnhandledError_1.reportUnhandledError);
              });
            }
            exports2.fromPromise = fromPromise;
            function fromIterable(iterable) {
              return new Observable_1.Observable(function(subscriber) {
                var e_1, _a;
                try {
                  for (var iterable_1 = __values(iterable), iterable_1_1 = iterable_1.next(); !iterable_1_1.done; iterable_1_1 = iterable_1.next()) {
                    var value = iterable_1_1.value;
                    subscriber.next(value);
                    if (subscriber.closed) {
                      return;
                    }
                  }
                } catch (e_1_1) {
                  e_1 = { error: e_1_1 };
                } finally {
                  try {
                    if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return))
                      _a.call(iterable_1);
                  } finally {
                    if (e_1)
                      throw e_1.error;
                  }
                }
                subscriber.complete();
              });
            }
            exports2.fromIterable = fromIterable;
            function fromAsyncIterable(asyncIterable) {
              return new Observable_1.Observable(function(subscriber) {
                process2(asyncIterable, subscriber).catch(function(err) {
                  return subscriber.error(err);
                });
              });
            }
            exports2.fromAsyncIterable = fromAsyncIterable;
            function fromReadableStreamLike(readableStream) {
              return fromAsyncIterable(isReadableStreamLike_1.readableStreamLikeToAsyncGenerator(readableStream));
            }
            exports2.fromReadableStreamLike = fromReadableStreamLike;
            function process2(asyncIterable, subscriber) {
              var asyncIterable_1, asyncIterable_1_1;
              var e_2, _a;
              return __awaiter(this, void 0, void 0, function() {
                var value, e_2_1;
                return __generator(this, function(_b) {
                  switch (_b.label) {
                    case 0:
                      _b.trys.push([0, 5, 6, 11]);
                      asyncIterable_1 = __asyncValues(asyncIterable);
                      _b.label = 1;
                    case 1:
                      return [4, asyncIterable_1.next()];
                    case 2:
                      if (!(asyncIterable_1_1 = _b.sent(), !asyncIterable_1_1.done))
                        return [3, 4];
                      value = asyncIterable_1_1.value;
                      subscriber.next(value);
                      if (subscriber.closed) {
                        return [2];
                      }
                      _b.label = 3;
                    case 3:
                      return [3, 1];
                    case 4:
                      return [3, 11];
                    case 5:
                      e_2_1 = _b.sent();
                      e_2 = { error: e_2_1 };
                      return [3, 11];
                    case 6:
                      _b.trys.push([6, , 9, 10]);
                      if (!(asyncIterable_1_1 && !asyncIterable_1_1.done && (_a = asyncIterable_1.return)))
                        return [3, 8];
                      return [4, _a.call(asyncIterable_1)];
                    case 7:
                      _b.sent();
                      _b.label = 8;
                    case 8:
                      return [3, 10];
                    case 9:
                      if (e_2)
                        throw e_2.error;
                      return [7];
                    case 10:
                      return [7];
                    case 11:
                      subscriber.complete();
                      return [2];
                  }
                });
              });
            }
          }
        ),
        /***/
        4449: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.interval = void 0;
            var async_1 = __webpack_require__2(4617);
            var timer_1 = __webpack_require__2(5710);
            function interval(period, scheduler) {
              if (period === void 0) {
                period = 0;
              }
              if (scheduler === void 0) {
                scheduler = async_1.asyncScheduler;
              }
              if (period < 0) {
                period = 0;
              }
              return timer_1.timer(period, period, scheduler);
            }
            exports2.interval = interval;
          }
        ),
        /***/
        7443: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.of = void 0;
            var args_1 = __webpack_require__2(2619);
            var from_1 = __webpack_require__2(6216);
            function of() {
              var args = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
              }
              var scheduler = args_1.popScheduler(args);
              return from_1.from(args, scheduler);
            }
            exports2.of = of;
          }
        ),
        /***/
        1282: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.onErrorResumeNext = void 0;
            var Observable_1 = __webpack_require__2(5271);
            var argsOrArgArray_1 = __webpack_require__2(4475);
            var OperatorSubscriber_1 = __webpack_require__2(5079);
            var noop_1 = __webpack_require__2(5729);
            var innerFrom_1 = __webpack_require__2(9451);
            function onErrorResumeNext() {
              var sources = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                sources[_i] = arguments[_i];
              }
              var nextSources = argsOrArgArray_1.argsOrArgArray(sources);
              return new Observable_1.Observable(function(subscriber) {
                var sourceIndex = 0;
                var subscribeNext = function() {
                  if (sourceIndex < nextSources.length) {
                    var nextSource = void 0;
                    try {
                      nextSource = innerFrom_1.innerFrom(nextSources[sourceIndex++]);
                    } catch (err) {
                      subscribeNext();
                      return;
                    }
                    var innerSubscriber = new OperatorSubscriber_1.OperatorSubscriber(subscriber, void 0, noop_1.noop, noop_1.noop);
                    nextSource.subscribe(innerSubscriber);
                    innerSubscriber.add(subscribeNext);
                  } else {
                    subscriber.complete();
                  }
                };
                subscribeNext();
              });
            }
            exports2.onErrorResumeNext = onErrorResumeNext;
          }
        ),
        /***/
        7779: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.raceInit = exports2.race = void 0;
            var Observable_1 = __webpack_require__2(5271);
            var innerFrom_1 = __webpack_require__2(9451);
            var argsOrArgArray_1 = __webpack_require__2(4475);
            var OperatorSubscriber_1 = __webpack_require__2(5079);
            function race() {
              var sources = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                sources[_i] = arguments[_i];
              }
              sources = argsOrArgArray_1.argsOrArgArray(sources);
              return sources.length === 1 ? innerFrom_1.innerFrom(sources[0]) : new Observable_1.Observable(raceInit(sources));
            }
            exports2.race = race;
            function raceInit(sources) {
              return function(subscriber) {
                var subscriptions = [];
                var _loop_1 = function(i3) {
                  subscriptions.push(innerFrom_1.innerFrom(sources[i3]).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
                    if (subscriptions) {
                      for (var s = 0; s < subscriptions.length; s++) {
                        s !== i3 && subscriptions[s].unsubscribe();
                      }
                      subscriptions = null;
                    }
                    subscriber.next(value);
                  })));
                };
                for (var i2 = 0; subscriptions && !subscriber.closed && i2 < sources.length; i2++) {
                  _loop_1(i2);
                }
              };
            }
            exports2.raceInit = raceInit;
          }
        ),
        /***/
        859: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.throwError = void 0;
            var Observable_1 = __webpack_require__2(5271);
            var isFunction_1 = __webpack_require__2(4432);
            function throwError(errorOrErrorFactory, scheduler) {
              var errorFactory = isFunction_1.isFunction(errorOrErrorFactory) ? errorOrErrorFactory : function() {
                return errorOrErrorFactory;
              };
              var init = function(subscriber) {
                return subscriber.error(errorFactory());
              };
              return new Observable_1.Observable(scheduler ? function(subscriber) {
                return scheduler.schedule(init, 0, subscriber);
              } : init);
            }
            exports2.throwError = throwError;
          }
        ),
        /***/
        5710: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.timer = void 0;
            var Observable_1 = __webpack_require__2(5271);
            var async_1 = __webpack_require__2(4617);
            var isScheduler_1 = __webpack_require__2(6551);
            var isDate_1 = __webpack_require__2(7761);
            function timer(dueTime, intervalOrScheduler, scheduler) {
              if (dueTime === void 0) {
                dueTime = 0;
              }
              if (scheduler === void 0) {
                scheduler = async_1.async;
              }
              var intervalDuration = -1;
              if (intervalOrScheduler != null) {
                if (isScheduler_1.isScheduler(intervalOrScheduler)) {
                  scheduler = intervalOrScheduler;
                } else {
                  intervalDuration = intervalOrScheduler;
                }
              }
              return new Observable_1.Observable(function(subscriber) {
                var due = isDate_1.isValidDate(dueTime) ? +dueTime - scheduler.now() : dueTime;
                if (due < 0) {
                  due = 0;
                }
                var n = 0;
                return scheduler.schedule(function() {
                  if (!subscriber.closed) {
                    subscriber.next(n++);
                    if (0 <= intervalDuration) {
                      this.schedule(void 0, intervalDuration);
                    } else {
                      subscriber.complete();
                    }
                  }
                }, due);
              });
            }
            exports2.timer = timer;
          }
        ),
        /***/
        2042: (
          /***/
          function(__unused_webpack_module, exports2, __webpack_require__2) {
            "use strict";
            var __read = this && this.__read || function(o, n) {
              var m = typeof Symbol === "function" && o[Symbol.iterator];
              if (!m)
                return o;
              var i2 = m.call(o), r, ar = [], e;
              try {
                while ((n === void 0 || n-- > 0) && !(r = i2.next()).done)
                  ar.push(r.value);
              } catch (error) {
                e = { error };
              } finally {
                try {
                  if (r && !r.done && (m = i2["return"]))
                    m.call(i2);
                } finally {
                  if (e)
                    throw e.error;
                }
              }
              return ar;
            };
            var __spreadArray2 = this && this.__spreadArray || function(to, from) {
              for (var i2 = 0, il = from.length, j = to.length; i2 < il; i2++, j++)
                to[j] = from[i2];
              return to;
            };
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.zip = void 0;
            var Observable_1 = __webpack_require__2(5271);
            var innerFrom_1 = __webpack_require__2(9451);
            var argsOrArgArray_1 = __webpack_require__2(4475);
            var empty_1 = __webpack_require__2(1727);
            var OperatorSubscriber_1 = __webpack_require__2(5079);
            var args_1 = __webpack_require__2(2619);
            function zip() {
              var args = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
              }
              var resultSelector = args_1.popResultSelector(args);
              var sources = argsOrArgArray_1.argsOrArgArray(args);
              return sources.length ? new Observable_1.Observable(function(subscriber) {
                var buffers = sources.map(function() {
                  return [];
                });
                var completed = sources.map(function() {
                  return false;
                });
                subscriber.add(function() {
                  buffers = completed = null;
                });
                var _loop_1 = function(sourceIndex2) {
                  innerFrom_1.innerFrom(sources[sourceIndex2]).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
                    buffers[sourceIndex2].push(value);
                    if (buffers.every(function(buffer) {
                      return buffer.length;
                    })) {
                      var result = buffers.map(function(buffer) {
                        return buffer.shift();
                      });
                      subscriber.next(resultSelector ? resultSelector.apply(void 0, __spreadArray2([], __read(result))) : result);
                      if (buffers.some(function(buffer, i2) {
                        return !buffer.length && completed[i2];
                      })) {
                        subscriber.complete();
                      }
                    }
                  }, function() {
                    completed[sourceIndex2] = true;
                    !buffers[sourceIndex2].length && subscriber.complete();
                  }));
                };
                for (var sourceIndex = 0; !subscriber.closed && sourceIndex < sources.length; sourceIndex++) {
                  _loop_1(sourceIndex);
                }
                return function() {
                  buffers = completed = null;
                };
              }) : empty_1.EMPTY;
            }
            exports2.zip = zip;
          }
        ),
        /***/
        5079: (
          /***/
          function(__unused_webpack_module, exports2, __webpack_require__2) {
            "use strict";
            var __extends = this && this.__extends || /* @__PURE__ */ function() {
              var extendStatics = function(d, b) {
                extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                  d2.__proto__ = b2;
                } || function(d2, b2) {
                  for (var p in b2)
                    if (Object.prototype.hasOwnProperty.call(b2, p))
                      d2[p] = b2[p];
                };
                return extendStatics(d, b);
              };
              return function(d, b) {
                if (typeof b !== "function" && b !== null)
                  throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
                extendStatics(d, b);
                function __() {
                  this.constructor = d;
                }
                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
              };
            }();
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.OperatorSubscriber = exports2.createOperatorSubscriber = void 0;
            var Subscriber_1 = __webpack_require__2(1403);
            function createOperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {
              return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);
            }
            exports2.createOperatorSubscriber = createOperatorSubscriber;
            var OperatorSubscriber = function(_super) {
              __extends(OperatorSubscriber2, _super);
              function OperatorSubscriber2(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {
                var _this = _super.call(this, destination) || this;
                _this.onFinalize = onFinalize;
                _this.shouldUnsubscribe = shouldUnsubscribe;
                _this._next = onNext ? function(value) {
                  try {
                    onNext(value);
                  } catch (err) {
                    destination.error(err);
                  }
                } : _super.prototype._next;
                _this._error = onError ? function(err) {
                  try {
                    onError(err);
                  } catch (err2) {
                    destination.error(err2);
                  } finally {
                    this.unsubscribe();
                  }
                } : _super.prototype._error;
                _this._complete = onComplete ? function() {
                  try {
                    onComplete();
                  } catch (err) {
                    destination.error(err);
                  } finally {
                    this.unsubscribe();
                  }
                } : _super.prototype._complete;
                return _this;
              }
              OperatorSubscriber2.prototype.unsubscribe = function() {
                var _a;
                if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
                  var closed_1 = this.closed;
                  _super.prototype.unsubscribe.call(this);
                  !closed_1 && ((_a = this.onFinalize) === null || _a === void 0 ? void 0 : _a.call(this));
                }
              };
              return OperatorSubscriber2;
            }(Subscriber_1.Subscriber);
            exports2.OperatorSubscriber = OperatorSubscriber;
          }
        ),
        /***/
        3533: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.audit = void 0;
            var lift_1 = __webpack_require__2(4024);
            var innerFrom_1 = __webpack_require__2(9451);
            var OperatorSubscriber_1 = __webpack_require__2(5079);
            function audit(durationSelector) {
              return lift_1.operate(function(source, subscriber) {
                var hasValue = false;
                var lastValue = null;
                var durationSubscriber = null;
                var isComplete = false;
                var endDuration = function() {
                  durationSubscriber === null || durationSubscriber === void 0 ? void 0 : durationSubscriber.unsubscribe();
                  durationSubscriber = null;
                  if (hasValue) {
                    hasValue = false;
                    var value = lastValue;
                    lastValue = null;
                    subscriber.next(value);
                  }
                  isComplete && subscriber.complete();
                };
                var cleanupDuration = function() {
                  durationSubscriber = null;
                  isComplete && subscriber.complete();
                };
                source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
                  hasValue = true;
                  lastValue = value;
                  if (!durationSubscriber) {
                    innerFrom_1.innerFrom(durationSelector(value)).subscribe(durationSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, endDuration, cleanupDuration));
                  }
                }, function() {
                  isComplete = true;
                  (!hasValue || !durationSubscriber || durationSubscriber.closed) && subscriber.complete();
                }));
              });
            }
            exports2.audit = audit;
          }
        ),
        /***/
        5188: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.auditTime = void 0;
            var async_1 = __webpack_require__2(4617);
            var audit_1 = __webpack_require__2(3533);
            var timer_1 = __webpack_require__2(5710);
            function auditTime(duration, scheduler) {
              if (scheduler === void 0) {
                scheduler = async_1.asyncScheduler;
              }
              return audit_1.audit(function() {
                return timer_1.timer(duration, scheduler);
              });
            }
            exports2.auditTime = auditTime;
          }
        ),
        /***/
        4514: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.buffer = void 0;
            var lift_1 = __webpack_require__2(4024);
            var noop_1 = __webpack_require__2(5729);
            var OperatorSubscriber_1 = __webpack_require__2(5079);
            var innerFrom_1 = __webpack_require__2(9451);
            function buffer(closingNotifier) {
              return lift_1.operate(function(source, subscriber) {
                var currentBuffer = [];
                source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
                  return currentBuffer.push(value);
                }, function() {
                  subscriber.next(currentBuffer);
                  subscriber.complete();
                }));
                innerFrom_1.innerFrom(closingNotifier).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
                  var b = currentBuffer;
                  currentBuffer = [];
                  subscriber.next(b);
                }, noop_1.noop));
                return function() {
                  currentBuffer = null;
                };
              });
            }
            exports2.buffer = buffer;
          }
        ),
        /***/
        2537: (
          /***/
          function(__unused_webpack_module, exports2, __webpack_require__2) {
            "use strict";
            var __values = this && this.__values || function(o) {
              var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i2 = 0;
              if (m)
                return m.call(o);
              if (o && typeof o.length === "number")
                return {
                  next: function() {
                    if (o && i2 >= o.length)
                      o = void 0;
                    return { value: o && o[i2++], done: !o };
                  }
                };
              throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
            };
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.bufferCount = void 0;
            var lift_1 = __webpack_require__2(4024);
            var OperatorSubscriber_1 = __webpack_require__2(5079);
            var arrRemove_1 = __webpack_require__2(2447);
            function bufferCount(bufferSize, startBufferEvery) {
              if (startBufferEvery === void 0) {
                startBufferEvery = null;
              }
              startBufferEvery = startBufferEvery !== null && startBufferEvery !== void 0 ? startBufferEvery : bufferSize;
              return lift_1.operate(function(source, subscriber) {
                var buffers = [];
                var count = 0;
                source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
                  var e_1, _a, e_2, _b;
                  var toEmit = null;
                  if (count++ % startBufferEvery === 0) {
                    buffers.push([]);
                  }
                  try {
                    for (var buffers_1 = __values(buffers), buffers_1_1 = buffers_1.next(); !buffers_1_1.done; buffers_1_1 = buffers_1.next()) {
                      var buffer = buffers_1_1.value;
                      buffer.push(value);
                      if (bufferSize <= buffer.length) {
                        toEmit = toEmit !== null && toEmit !== void 0 ? toEmit : [];
                        toEmit.push(buffer);
                      }
                    }
                  } catch (e_1_1) {
                    e_1 = { error: e_1_1 };
                  } finally {
                    try {
                      if (buffers_1_1 && !buffers_1_1.done && (_a = buffers_1.return))
                        _a.call(buffers_1);
                    } finally {
                      if (e_1)
                        throw e_1.error;
                    }
                  }
                  if (toEmit) {
                    try {
                      for (var toEmit_1 = __values(toEmit), toEmit_1_1 = toEmit_1.next(); !toEmit_1_1.done; toEmit_1_1 = toEmit_1.next()) {
                        var buffer = toEmit_1_1.value;
                        arrRemove_1.arrRemove(buffers, buffer);
                        subscriber.next(buffer);
                      }
                    } catch (e_2_1) {
                      e_2 = { error: e_2_1 };
                    } finally {
                      try {
                        if (toEmit_1_1 && !toEmit_1_1.done && (_b = toEmit_1.return))
                          _b.call(toEmit_1);
                      } finally {
                        if (e_2)
                          throw e_2.error;
                      }
                    }
                  }
                }, function() {
                  var e_3, _a;
                  try {
                    for (var buffers_2 = __values(buffers), buffers_2_1 = buffers_2.next(); !buffers_2_1.done; buffers_2_1 = buffers_2.next()) {
                      var buffer = buffers_2_1.value;
                      subscriber.next(buffer);
                    }
                  } catch (e_3_1) {
                    e_3 = { error: e_3_1 };
                  } finally {
                    try {
                      if (buffers_2_1 && !buffers_2_1.done && (_a = buffers_2.return))
                        _a.call(buffers_2);
                    } finally {
                      if (e_3)
                        throw e_3.error;
                    }
                  }
                  subscriber.complete();
                }, void 0, function() {
                  buffers = null;
                }));
              });
            }
            exports2.bufferCount = bufferCount;
          }
        ),
        /***/
        8720: (
          /***/
          function(__unused_webpack_module, exports2, __webpack_require__2) {
            "use strict";
            var __values = this && this.__values || function(o) {
              var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i2 = 0;
              if (m)
                return m.call(o);
              if (o && typeof o.length === "number")
                return {
                  next: function() {
                    if (o && i2 >= o.length)
                      o = void 0;
                    return { value: o && o[i2++], done: !o };
                  }
                };
              throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
            };
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.bufferTime = void 0;
            var Subscription_1 = __webpack_require__2(7215);
            var lift_1 = __webpack_require__2(4024);
            var OperatorSubscriber_1 = __webpack_require__2(5079);
            var arrRemove_1 = __webpack_require__2(2447);
            var async_1 = __webpack_require__2(4617);
            var args_1 = __webpack_require__2(2619);
            var executeSchedule_1 = __webpack_require__2(5421);
            function bufferTime(bufferTimeSpan) {
              var _a, _b;
              var otherArgs = [];
              for (var _i = 1; _i < arguments.length; _i++) {
                otherArgs[_i - 1] = arguments[_i];
              }
              var scheduler = (_a = args_1.popScheduler(otherArgs)) !== null && _a !== void 0 ? _a : async_1.asyncScheduler;
              var bufferCreationInterval = (_b = otherArgs[0]) !== null && _b !== void 0 ? _b : null;
              var maxBufferSize = otherArgs[1] || Infinity;
              return lift_1.operate(function(source, subscriber) {
                var bufferRecords = [];
                var restartOnEmit = false;
                var emit = function(record) {
                  var buffer = record.buffer, subs = record.subs;
                  subs.unsubscribe();
                  arrRemove_1.arrRemove(bufferRecords, record);
                  subscriber.next(buffer);
                  restartOnEmit && startBuffer();
                };
                var startBuffer = function() {
                  if (bufferRecords) {
                    var subs = new Subscription_1.Subscription();
                    subscriber.add(subs);
                    var buffer = [];
                    var record_1 = {
                      buffer,
                      subs
                    };
                    bufferRecords.push(record_1);
                    executeSchedule_1.executeSchedule(subs, scheduler, function() {
                      return emit(record_1);
                    }, bufferTimeSpan);
                  }
                };
                if (bufferCreationInterval !== null && bufferCreationInterval >= 0) {
                  executeSchedule_1.executeSchedule(subscriber, scheduler, startBuffer, bufferCreationInterval, true);
                } else {
                  restartOnEmit = true;
                }
                startBuffer();
                var bufferTimeSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
                  var e_1, _a2;
                  var recordsCopy = bufferRecords.slice();
                  try {
                    for (var recordsCopy_1 = __values(recordsCopy), recordsCopy_1_1 = recordsCopy_1.next(); !recordsCopy_1_1.done; recordsCopy_1_1 = recordsCopy_1.next()) {
                      var record = recordsCopy_1_1.value;
                      var buffer = record.buffer;
                      buffer.push(value);
                      maxBufferSize <= buffer.length && emit(record);
                    }
                  } catch (e_1_1) {
                    e_1 = { error: e_1_1 };
                  } finally {
                    try {
                      if (recordsCopy_1_1 && !recordsCopy_1_1.done && (_a2 = recordsCopy_1.return))
                        _a2.call(recordsCopy_1);
                    } finally {
                      if (e_1)
                        throw e_1.error;
                    }
                  }
                }, function() {
                  while (bufferRecords === null || bufferRecords === void 0 ? void 0 : bufferRecords.length) {
                    subscriber.next(bufferRecords.shift().buffer);
                  }
                  bufferTimeSubscriber === null || bufferTimeSubscriber === void 0 ? void 0 : bufferTimeSubscriber.unsubscribe();
                  subscriber.complete();
                  subscriber.unsubscribe();
                }, void 0, function() {
                  return bufferRecords = null;
                });
                source.subscribe(bufferTimeSubscriber);
              });
            }
            exports2.bufferTime = bufferTime;
          }
        ),
        /***/
        7932: (
          /***/
          function(__unused_webpack_module, exports2, __webpack_require__2) {
            "use strict";
            var __values = this && this.__values || function(o) {
              var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i2 = 0;
              if (m)
                return m.call(o);
              if (o && typeof o.length === "number")
                return {
                  next: function() {
                    if (o && i2 >= o.length)
                      o = void 0;
                    return { value: o && o[i2++], done: !o };
                  }
                };
              throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
            };
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.bufferToggle = void 0;
            var Subscription_1 = __webpack_require__2(7215);
            var lift_1 = __webpack_require__2(4024);
            var innerFrom_1 = __webpack_require__2(9451);
            var OperatorSubscriber_1 = __webpack_require__2(5079);
            var noop_1 = __webpack_require__2(5729);
            var arrRemove_1 = __webpack_require__2(2447);
            function bufferToggle(openings, closingSelector) {
              return lift_1.operate(function(source, subscriber) {
                var buffers = [];
                innerFrom_1.innerFrom(openings).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(openValue) {
                  var buffer = [];
                  buffers.push(buffer);
                  var closingSubscription = new Subscription_1.Subscription();
                  var emitBuffer = function() {
                    arrRemove_1.arrRemove(buffers, buffer);
                    subscriber.next(buffer);
                    closingSubscription.unsubscribe();
                  };
                  closingSubscription.add(innerFrom_1.innerFrom(closingSelector(openValue)).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, emitBuffer, noop_1.noop)));
                }, noop_1.noop));
                source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
                  var e_1, _a;
                  try {
                    for (var buffers_1 = __values(buffers), buffers_1_1 = buffers_1.next(); !buffers_1_1.done; buffers_1_1 = buffers_1.next()) {
                      var buffer = buffers_1_1.value;
                      buffer.push(value);
                    }
                  } catch (e_1_1) {
                    e_1 = { error: e_1_1 };
                  } finally {
                    try {
                      if (buffers_1_1 && !buffers_1_1.done && (_a = buffers_1.return))
                        _a.call(buffers_1);
                    } finally {
                      if (e_1)
                        throw e_1.error;
                    }
                  }
                }, function() {
                  while (buffers.length > 0) {
                    subscriber.next(buffers.shift());
                  }
                  subscriber.complete();
                }));
              });
            }
            exports2.bufferToggle = bufferToggle;
          }
        ),
        /***/
        1445: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.bufferWhen = void 0;
            var lift_1 = __webpack_require__2(4024);
            var noop_1 = __webpack_require__2(5729);
            var OperatorSubscriber_1 = __webpack_require__2(5079);
            var innerFrom_1 = __webpack_require__2(9451);
            function bufferWhen(closingSelector) {
              return lift_1.operate(function(source, subscriber) {
                var buffer = null;
                var closingSubscriber = null;
                var openBuffer = function() {
                  closingSubscriber === null || closingSubscriber === void 0 ? void 0 : closingSubscriber.unsubscribe();
                  var b = buffer;
                  buffer = [];
                  b && subscriber.next(b);
                  innerFrom_1.innerFrom(closingSelector()).subscribe(closingSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, openBuffer, noop_1.noop));
                };
                openBuffer();
                source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
                  return buffer === null || buffer === void 0 ? void 0 : buffer.push(value);
                }, function() {
                  buffer && subscriber.next(buffer);
                  subscriber.complete();
                }, void 0, function() {
                  return buffer = closingSubscriber = null;
                }));
              });
            }
            exports2.bufferWhen = bufferWhen;
          }
        ),
        /***/
        4418: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.catchError = void 0;
            var innerFrom_1 = __webpack_require__2(9451);
            var OperatorSubscriber_1 = __webpack_require__2(5079);
            var lift_1 = __webpack_require__2(4024);
            function catchError(selector) {
              return lift_1.operate(function(source, subscriber) {
                var innerSub = null;
                var syncUnsub = false;
                var handledResult;
                innerSub = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, void 0, void 0, function(err) {
                  handledResult = innerFrom_1.innerFrom(selector(err, catchError(selector)(source)));
                  if (innerSub) {
                    innerSub.unsubscribe();
                    innerSub = null;
                    handledResult.subscribe(subscriber);
                  } else {
                    syncUnsub = true;
                  }
                }));
                if (syncUnsub) {
                  innerSub.unsubscribe();
                  innerSub = null;
                  handledResult.subscribe(subscriber);
                }
              });
            }
            exports2.catchError = catchError;
          }
        ),
        /***/
        4163: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.combineAll = void 0;
            var combineLatestAll_1 = __webpack_require__2(9893);
            exports2.combineAll = combineLatestAll_1.combineLatestAll;
          }
        ),
        /***/
        8169: (
          /***/
          function(__unused_webpack_module, exports2, __webpack_require__2) {
            "use strict";
            var __read = this && this.__read || function(o, n) {
              var m = typeof Symbol === "function" && o[Symbol.iterator];
              if (!m)
                return o;
              var i2 = m.call(o), r, ar = [], e;
              try {
                while ((n === void 0 || n-- > 0) && !(r = i2.next()).done)
                  ar.push(r.value);
              } catch (error) {
                e = { error };
              } finally {
                try {
                  if (r && !r.done && (m = i2["return"]))
                    m.call(i2);
                } finally {
                  if (e)
                    throw e.error;
                }
              }
              return ar;
            };
            var __spreadArray2 = this && this.__spreadArray || function(to, from) {
              for (var i2 = 0, il = from.length, j = to.length; i2 < il; i2++, j++)
                to[j] = from[i2];
              return to;
            };
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.combineLatest = void 0;
            var combineLatest_1 = __webpack_require__2(1047);
            var lift_1 = __webpack_require__2(4024);
            var argsOrArgArray_1 = __webpack_require__2(4475);
            var mapOneOrManyArgs_1 = __webpack_require__2(4666);
            var pipe_1 = __webpack_require__2(5966);
            var args_1 = __webpack_require__2(2619);
            function combineLatest() {
              var args = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
              }
              var resultSelector = args_1.popResultSelector(args);
              return resultSelector ? pipe_1.pipe(combineLatest.apply(void 0, __spreadArray2([], __read(args))), mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector)) : lift_1.operate(function(source, subscriber) {
                combineLatest_1.combineLatestInit(__spreadArray2([source], __read(argsOrArgArray_1.argsOrArgArray(args))))(subscriber);
              });
            }
            exports2.combineLatest = combineLatest;
          }
        ),
        /***/
        9893: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.combineLatestAll = void 0;
            var combineLatest_1 = __webpack_require__2(1047);
            var joinAllInternals_1 = __webpack_require__2(7534);
            function combineLatestAll(project) {
              return joinAllInternals_1.joinAllInternals(combineLatest_1.combineLatest, project);
            }
            exports2.combineLatestAll = combineLatestAll;
          }
        ),
        /***/
        7230: (
          /***/
          function(__unused_webpack_module, exports2, __webpack_require__2) {
            "use strict";
            var __read = this && this.__read || function(o, n) {
              var m = typeof Symbol === "function" && o[Symbol.iterator];
              if (!m)
                return o;
              var i2 = m.call(o), r, ar = [], e;
              try {
                while ((n === void 0 || n-- > 0) && !(r = i2.next()).done)
                  ar.push(r.value);
              } catch (error) {
                e = { error };
              } finally {
                try {
                  if (r && !r.done && (m = i2["return"]))
                    m.call(i2);
                } finally {
                  if (e)
                    throw e.error;
                }
              }
              return ar;
            };
            var __spreadArray2 = this && this.__spreadArray || function(to, from) {
              for (var i2 = 0, il = from.length, j = to.length; i2 < il; i2++, j++)
                to[j] = from[i2];
              return to;
            };
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.combineLatestWith = void 0;
            var combineLatest_1 = __webpack_require__2(8169);
            function combineLatestWith() {
              var otherSources = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                otherSources[_i] = arguments[_i];
              }
              return combineLatest_1.combineLatest.apply(void 0, __spreadArray2([], __read(otherSources)));
            }
            exports2.combineLatestWith = combineLatestWith;
          }
        ),
        /***/
        4098: (
          /***/
          function(__unused_webpack_module, exports2, __webpack_require__2) {
            "use strict";
            var __read = this && this.__read || function(o, n) {
              var m = typeof Symbol === "function" && o[Symbol.iterator];
              if (!m)
                return o;
              var i2 = m.call(o), r, ar = [], e;
              try {
                while ((n === void 0 || n-- > 0) && !(r = i2.next()).done)
                  ar.push(r.value);
              } catch (error) {
                e = { error };
              } finally {
                try {
                  if (r && !r.done && (m = i2["return"]))
                    m.call(i2);
                } finally {
                  if (e)
                    throw e.error;
                }
              }
              return ar;
            };
            var __spreadArray2 = this && this.__spreadArray || function(to, from) {
              for (var i2 = 0, il = from.length, j = to.length; i2 < il; i2++, j++)
                to[j] = from[i2];
              return to;
            };
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.concat = void 0;
            var lift_1 = __webpack_require__2(4024);
            var concatAll_1 = __webpack_require__2(4554);
            var args_1 = __webpack_require__2(2619);
            var from_1 = __webpack_require__2(6216);
            function concat() {
              var args = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
              }
              var scheduler = args_1.popScheduler(args);
              return lift_1.operate(function(source, subscriber) {
                concatAll_1.concatAll()(from_1.from(__spreadArray2([source], __read(args)), scheduler)).subscribe(subscriber);
              });
            }
            exports2.concat = concat;
          }
        ),
        /***/
        4554: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.concatAll = void 0;
            var mergeAll_1 = __webpack_require__2(4594);
            function concatAll() {
              return mergeAll_1.mergeAll(1);
            }
            exports2.concatAll = concatAll;
          }
        ),
        /***/
        1048: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.concatMap = void 0;
            var mergeMap_1 = __webpack_require__2(9010);
            var isFunction_1 = __webpack_require__2(4432);
            function concatMap(project, resultSelector) {
              return isFunction_1.isFunction(resultSelector) ? mergeMap_1.mergeMap(project, resultSelector, 1) : mergeMap_1.mergeMap(project, 1);
            }
            exports2.concatMap = concatMap;
          }
        ),
        /***/
        381: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.concatMapTo = void 0;
            var concatMap_1 = __webpack_require__2(1048);
            var isFunction_1 = __webpack_require__2(4432);
            function concatMapTo(innerObservable, resultSelector) {
              return isFunction_1.isFunction(resultSelector) ? concatMap_1.concatMap(function() {
                return innerObservable;
              }, resultSelector) : concatMap_1.concatMap(function() {
                return innerObservable;
              });
            }
            exports2.concatMapTo = concatMapTo;
          }
        ),
        /***/
        4724: (
          /***/
          function(__unused_webpack_module, exports2, __webpack_require__2) {
            "use strict";
            var __read = this && this.__read || function(o, n) {
              var m = typeof Symbol === "function" && o[Symbol.iterator];
              if (!m)
                return o;
              var i2 = m.call(o), r, ar = [], e;
              try {
                while ((n === void 0 || n-- > 0) && !(r = i2.next()).done)
                  ar.push(r.value);
              } catch (error) {
                e = { error };
              } finally {
                try {
                  if (r && !r.done && (m = i2["return"]))
                    m.call(i2);
                } finally {
                  if (e)
                    throw e.error;
                }
              }
              return ar;
            };
            var __spreadArray2 = this && this.__spreadArray || function(to, from) {
              for (var i2 = 0, il = from.length, j = to.length; i2 < il; i2++, j++)
                to[j] = from[i2];
              return to;
            };
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.concatWith = void 0;
            var concat_1 = __webpack_require__2(4098);
            function concatWith() {
              var otherSources = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                otherSources[_i] = arguments[_i];
              }
              return concat_1.concat.apply(void 0, __spreadArray2([], __read(otherSources)));
            }
            exports2.concatWith = concatWith;
          }
        ),
        /***/
        4347: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.connect = void 0;
            var Subject_1 = __webpack_require__2(9520);
            var innerFrom_1 = __webpack_require__2(9451);
            var lift_1 = __webpack_require__2(4024);
            var fromSubscribable_1 = __webpack_require__2(2160);
            var DEFAULT_CONFIG = {
              connector: function() {
                return new Subject_1.Subject();
              }
            };
            function connect(selector, config2) {
              if (config2 === void 0) {
                config2 = DEFAULT_CONFIG;
              }
              var connector = config2.connector;
              return lift_1.operate(function(source, subscriber) {
                var subject = connector();
                innerFrom_1.innerFrom(selector(fromSubscribable_1.fromSubscribable(subject))).subscribe(subscriber);
                subscriber.add(source.subscribe(subject));
              });
            }
            exports2.connect = connect;
          }
        ),
        /***/
        6944: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.count = void 0;
            var reduce_1 = __webpack_require__2(1386);
            function count(predicate) {
              return reduce_1.reduce(function(total, value, i2) {
                return !predicate || predicate(value, i2) ? total + 1 : total;
              }, 0);
            }
            exports2.count = count;
          }
        ),
        /***/
        440: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.debounce = void 0;
            var lift_1 = __webpack_require__2(4024);
            var noop_1 = __webpack_require__2(5729);
            var OperatorSubscriber_1 = __webpack_require__2(5079);
            var innerFrom_1 = __webpack_require__2(9451);
            function debounce(durationSelector) {
              return lift_1.operate(function(source, subscriber) {
                var hasValue = false;
                var lastValue = null;
                var durationSubscriber = null;
                var emit = function() {
                  durationSubscriber === null || durationSubscriber === void 0 ? void 0 : durationSubscriber.unsubscribe();
                  durationSubscriber = null;
                  if (hasValue) {
                    hasValue = false;
                    var value = lastValue;
                    lastValue = null;
                    subscriber.next(value);
                  }
                };
                source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
                  durationSubscriber === null || durationSubscriber === void 0 ? void 0 : durationSubscriber.unsubscribe();
                  hasValue = true;
                  lastValue = value;
                  durationSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, emit, noop_1.noop);
                  innerFrom_1.innerFrom(durationSelector(value)).subscribe(durationSubscriber);
                }, function() {
                  emit();
                  subscriber.complete();
                }, void 0, function() {
                  lastValue = durationSubscriber = null;
                }));
              });
            }
            exports2.debounce = debounce;
          }
        ),
        /***/
        8157: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.debounceTime = void 0;
            var async_1 = __webpack_require__2(4617);
            var lift_1 = __webpack_require__2(4024);
            var OperatorSubscriber_1 = __webpack_require__2(5079);
            function debounceTime(dueTime, scheduler) {
              if (scheduler === void 0) {
                scheduler = async_1.asyncScheduler;
              }
              return lift_1.operate(function(source, subscriber) {
                var activeTask = null;
                var lastValue = null;
                var lastTime = null;
                var emit = function() {
                  if (activeTask) {
                    activeTask.unsubscribe();
                    activeTask = null;
                    var value = lastValue;
                    lastValue = null;
                    subscriber.next(value);
                  }
                };
                function emitWhenIdle() {
                  var targetTime = lastTime + dueTime;
                  var now = scheduler.now();
                  if (now < targetTime) {
                    activeTask = this.schedule(void 0, targetTime - now);
                    subscriber.add(activeTask);
                    return;
                  }
                  emit();
                }
                source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
                  lastValue = value;
                  lastTime = scheduler.now();
                  if (!activeTask) {
                    activeTask = scheduler.schedule(emitWhenIdle, dueTime);
                    subscriber.add(activeTask);
                  }
                }, function() {
                  emit();
                  subscriber.complete();
                }, void 0, function() {
                  lastValue = activeTask = null;
                }));
              });
            }
            exports2.debounceTime = debounceTime;
          }
        ),
        /***/
        1714: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.defaultIfEmpty = void 0;
            var lift_1 = __webpack_require__2(4024);
            var OperatorSubscriber_1 = __webpack_require__2(5079);
            function defaultIfEmpty(defaultValue) {
              return lift_1.operate(function(source, subscriber) {
                var hasValue = false;
                source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
                  hasValue = true;
                  subscriber.next(value);
                }, function() {
                  if (!hasValue) {
                    subscriber.next(defaultValue);
                  }
                  subscriber.complete();
                }));
              });
            }
            exports2.defaultIfEmpty = defaultIfEmpty;
          }
        ),
        /***/
        1030: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.delay = void 0;
            var async_1 = __webpack_require__2(4617);
            var delayWhen_1 = __webpack_require__2(6405);
            var timer_1 = __webpack_require__2(5710);
            function delay(due, scheduler) {
              if (scheduler === void 0) {
                scheduler = async_1.asyncScheduler;
              }
              var duration = timer_1.timer(due, scheduler);
              return delayWhen_1.delayWhen(function() {
                return duration;
              });
            }
            exports2.delay = delay;
          }
        ),
        /***/
        6405: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.delayWhen = void 0;
            var concat_1 = __webpack_require__2(79);
            var take_1 = __webpack_require__2(7138);
            var ignoreElements_1 = __webpack_require__2(3470);
            var mapTo_1 = __webpack_require__2(4791);
            var mergeMap_1 = __webpack_require__2(9010);
            var innerFrom_1 = __webpack_require__2(9451);
            function delayWhen(delayDurationSelector, subscriptionDelay) {
              if (subscriptionDelay) {
                return function(source) {
                  return concat_1.concat(subscriptionDelay.pipe(take_1.take(1), ignoreElements_1.ignoreElements()), source.pipe(delayWhen(delayDurationSelector)));
                };
              }
              return mergeMap_1.mergeMap(function(value, index) {
                return innerFrom_1.innerFrom(delayDurationSelector(value, index)).pipe(take_1.take(1), mapTo_1.mapTo(value));
              });
            }
            exports2.delayWhen = delayWhen;
          }
        ),
        /***/
        9142: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.dematerialize = void 0;
            var Notification_1 = __webpack_require__2(3868);
            var lift_1 = __webpack_require__2(4024);
            var OperatorSubscriber_1 = __webpack_require__2(5079);
            function dematerialize() {
              return lift_1.operate(function(source, subscriber) {
                source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(notification) {
                  return Notification_1.observeNotification(notification, subscriber);
                }));
              });
            }
            exports2.dematerialize = dematerialize;
          }
        ),
        /***/
        2307: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.distinct = void 0;
            var lift_1 = __webpack_require__2(4024);
            var OperatorSubscriber_1 = __webpack_require__2(5079);
            var noop_1 = __webpack_require__2(5729);
            var innerFrom_1 = __webpack_require__2(9451);
            function distinct(keySelector, flushes) {
              return lift_1.operate(function(source, subscriber) {
                var distinctKeys = /* @__PURE__ */ new Set();
                source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
                  var key = keySelector ? keySelector(value) : value;
                  if (!distinctKeys.has(key)) {
                    distinctKeys.add(key);
                    subscriber.next(value);
                  }
                }));
                flushes && innerFrom_1.innerFrom(flushes).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
                  return distinctKeys.clear();
                }, noop_1.noop));
              });
            }
            exports2.distinct = distinct;
          }
        ),
        /***/
        9131: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.distinctUntilChanged = void 0;
            var identity_1 = __webpack_require__2(9144);
            var lift_1 = __webpack_require__2(4024);
            var OperatorSubscriber_1 = __webpack_require__2(5079);
            function distinctUntilChanged(comparator, keySelector) {
              if (keySelector === void 0) {
                keySelector = identity_1.identity;
              }
              comparator = comparator !== null && comparator !== void 0 ? comparator : defaultCompare;
              return lift_1.operate(function(source, subscriber) {
                var previousKey;
                var first = true;
                source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
                  var currentKey = keySelector(value);
                  if (first || !comparator(previousKey, currentKey)) {
                    first = false;
                    previousKey = currentKey;
                    subscriber.next(value);
                  }
                }));
              });
            }
            exports2.distinctUntilChanged = distinctUntilChanged;
            function defaultCompare(a, b) {
              return a === b;
            }
          }
        ),
        /***/
        6659: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.distinctUntilKeyChanged = void 0;
            var distinctUntilChanged_1 = __webpack_require__2(9131);
            function distinctUntilKeyChanged(key, compare) {
              return distinctUntilChanged_1.distinctUntilChanged(function(x, y) {
                return compare ? compare(x[key], y[key]) : x[key] === y[key];
              });
            }
            exports2.distinctUntilKeyChanged = distinctUntilKeyChanged;
          }
        ),
        /***/
        4217: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.elementAt = void 0;
            var ArgumentOutOfRangeError_1 = __webpack_require__2(6809);
            var filter_1 = __webpack_require__2(2763);
            var throwIfEmpty_1 = __webpack_require__2(8062);
            var defaultIfEmpty_1 = __webpack_require__2(1714);
            var take_1 = __webpack_require__2(7138);
            function elementAt(index, defaultValue) {
              if (index < 0) {
                throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError();
              }
              var hasDefaultValue = arguments.length >= 2;
              return function(source) {
                return source.pipe(filter_1.filter(function(v, i2) {
                  return i2 === index;
                }), take_1.take(1), hasDefaultValue ? defaultIfEmpty_1.defaultIfEmpty(defaultValue) : throwIfEmpty_1.throwIfEmpty(function() {
                  return new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError();
                }));
              };
            }
            exports2.elementAt = elementAt;
          }
        ),
        /***/
        4707: (
          /***/
          function(__unused_webpack_module, exports2, __webpack_require__2) {
            "use strict";
            var __read = this && this.__read || function(o, n) {
              var m = typeof Symbol === "function" && o[Symbol.iterator];
              if (!m)
                return o;
              var i2 = m.call(o), r, ar = [], e;
              try {
                while ((n === void 0 || n-- > 0) && !(r = i2.next()).done)
                  ar.push(r.value);
              } catch (error) {
                e = { error };
              } finally {
                try {
                  if (r && !r.done && (m = i2["return"]))
                    m.call(i2);
                } finally {
                  if (e)
                    throw e.error;
                }
              }
              return ar;
            };
            var __spreadArray2 = this && this.__spreadArray || function(to, from) {
              for (var i2 = 0, il = from.length, j = to.length; i2 < il; i2++, j++)
                to[j] = from[i2];
              return to;
            };
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.endWith = void 0;
            var concat_1 = __webpack_require__2(79);
            var of_1 = __webpack_require__2(7443);
            function endWith() {
              var values = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                values[_i] = arguments[_i];
              }
              return function(source) {
                return concat_1.concat(source, of_1.of.apply(void 0, __spreadArray2([], __read(values))));
              };
            }
            exports2.endWith = endWith;
          }
        ),
        /***/
        9276: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.every = void 0;
            var lift_1 = __webpack_require__2(4024);
            var OperatorSubscriber_1 = __webpack_require__2(5079);
            function every(predicate, thisArg) {
              return lift_1.operate(function(source, subscriber) {
                var index = 0;
                source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
                  if (!predicate.call(thisArg, value, index++, source)) {
                    subscriber.next(false);
                    subscriber.complete();
                  }
                }, function() {
                  subscriber.next(true);
                  subscriber.complete();
                }));
              });
            }
            exports2.every = every;
          }
        ),
        /***/
        337: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.exhaust = void 0;
            var exhaustAll_1 = __webpack_require__2(3977);
            exports2.exhaust = exhaustAll_1.exhaustAll;
          }
        ),
        /***/
        3977: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.exhaustAll = void 0;
            var exhaustMap_1 = __webpack_require__2(368);
            var identity_1 = __webpack_require__2(9144);
            function exhaustAll() {
              return exhaustMap_1.exhaustMap(identity_1.identity);
            }
            exports2.exhaustAll = exhaustAll;
          }
        ),
        /***/
        368: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.exhaustMap = void 0;
            var map_1 = __webpack_require__2(4338);
            var innerFrom_1 = __webpack_require__2(9451);
            var lift_1 = __webpack_require__2(4024);
            var OperatorSubscriber_1 = __webpack_require__2(5079);
            function exhaustMap(project, resultSelector) {
              if (resultSelector) {
                return function(source) {
                  return source.pipe(exhaustMap(function(a, i2) {
                    return innerFrom_1.innerFrom(project(a, i2)).pipe(map_1.map(function(b, ii) {
                      return resultSelector(a, b, i2, ii);
                    }));
                  }));
                };
              }
              return lift_1.operate(function(source, subscriber) {
                var index = 0;
                var innerSub = null;
                var isComplete = false;
                source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(outerValue) {
                  if (!innerSub) {
                    innerSub = OperatorSubscriber_1.createOperatorSubscriber(subscriber, void 0, function() {
                      innerSub = null;
                      isComplete && subscriber.complete();
                    });
                    innerFrom_1.innerFrom(project(outerValue, index++)).subscribe(innerSub);
                  }
                }, function() {
                  isComplete = true;
                  !innerSub && subscriber.complete();
                }));
              });
            }
            exports2.exhaustMap = exhaustMap;
          }
        ),
        /***/
        7829: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.expand = void 0;
            var lift_1 = __webpack_require__2(4024);
            var mergeInternals_1 = __webpack_require__2(7163);
            function expand(project, concurrent, scheduler) {
              if (concurrent === void 0) {
                concurrent = Infinity;
              }
              concurrent = (concurrent || 0) < 1 ? Infinity : concurrent;
              return lift_1.operate(function(source, subscriber) {
                return mergeInternals_1.mergeInternals(source, subscriber, project, concurrent, void 0, true, scheduler);
              });
            }
            exports2.expand = expand;
          }
        ),
        /***/
        2763: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.filter = void 0;
            var lift_1 = __webpack_require__2(4024);
            var OperatorSubscriber_1 = __webpack_require__2(5079);
            function filter(predicate, thisArg) {
              return lift_1.operate(function(source, subscriber) {
                var index = 0;
                source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
                  return predicate.call(thisArg, value, index++) && subscriber.next(value);
                }));
              });
            }
            exports2.filter = filter;
          }
        ),
        /***/
        4106: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.finalize = void 0;
            var lift_1 = __webpack_require__2(4024);
            function finalize(callback) {
              return lift_1.operate(function(source, subscriber) {
                try {
                  source.subscribe(subscriber);
                } finally {
                  subscriber.add(callback);
                }
              });
            }
            exports2.finalize = finalize;
          }
        ),
        /***/
        8759: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.createFind = exports2.find = void 0;
            var lift_1 = __webpack_require__2(4024);
            var OperatorSubscriber_1 = __webpack_require__2(5079);
            function find(predicate, thisArg) {
              return lift_1.operate(createFind(predicate, thisArg, "value"));
            }
            exports2.find = find;
            function createFind(predicate, thisArg, emit) {
              var findIndex = emit === "index";
              return function(source, subscriber) {
                var index = 0;
                source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
                  var i2 = index++;
                  if (predicate.call(thisArg, value, i2, source)) {
                    subscriber.next(findIndex ? i2 : value);
                    subscriber.complete();
                  }
                }, function() {
                  subscriber.next(findIndex ? -1 : void 0);
                  subscriber.complete();
                }));
              };
            }
            exports2.createFind = createFind;
          }
        ),
        /***/
        3999: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.findIndex = void 0;
            var lift_1 = __webpack_require__2(4024);
            var find_1 = __webpack_require__2(8759);
            function findIndex(predicate, thisArg) {
              return lift_1.operate(find_1.createFind(predicate, thisArg, "index"));
            }
            exports2.findIndex = findIndex;
          }
        ),
        /***/
        5194: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.first = void 0;
            var EmptyError_1 = __webpack_require__2(8032);
            var filter_1 = __webpack_require__2(2763);
            var take_1 = __webpack_require__2(7138);
            var defaultIfEmpty_1 = __webpack_require__2(1714);
            var throwIfEmpty_1 = __webpack_require__2(8062);
            var identity_1 = __webpack_require__2(9144);
            function first(predicate, defaultValue) {
              var hasDefaultValue = arguments.length >= 2;
              return function(source) {
                return source.pipe(predicate ? filter_1.filter(function(v, i2) {
                  return predicate(v, i2, source);
                }) : identity_1.identity, take_1.take(1), hasDefaultValue ? defaultIfEmpty_1.defaultIfEmpty(defaultValue) : throwIfEmpty_1.throwIfEmpty(function() {
                  return new EmptyError_1.EmptyError();
                }));
              };
            }
            exports2.first = first;
          }
        ),
        /***/
        2735: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.flatMap = void 0;
            var mergeMap_1 = __webpack_require__2(9010);
            exports2.flatMap = mergeMap_1.mergeMap;
          }
        ),
        /***/
        1664: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.groupBy = void 0;
            var Observable_1 = __webpack_require__2(5271);
            var innerFrom_1 = __webpack_require__2(9451);
            var Subject_1 = __webpack_require__2(9520);
            var lift_1 = __webpack_require__2(4024);
            var OperatorSubscriber_1 = __webpack_require__2(5079);
            function groupBy(keySelector, elementOrOptions, duration, connector) {
              return lift_1.operate(function(source, subscriber) {
                var element;
                if (!elementOrOptions || typeof elementOrOptions === "function") {
                  element = elementOrOptions;
                } else {
                  duration = elementOrOptions.duration, element = elementOrOptions.element, connector = elementOrOptions.connector;
                }
                var groups = /* @__PURE__ */ new Map();
                var notify = function(cb) {
                  groups.forEach(cb);
                  cb(subscriber);
                };
                var handleError = function(err) {
                  return notify(function(consumer) {
                    return consumer.error(err);
                  });
                };
                var activeGroups = 0;
                var teardownAttempted = false;
                var groupBySourceSubscriber = new OperatorSubscriber_1.OperatorSubscriber(subscriber, function(value) {
                  try {
                    var key_1 = keySelector(value);
                    var group_1 = groups.get(key_1);
                    if (!group_1) {
                      groups.set(key_1, group_1 = connector ? connector() : new Subject_1.Subject());
                      var grouped = createGroupedObservable(key_1, group_1);
                      subscriber.next(grouped);
                      if (duration) {
                        var durationSubscriber_1 = OperatorSubscriber_1.createOperatorSubscriber(group_1, function() {
                          group_1.complete();
                          durationSubscriber_1 === null || durationSubscriber_1 === void 0 ? void 0 : durationSubscriber_1.unsubscribe();
                        }, void 0, void 0, function() {
                          return groups.delete(key_1);
                        });
                        groupBySourceSubscriber.add(innerFrom_1.innerFrom(duration(grouped)).subscribe(durationSubscriber_1));
                      }
                    }
                    group_1.next(element ? element(value) : value);
                  } catch (err) {
                    handleError(err);
                  }
                }, function() {
                  return notify(function(consumer) {
                    return consumer.complete();
                  });
                }, handleError, function() {
                  return groups.clear();
                }, function() {
                  teardownAttempted = true;
                  return activeGroups === 0;
                });
                source.subscribe(groupBySourceSubscriber);
                function createGroupedObservable(key, groupSubject) {
                  var result = new Observable_1.Observable(function(groupSubscriber) {
                    activeGroups++;
                    var innerSub = groupSubject.subscribe(groupSubscriber);
                    return function() {
                      innerSub.unsubscribe();
                      --activeGroups === 0 && teardownAttempted && groupBySourceSubscriber.unsubscribe();
                    };
                  });
                  result.key = key;
                  return result;
                }
              });
            }
            exports2.groupBy = groupBy;
          }
        ),
        /***/
        3470: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.ignoreElements = void 0;
            var lift_1 = __webpack_require__2(4024);
            var OperatorSubscriber_1 = __webpack_require__2(5079);
            var noop_1 = __webpack_require__2(5729);
            function ignoreElements() {
              return lift_1.operate(function(source, subscriber) {
                source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, noop_1.noop));
              });
            }
            exports2.ignoreElements = ignoreElements;
          }
        ),
        /***/
        9549: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.isEmpty = void 0;
            var lift_1 = __webpack_require__2(4024);
            var OperatorSubscriber_1 = __webpack_require__2(5079);
            function isEmpty() {
              return lift_1.operate(function(source, subscriber) {
                source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
                  subscriber.next(false);
                  subscriber.complete();
                }, function() {
                  subscriber.next(true);
                  subscriber.complete();
                }));
              });
            }
            exports2.isEmpty = isEmpty;
          }
        ),
        /***/
        7534: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.joinAllInternals = void 0;
            var identity_1 = __webpack_require__2(9144);
            var mapOneOrManyArgs_1 = __webpack_require__2(4666);
            var pipe_1 = __webpack_require__2(5966);
            var mergeMap_1 = __webpack_require__2(9010);
            var toArray_1 = __webpack_require__2(2378);
            function joinAllInternals(joinFn, project) {
              return pipe_1.pipe(toArray_1.toArray(), mergeMap_1.mergeMap(function(sources) {
                return joinFn(sources);
              }), project ? mapOneOrManyArgs_1.mapOneOrManyArgs(project) : identity_1.identity);
            }
            exports2.joinAllInternals = joinAllInternals;
          }
        ),
        /***/
        9582: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.last = void 0;
            var EmptyError_1 = __webpack_require__2(8032);
            var filter_1 = __webpack_require__2(2763);
            var takeLast_1 = __webpack_require__2(4288);
            var throwIfEmpty_1 = __webpack_require__2(8062);
            var defaultIfEmpty_1 = __webpack_require__2(1714);
            var identity_1 = __webpack_require__2(9144);
            function last(predicate, defaultValue) {
              var hasDefaultValue = arguments.length >= 2;
              return function(source) {
                return source.pipe(predicate ? filter_1.filter(function(v, i2) {
                  return predicate(v, i2, source);
                }) : identity_1.identity, takeLast_1.takeLast(1), hasDefaultValue ? defaultIfEmpty_1.defaultIfEmpty(defaultValue) : throwIfEmpty_1.throwIfEmpty(function() {
                  return new EmptyError_1.EmptyError();
                }));
              };
            }
            exports2.last = last;
          }
        ),
        /***/
        4338: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.map = void 0;
            var lift_1 = __webpack_require__2(4024);
            var OperatorSubscriber_1 = __webpack_require__2(5079);
            function map(project, thisArg) {
              return lift_1.operate(function(source, subscriber) {
                var index = 0;
                source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
                  subscriber.next(project.call(thisArg, value, index++));
                }));
              });
            }
            exports2.map = map;
          }
        ),
        /***/
        4791: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.mapTo = void 0;
            var map_1 = __webpack_require__2(4338);
            function mapTo(value) {
              return map_1.map(function() {
                return value;
              });
            }
            exports2.mapTo = mapTo;
          }
        ),
        /***/
        9318: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.materialize = void 0;
            var Notification_1 = __webpack_require__2(3868);
            var lift_1 = __webpack_require__2(4024);
            var OperatorSubscriber_1 = __webpack_require__2(5079);
            function materialize() {
              return lift_1.operate(function(source, subscriber) {
                source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
                  subscriber.next(Notification_1.Notification.createNext(value));
                }, function() {
                  subscriber.next(Notification_1.Notification.createComplete());
                  subscriber.complete();
                }, function(err) {
                  subscriber.next(Notification_1.Notification.createError(err));
                  subscriber.complete();
                }));
              });
            }
            exports2.materialize = materialize;
          }
        ),
        /***/
        7446: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.max = void 0;
            var reduce_1 = __webpack_require__2(1386);
            var isFunction_1 = __webpack_require__2(4432);
            function max(comparer) {
              return reduce_1.reduce(isFunction_1.isFunction(comparer) ? function(x, y) {
                return comparer(x, y) > 0 ? x : y;
              } : function(x, y) {
                return x > y ? x : y;
              });
            }
            exports2.max = max;
          }
        ),
        /***/
        6094: (
          /***/
          function(__unused_webpack_module, exports2, __webpack_require__2) {
            "use strict";
            var __read = this && this.__read || function(o, n) {
              var m = typeof Symbol === "function" && o[Symbol.iterator];
              if (!m)
                return o;
              var i2 = m.call(o), r, ar = [], e;
              try {
                while ((n === void 0 || n-- > 0) && !(r = i2.next()).done)
                  ar.push(r.value);
              } catch (error) {
                e = { error };
              } finally {
                try {
                  if (r && !r.done && (m = i2["return"]))
                    m.call(i2);
                } finally {
                  if (e)
                    throw e.error;
                }
              }
              return ar;
            };
            var __spreadArray2 = this && this.__spreadArray || function(to, from) {
              for (var i2 = 0, il = from.length, j = to.length; i2 < il; i2++, j++)
                to[j] = from[i2];
              return to;
            };
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.merge = void 0;
            var lift_1 = __webpack_require__2(4024);
            var argsOrArgArray_1 = __webpack_require__2(4475);
            var mergeAll_1 = __webpack_require__2(4594);
            var args_1 = __webpack_require__2(2619);
            var from_1 = __webpack_require__2(6216);
            function merge() {
              var args = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
              }
              var scheduler = args_1.popScheduler(args);
              var concurrent = args_1.popNumber(args, Infinity);
              args = argsOrArgArray_1.argsOrArgArray(args);
              return lift_1.operate(function(source, subscriber) {
                mergeAll_1.mergeAll(concurrent)(from_1.from(__spreadArray2([source], __read(args)), scheduler)).subscribe(subscriber);
              });
            }
            exports2.merge = merge;
          }
        ),
        /***/
        4594: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.mergeAll = void 0;
            var mergeMap_1 = __webpack_require__2(9010);
            var identity_1 = __webpack_require__2(9144);
            function mergeAll(concurrent) {
              if (concurrent === void 0) {
                concurrent = Infinity;
              }
              return mergeMap_1.mergeMap(identity_1.identity, concurrent);
            }
            exports2.mergeAll = mergeAll;
          }
        ),
        /***/
        7163: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.mergeInternals = void 0;
            var innerFrom_1 = __webpack_require__2(9451);
            var executeSchedule_1 = __webpack_require__2(5421);
            var OperatorSubscriber_1 = __webpack_require__2(5079);
            function mergeInternals(source, subscriber, project, concurrent, onBeforeNext, expand, innerSubScheduler, additionalFinalizer) {
              var buffer = [];
              var active = 0;
              var index = 0;
              var isComplete = false;
              var checkComplete = function() {
                if (isComplete && !buffer.length && !active) {
                  subscriber.complete();
                }
              };
              var outerNext = function(value) {
                return active < concurrent ? doInnerSub(value) : buffer.push(value);
              };
              var doInnerSub = function(value) {
                expand && subscriber.next(value);
                active++;
                var innerComplete = false;
                innerFrom_1.innerFrom(project(value, index++)).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(innerValue) {
                  onBeforeNext === null || onBeforeNext === void 0 ? void 0 : onBeforeNext(innerValue);
                  if (expand) {
                    outerNext(innerValue);
                  } else {
                    subscriber.next(innerValue);
                  }
                }, function() {
                  innerComplete = true;
                }, void 0, function() {
                  if (innerComplete) {
                    try {
                      active--;
                      var _loop_1 = function() {
                        var bufferedValue = buffer.shift();
                        if (innerSubScheduler) {
                          executeSchedule_1.executeSchedule(subscriber, innerSubScheduler, function() {
                            return doInnerSub(bufferedValue);
                          });
                        } else {
                          doInnerSub(bufferedValue);
                        }
                      };
                      while (buffer.length && active < concurrent) {
                        _loop_1();
                      }
                      checkComplete();
                    } catch (err) {
                      subscriber.error(err);
                    }
                  }
                }));
              };
              source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, outerNext, function() {
                isComplete = true;
                checkComplete();
              }));
              return function() {
                additionalFinalizer === null || additionalFinalizer === void 0 ? void 0 : additionalFinalizer();
              };
            }
            exports2.mergeInternals = mergeInternals;
          }
        ),
        /***/
        9010: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.mergeMap = void 0;
            var map_1 = __webpack_require__2(4338);
            var innerFrom_1 = __webpack_require__2(9451);
            var lift_1 = __webpack_require__2(4024);
            var mergeInternals_1 = __webpack_require__2(7163);
            var isFunction_1 = __webpack_require__2(4432);
            function mergeMap(project, resultSelector, concurrent) {
              if (concurrent === void 0) {
                concurrent = Infinity;
              }
              if (isFunction_1.isFunction(resultSelector)) {
                return mergeMap(function(a, i2) {
                  return map_1.map(function(b, ii) {
                    return resultSelector(a, b, i2, ii);
                  })(innerFrom_1.innerFrom(project(a, i2)));
                }, concurrent);
              } else if (typeof resultSelector === "number") {
                concurrent = resultSelector;
              }
              return lift_1.operate(function(source, subscriber) {
                return mergeInternals_1.mergeInternals(source, subscriber, project, concurrent);
              });
            }
            exports2.mergeMap = mergeMap;
          }
        ),
        /***/
        8983: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.mergeMapTo = void 0;
            var mergeMap_1 = __webpack_require__2(9010);
            var isFunction_1 = __webpack_require__2(4432);
            function mergeMapTo(innerObservable, resultSelector, concurrent) {
              if (concurrent === void 0) {
                concurrent = Infinity;
              }
              if (isFunction_1.isFunction(resultSelector)) {
                return mergeMap_1.mergeMap(function() {
                  return innerObservable;
                }, resultSelector, concurrent);
              }
              if (typeof resultSelector === "number") {
                concurrent = resultSelector;
              }
              return mergeMap_1.mergeMap(function() {
                return innerObservable;
              }, concurrent);
            }
            exports2.mergeMapTo = mergeMapTo;
          }
        ),
        /***/
        2170: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.mergeScan = void 0;
            var lift_1 = __webpack_require__2(4024);
            var mergeInternals_1 = __webpack_require__2(7163);
            function mergeScan(accumulator, seed, concurrent) {
              if (concurrent === void 0) {
                concurrent = Infinity;
              }
              return lift_1.operate(function(source, subscriber) {
                var state = seed;
                return mergeInternals_1.mergeInternals(source, subscriber, function(value, index) {
                  return accumulator(state, value, index);
                }, concurrent, function(value) {
                  state = value;
                }, false, void 0, function() {
                  return state = null;
                });
              });
            }
            exports2.mergeScan = mergeScan;
          }
        ),
        /***/
        3674: (
          /***/
          function(__unused_webpack_module, exports2, __webpack_require__2) {
            "use strict";
            var __read = this && this.__read || function(o, n) {
              var m = typeof Symbol === "function" && o[Symbol.iterator];
              if (!m)
                return o;
              var i2 = m.call(o), r, ar = [], e;
              try {
                while ((n === void 0 || n-- > 0) && !(r = i2.next()).done)
                  ar.push(r.value);
              } catch (error) {
                e = { error };
              } finally {
                try {
                  if (r && !r.done && (m = i2["return"]))
                    m.call(i2);
                } finally {
                  if (e)
                    throw e.error;
                }
              }
              return ar;
            };
            var __spreadArray2 = this && this.__spreadArray || function(to, from) {
              for (var i2 = 0, il = from.length, j = to.length; i2 < il; i2++, j++)
                to[j] = from[i2];
              return to;
            };
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.mergeWith = void 0;
            var merge_1 = __webpack_require__2(6094);
            function mergeWith() {
              var otherSources = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                otherSources[_i] = arguments[_i];
              }
              return merge_1.merge.apply(void 0, __spreadArray2([], __read(otherSources)));
            }
            exports2.mergeWith = mergeWith;
          }
        ),
        /***/
        1446: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.min = void 0;
            var reduce_1 = __webpack_require__2(1386);
            var isFunction_1 = __webpack_require__2(4432);
            function min(comparer) {
              return reduce_1.reduce(isFunction_1.isFunction(comparer) ? function(x, y) {
                return comparer(x, y) < 0 ? x : y;
              } : function(x, y) {
                return x < y ? x : y;
              });
            }
            exports2.min = min;
          }
        ),
        /***/
        2318: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.multicast = void 0;
            var ConnectableObservable_1 = __webpack_require__2(3739);
            var isFunction_1 = __webpack_require__2(4432);
            var connect_1 = __webpack_require__2(4347);
            function multicast(subjectOrSubjectFactory, selector) {
              var subjectFactory = isFunction_1.isFunction(subjectOrSubjectFactory) ? subjectOrSubjectFactory : function() {
                return subjectOrSubjectFactory;
              };
              if (isFunction_1.isFunction(selector)) {
                return connect_1.connect(selector, {
                  connector: subjectFactory
                });
              }
              return function(source) {
                return new ConnectableObservable_1.ConnectableObservable(source, subjectFactory);
              };
            }
            exports2.multicast = multicast;
          }
        ),
        /***/
        3165: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.observeOn = void 0;
            var executeSchedule_1 = __webpack_require__2(5421);
            var lift_1 = __webpack_require__2(4024);
            var OperatorSubscriber_1 = __webpack_require__2(5079);
            function observeOn(scheduler, delay) {
              if (delay === void 0) {
                delay = 0;
              }
              return lift_1.operate(function(source, subscriber) {
                source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
                  return executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
                    return subscriber.next(value);
                  }, delay);
                }, function() {
                  return executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
                    return subscriber.complete();
                  }, delay);
                }, function(err) {
                  return executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
                    return subscriber.error(err);
                  }, delay);
                }));
              });
            }
            exports2.observeOn = observeOn;
          }
        ),
        /***/
        2216: (
          /***/
          function(__unused_webpack_module, exports2, __webpack_require__2) {
            "use strict";
            var __read = this && this.__read || function(o, n) {
              var m = typeof Symbol === "function" && o[Symbol.iterator];
              if (!m)
                return o;
              var i2 = m.call(o), r, ar = [], e;
              try {
                while ((n === void 0 || n-- > 0) && !(r = i2.next()).done)
                  ar.push(r.value);
              } catch (error) {
                e = { error };
              } finally {
                try {
                  if (r && !r.done && (m = i2["return"]))
                    m.call(i2);
                } finally {
                  if (e)
                    throw e.error;
                }
              }
              return ar;
            };
            var __spreadArray2 = this && this.__spreadArray || function(to, from) {
              for (var i2 = 0, il = from.length, j = to.length; i2 < il; i2++, j++)
                to[j] = from[i2];
              return to;
            };
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.onErrorResumeNext = exports2.onErrorResumeNextWith = void 0;
            var argsOrArgArray_1 = __webpack_require__2(4475);
            var onErrorResumeNext_1 = __webpack_require__2(1282);
            function onErrorResumeNextWith() {
              var sources = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                sources[_i] = arguments[_i];
              }
              var nextSources = argsOrArgArray_1.argsOrArgArray(sources);
              return function(source) {
                return onErrorResumeNext_1.onErrorResumeNext.apply(void 0, __spreadArray2([source], __read(nextSources)));
              };
            }
            exports2.onErrorResumeNextWith = onErrorResumeNextWith;
            exports2.onErrorResumeNext = onErrorResumeNextWith;
          }
        ),
        /***/
        402: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.pairwise = void 0;
            var lift_1 = __webpack_require__2(4024);
            var OperatorSubscriber_1 = __webpack_require__2(5079);
            function pairwise() {
              return lift_1.operate(function(source, subscriber) {
                var prev;
                var hasPrev = false;
                source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
                  var p = prev;
                  prev = value;
                  hasPrev && subscriber.next([p, value]);
                  hasPrev = true;
                }));
              });
            }
            exports2.pairwise = pairwise;
          }
        ),
        /***/
        5960: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.partition = void 0;
            var not_1 = __webpack_require__2(1574);
            var filter_1 = __webpack_require__2(2763);
            function partition(predicate, thisArg) {
              return function(source) {
                return [filter_1.filter(predicate, thisArg)(source), filter_1.filter(not_1.not(predicate, thisArg))(source)];
              };
            }
            exports2.partition = partition;
          }
        ),
        /***/
        5658: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.pluck = void 0;
            var map_1 = __webpack_require__2(4338);
            function pluck() {
              var properties = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                properties[_i] = arguments[_i];
              }
              var length = properties.length;
              if (length === 0) {
                throw new Error("list of properties cannot be empty.");
              }
              return map_1.map(function(x) {
                var currentProp = x;
                for (var i2 = 0; i2 < length; i2++) {
                  var p = currentProp === null || currentProp === void 0 ? void 0 : currentProp[properties[i2]];
                  if (typeof p !== "undefined") {
                    currentProp = p;
                  } else {
                    return void 0;
                  }
                }
                return currentProp;
              });
            }
            exports2.pluck = pluck;
          }
        ),
        /***/
        3881: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.publish = void 0;
            var Subject_1 = __webpack_require__2(9520);
            var multicast_1 = __webpack_require__2(2318);
            var connect_1 = __webpack_require__2(4347);
            function publish(selector) {
              return selector ? function(source) {
                return connect_1.connect(selector)(source);
              } : function(source) {
                return multicast_1.multicast(new Subject_1.Subject())(source);
              };
            }
            exports2.publish = publish;
          }
        ),
        /***/
        1755: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.publishBehavior = void 0;
            var BehaviorSubject_1 = __webpack_require__2(8042);
            var ConnectableObservable_1 = __webpack_require__2(3739);
            function publishBehavior(initialValue) {
              return function(source) {
                var subject = new BehaviorSubject_1.BehaviorSubject(initialValue);
                return new ConnectableObservable_1.ConnectableObservable(source, function() {
                  return subject;
                });
              };
            }
            exports2.publishBehavior = publishBehavior;
          }
        ),
        /***/
        9801: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.publishLast = void 0;
            var AsyncSubject_1 = __webpack_require__2(7257);
            var ConnectableObservable_1 = __webpack_require__2(3739);
            function publishLast() {
              return function(source) {
                var subject = new AsyncSubject_1.AsyncSubject();
                return new ConnectableObservable_1.ConnectableObservable(source, function() {
                  return subject;
                });
              };
            }
            exports2.publishLast = publishLast;
          }
        ),
        /***/
        5021: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.publishReplay = void 0;
            var ReplaySubject_1 = __webpack_require__2(216);
            var multicast_1 = __webpack_require__2(2318);
            var isFunction_1 = __webpack_require__2(4432);
            function publishReplay(bufferSize, windowTime, selectorOrScheduler, timestampProvider) {
              if (selectorOrScheduler && !isFunction_1.isFunction(selectorOrScheduler)) {
                timestampProvider = selectorOrScheduler;
              }
              var selector = isFunction_1.isFunction(selectorOrScheduler) ? selectorOrScheduler : void 0;
              return function(source) {
                return multicast_1.multicast(new ReplaySubject_1.ReplaySubject(bufferSize, windowTime, timestampProvider), selector)(source);
              };
            }
            exports2.publishReplay = publishReplay;
          }
        ),
        /***/
        2749: (
          /***/
          function(__unused_webpack_module, exports2, __webpack_require__2) {
            "use strict";
            var __read = this && this.__read || function(o, n) {
              var m = typeof Symbol === "function" && o[Symbol.iterator];
              if (!m)
                return o;
              var i2 = m.call(o), r, ar = [], e;
              try {
                while ((n === void 0 || n-- > 0) && !(r = i2.next()).done)
                  ar.push(r.value);
              } catch (error) {
                e = { error };
              } finally {
                try {
                  if (r && !r.done && (m = i2["return"]))
                    m.call(i2);
                } finally {
                  if (e)
                    throw e.error;
                }
              }
              return ar;
            };
            var __spreadArray2 = this && this.__spreadArray || function(to, from) {
              for (var i2 = 0, il = from.length, j = to.length; i2 < il; i2++, j++)
                to[j] = from[i2];
              return to;
            };
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.race = void 0;
            var argsOrArgArray_1 = __webpack_require__2(4475);
            var raceWith_1 = __webpack_require__2(9925);
            function race() {
              var args = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
              }
              return raceWith_1.raceWith.apply(void 0, __spreadArray2([], __read(argsOrArgArray_1.argsOrArgArray(args))));
            }
            exports2.race = race;
          }
        ),
        /***/
        9925: (
          /***/
          function(__unused_webpack_module, exports2, __webpack_require__2) {
            "use strict";
            var __read = this && this.__read || function(o, n) {
              var m = typeof Symbol === "function" && o[Symbol.iterator];
              if (!m)
                return o;
              var i2 = m.call(o), r, ar = [], e;
              try {
                while ((n === void 0 || n-- > 0) && !(r = i2.next()).done)
                  ar.push(r.value);
              } catch (error) {
                e = { error };
              } finally {
                try {
                  if (r && !r.done && (m = i2["return"]))
                    m.call(i2);
                } finally {
                  if (e)
                    throw e.error;
                }
              }
              return ar;
            };
            var __spreadArray2 = this && this.__spreadArray || function(to, from) {
              for (var i2 = 0, il = from.length, j = to.length; i2 < il; i2++, j++)
                to[j] = from[i2];
              return to;
            };
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.raceWith = void 0;
            var race_1 = __webpack_require__2(7779);
            var lift_1 = __webpack_require__2(4024);
            var identity_1 = __webpack_require__2(9144);
            function raceWith() {
              var otherSources = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                otherSources[_i] = arguments[_i];
              }
              return !otherSources.length ? identity_1.identity : lift_1.operate(function(source, subscriber) {
                race_1.raceInit(__spreadArray2([source], __read(otherSources)))(subscriber);
              });
            }
            exports2.raceWith = raceWith;
          }
        ),
        /***/
        1386: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.reduce = void 0;
            var scanInternals_1 = __webpack_require__2(2181);
            var lift_1 = __webpack_require__2(4024);
            function reduce(accumulator, seed) {
              return lift_1.operate(scanInternals_1.scanInternals(accumulator, seed, arguments.length >= 2, false, true));
            }
            exports2.reduce = reduce;
          }
        ),
        /***/
        2711: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.refCount = void 0;
            var lift_1 = __webpack_require__2(4024);
            var OperatorSubscriber_1 = __webpack_require__2(5079);
            function refCount() {
              return lift_1.operate(function(source, subscriber) {
                var connection = null;
                source._refCount++;
                var refCounter = OperatorSubscriber_1.createOperatorSubscriber(subscriber, void 0, void 0, void 0, function() {
                  if (!source || source._refCount <= 0 || 0 < --source._refCount) {
                    connection = null;
                    return;
                  }
                  var sharedConnection = source._connection;
                  var conn = connection;
                  connection = null;
                  if (sharedConnection && (!conn || sharedConnection === conn)) {
                    sharedConnection.unsubscribe();
                  }
                  subscriber.unsubscribe();
                });
                source.subscribe(refCounter);
                if (!refCounter.closed) {
                  connection = source.connect();
                }
              });
            }
            exports2.refCount = refCount;
          }
        ),
        /***/
        1194: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.repeat = void 0;
            var empty_1 = __webpack_require__2(1727);
            var lift_1 = __webpack_require__2(4024);
            var OperatorSubscriber_1 = __webpack_require__2(5079);
            var innerFrom_1 = __webpack_require__2(9451);
            var timer_1 = __webpack_require__2(5710);
            function repeat(countOrConfig) {
              var _a;
              var count = Infinity;
              var delay;
              if (countOrConfig != null) {
                if (typeof countOrConfig === "object") {
                  _a = countOrConfig.count, count = _a === void 0 ? Infinity : _a, delay = countOrConfig.delay;
                } else {
                  count = countOrConfig;
                }
              }
              return count <= 0 ? function() {
                return empty_1.EMPTY;
              } : lift_1.operate(function(source, subscriber) {
                var soFar = 0;
                var sourceSub;
                var resubscribe = function() {
                  sourceSub === null || sourceSub === void 0 ? void 0 : sourceSub.unsubscribe();
                  sourceSub = null;
                  if (delay != null) {
                    var notifier = typeof delay === "number" ? timer_1.timer(delay) : innerFrom_1.innerFrom(delay(soFar));
                    var notifierSubscriber_1 = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
                      notifierSubscriber_1.unsubscribe();
                      subscribeToSource();
                    });
                    notifier.subscribe(notifierSubscriber_1);
                  } else {
                    subscribeToSource();
                  }
                };
                var subscribeToSource = function() {
                  var syncUnsub = false;
                  sourceSub = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, void 0, function() {
                    if (++soFar < count) {
                      if (sourceSub) {
                        resubscribe();
                      } else {
                        syncUnsub = true;
                      }
                    } else {
                      subscriber.complete();
                    }
                  }));
                  if (syncUnsub) {
                    resubscribe();
                  }
                };
                subscribeToSource();
              });
            }
            exports2.repeat = repeat;
          }
        ),
        /***/
        7085: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.repeatWhen = void 0;
            var innerFrom_1 = __webpack_require__2(9451);
            var Subject_1 = __webpack_require__2(9520);
            var lift_1 = __webpack_require__2(4024);
            var OperatorSubscriber_1 = __webpack_require__2(5079);
            function repeatWhen(notifier) {
              return lift_1.operate(function(source, subscriber) {
                var innerSub;
                var syncResub = false;
                var completions$;
                var isNotifierComplete = false;
                var isMainComplete = false;
                var checkComplete = function() {
                  return isMainComplete && isNotifierComplete && (subscriber.complete(), true);
                };
                var getCompletionSubject = function() {
                  if (!completions$) {
                    completions$ = new Subject_1.Subject();
                    innerFrom_1.innerFrom(notifier(completions$)).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
                      if (innerSub) {
                        subscribeForRepeatWhen();
                      } else {
                        syncResub = true;
                      }
                    }, function() {
                      isNotifierComplete = true;
                      checkComplete();
                    }));
                  }
                  return completions$;
                };
                var subscribeForRepeatWhen = function() {
                  isMainComplete = false;
                  innerSub = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, void 0, function() {
                    isMainComplete = true;
                    !checkComplete() && getCompletionSubject().next();
                  }));
                  if (syncResub) {
                    innerSub.unsubscribe();
                    innerSub = null;
                    syncResub = false;
                    subscribeForRepeatWhen();
                  }
                };
                subscribeForRepeatWhen();
              });
            }
            exports2.repeatWhen = repeatWhen;
          }
        ),
        /***/
        7524: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.retry = void 0;
            var lift_1 = __webpack_require__2(4024);
            var OperatorSubscriber_1 = __webpack_require__2(5079);
            var identity_1 = __webpack_require__2(9144);
            var timer_1 = __webpack_require__2(5710);
            var innerFrom_1 = __webpack_require__2(9451);
            function retry(configOrCount) {
              if (configOrCount === void 0) {
                configOrCount = Infinity;
              }
              var config2;
              if (configOrCount && typeof configOrCount === "object") {
                config2 = configOrCount;
              } else {
                config2 = {
                  count: configOrCount
                };
              }
              var _a = config2.count, count = _a === void 0 ? Infinity : _a, delay = config2.delay, _b = config2.resetOnSuccess, resetOnSuccess = _b === void 0 ? false : _b;
              return count <= 0 ? identity_1.identity : lift_1.operate(function(source, subscriber) {
                var soFar = 0;
                var innerSub;
                var subscribeForRetry = function() {
                  var syncUnsub = false;
                  innerSub = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
                    if (resetOnSuccess) {
                      soFar = 0;
                    }
                    subscriber.next(value);
                  }, void 0, function(err) {
                    if (soFar++ < count) {
                      var resub_1 = function() {
                        if (innerSub) {
                          innerSub.unsubscribe();
                          innerSub = null;
                          subscribeForRetry();
                        } else {
                          syncUnsub = true;
                        }
                      };
                      if (delay != null) {
                        var notifier = typeof delay === "number" ? timer_1.timer(delay) : innerFrom_1.innerFrom(delay(err, soFar));
                        var notifierSubscriber_1 = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
                          notifierSubscriber_1.unsubscribe();
                          resub_1();
                        }, function() {
                          subscriber.complete();
                        });
                        notifier.subscribe(notifierSubscriber_1);
                      } else {
                        resub_1();
                      }
                    } else {
                      subscriber.error(err);
                    }
                  }));
                  if (syncUnsub) {
                    innerSub.unsubscribe();
                    innerSub = null;
                    subscribeForRetry();
                  }
                };
                subscribeForRetry();
              });
            }
            exports2.retry = retry;
          }
        ),
        /***/
        548: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.retryWhen = void 0;
            var innerFrom_1 = __webpack_require__2(9451);
            var Subject_1 = __webpack_require__2(9520);
            var lift_1 = __webpack_require__2(4024);
            var OperatorSubscriber_1 = __webpack_require__2(5079);
            function retryWhen(notifier) {
              return lift_1.operate(function(source, subscriber) {
                var innerSub;
                var syncResub = false;
                var errors$;
                var subscribeForRetryWhen = function() {
                  innerSub = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, void 0, void 0, function(err) {
                    if (!errors$) {
                      errors$ = new Subject_1.Subject();
                      innerFrom_1.innerFrom(notifier(errors$)).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
                        return innerSub ? subscribeForRetryWhen() : syncResub = true;
                      }));
                    }
                    if (errors$) {
                      errors$.next(err);
                    }
                  }));
                  if (syncResub) {
                    innerSub.unsubscribe();
                    innerSub = null;
                    syncResub = false;
                    subscribeForRetryWhen();
                  }
                };
                subscribeForRetryWhen();
              });
            }
            exports2.retryWhen = retryWhen;
          }
        ),
        /***/
        6577: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.sample = void 0;
            var innerFrom_1 = __webpack_require__2(9451);
            var lift_1 = __webpack_require__2(4024);
            var noop_1 = __webpack_require__2(5729);
            var OperatorSubscriber_1 = __webpack_require__2(5079);
            function sample(notifier) {
              return lift_1.operate(function(source, subscriber) {
                var hasValue = false;
                var lastValue = null;
                source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
                  hasValue = true;
                  lastValue = value;
                }));
                innerFrom_1.innerFrom(notifier).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
                  if (hasValue) {
                    hasValue = false;
                    var value = lastValue;
                    lastValue = null;
                    subscriber.next(value);
                  }
                }, noop_1.noop));
              });
            }
            exports2.sample = sample;
          }
        ),
        /***/
        3815: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.sampleTime = void 0;
            var async_1 = __webpack_require__2(4617);
            var sample_1 = __webpack_require__2(6577);
            var interval_1 = __webpack_require__2(4449);
            function sampleTime(period, scheduler) {
              if (scheduler === void 0) {
                scheduler = async_1.asyncScheduler;
              }
              return sample_1.sample(interval_1.interval(period, scheduler));
            }
            exports2.sampleTime = sampleTime;
          }
        ),
        /***/
        7250: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.scan = void 0;
            var lift_1 = __webpack_require__2(4024);
            var scanInternals_1 = __webpack_require__2(2181);
            function scan(accumulator, seed) {
              return lift_1.operate(scanInternals_1.scanInternals(accumulator, seed, arguments.length >= 2, true));
            }
            exports2.scan = scan;
          }
        ),
        /***/
        2181: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.scanInternals = void 0;
            var OperatorSubscriber_1 = __webpack_require__2(5079);
            function scanInternals(accumulator, seed, hasSeed, emitOnNext, emitBeforeComplete) {
              return function(source, subscriber) {
                var hasState = hasSeed;
                var state = seed;
                var index = 0;
                source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
                  var i2 = index++;
                  state = hasState ? accumulator(state, value, i2) : (hasState = true, value);
                  emitOnNext && subscriber.next(state);
                }, emitBeforeComplete && function() {
                  hasState && subscriber.next(state);
                  subscriber.complete();
                }));
              };
            }
            exports2.scanInternals = scanInternals;
          }
        ),
        /***/
        842: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.sequenceEqual = void 0;
            var lift_1 = __webpack_require__2(4024);
            var OperatorSubscriber_1 = __webpack_require__2(5079);
            var innerFrom_1 = __webpack_require__2(9451);
            function sequenceEqual(compareTo, comparator) {
              if (comparator === void 0) {
                comparator = function(a, b) {
                  return a === b;
                };
              }
              return lift_1.operate(function(source, subscriber) {
                var aState = createState();
                var bState = createState();
                var emit = function(isEqual) {
                  subscriber.next(isEqual);
                  subscriber.complete();
                };
                var createSubscriber = function(selfState, otherState) {
                  var sequenceEqualSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(a) {
                    var buffer = otherState.buffer, complete = otherState.complete;
                    if (buffer.length === 0) {
                      complete ? emit(false) : selfState.buffer.push(a);
                    } else {
                      !comparator(a, buffer.shift()) && emit(false);
                    }
                  }, function() {
                    selfState.complete = true;
                    var complete = otherState.complete, buffer = otherState.buffer;
                    complete && emit(buffer.length === 0);
                    sequenceEqualSubscriber === null || sequenceEqualSubscriber === void 0 ? void 0 : sequenceEqualSubscriber.unsubscribe();
                  });
                  return sequenceEqualSubscriber;
                };
                source.subscribe(createSubscriber(aState, bState));
                innerFrom_1.innerFrom(compareTo).subscribe(createSubscriber(bState, aState));
              });
            }
            exports2.sequenceEqual = sequenceEqual;
            function createState() {
              return {
                buffer: [],
                complete: false
              };
            }
          }
        ),
        /***/
        9728: (
          /***/
          function(__unused_webpack_module, exports2, __webpack_require__2) {
            "use strict";
            var __read = this && this.__read || function(o, n) {
              var m = typeof Symbol === "function" && o[Symbol.iterator];
              if (!m)
                return o;
              var i2 = m.call(o), r, ar = [], e;
              try {
                while ((n === void 0 || n-- > 0) && !(r = i2.next()).done)
                  ar.push(r.value);
              } catch (error) {
                e = { error };
              } finally {
                try {
                  if (r && !r.done && (m = i2["return"]))
                    m.call(i2);
                } finally {
                  if (e)
                    throw e.error;
                }
              }
              return ar;
            };
            var __spreadArray2 = this && this.__spreadArray || function(to, from) {
              for (var i2 = 0, il = from.length, j = to.length; i2 < il; i2++, j++)
                to[j] = from[i2];
              return to;
            };
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.share = void 0;
            var innerFrom_1 = __webpack_require__2(9451);
            var Subject_1 = __webpack_require__2(9520);
            var Subscriber_1 = __webpack_require__2(1403);
            var lift_1 = __webpack_require__2(4024);
            function share(options) {
              if (options === void 0) {
                options = {};
              }
              var _a = options.connector, connector = _a === void 0 ? function() {
                return new Subject_1.Subject();
              } : _a, _b = options.resetOnError, resetOnError = _b === void 0 ? true : _b, _c = options.resetOnComplete, resetOnComplete = _c === void 0 ? true : _c, _d = options.resetOnRefCountZero, resetOnRefCountZero = _d === void 0 ? true : _d;
              return function(wrapperSource) {
                var connection;
                var resetConnection;
                var subject;
                var refCount = 0;
                var hasCompleted = false;
                var hasErrored = false;
                var cancelReset = function() {
                  resetConnection === null || resetConnection === void 0 ? void 0 : resetConnection.unsubscribe();
                  resetConnection = void 0;
                };
                var reset = function() {
                  cancelReset();
                  connection = subject = void 0;
                  hasCompleted = hasErrored = false;
                };
                var resetAndUnsubscribe = function() {
                  var conn = connection;
                  reset();
                  conn === null || conn === void 0 ? void 0 : conn.unsubscribe();
                };
                return lift_1.operate(function(source, subscriber) {
                  refCount++;
                  if (!hasErrored && !hasCompleted) {
                    cancelReset();
                  }
                  var dest = subject = subject !== null && subject !== void 0 ? subject : connector();
                  subscriber.add(function() {
                    refCount--;
                    if (refCount === 0 && !hasErrored && !hasCompleted) {
                      resetConnection = handleReset(resetAndUnsubscribe, resetOnRefCountZero);
                    }
                  });
                  dest.subscribe(subscriber);
                  if (!connection && refCount > 0) {
                    connection = new Subscriber_1.SafeSubscriber({
                      next: function(value) {
                        return dest.next(value);
                      },
                      error: function(err) {
                        hasErrored = true;
                        cancelReset();
                        resetConnection = handleReset(reset, resetOnError, err);
                        dest.error(err);
                      },
                      complete: function() {
                        hasCompleted = true;
                        cancelReset();
                        resetConnection = handleReset(reset, resetOnComplete);
                        dest.complete();
                      }
                    });
                    innerFrom_1.innerFrom(source).subscribe(connection);
                  }
                })(wrapperSource);
              };
            }
            exports2.share = share;
            function handleReset(reset, on) {
              var args = [];
              for (var _i = 2; _i < arguments.length; _i++) {
                args[_i - 2] = arguments[_i];
              }
              if (on === true) {
                reset();
                return;
              }
              if (on === false) {
                return;
              }
              var onSubscriber = new Subscriber_1.SafeSubscriber({
                next: function() {
                  onSubscriber.unsubscribe();
                  reset();
                }
              });
              return innerFrom_1.innerFrom(on.apply(void 0, __spreadArray2([], __read(args)))).subscribe(onSubscriber);
            }
          }
        ),
        /***/
        7768: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.shareReplay = void 0;
            var ReplaySubject_1 = __webpack_require__2(216);
            var share_1 = __webpack_require__2(9728);
            function shareReplay(configOrBufferSize, windowTime, scheduler) {
              var _a, _b, _c;
              var bufferSize;
              var refCount = false;
              if (configOrBufferSize && typeof configOrBufferSize === "object") {
                _a = configOrBufferSize.bufferSize, bufferSize = _a === void 0 ? Infinity : _a, _b = configOrBufferSize.windowTime, windowTime = _b === void 0 ? Infinity : _b, _c = configOrBufferSize.refCount, refCount = _c === void 0 ? false : _c, scheduler = configOrBufferSize.scheduler;
              } else {
                bufferSize = configOrBufferSize !== null && configOrBufferSize !== void 0 ? configOrBufferSize : Infinity;
              }
              return share_1.share({
                connector: function() {
                  return new ReplaySubject_1.ReplaySubject(bufferSize, windowTime, scheduler);
                },
                resetOnError: true,
                resetOnComplete: false,
                resetOnRefCountZero: refCount
              });
            }
            exports2.shareReplay = shareReplay;
          }
        ),
        /***/
        2445: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.single = void 0;
            var EmptyError_1 = __webpack_require__2(8032);
            var SequenceError_1 = __webpack_require__2(6228);
            var NotFoundError_1 = __webpack_require__2(1137);
            var lift_1 = __webpack_require__2(4024);
            var OperatorSubscriber_1 = __webpack_require__2(5079);
            function single(predicate) {
              return lift_1.operate(function(source, subscriber) {
                var hasValue = false;
                var singleValue;
                var seenValue = false;
                var index = 0;
                source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
                  seenValue = true;
                  if (!predicate || predicate(value, index++, source)) {
                    hasValue && subscriber.error(new SequenceError_1.SequenceError("Too many matching values"));
                    hasValue = true;
                    singleValue = value;
                  }
                }, function() {
                  if (hasValue) {
                    subscriber.next(singleValue);
                    subscriber.complete();
                  } else {
                    subscriber.error(seenValue ? new NotFoundError_1.NotFoundError("No matching values") : new EmptyError_1.EmptyError());
                  }
                }));
              });
            }
            exports2.single = single;
          }
        ),
        /***/
        6262: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.skip = void 0;
            var filter_1 = __webpack_require__2(2763);
            function skip(count) {
              return filter_1.filter(function(_, index) {
                return count <= index;
              });
            }
            exports2.skip = skip;
          }
        ),
        /***/
        7397: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.skipLast = void 0;
            var identity_1 = __webpack_require__2(9144);
            var lift_1 = __webpack_require__2(4024);
            var OperatorSubscriber_1 = __webpack_require__2(5079);
            function skipLast(skipCount) {
              return skipCount <= 0 ? identity_1.identity : lift_1.operate(function(source, subscriber) {
                var ring = new Array(skipCount);
                var seen = 0;
                source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
                  var valueIndex = seen++;
                  if (valueIndex < skipCount) {
                    ring[valueIndex] = value;
                  } else {
                    var index = valueIndex % skipCount;
                    var oldValue = ring[index];
                    ring[index] = value;
                    subscriber.next(oldValue);
                  }
                }));
                return function() {
                  ring = null;
                };
              });
            }
            exports2.skipLast = skipLast;
          }
        ),
        /***/
        9900: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.skipUntil = void 0;
            var lift_1 = __webpack_require__2(4024);
            var OperatorSubscriber_1 = __webpack_require__2(5079);
            var innerFrom_1 = __webpack_require__2(9451);
            var noop_1 = __webpack_require__2(5729);
            function skipUntil(notifier) {
              return lift_1.operate(function(source, subscriber) {
                var taking = false;
                var skipSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
                  skipSubscriber === null || skipSubscriber === void 0 ? void 0 : skipSubscriber.unsubscribe();
                  taking = true;
                }, noop_1.noop);
                innerFrom_1.innerFrom(notifier).subscribe(skipSubscriber);
                source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
                  return taking && subscriber.next(value);
                }));
              });
            }
            exports2.skipUntil = skipUntil;
          }
        ),
        /***/
        1620: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.skipWhile = void 0;
            var lift_1 = __webpack_require__2(4024);
            var OperatorSubscriber_1 = __webpack_require__2(5079);
            function skipWhile(predicate) {
              return lift_1.operate(function(source, subscriber) {
                var taking = false;
                var index = 0;
                source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
                  return (taking || (taking = !predicate(value, index++))) && subscriber.next(value);
                }));
              });
            }
            exports2.skipWhile = skipWhile;
          }
        ),
        /***/
        3424: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.startWith = void 0;
            var concat_1 = __webpack_require__2(79);
            var args_1 = __webpack_require__2(2619);
            var lift_1 = __webpack_require__2(4024);
            function startWith() {
              var values = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                values[_i] = arguments[_i];
              }
              var scheduler = args_1.popScheduler(values);
              return lift_1.operate(function(source, subscriber) {
                (scheduler ? concat_1.concat(values, source, scheduler) : concat_1.concat(values, source)).subscribe(subscriber);
              });
            }
            exports2.startWith = startWith;
          }
        ),
        /***/
        831: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.subscribeOn = void 0;
            var lift_1 = __webpack_require__2(4024);
            function subscribeOn(scheduler, delay) {
              if (delay === void 0) {
                delay = 0;
              }
              return lift_1.operate(function(source, subscriber) {
                subscriber.add(scheduler.schedule(function() {
                  return source.subscribe(subscriber);
                }, delay));
              });
            }
            exports2.subscribeOn = subscribeOn;
          }
        ),
        /***/
        411: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.switchAll = void 0;
            var switchMap_1 = __webpack_require__2(7222);
            var identity_1 = __webpack_require__2(9144);
            function switchAll() {
              return switchMap_1.switchMap(identity_1.identity);
            }
            exports2.switchAll = switchAll;
          }
        ),
        /***/
        7222: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.switchMap = void 0;
            var innerFrom_1 = __webpack_require__2(9451);
            var lift_1 = __webpack_require__2(4024);
            var OperatorSubscriber_1 = __webpack_require__2(5079);
            function switchMap(project, resultSelector) {
              return lift_1.operate(function(source, subscriber) {
                var innerSubscriber = null;
                var index = 0;
                var isComplete = false;
                var checkComplete = function() {
                  return isComplete && !innerSubscriber && subscriber.complete();
                };
                source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
                  innerSubscriber === null || innerSubscriber === void 0 ? void 0 : innerSubscriber.unsubscribe();
                  var innerIndex = 0;
                  var outerIndex = index++;
                  innerFrom_1.innerFrom(project(value, outerIndex)).subscribe(innerSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(innerValue) {
                    return subscriber.next(resultSelector ? resultSelector(value, innerValue, outerIndex, innerIndex++) : innerValue);
                  }, function() {
                    innerSubscriber = null;
                    checkComplete();
                  }));
                }, function() {
                  isComplete = true;
                  checkComplete();
                }));
              });
            }
            exports2.switchMap = switchMap;
          }
        ),
        /***/
        6464: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.switchMapTo = void 0;
            var switchMap_1 = __webpack_require__2(7222);
            var isFunction_1 = __webpack_require__2(4432);
            function switchMapTo(innerObservable, resultSelector) {
              return isFunction_1.isFunction(resultSelector) ? switchMap_1.switchMap(function() {
                return innerObservable;
              }, resultSelector) : switchMap_1.switchMap(function() {
                return innerObservable;
              });
            }
            exports2.switchMapTo = switchMapTo;
          }
        ),
        /***/
        4434: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.switchScan = void 0;
            var switchMap_1 = __webpack_require__2(7222);
            var lift_1 = __webpack_require__2(4024);
            function switchScan(accumulator, seed) {
              return lift_1.operate(function(source, subscriber) {
                var state = seed;
                switchMap_1.switchMap(function(value, index) {
                  return accumulator(state, value, index);
                }, function(_, innerValue) {
                  return state = innerValue, innerValue;
                })(source).subscribe(subscriber);
                return function() {
                  state = null;
                };
              });
            }
            exports2.switchScan = switchScan;
          }
        ),
        /***/
        7138: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.take = void 0;
            var empty_1 = __webpack_require__2(1727);
            var lift_1 = __webpack_require__2(4024);
            var OperatorSubscriber_1 = __webpack_require__2(5079);
            function take(count) {
              return count <= 0 ? function() {
                return empty_1.EMPTY;
              } : lift_1.operate(function(source, subscriber) {
                var seen = 0;
                source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
                  if (++seen <= count) {
                    subscriber.next(value);
                    if (count <= seen) {
                      subscriber.complete();
                    }
                  }
                }));
              });
            }
            exports2.take = take;
          }
        ),
        /***/
        4288: (
          /***/
          function(__unused_webpack_module, exports2, __webpack_require__2) {
            "use strict";
            var __values = this && this.__values || function(o) {
              var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i2 = 0;
              if (m)
                return m.call(o);
              if (o && typeof o.length === "number")
                return {
                  next: function() {
                    if (o && i2 >= o.length)
                      o = void 0;
                    return { value: o && o[i2++], done: !o };
                  }
                };
              throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
            };
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.takeLast = void 0;
            var empty_1 = __webpack_require__2(1727);
            var lift_1 = __webpack_require__2(4024);
            var OperatorSubscriber_1 = __webpack_require__2(5079);
            function takeLast(count) {
              return count <= 0 ? function() {
                return empty_1.EMPTY;
              } : lift_1.operate(function(source, subscriber) {
                var buffer = [];
                source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
                  buffer.push(value);
                  count < buffer.length && buffer.shift();
                }, function() {
                  var e_1, _a;
                  try {
                    for (var buffer_1 = __values(buffer), buffer_1_1 = buffer_1.next(); !buffer_1_1.done; buffer_1_1 = buffer_1.next()) {
                      var value = buffer_1_1.value;
                      subscriber.next(value);
                    }
                  } catch (e_1_1) {
                    e_1 = { error: e_1_1 };
                  } finally {
                    try {
                      if (buffer_1_1 && !buffer_1_1.done && (_a = buffer_1.return))
                        _a.call(buffer_1);
                    } finally {
                      if (e_1)
                        throw e_1.error;
                    }
                  }
                  subscriber.complete();
                }, void 0, function() {
                  buffer = null;
                }));
              });
            }
            exports2.takeLast = takeLast;
          }
        ),
        /***/
        7341: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.takeUntil = void 0;
            var lift_1 = __webpack_require__2(4024);
            var OperatorSubscriber_1 = __webpack_require__2(5079);
            var innerFrom_1 = __webpack_require__2(9451);
            var noop_1 = __webpack_require__2(5729);
            function takeUntil(notifier) {
              return lift_1.operate(function(source, subscriber) {
                innerFrom_1.innerFrom(notifier).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
                  return subscriber.complete();
                }, noop_1.noop));
                !subscriber.closed && source.subscribe(subscriber);
              });
            }
            exports2.takeUntil = takeUntil;
          }
        ),
        /***/
        653: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.takeWhile = void 0;
            var lift_1 = __webpack_require__2(4024);
            var OperatorSubscriber_1 = __webpack_require__2(5079);
            function takeWhile(predicate, inclusive) {
              if (inclusive === void 0) {
                inclusive = false;
              }
              return lift_1.operate(function(source, subscriber) {
                var index = 0;
                source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
                  var result = predicate(value, index++);
                  (result || inclusive) && subscriber.next(value);
                  !result && subscriber.complete();
                }));
              });
            }
            exports2.takeWhile = takeWhile;
          }
        ),
        /***/
        8668: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.tap = void 0;
            var isFunction_1 = __webpack_require__2(4432);
            var lift_1 = __webpack_require__2(4024);
            var OperatorSubscriber_1 = __webpack_require__2(5079);
            var identity_1 = __webpack_require__2(9144);
            function tap(observerOrNext, error, complete) {
              var tapObserver = isFunction_1.isFunction(observerOrNext) || error || complete ? { next: observerOrNext, error, complete } : observerOrNext;
              return tapObserver ? lift_1.operate(function(source, subscriber) {
                var _a;
                (_a = tapObserver.subscribe) === null || _a === void 0 ? void 0 : _a.call(tapObserver);
                var isUnsub = true;
                source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
                  var _a2;
                  (_a2 = tapObserver.next) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver, value);
                  subscriber.next(value);
                }, function() {
                  var _a2;
                  isUnsub = false;
                  (_a2 = tapObserver.complete) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver);
                  subscriber.complete();
                }, function(err) {
                  var _a2;
                  isUnsub = false;
                  (_a2 = tapObserver.error) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver, err);
                  subscriber.error(err);
                }, function() {
                  var _a2, _b;
                  if (isUnsub) {
                    (_a2 = tapObserver.unsubscribe) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver);
                  }
                  (_b = tapObserver.finalize) === null || _b === void 0 ? void 0 : _b.call(tapObserver);
                }));
              }) : identity_1.identity;
            }
            exports2.tap = tap;
          }
        ),
        /***/
        9466: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.throttle = void 0;
            var lift_1 = __webpack_require__2(4024);
            var OperatorSubscriber_1 = __webpack_require__2(5079);
            var innerFrom_1 = __webpack_require__2(9451);
            function throttle(durationSelector, config2) {
              return lift_1.operate(function(source, subscriber) {
                var _a = config2 !== null && config2 !== void 0 ? config2 : {}, _b = _a.leading, leading = _b === void 0 ? true : _b, _c = _a.trailing, trailing = _c === void 0 ? false : _c;
                var hasValue = false;
                var sendValue = null;
                var throttled = null;
                var isComplete = false;
                var endThrottling = function() {
                  throttled === null || throttled === void 0 ? void 0 : throttled.unsubscribe();
                  throttled = null;
                  if (trailing) {
                    send();
                    isComplete && subscriber.complete();
                  }
                };
                var cleanupThrottling = function() {
                  throttled = null;
                  isComplete && subscriber.complete();
                };
                var startThrottle = function(value) {
                  return throttled = innerFrom_1.innerFrom(durationSelector(value)).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, endThrottling, cleanupThrottling));
                };
                var send = function() {
                  if (hasValue) {
                    hasValue = false;
                    var value = sendValue;
                    sendValue = null;
                    subscriber.next(value);
                    !isComplete && startThrottle(value);
                  }
                };
                source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
                  hasValue = true;
                  sendValue = value;
                  !(throttled && !throttled.closed) && (leading ? send() : startThrottle(value));
                }, function() {
                  isComplete = true;
                  !(trailing && hasValue && throttled && !throttled.closed) && subscriber.complete();
                }));
              });
            }
            exports2.throttle = throttle;
          }
        ),
        /***/
        9705: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.throttleTime = void 0;
            var async_1 = __webpack_require__2(4617);
            var throttle_1 = __webpack_require__2(9466);
            var timer_1 = __webpack_require__2(5710);
            function throttleTime(duration, scheduler, config2) {
              if (scheduler === void 0) {
                scheduler = async_1.asyncScheduler;
              }
              var duration$ = timer_1.timer(duration, scheduler);
              return throttle_1.throttle(function() {
                return duration$;
              }, config2);
            }
            exports2.throttleTime = throttleTime;
          }
        ),
        /***/
        8062: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.throwIfEmpty = void 0;
            var EmptyError_1 = __webpack_require__2(8032);
            var lift_1 = __webpack_require__2(4024);
            var OperatorSubscriber_1 = __webpack_require__2(5079);
            function throwIfEmpty(errorFactory) {
              if (errorFactory === void 0) {
                errorFactory = defaultErrorFactory;
              }
              return lift_1.operate(function(source, subscriber) {
                var hasValue = false;
                source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
                  hasValue = true;
                  subscriber.next(value);
                }, function() {
                  return hasValue ? subscriber.complete() : subscriber.error(errorFactory());
                }));
              });
            }
            exports2.throwIfEmpty = throwIfEmpty;
            function defaultErrorFactory() {
              return new EmptyError_1.EmptyError();
            }
          }
        ),
        /***/
        6610: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.TimeInterval = exports2.timeInterval = void 0;
            var async_1 = __webpack_require__2(4617);
            var lift_1 = __webpack_require__2(4024);
            var OperatorSubscriber_1 = __webpack_require__2(5079);
            function timeInterval(scheduler) {
              if (scheduler === void 0) {
                scheduler = async_1.asyncScheduler;
              }
              return lift_1.operate(function(source, subscriber) {
                var last = scheduler.now();
                source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
                  var now = scheduler.now();
                  var interval = now - last;
                  last = now;
                  subscriber.next(new TimeInterval(value, interval));
                }));
              });
            }
            exports2.timeInterval = timeInterval;
            var TimeInterval = /* @__PURE__ */ function() {
              function TimeInterval2(value, interval) {
                this.value = value;
                this.interval = interval;
              }
              return TimeInterval2;
            }();
            exports2.TimeInterval = TimeInterval;
          }
        ),
        /***/
        6279: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.timeout = exports2.TimeoutError = void 0;
            var async_1 = __webpack_require__2(4617);
            var isDate_1 = __webpack_require__2(7761);
            var lift_1 = __webpack_require__2(4024);
            var innerFrom_1 = __webpack_require__2(9451);
            var createErrorClass_1 = __webpack_require__2(9876);
            var OperatorSubscriber_1 = __webpack_require__2(5079);
            var executeSchedule_1 = __webpack_require__2(5421);
            exports2.TimeoutError = createErrorClass_1.createErrorClass(function(_super) {
              return function TimeoutErrorImpl(info) {
                if (info === void 0) {
                  info = null;
                }
                _super(this);
                this.message = "Timeout has occurred";
                this.name = "TimeoutError";
                this.info = info;
              };
            });
            function timeout(config2, schedulerArg) {
              var _a = isDate_1.isValidDate(config2) ? { first: config2 } : typeof config2 === "number" ? { each: config2 } : config2, first = _a.first, each = _a.each, _b = _a.with, _with = _b === void 0 ? timeoutErrorFactory : _b, _c = _a.scheduler, scheduler = _c === void 0 ? schedulerArg !== null && schedulerArg !== void 0 ? schedulerArg : async_1.asyncScheduler : _c, _d = _a.meta, meta = _d === void 0 ? null : _d;
              if (first == null && each == null) {
                throw new TypeError("No timeout provided.");
              }
              return lift_1.operate(function(source, subscriber) {
                var originalSourceSubscription;
                var timerSubscription;
                var lastValue = null;
                var seen = 0;
                var startTimer = function(delay) {
                  timerSubscription = executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
                    try {
                      originalSourceSubscription.unsubscribe();
                      innerFrom_1.innerFrom(_with({
                        meta,
                        lastValue,
                        seen
                      })).subscribe(subscriber);
                    } catch (err) {
                      subscriber.error(err);
                    }
                  }, delay);
                };
                originalSourceSubscription = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
                  timerSubscription === null || timerSubscription === void 0 ? void 0 : timerSubscription.unsubscribe();
                  seen++;
                  subscriber.next(lastValue = value);
                  each > 0 && startTimer(each);
                }, void 0, void 0, function() {
                  if (!(timerSubscription === null || timerSubscription === void 0 ? void 0 : timerSubscription.closed)) {
                    timerSubscription === null || timerSubscription === void 0 ? void 0 : timerSubscription.unsubscribe();
                  }
                  lastValue = null;
                }));
                !seen && startTimer(first != null ? typeof first === "number" ? first : +first - scheduler.now() : each);
              });
            }
            exports2.timeout = timeout;
            function timeoutErrorFactory(info) {
              throw new exports2.TimeoutError(info);
            }
          }
        ),
        /***/
        8132: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.timeoutWith = void 0;
            var async_1 = __webpack_require__2(4617);
            var isDate_1 = __webpack_require__2(7761);
            var timeout_1 = __webpack_require__2(6279);
            function timeoutWith(due, withObservable, scheduler) {
              var first;
              var each;
              var _with;
              scheduler = scheduler !== null && scheduler !== void 0 ? scheduler : async_1.async;
              if (isDate_1.isValidDate(due)) {
                first = due;
              } else if (typeof due === "number") {
                each = due;
              }
              if (withObservable) {
                _with = function() {
                  return withObservable;
                };
              } else {
                throw new TypeError("No observable provided to switch to");
              }
              if (first == null && each == null) {
                throw new TypeError("No timeout provided.");
              }
              return timeout_1.timeout({
                first,
                each,
                scheduler,
                with: _with
              });
            }
            exports2.timeoutWith = timeoutWith;
          }
        ),
        /***/
        4553: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.timestamp = void 0;
            var dateTimestampProvider_1 = __webpack_require__2(1713);
            var map_1 = __webpack_require__2(4338);
            function timestamp(timestampProvider) {
              if (timestampProvider === void 0) {
                timestampProvider = dateTimestampProvider_1.dateTimestampProvider;
              }
              return map_1.map(function(value) {
                return { value, timestamp: timestampProvider.now() };
              });
            }
            exports2.timestamp = timestamp;
          }
        ),
        /***/
        2378: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.toArray = void 0;
            var reduce_1 = __webpack_require__2(1386);
            var lift_1 = __webpack_require__2(4024);
            var arrReducer = function(arr, value) {
              return arr.push(value), arr;
            };
            function toArray() {
              return lift_1.operate(function(source, subscriber) {
                reduce_1.reduce(arrReducer, [])(source).subscribe(subscriber);
              });
            }
            exports2.toArray = toArray;
          }
        ),
        /***/
        4768: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.window = void 0;
            var Subject_1 = __webpack_require__2(9520);
            var lift_1 = __webpack_require__2(4024);
            var OperatorSubscriber_1 = __webpack_require__2(5079);
            var noop_1 = __webpack_require__2(5729);
            var innerFrom_1 = __webpack_require__2(9451);
            function window2(windowBoundaries) {
              return lift_1.operate(function(source, subscriber) {
                var windowSubject = new Subject_1.Subject();
                subscriber.next(windowSubject.asObservable());
                var errorHandler = function(err) {
                  windowSubject.error(err);
                  subscriber.error(err);
                };
                source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
                  return windowSubject === null || windowSubject === void 0 ? void 0 : windowSubject.next(value);
                }, function() {
                  windowSubject.complete();
                  subscriber.complete();
                }, errorHandler));
                innerFrom_1.innerFrom(windowBoundaries).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
                  windowSubject.complete();
                  subscriber.next(windowSubject = new Subject_1.Subject());
                }, noop_1.noop, errorHandler));
                return function() {
                  windowSubject === null || windowSubject === void 0 ? void 0 : windowSubject.unsubscribe();
                  windowSubject = null;
                };
              });
            }
            exports2.window = window2;
          }
        ),
        /***/
        131: (
          /***/
          function(__unused_webpack_module, exports2, __webpack_require__2) {
            "use strict";
            var __values = this && this.__values || function(o) {
              var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i2 = 0;
              if (m)
                return m.call(o);
              if (o && typeof o.length === "number")
                return {
                  next: function() {
                    if (o && i2 >= o.length)
                      o = void 0;
                    return { value: o && o[i2++], done: !o };
                  }
                };
              throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
            };
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.windowCount = void 0;
            var Subject_1 = __webpack_require__2(9520);
            var lift_1 = __webpack_require__2(4024);
            var OperatorSubscriber_1 = __webpack_require__2(5079);
            function windowCount(windowSize, startWindowEvery) {
              if (startWindowEvery === void 0) {
                startWindowEvery = 0;
              }
              var startEvery = startWindowEvery > 0 ? startWindowEvery : windowSize;
              return lift_1.operate(function(source, subscriber) {
                var windows = [new Subject_1.Subject()];
                var starts = [];
                var count = 0;
                subscriber.next(windows[0].asObservable());
                source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
                  var e_1, _a;
                  try {
                    for (var windows_1 = __values(windows), windows_1_1 = windows_1.next(); !windows_1_1.done; windows_1_1 = windows_1.next()) {
                      var window_1 = windows_1_1.value;
                      window_1.next(value);
                    }
                  } catch (e_1_1) {
                    e_1 = { error: e_1_1 };
                  } finally {
                    try {
                      if (windows_1_1 && !windows_1_1.done && (_a = windows_1.return))
                        _a.call(windows_1);
                    } finally {
                      if (e_1)
                        throw e_1.error;
                    }
                  }
                  var c = count - windowSize + 1;
                  if (c >= 0 && c % startEvery === 0) {
                    windows.shift().complete();
                  }
                  if (++count % startEvery === 0) {
                    var window_2 = new Subject_1.Subject();
                    windows.push(window_2);
                    subscriber.next(window_2.asObservable());
                  }
                }, function() {
                  while (windows.length > 0) {
                    windows.shift().complete();
                  }
                  subscriber.complete();
                }, function(err) {
                  while (windows.length > 0) {
                    windows.shift().error(err);
                  }
                  subscriber.error(err);
                }, function() {
                  starts = null;
                  windows = null;
                }));
              });
            }
            exports2.windowCount = windowCount;
          }
        ),
        /***/
        9579: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.windowTime = void 0;
            var Subject_1 = __webpack_require__2(9520);
            var async_1 = __webpack_require__2(4617);
            var Subscription_1 = __webpack_require__2(7215);
            var lift_1 = __webpack_require__2(4024);
            var OperatorSubscriber_1 = __webpack_require__2(5079);
            var arrRemove_1 = __webpack_require__2(2447);
            var args_1 = __webpack_require__2(2619);
            var executeSchedule_1 = __webpack_require__2(5421);
            function windowTime(windowTimeSpan) {
              var _a, _b;
              var otherArgs = [];
              for (var _i = 1; _i < arguments.length; _i++) {
                otherArgs[_i - 1] = arguments[_i];
              }
              var scheduler = (_a = args_1.popScheduler(otherArgs)) !== null && _a !== void 0 ? _a : async_1.asyncScheduler;
              var windowCreationInterval = (_b = otherArgs[0]) !== null && _b !== void 0 ? _b : null;
              var maxWindowSize = otherArgs[1] || Infinity;
              return lift_1.operate(function(source, subscriber) {
                var windowRecords = [];
                var restartOnClose = false;
                var closeWindow = function(record) {
                  var window2 = record.window, subs = record.subs;
                  window2.complete();
                  subs.unsubscribe();
                  arrRemove_1.arrRemove(windowRecords, record);
                  restartOnClose && startWindow();
                };
                var startWindow = function() {
                  if (windowRecords) {
                    var subs = new Subscription_1.Subscription();
                    subscriber.add(subs);
                    var window_1 = new Subject_1.Subject();
                    var record_1 = {
                      window: window_1,
                      subs,
                      seen: 0
                    };
                    windowRecords.push(record_1);
                    subscriber.next(window_1.asObservable());
                    executeSchedule_1.executeSchedule(subs, scheduler, function() {
                      return closeWindow(record_1);
                    }, windowTimeSpan);
                  }
                };
                if (windowCreationInterval !== null && windowCreationInterval >= 0) {
                  executeSchedule_1.executeSchedule(subscriber, scheduler, startWindow, windowCreationInterval, true);
                } else {
                  restartOnClose = true;
                }
                startWindow();
                var loop = function(cb) {
                  return windowRecords.slice().forEach(cb);
                };
                var terminate = function(cb) {
                  loop(function(_a2) {
                    var window2 = _a2.window;
                    return cb(window2);
                  });
                  cb(subscriber);
                  subscriber.unsubscribe();
                };
                source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
                  loop(function(record) {
                    record.window.next(value);
                    maxWindowSize <= ++record.seen && closeWindow(record);
                  });
                }, function() {
                  return terminate(function(consumer) {
                    return consumer.complete();
                  });
                }, function(err) {
                  return terminate(function(consumer) {
                    return consumer.error(err);
                  });
                }));
                return function() {
                  windowRecords = null;
                };
              });
            }
            exports2.windowTime = windowTime;
          }
        ),
        /***/
        752: (
          /***/
          function(__unused_webpack_module, exports2, __webpack_require__2) {
            "use strict";
            var __values = this && this.__values || function(o) {
              var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i2 = 0;
              if (m)
                return m.call(o);
              if (o && typeof o.length === "number")
                return {
                  next: function() {
                    if (o && i2 >= o.length)
                      o = void 0;
                    return { value: o && o[i2++], done: !o };
                  }
                };
              throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
            };
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.windowToggle = void 0;
            var Subject_1 = __webpack_require__2(9520);
            var Subscription_1 = __webpack_require__2(7215);
            var lift_1 = __webpack_require__2(4024);
            var innerFrom_1 = __webpack_require__2(9451);
            var OperatorSubscriber_1 = __webpack_require__2(5079);
            var noop_1 = __webpack_require__2(5729);
            var arrRemove_1 = __webpack_require__2(2447);
            function windowToggle(openings, closingSelector) {
              return lift_1.operate(function(source, subscriber) {
                var windows = [];
                var handleError = function(err) {
                  while (0 < windows.length) {
                    windows.shift().error(err);
                  }
                  subscriber.error(err);
                };
                innerFrom_1.innerFrom(openings).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(openValue) {
                  var window2 = new Subject_1.Subject();
                  windows.push(window2);
                  var closingSubscription = new Subscription_1.Subscription();
                  var closeWindow = function() {
                    arrRemove_1.arrRemove(windows, window2);
                    window2.complete();
                    closingSubscription.unsubscribe();
                  };
                  var closingNotifier;
                  try {
                    closingNotifier = innerFrom_1.innerFrom(closingSelector(openValue));
                  } catch (err) {
                    handleError(err);
                    return;
                  }
                  subscriber.next(window2.asObservable());
                  closingSubscription.add(closingNotifier.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, closeWindow, noop_1.noop, handleError)));
                }, noop_1.noop));
                source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
                  var e_1, _a;
                  var windowsCopy = windows.slice();
                  try {
                    for (var windowsCopy_1 = __values(windowsCopy), windowsCopy_1_1 = windowsCopy_1.next(); !windowsCopy_1_1.done; windowsCopy_1_1 = windowsCopy_1.next()) {
                      var window_1 = windowsCopy_1_1.value;
                      window_1.next(value);
                    }
                  } catch (e_1_1) {
                    e_1 = { error: e_1_1 };
                  } finally {
                    try {
                      if (windowsCopy_1_1 && !windowsCopy_1_1.done && (_a = windowsCopy_1.return))
                        _a.call(windowsCopy_1);
                    } finally {
                      if (e_1)
                        throw e_1.error;
                    }
                  }
                }, function() {
                  while (0 < windows.length) {
                    windows.shift().complete();
                  }
                  subscriber.complete();
                }, handleError, function() {
                  while (0 < windows.length) {
                    windows.shift().unsubscribe();
                  }
                }));
              });
            }
            exports2.windowToggle = windowToggle;
          }
        ),
        /***/
        582: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.windowWhen = void 0;
            var Subject_1 = __webpack_require__2(9520);
            var lift_1 = __webpack_require__2(4024);
            var OperatorSubscriber_1 = __webpack_require__2(5079);
            var innerFrom_1 = __webpack_require__2(9451);
            function windowWhen(closingSelector) {
              return lift_1.operate(function(source, subscriber) {
                var window2;
                var closingSubscriber;
                var handleError = function(err) {
                  window2.error(err);
                  subscriber.error(err);
                };
                var openWindow = function() {
                  closingSubscriber === null || closingSubscriber === void 0 ? void 0 : closingSubscriber.unsubscribe();
                  window2 === null || window2 === void 0 ? void 0 : window2.complete();
                  window2 = new Subject_1.Subject();
                  subscriber.next(window2.asObservable());
                  var closingNotifier;
                  try {
                    closingNotifier = innerFrom_1.innerFrom(closingSelector());
                  } catch (err) {
                    handleError(err);
                    return;
                  }
                  closingNotifier.subscribe(closingSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, openWindow, openWindow, handleError));
                };
                openWindow();
                source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
                  return window2.next(value);
                }, function() {
                  window2.complete();
                  subscriber.complete();
                }, handleError, function() {
                  closingSubscriber === null || closingSubscriber === void 0 ? void 0 : closingSubscriber.unsubscribe();
                  window2 = null;
                }));
              });
            }
            exports2.windowWhen = windowWhen;
          }
        ),
        /***/
        4255: (
          /***/
          function(__unused_webpack_module, exports2, __webpack_require__2) {
            "use strict";
            var __read = this && this.__read || function(o, n) {
              var m = typeof Symbol === "function" && o[Symbol.iterator];
              if (!m)
                return o;
              var i2 = m.call(o), r, ar = [], e;
              try {
                while ((n === void 0 || n-- > 0) && !(r = i2.next()).done)
                  ar.push(r.value);
              } catch (error) {
                e = { error };
              } finally {
                try {
                  if (r && !r.done && (m = i2["return"]))
                    m.call(i2);
                } finally {
                  if (e)
                    throw e.error;
                }
              }
              return ar;
            };
            var __spreadArray2 = this && this.__spreadArray || function(to, from) {
              for (var i2 = 0, il = from.length, j = to.length; i2 < il; i2++, j++)
                to[j] = from[i2];
              return to;
            };
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.withLatestFrom = void 0;
            var lift_1 = __webpack_require__2(4024);
            var OperatorSubscriber_1 = __webpack_require__2(5079);
            var innerFrom_1 = __webpack_require__2(9451);
            var identity_1 = __webpack_require__2(9144);
            var noop_1 = __webpack_require__2(5729);
            var args_1 = __webpack_require__2(2619);
            function withLatestFrom() {
              var inputs = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                inputs[_i] = arguments[_i];
              }
              var project = args_1.popResultSelector(inputs);
              return lift_1.operate(function(source, subscriber) {
                var len = inputs.length;
                var otherValues = new Array(len);
                var hasValue = inputs.map(function() {
                  return false;
                });
                var ready = false;
                var _loop_1 = function(i3) {
                  innerFrom_1.innerFrom(inputs[i3]).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
                    otherValues[i3] = value;
                    if (!ready && !hasValue[i3]) {
                      hasValue[i3] = true;
                      (ready = hasValue.every(identity_1.identity)) && (hasValue = null);
                    }
                  }, noop_1.noop));
                };
                for (var i2 = 0; i2 < len; i2++) {
                  _loop_1(i2);
                }
                source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
                  if (ready) {
                    var values = __spreadArray2([value], __read(otherValues));
                    subscriber.next(project ? project.apply(void 0, __spreadArray2([], __read(values))) : values);
                  }
                }));
              });
            }
            exports2.withLatestFrom = withLatestFrom;
          }
        ),
        /***/
        3253: (
          /***/
          function(__unused_webpack_module, exports2, __webpack_require__2) {
            "use strict";
            var __read = this && this.__read || function(o, n) {
              var m = typeof Symbol === "function" && o[Symbol.iterator];
              if (!m)
                return o;
              var i2 = m.call(o), r, ar = [], e;
              try {
                while ((n === void 0 || n-- > 0) && !(r = i2.next()).done)
                  ar.push(r.value);
              } catch (error) {
                e = { error };
              } finally {
                try {
                  if (r && !r.done && (m = i2["return"]))
                    m.call(i2);
                } finally {
                  if (e)
                    throw e.error;
                }
              }
              return ar;
            };
            var __spreadArray2 = this && this.__spreadArray || function(to, from) {
              for (var i2 = 0, il = from.length, j = to.length; i2 < il; i2++, j++)
                to[j] = from[i2];
              return to;
            };
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.zip = void 0;
            var zip_1 = __webpack_require__2(2042);
            var lift_1 = __webpack_require__2(4024);
            function zip() {
              var sources = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                sources[_i] = arguments[_i];
              }
              return lift_1.operate(function(source, subscriber) {
                zip_1.zip.apply(void 0, __spreadArray2([source], __read(sources))).subscribe(subscriber);
              });
            }
            exports2.zip = zip;
          }
        ),
        /***/
        7220: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.zipAll = void 0;
            var zip_1 = __webpack_require__2(2042);
            var joinAllInternals_1 = __webpack_require__2(7534);
            function zipAll(project) {
              return joinAllInternals_1.joinAllInternals(zip_1.zip, project);
            }
            exports2.zipAll = zipAll;
          }
        ),
        /***/
        9287: (
          /***/
          function(__unused_webpack_module, exports2, __webpack_require__2) {
            "use strict";
            var __read = this && this.__read || function(o, n) {
              var m = typeof Symbol === "function" && o[Symbol.iterator];
              if (!m)
                return o;
              var i2 = m.call(o), r, ar = [], e;
              try {
                while ((n === void 0 || n-- > 0) && !(r = i2.next()).done)
                  ar.push(r.value);
              } catch (error) {
                e = { error };
              } finally {
                try {
                  if (r && !r.done && (m = i2["return"]))
                    m.call(i2);
                } finally {
                  if (e)
                    throw e.error;
                }
              }
              return ar;
            };
            var __spreadArray2 = this && this.__spreadArray || function(to, from) {
              for (var i2 = 0, il = from.length, j = to.length; i2 < il; i2++, j++)
                to[j] = from[i2];
              return to;
            };
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.zipWith = void 0;
            var zip_1 = __webpack_require__2(3253);
            function zipWith() {
              var otherInputs = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                otherInputs[_i] = arguments[_i];
              }
              return zip_1.zip.apply(void 0, __spreadArray2([], __read(otherInputs)));
            }
            exports2.zipWith = zipWith;
          }
        ),
        /***/
        3584: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.scheduleArray = void 0;
            var Observable_1 = __webpack_require__2(5271);
            function scheduleArray(input, scheduler) {
              return new Observable_1.Observable(function(subscriber) {
                var i2 = 0;
                return scheduler.schedule(function() {
                  if (i2 === input.length) {
                    subscriber.complete();
                  } else {
                    subscriber.next(input[i2++]);
                    if (!subscriber.closed) {
                      this.schedule();
                    }
                  }
                });
              });
            }
            exports2.scheduleArray = scheduleArray;
          }
        ),
        /***/
        1659: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.scheduleAsyncIterable = void 0;
            var Observable_1 = __webpack_require__2(5271);
            var executeSchedule_1 = __webpack_require__2(5421);
            function scheduleAsyncIterable(input, scheduler) {
              if (!input) {
                throw new Error("Iterable cannot be null");
              }
              return new Observable_1.Observable(function(subscriber) {
                executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
                  var iterator = input[Symbol.asyncIterator]();
                  executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
                    iterator.next().then(function(result) {
                      if (result.done) {
                        subscriber.complete();
                      } else {
                        subscriber.next(result.value);
                      }
                    });
                  }, 0, true);
                });
              });
            }
            exports2.scheduleAsyncIterable = scheduleAsyncIterable;
          }
        ),
        /***/
        8840: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.scheduleIterable = void 0;
            var Observable_1 = __webpack_require__2(5271);
            var iterator_1 = __webpack_require__2(5686);
            var isFunction_1 = __webpack_require__2(4432);
            var executeSchedule_1 = __webpack_require__2(5421);
            function scheduleIterable(input, scheduler) {
              return new Observable_1.Observable(function(subscriber) {
                var iterator;
                executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
                  iterator = input[iterator_1.iterator]();
                  executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
                    var _a;
                    var value;
                    var done;
                    try {
                      _a = iterator.next(), value = _a.value, done = _a.done;
                    } catch (err) {
                      subscriber.error(err);
                      return;
                    }
                    if (done) {
                      subscriber.complete();
                    } else {
                      subscriber.next(value);
                    }
                  }, 0, true);
                });
                return function() {
                  return isFunction_1.isFunction(iterator === null || iterator === void 0 ? void 0 : iterator.return) && iterator.return();
                };
              });
            }
            exports2.scheduleIterable = scheduleIterable;
          }
        ),
        /***/
        5704: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.scheduleObservable = void 0;
            var innerFrom_1 = __webpack_require__2(9451);
            var observeOn_1 = __webpack_require__2(3165);
            var subscribeOn_1 = __webpack_require__2(831);
            function scheduleObservable(input, scheduler) {
              return innerFrom_1.innerFrom(input).pipe(subscribeOn_1.subscribeOn(scheduler), observeOn_1.observeOn(scheduler));
            }
            exports2.scheduleObservable = scheduleObservable;
          }
        ),
        /***/
        4644: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.schedulePromise = void 0;
            var innerFrom_1 = __webpack_require__2(9451);
            var observeOn_1 = __webpack_require__2(3165);
            var subscribeOn_1 = __webpack_require__2(831);
            function schedulePromise(input, scheduler) {
              return innerFrom_1.innerFrom(input).pipe(subscribeOn_1.subscribeOn(scheduler), observeOn_1.observeOn(scheduler));
            }
            exports2.schedulePromise = schedulePromise;
          }
        ),
        /***/
        3035: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.scheduleReadableStreamLike = void 0;
            var scheduleAsyncIterable_1 = __webpack_require__2(1659);
            var isReadableStreamLike_1 = __webpack_require__2(9266);
            function scheduleReadableStreamLike(input, scheduler) {
              return scheduleAsyncIterable_1.scheduleAsyncIterable(isReadableStreamLike_1.readableStreamLikeToAsyncGenerator(input), scheduler);
            }
            exports2.scheduleReadableStreamLike = scheduleReadableStreamLike;
          }
        ),
        /***/
        3200: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.scheduled = void 0;
            var scheduleObservable_1 = __webpack_require__2(5704);
            var schedulePromise_1 = __webpack_require__2(4644);
            var scheduleArray_1 = __webpack_require__2(3584);
            var scheduleIterable_1 = __webpack_require__2(8840);
            var scheduleAsyncIterable_1 = __webpack_require__2(1659);
            var isInteropObservable_1 = __webpack_require__2(3292);
            var isPromise_1 = __webpack_require__2(2644);
            var isArrayLike_1 = __webpack_require__2(8219);
            var isIterable_1 = __webpack_require__2(6380);
            var isAsyncIterable_1 = __webpack_require__2(7707);
            var throwUnobservableError_1 = __webpack_require__2(4883);
            var isReadableStreamLike_1 = __webpack_require__2(9266);
            var scheduleReadableStreamLike_1 = __webpack_require__2(3035);
            function scheduled(input, scheduler) {
              if (input != null) {
                if (isInteropObservable_1.isInteropObservable(input)) {
                  return scheduleObservable_1.scheduleObservable(input, scheduler);
                }
                if (isArrayLike_1.isArrayLike(input)) {
                  return scheduleArray_1.scheduleArray(input, scheduler);
                }
                if (isPromise_1.isPromise(input)) {
                  return schedulePromise_1.schedulePromise(input, scheduler);
                }
                if (isAsyncIterable_1.isAsyncIterable(input)) {
                  return scheduleAsyncIterable_1.scheduleAsyncIterable(input, scheduler);
                }
                if (isIterable_1.isIterable(input)) {
                  return scheduleIterable_1.scheduleIterable(input, scheduler);
                }
                if (isReadableStreamLike_1.isReadableStreamLike(input)) {
                  return scheduleReadableStreamLike_1.scheduleReadableStreamLike(input, scheduler);
                }
              }
              throw throwUnobservableError_1.createInvalidObservableTypeError(input);
            }
            exports2.scheduled = scheduled;
          }
        ),
        /***/
        4756: (
          /***/
          function(__unused_webpack_module, exports2, __webpack_require__2) {
            "use strict";
            var __extends = this && this.__extends || /* @__PURE__ */ function() {
              var extendStatics = function(d, b) {
                extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                  d2.__proto__ = b2;
                } || function(d2, b2) {
                  for (var p in b2)
                    if (Object.prototype.hasOwnProperty.call(b2, p))
                      d2[p] = b2[p];
                };
                return extendStatics(d, b);
              };
              return function(d, b) {
                if (typeof b !== "function" && b !== null)
                  throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
                extendStatics(d, b);
                function __() {
                  this.constructor = d;
                }
                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
              };
            }();
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.Action = void 0;
            var Subscription_1 = __webpack_require__2(7215);
            var Action = function(_super) {
              __extends(Action2, _super);
              function Action2(scheduler, work) {
                return _super.call(this) || this;
              }
              Action2.prototype.schedule = function(state, delay) {
                if (delay === void 0) {
                  delay = 0;
                }
                return this;
              };
              return Action2;
            }(Subscription_1.Subscription);
            exports2.Action = Action;
          }
        ),
        /***/
        1172: (
          /***/
          function(__unused_webpack_module, exports2, __webpack_require__2) {
            "use strict";
            var __extends = this && this.__extends || /* @__PURE__ */ function() {
              var extendStatics = function(d, b) {
                extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                  d2.__proto__ = b2;
                } || function(d2, b2) {
                  for (var p in b2)
                    if (Object.prototype.hasOwnProperty.call(b2, p))
                      d2[p] = b2[p];
                };
                return extendStatics(d, b);
              };
              return function(d, b) {
                if (typeof b !== "function" && b !== null)
                  throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
                extendStatics(d, b);
                function __() {
                  this.constructor = d;
                }
                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
              };
            }();
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.AsyncAction = void 0;
            var Action_1 = __webpack_require__2(4756);
            var intervalProvider_1 = __webpack_require__2(9678);
            var arrRemove_1 = __webpack_require__2(2447);
            var AsyncAction = function(_super) {
              __extends(AsyncAction2, _super);
              function AsyncAction2(scheduler, work) {
                var _this = _super.call(this, scheduler, work) || this;
                _this.scheduler = scheduler;
                _this.work = work;
                _this.pending = false;
                return _this;
              }
              AsyncAction2.prototype.schedule = function(state, delay) {
                var _a;
                if (delay === void 0) {
                  delay = 0;
                }
                if (this.closed) {
                  return this;
                }
                this.state = state;
                var id = this.id;
                var scheduler = this.scheduler;
                if (id != null) {
                  this.id = this.recycleAsyncId(scheduler, id, delay);
                }
                this.pending = true;
                this.delay = delay;
                this.id = (_a = this.id) !== null && _a !== void 0 ? _a : this.requestAsyncId(scheduler, this.id, delay);
                return this;
              };
              AsyncAction2.prototype.requestAsyncId = function(scheduler, _id, delay) {
                if (delay === void 0) {
                  delay = 0;
                }
                return intervalProvider_1.intervalProvider.setInterval(scheduler.flush.bind(scheduler, this), delay);
              };
              AsyncAction2.prototype.recycleAsyncId = function(_scheduler, id, delay) {
                if (delay === void 0) {
                  delay = 0;
                }
                if (delay != null && this.delay === delay && this.pending === false) {
                  return id;
                }
                if (id != null) {
                  intervalProvider_1.intervalProvider.clearInterval(id);
                }
                return void 0;
              };
              AsyncAction2.prototype.execute = function(state, delay) {
                if (this.closed) {
                  return new Error("executing a cancelled action");
                }
                this.pending = false;
                var error = this._execute(state, delay);
                if (error) {
                  return error;
                } else if (this.pending === false && this.id != null) {
                  this.id = this.recycleAsyncId(this.scheduler, this.id, null);
                }
              };
              AsyncAction2.prototype._execute = function(state, _delay) {
                var errored = false;
                var errorValue;
                try {
                  this.work(state);
                } catch (e) {
                  errored = true;
                  errorValue = e ? e : new Error("Scheduled action threw falsy error");
                }
                if (errored) {
                  this.unsubscribe();
                  return errorValue;
                }
              };
              AsyncAction2.prototype.unsubscribe = function() {
                if (!this.closed) {
                  var _a = this, id = _a.id, scheduler = _a.scheduler;
                  var actions = scheduler.actions;
                  this.work = this.state = this.scheduler = null;
                  this.pending = false;
                  arrRemove_1.arrRemove(actions, this);
                  if (id != null) {
                    this.id = this.recycleAsyncId(scheduler, id, null);
                  }
                  this.delay = null;
                  _super.prototype.unsubscribe.call(this);
                }
              };
              return AsyncAction2;
            }(Action_1.Action);
            exports2.AsyncAction = AsyncAction;
          }
        ),
        /***/
        6759: (
          /***/
          function(__unused_webpack_module, exports2, __webpack_require__2) {
            "use strict";
            var __extends = this && this.__extends || /* @__PURE__ */ function() {
              var extendStatics = function(d, b) {
                extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                  d2.__proto__ = b2;
                } || function(d2, b2) {
                  for (var p in b2)
                    if (Object.prototype.hasOwnProperty.call(b2, p))
                      d2[p] = b2[p];
                };
                return extendStatics(d, b);
              };
              return function(d, b) {
                if (typeof b !== "function" && b !== null)
                  throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
                extendStatics(d, b);
                function __() {
                  this.constructor = d;
                }
                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
              };
            }();
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.AsyncScheduler = void 0;
            var Scheduler_1 = __webpack_require__2(3980);
            var AsyncScheduler = function(_super) {
              __extends(AsyncScheduler2, _super);
              function AsyncScheduler2(SchedulerAction, now) {
                if (now === void 0) {
                  now = Scheduler_1.Scheduler.now;
                }
                var _this = _super.call(this, SchedulerAction, now) || this;
                _this.actions = [];
                _this._active = false;
                return _this;
              }
              AsyncScheduler2.prototype.flush = function(action) {
                var actions = this.actions;
                if (this._active) {
                  actions.push(action);
                  return;
                }
                var error;
                this._active = true;
                do {
                  if (error = action.execute(action.state, action.delay)) {
                    break;
                  }
                } while (action = actions.shift());
                this._active = false;
                if (error) {
                  while (action = actions.shift()) {
                    action.unsubscribe();
                  }
                  throw error;
                }
              };
              return AsyncScheduler2;
            }(Scheduler_1.Scheduler);
            exports2.AsyncScheduler = AsyncScheduler;
          }
        ),
        /***/
        4617: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.async = exports2.asyncScheduler = void 0;
            var AsyncAction_1 = __webpack_require__2(1172);
            var AsyncScheduler_1 = __webpack_require__2(6759);
            exports2.asyncScheduler = new AsyncScheduler_1.AsyncScheduler(AsyncAction_1.AsyncAction);
            exports2.async = exports2.asyncScheduler;
          }
        ),
        /***/
        1713: (
          /***/
          (__unused_webpack_module, exports2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.dateTimestampProvider = void 0;
            exports2.dateTimestampProvider = {
              now: function() {
                return (exports2.dateTimestampProvider.delegate || Date).now();
              },
              delegate: void 0
            };
          }
        ),
        /***/
        9678: (
          /***/
          function(__unused_webpack_module, exports2) {
            "use strict";
            var __read = this && this.__read || function(o, n) {
              var m = typeof Symbol === "function" && o[Symbol.iterator];
              if (!m)
                return o;
              var i2 = m.call(o), r, ar = [], e;
              try {
                while ((n === void 0 || n-- > 0) && !(r = i2.next()).done)
                  ar.push(r.value);
              } catch (error) {
                e = { error };
              } finally {
                try {
                  if (r && !r.done && (m = i2["return"]))
                    m.call(i2);
                } finally {
                  if (e)
                    throw e.error;
                }
              }
              return ar;
            };
            var __spreadArray2 = this && this.__spreadArray || function(to, from) {
              for (var i2 = 0, il = from.length, j = to.length; i2 < il; i2++, j++)
                to[j] = from[i2];
              return to;
            };
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.intervalProvider = void 0;
            exports2.intervalProvider = {
              setInterval: function(handler, timeout) {
                var args = [];
                for (var _i = 2; _i < arguments.length; _i++) {
                  args[_i - 2] = arguments[_i];
                }
                var delegate = exports2.intervalProvider.delegate;
                if (delegate === null || delegate === void 0 ? void 0 : delegate.setInterval) {
                  return delegate.setInterval.apply(delegate, __spreadArray2([handler, timeout], __read(args)));
                }
                return setInterval.apply(void 0, __spreadArray2([handler, timeout], __read(args)));
              },
              clearInterval: function(handle) {
                var delegate = exports2.intervalProvider.delegate;
                return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearInterval) || clearInterval)(handle);
              },
              delegate: void 0
            };
          }
        ),
        /***/
        8972: (
          /***/
          function(__unused_webpack_module, exports2) {
            "use strict";
            var __read = this && this.__read || function(o, n) {
              var m = typeof Symbol === "function" && o[Symbol.iterator];
              if (!m)
                return o;
              var i2 = m.call(o), r, ar = [], e;
              try {
                while ((n === void 0 || n-- > 0) && !(r = i2.next()).done)
                  ar.push(r.value);
              } catch (error) {
                e = { error };
              } finally {
                try {
                  if (r && !r.done && (m = i2["return"]))
                    m.call(i2);
                } finally {
                  if (e)
                    throw e.error;
                }
              }
              return ar;
            };
            var __spreadArray2 = this && this.__spreadArray || function(to, from) {
              for (var i2 = 0, il = from.length, j = to.length; i2 < il; i2++, j++)
                to[j] = from[i2];
              return to;
            };
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.timeoutProvider = void 0;
            exports2.timeoutProvider = {
              setTimeout: function(handler, timeout) {
                var args = [];
                for (var _i = 2; _i < arguments.length; _i++) {
                  args[_i - 2] = arguments[_i];
                }
                var delegate = exports2.timeoutProvider.delegate;
                if (delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) {
                  return delegate.setTimeout.apply(delegate, __spreadArray2([handler, timeout], __read(args)));
                }
                return setTimeout.apply(void 0, __spreadArray2([handler, timeout], __read(args)));
              },
              clearTimeout: function(handle) {
                var delegate = exports2.timeoutProvider.delegate;
                return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);
              },
              delegate: void 0
            };
          }
        ),
        /***/
        5686: (
          /***/
          (__unused_webpack_module, exports2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.iterator = exports2.getSymbolIterator = void 0;
            function getSymbolIterator() {
              if (typeof Symbol !== "function" || !Symbol.iterator) {
                return "@@iterator";
              }
              return Symbol.iterator;
            }
            exports2.getSymbolIterator = getSymbolIterator;
            exports2.iterator = getSymbolIterator();
          }
        ),
        /***/
        2138: (
          /***/
          (__unused_webpack_module, exports2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.observable = void 0;
            exports2.observable = function() {
              return typeof Symbol === "function" && Symbol.observable || "@@observable";
            }();
          }
        ),
        /***/
        6809: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.ArgumentOutOfRangeError = void 0;
            var createErrorClass_1 = __webpack_require__2(9876);
            exports2.ArgumentOutOfRangeError = createErrorClass_1.createErrorClass(function(_super) {
              return function ArgumentOutOfRangeErrorImpl() {
                _super(this);
                this.name = "ArgumentOutOfRangeError";
                this.message = "argument out of range";
              };
            });
          }
        ),
        /***/
        8032: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.EmptyError = void 0;
            var createErrorClass_1 = __webpack_require__2(9876);
            exports2.EmptyError = createErrorClass_1.createErrorClass(function(_super) {
              return function EmptyErrorImpl() {
                _super(this);
                this.name = "EmptyError";
                this.message = "no elements in sequence";
              };
            });
          }
        ),
        /***/
        1137: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.NotFoundError = void 0;
            var createErrorClass_1 = __webpack_require__2(9876);
            exports2.NotFoundError = createErrorClass_1.createErrorClass(function(_super) {
              return function NotFoundErrorImpl(message) {
                _super(this);
                this.name = "NotFoundError";
                this.message = message;
              };
            });
          }
        ),
        /***/
        7392: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.ObjectUnsubscribedError = void 0;
            var createErrorClass_1 = __webpack_require__2(9876);
            exports2.ObjectUnsubscribedError = createErrorClass_1.createErrorClass(function(_super) {
              return function ObjectUnsubscribedErrorImpl() {
                _super(this);
                this.name = "ObjectUnsubscribedError";
                this.message = "object unsubscribed";
              };
            });
          }
        ),
        /***/
        6228: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.SequenceError = void 0;
            var createErrorClass_1 = __webpack_require__2(9876);
            exports2.SequenceError = createErrorClass_1.createErrorClass(function(_super) {
              return function SequenceErrorImpl(message) {
                _super(this);
                this.name = "SequenceError";
                this.message = message;
              };
            });
          }
        ),
        /***/
        5463: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.UnsubscriptionError = void 0;
            var createErrorClass_1 = __webpack_require__2(9876);
            exports2.UnsubscriptionError = createErrorClass_1.createErrorClass(function(_super) {
              return function UnsubscriptionErrorImpl(errors) {
                _super(this);
                this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function(err, i2) {
                  return i2 + 1 + ") " + err.toString();
                }).join("\n  ") : "";
                this.name = "UnsubscriptionError";
                this.errors = errors;
              };
            });
          }
        ),
        /***/
        2619: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.popNumber = exports2.popScheduler = exports2.popResultSelector = void 0;
            var isFunction_1 = __webpack_require__2(4432);
            var isScheduler_1 = __webpack_require__2(6551);
            function last(arr) {
              return arr[arr.length - 1];
            }
            function popResultSelector(args) {
              return isFunction_1.isFunction(last(args)) ? args.pop() : void 0;
            }
            exports2.popResultSelector = popResultSelector;
            function popScheduler(args) {
              return isScheduler_1.isScheduler(last(args)) ? args.pop() : void 0;
            }
            exports2.popScheduler = popScheduler;
            function popNumber(args, defaultValue) {
              return typeof last(args) === "number" ? args.pop() : defaultValue;
            }
            exports2.popNumber = popNumber;
          }
        ),
        /***/
        4744: (
          /***/
          (__unused_webpack_module, exports2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.argsArgArrayOrObject = void 0;
            var isArray2 = Array.isArray;
            var getPrototypeOf = Object.getPrototypeOf, objectProto = Object.prototype, getKeys = Object.keys;
            function argsArgArrayOrObject(args) {
              if (args.length === 1) {
                var first_1 = args[0];
                if (isArray2(first_1)) {
                  return { args: first_1, keys: null };
                }
                if (isPOJO(first_1)) {
                  var keys = getKeys(first_1);
                  return {
                    args: keys.map(function(key) {
                      return first_1[key];
                    }),
                    keys
                  };
                }
              }
              return { args, keys: null };
            }
            exports2.argsArgArrayOrObject = argsArgArrayOrObject;
            function isPOJO(obj) {
              return obj && typeof obj === "object" && getPrototypeOf(obj) === objectProto;
            }
          }
        ),
        /***/
        4475: (
          /***/
          (__unused_webpack_module, exports2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.argsOrArgArray = void 0;
            var isArray2 = Array.isArray;
            function argsOrArgArray(args) {
              return args.length === 1 && isArray2(args[0]) ? args[0] : args;
            }
            exports2.argsOrArgArray = argsOrArgArray;
          }
        ),
        /***/
        2447: (
          /***/
          (__unused_webpack_module, exports2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.arrRemove = void 0;
            function arrRemove(arr, item) {
              if (arr) {
                var index = arr.indexOf(item);
                0 <= index && arr.splice(index, 1);
              }
            }
            exports2.arrRemove = arrRemove;
          }
        ),
        /***/
        9876: (
          /***/
          (__unused_webpack_module, exports2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.createErrorClass = void 0;
            function createErrorClass(createImpl) {
              var _super = function(instance) {
                Error.call(instance);
                instance.stack = new Error().stack;
              };
              var ctorFunc = createImpl(_super);
              ctorFunc.prototype = Object.create(Error.prototype);
              ctorFunc.prototype.constructor = ctorFunc;
              return ctorFunc;
            }
            exports2.createErrorClass = createErrorClass;
          }
        ),
        /***/
        1589: (
          /***/
          (__unused_webpack_module, exports2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.createObject = void 0;
            function createObject(keys, values) {
              return keys.reduce(function(result, key, i2) {
                return result[key] = values[i2], result;
              }, {});
            }
            exports2.createObject = createObject;
          }
        ),
        /***/
        4770: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.captureError = exports2.errorContext = void 0;
            var config_1 = __webpack_require__2(3782);
            var context = null;
            function errorContext(cb) {
              if (config_1.config.useDeprecatedSynchronousErrorHandling) {
                var isRoot = !context;
                if (isRoot) {
                  context = { errorThrown: false, error: null };
                }
                cb();
                if (isRoot) {
                  var _a = context, errorThrown = _a.errorThrown, error = _a.error;
                  context = null;
                  if (errorThrown) {
                    throw error;
                  }
                }
              } else {
                cb();
              }
            }
            exports2.errorContext = errorContext;
            function captureError(err) {
              if (config_1.config.useDeprecatedSynchronousErrorHandling && context) {
                context.errorThrown = true;
                context.error = err;
              }
            }
            exports2.captureError = captureError;
          }
        ),
        /***/
        5421: (
          /***/
          (__unused_webpack_module, exports2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.executeSchedule = void 0;
            function executeSchedule(parentSubscription, scheduler, work, delay, repeat) {
              if (delay === void 0) {
                delay = 0;
              }
              if (repeat === void 0) {
                repeat = false;
              }
              var scheduleSubscription = scheduler.schedule(function() {
                work();
                if (repeat) {
                  parentSubscription.add(this.schedule(null, delay));
                } else {
                  this.unsubscribe();
                }
              }, delay);
              parentSubscription.add(scheduleSubscription);
              if (!repeat) {
                return scheduleSubscription;
              }
            }
            exports2.executeSchedule = executeSchedule;
          }
        ),
        /***/
        9144: (
          /***/
          (__unused_webpack_module, exports2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.identity = void 0;
            function identity(x) {
              return x;
            }
            exports2.identity = identity;
          }
        ),
        /***/
        8219: (
          /***/
          (__unused_webpack_module, exports2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.isArrayLike = void 0;
            exports2.isArrayLike = function(x) {
              return x && typeof x.length === "number" && typeof x !== "function";
            };
          }
        ),
        /***/
        7707: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.isAsyncIterable = void 0;
            var isFunction_1 = __webpack_require__2(4432);
            function isAsyncIterable(obj) {
              return Symbol.asyncIterator && isFunction_1.isFunction(obj === null || obj === void 0 ? void 0 : obj[Symbol.asyncIterator]);
            }
            exports2.isAsyncIterable = isAsyncIterable;
          }
        ),
        /***/
        7761: (
          /***/
          (__unused_webpack_module, exports2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.isValidDate = void 0;
            function isValidDate(value) {
              return value instanceof Date && !isNaN(value);
            }
            exports2.isValidDate = isValidDate;
          }
        ),
        /***/
        4432: (
          /***/
          (__unused_webpack_module, exports2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.isFunction = void 0;
            function isFunction(value) {
              return typeof value === "function";
            }
            exports2.isFunction = isFunction;
          }
        ),
        /***/
        3292: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.isInteropObservable = void 0;
            var observable_1 = __webpack_require__2(2138);
            var isFunction_1 = __webpack_require__2(4432);
            function isInteropObservable(input) {
              return isFunction_1.isFunction(input[observable_1.observable]);
            }
            exports2.isInteropObservable = isInteropObservable;
          }
        ),
        /***/
        6380: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.isIterable = void 0;
            var iterator_1 = __webpack_require__2(5686);
            var isFunction_1 = __webpack_require__2(4432);
            function isIterable(input) {
              return isFunction_1.isFunction(input === null || input === void 0 ? void 0 : input[iterator_1.iterator]);
            }
            exports2.isIterable = isIterable;
          }
        ),
        /***/
        2644: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.isPromise = void 0;
            var isFunction_1 = __webpack_require__2(4432);
            function isPromise(value) {
              return isFunction_1.isFunction(value === null || value === void 0 ? void 0 : value.then);
            }
            exports2.isPromise = isPromise;
          }
        ),
        /***/
        9266: (
          /***/
          function(__unused_webpack_module, exports2, __webpack_require__2) {
            "use strict";
            var __generator = this && this.__generator || function(thisArg, body) {
              var _ = { label: 0, sent: function() {
                if (t[0] & 1)
                  throw t[1];
                return t[1];
              }, trys: [], ops: [] }, f, y, t, g;
              return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
                return this;
              }), g;
              function verb(n) {
                return function(v) {
                  return step([n, v]);
                };
              }
              function step(op) {
                if (f)
                  throw new TypeError("Generator is already executing.");
                while (_)
                  try {
                    if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                      return t;
                    if (y = 0, t)
                      op = [op[0] & 2, t.value];
                    switch (op[0]) {
                      case 0:
                      case 1:
                        t = op;
                        break;
                      case 4:
                        _.label++;
                        return { value: op[1], done: false };
                      case 5:
                        _.label++;
                        y = op[1];
                        op = [0];
                        continue;
                      case 7:
                        op = _.ops.pop();
                        _.trys.pop();
                        continue;
                      default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                          _ = 0;
                          continue;
                        }
                        if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                          _.label = op[1];
                          break;
                        }
                        if (op[0] === 6 && _.label < t[1]) {
                          _.label = t[1];
                          t = op;
                          break;
                        }
                        if (t && _.label < t[2]) {
                          _.label = t[2];
                          _.ops.push(op);
                          break;
                        }
                        if (t[2])
                          _.ops.pop();
                        _.trys.pop();
                        continue;
                    }
                    op = body.call(thisArg, _);
                  } catch (e) {
                    op = [6, e];
                    y = 0;
                  } finally {
                    f = t = 0;
                  }
                if (op[0] & 5)
                  throw op[1];
                return { value: op[0] ? op[1] : void 0, done: true };
              }
            };
            var __await = this && this.__await || function(v) {
              return this instanceof __await ? (this.v = v, this) : new __await(v);
            };
            var __asyncGenerator = this && this.__asyncGenerator || function(thisArg, _arguments, generator) {
              if (!Symbol.asyncIterator)
                throw new TypeError("Symbol.asyncIterator is not defined.");
              var g = generator.apply(thisArg, _arguments || []), i2, q = [];
              return i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
                return this;
              }, i2;
              function verb(n) {
                if (g[n])
                  i2[n] = function(v) {
                    return new Promise(function(a, b) {
                      q.push([n, v, a, b]) > 1 || resume(n, v);
                    });
                  };
              }
              function resume(n, v) {
                try {
                  step(g[n](v));
                } catch (e) {
                  settle(q[0][3], e);
                }
              }
              function step(r) {
                r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
              }
              function fulfill(value) {
                resume("next", value);
              }
              function reject(value) {
                resume("throw", value);
              }
              function settle(f, v) {
                if (f(v), q.shift(), q.length)
                  resume(q[0][0], q[0][1]);
              }
            };
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.isReadableStreamLike = exports2.readableStreamLikeToAsyncGenerator = void 0;
            var isFunction_1 = __webpack_require__2(4432);
            function readableStreamLikeToAsyncGenerator(readableStream) {
              return __asyncGenerator(this, arguments, function readableStreamLikeToAsyncGenerator_1() {
                var reader, _a, value, done;
                return __generator(this, function(_b) {
                  switch (_b.label) {
                    case 0:
                      reader = readableStream.getReader();
                      _b.label = 1;
                    case 1:
                      _b.trys.push([1, , 9, 10]);
                      _b.label = 2;
                    case 2:
                      if (false) {
                      }
                      return [4, __await(reader.read())];
                    case 3:
                      _a = _b.sent(), value = _a.value, done = _a.done;
                      if (!done)
                        return [3, 5];
                      return [4, __await(void 0)];
                    case 4:
                      return [2, _b.sent()];
                    case 5:
                      return [4, __await(value)];
                    case 6:
                      return [4, _b.sent()];
                    case 7:
                      _b.sent();
                      return [3, 2];
                    case 8:
                      return [3, 10];
                    case 9:
                      reader.releaseLock();
                      return [7];
                    case 10:
                      return [2];
                  }
                });
              });
            }
            exports2.readableStreamLikeToAsyncGenerator = readableStreamLikeToAsyncGenerator;
            function isReadableStreamLike(obj) {
              return isFunction_1.isFunction(obj === null || obj === void 0 ? void 0 : obj.getReader);
            }
            exports2.isReadableStreamLike = isReadableStreamLike;
          }
        ),
        /***/
        6551: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.isScheduler = void 0;
            var isFunction_1 = __webpack_require__2(4432);
            function isScheduler(value) {
              return value && isFunction_1.isFunction(value.schedule);
            }
            exports2.isScheduler = isScheduler;
          }
        ),
        /***/
        4024: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.operate = exports2.hasLift = void 0;
            var isFunction_1 = __webpack_require__2(4432);
            function hasLift(source) {
              return isFunction_1.isFunction(source === null || source === void 0 ? void 0 : source.lift);
            }
            exports2.hasLift = hasLift;
            function operate(init) {
              return function(source) {
                if (hasLift(source)) {
                  return source.lift(function(liftedSource) {
                    try {
                      return init(liftedSource, this);
                    } catch (err) {
                      this.error(err);
                    }
                  });
                }
                throw new TypeError("Unable to lift unknown Observable type");
              };
            }
            exports2.operate = operate;
          }
        ),
        /***/
        4666: (
          /***/
          function(__unused_webpack_module, exports2, __webpack_require__2) {
            "use strict";
            var __read = this && this.__read || function(o, n) {
              var m = typeof Symbol === "function" && o[Symbol.iterator];
              if (!m)
                return o;
              var i2 = m.call(o), r, ar = [], e;
              try {
                while ((n === void 0 || n-- > 0) && !(r = i2.next()).done)
                  ar.push(r.value);
              } catch (error) {
                e = { error };
              } finally {
                try {
                  if (r && !r.done && (m = i2["return"]))
                    m.call(i2);
                } finally {
                  if (e)
                    throw e.error;
                }
              }
              return ar;
            };
            var __spreadArray2 = this && this.__spreadArray || function(to, from) {
              for (var i2 = 0, il = from.length, j = to.length; i2 < il; i2++, j++)
                to[j] = from[i2];
              return to;
            };
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.mapOneOrManyArgs = void 0;
            var map_1 = __webpack_require__2(4338);
            var isArray2 = Array.isArray;
            function callOrApply(fn, args) {
              return isArray2(args) ? fn.apply(void 0, __spreadArray2([], __read(args))) : fn(args);
            }
            function mapOneOrManyArgs(fn) {
              return map_1.map(function(args) {
                return callOrApply(fn, args);
              });
            }
            exports2.mapOneOrManyArgs = mapOneOrManyArgs;
          }
        ),
        /***/
        5729: (
          /***/
          (__unused_webpack_module, exports2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.noop = void 0;
            function noop() {
            }
            exports2.noop = noop;
          }
        ),
        /***/
        1574: (
          /***/
          (__unused_webpack_module, exports2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.not = void 0;
            function not(pred, thisArg) {
              return function(value, index) {
                return !pred.call(thisArg, value, index);
              };
            }
            exports2.not = not;
          }
        ),
        /***/
        5966: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.pipeFromArray = exports2.pipe = void 0;
            var identity_1 = __webpack_require__2(9144);
            function pipe() {
              var fns = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                fns[_i] = arguments[_i];
              }
              return pipeFromArray(fns);
            }
            exports2.pipe = pipe;
            function pipeFromArray(fns) {
              if (fns.length === 0) {
                return identity_1.identity;
              }
              if (fns.length === 1) {
                return fns[0];
              }
              return function piped(input) {
                return fns.reduce(function(prev, fn) {
                  return fn(prev);
                }, input);
              };
            }
            exports2.pipeFromArray = pipeFromArray;
          }
        ),
        /***/
        7234: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.reportUnhandledError = void 0;
            var config_1 = __webpack_require__2(3782);
            var timeoutProvider_1 = __webpack_require__2(8972);
            function reportUnhandledError(err) {
              timeoutProvider_1.timeoutProvider.setTimeout(function() {
                var onUnhandledError = config_1.config.onUnhandledError;
                if (onUnhandledError) {
                  onUnhandledError(err);
                } else {
                  throw err;
                }
              });
            }
            exports2.reportUnhandledError = reportUnhandledError;
          }
        ),
        /***/
        4883: (
          /***/
          (__unused_webpack_module, exports2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.createInvalidObservableTypeError = void 0;
            function createInvalidObservableTypeError(input) {
              return new TypeError("You provided " + (input !== null && typeof input === "object" ? "an invalid object" : "'" + input + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
            }
            exports2.createInvalidObservableTypeError = createInvalidObservableTypeError;
          }
        ),
        /***/
        9978: (
          /***/
          (__unused_webpack_module, exports2, __webpack_require__2) => {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.mergeAll = exports2.merge = exports2.max = exports2.materialize = exports2.mapTo = exports2.map = exports2.last = exports2.isEmpty = exports2.ignoreElements = exports2.groupBy = exports2.first = exports2.findIndex = exports2.find = exports2.finalize = exports2.filter = exports2.expand = exports2.exhaustMap = exports2.exhaustAll = exports2.exhaust = exports2.every = exports2.endWith = exports2.elementAt = exports2.distinctUntilKeyChanged = exports2.distinctUntilChanged = exports2.distinct = exports2.dematerialize = exports2.delayWhen = exports2.delay = exports2.defaultIfEmpty = exports2.debounceTime = exports2.debounce = exports2.count = exports2.connect = exports2.concatWith = exports2.concatMapTo = exports2.concatMap = exports2.concatAll = exports2.concat = exports2.combineLatestWith = exports2.combineLatest = exports2.combineLatestAll = exports2.combineAll = exports2.catchError = exports2.bufferWhen = exports2.bufferToggle = exports2.bufferTime = exports2.bufferCount = exports2.buffer = exports2.auditTime = exports2.audit = void 0;
            exports2.timeInterval = exports2.throwIfEmpty = exports2.throttleTime = exports2.throttle = exports2.tap = exports2.takeWhile = exports2.takeUntil = exports2.takeLast = exports2.take = exports2.switchScan = exports2.switchMapTo = exports2.switchMap = exports2.switchAll = exports2.subscribeOn = exports2.startWith = exports2.skipWhile = exports2.skipUntil = exports2.skipLast = exports2.skip = exports2.single = exports2.shareReplay = exports2.share = exports2.sequenceEqual = exports2.scan = exports2.sampleTime = exports2.sample = exports2.refCount = exports2.retryWhen = exports2.retry = exports2.repeatWhen = exports2.repeat = exports2.reduce = exports2.raceWith = exports2.race = exports2.publishReplay = exports2.publishLast = exports2.publishBehavior = exports2.publish = exports2.pluck = exports2.partition = exports2.pairwise = exports2.onErrorResumeNext = exports2.observeOn = exports2.multicast = exports2.min = exports2.mergeWith = exports2.mergeScan = exports2.mergeMapTo = exports2.mergeMap = exports2.flatMap = void 0;
            exports2.zipWith = exports2.zipAll = exports2.zip = exports2.withLatestFrom = exports2.windowWhen = exports2.windowToggle = exports2.windowTime = exports2.windowCount = exports2.window = exports2.toArray = exports2.timestamp = exports2.timeoutWith = exports2.timeout = void 0;
            var audit_1 = __webpack_require__2(3533);
            Object.defineProperty(exports2, "audit", { enumerable: true, get: function() {
              return audit_1.audit;
            } });
            var auditTime_1 = __webpack_require__2(5188);
            Object.defineProperty(exports2, "auditTime", { enumerable: true, get: function() {
              return auditTime_1.auditTime;
            } });
            var buffer_1 = __webpack_require__2(4514);
            Object.defineProperty(exports2, "buffer", { enumerable: true, get: function() {
              return buffer_1.buffer;
            } });
            var bufferCount_1 = __webpack_require__2(2537);
            Object.defineProperty(exports2, "bufferCount", { enumerable: true, get: function() {
              return bufferCount_1.bufferCount;
            } });
            var bufferTime_1 = __webpack_require__2(8720);
            Object.defineProperty(exports2, "bufferTime", { enumerable: true, get: function() {
              return bufferTime_1.bufferTime;
            } });
            var bufferToggle_1 = __webpack_require__2(7932);
            Object.defineProperty(exports2, "bufferToggle", { enumerable: true, get: function() {
              return bufferToggle_1.bufferToggle;
            } });
            var bufferWhen_1 = __webpack_require__2(1445);
            Object.defineProperty(exports2, "bufferWhen", { enumerable: true, get: function() {
              return bufferWhen_1.bufferWhen;
            } });
            var catchError_1 = __webpack_require__2(4418);
            Object.defineProperty(exports2, "catchError", { enumerable: true, get: function() {
              return catchError_1.catchError;
            } });
            var combineAll_1 = __webpack_require__2(4163);
            Object.defineProperty(exports2, "combineAll", { enumerable: true, get: function() {
              return combineAll_1.combineAll;
            } });
            var combineLatestAll_1 = __webpack_require__2(9893);
            Object.defineProperty(exports2, "combineLatestAll", { enumerable: true, get: function() {
              return combineLatestAll_1.combineLatestAll;
            } });
            var combineLatest_1 = __webpack_require__2(8169);
            Object.defineProperty(exports2, "combineLatest", { enumerable: true, get: function() {
              return combineLatest_1.combineLatest;
            } });
            var combineLatestWith_1 = __webpack_require__2(7230);
            Object.defineProperty(exports2, "combineLatestWith", { enumerable: true, get: function() {
              return combineLatestWith_1.combineLatestWith;
            } });
            var concat_1 = __webpack_require__2(4098);
            Object.defineProperty(exports2, "concat", { enumerable: true, get: function() {
              return concat_1.concat;
            } });
            var concatAll_1 = __webpack_require__2(4554);
            Object.defineProperty(exports2, "concatAll", { enumerable: true, get: function() {
              return concatAll_1.concatAll;
            } });
            var concatMap_1 = __webpack_require__2(1048);
            Object.defineProperty(exports2, "concatMap", { enumerable: true, get: function() {
              return concatMap_1.concatMap;
            } });
            var concatMapTo_1 = __webpack_require__2(381);
            Object.defineProperty(exports2, "concatMapTo", { enumerable: true, get: function() {
              return concatMapTo_1.concatMapTo;
            } });
            var concatWith_1 = __webpack_require__2(4724);
            Object.defineProperty(exports2, "concatWith", { enumerable: true, get: function() {
              return concatWith_1.concatWith;
            } });
            var connect_1 = __webpack_require__2(4347);
            Object.defineProperty(exports2, "connect", { enumerable: true, get: function() {
              return connect_1.connect;
            } });
            var count_1 = __webpack_require__2(6944);
            Object.defineProperty(exports2, "count", { enumerable: true, get: function() {
              return count_1.count;
            } });
            var debounce_1 = __webpack_require__2(440);
            Object.defineProperty(exports2, "debounce", { enumerable: true, get: function() {
              return debounce_1.debounce;
            } });
            var debounceTime_1 = __webpack_require__2(8157);
            Object.defineProperty(exports2, "debounceTime", { enumerable: true, get: function() {
              return debounceTime_1.debounceTime;
            } });
            var defaultIfEmpty_1 = __webpack_require__2(1714);
            Object.defineProperty(exports2, "defaultIfEmpty", { enumerable: true, get: function() {
              return defaultIfEmpty_1.defaultIfEmpty;
            } });
            var delay_1 = __webpack_require__2(1030);
            Object.defineProperty(exports2, "delay", { enumerable: true, get: function() {
              return delay_1.delay;
            } });
            var delayWhen_1 = __webpack_require__2(6405);
            Object.defineProperty(exports2, "delayWhen", { enumerable: true, get: function() {
              return delayWhen_1.delayWhen;
            } });
            var dematerialize_1 = __webpack_require__2(9142);
            Object.defineProperty(exports2, "dematerialize", { enumerable: true, get: function() {
              return dematerialize_1.dematerialize;
            } });
            var distinct_1 = __webpack_require__2(2307);
            Object.defineProperty(exports2, "distinct", { enumerable: true, get: function() {
              return distinct_1.distinct;
            } });
            var distinctUntilChanged_1 = __webpack_require__2(9131);
            Object.defineProperty(exports2, "distinctUntilChanged", { enumerable: true, get: function() {
              return distinctUntilChanged_1.distinctUntilChanged;
            } });
            var distinctUntilKeyChanged_1 = __webpack_require__2(6659);
            Object.defineProperty(exports2, "distinctUntilKeyChanged", { enumerable: true, get: function() {
              return distinctUntilKeyChanged_1.distinctUntilKeyChanged;
            } });
            var elementAt_1 = __webpack_require__2(4217);
            Object.defineProperty(exports2, "elementAt", { enumerable: true, get: function() {
              return elementAt_1.elementAt;
            } });
            var endWith_1 = __webpack_require__2(4707);
            Object.defineProperty(exports2, "endWith", { enumerable: true, get: function() {
              return endWith_1.endWith;
            } });
            var every_1 = __webpack_require__2(9276);
            Object.defineProperty(exports2, "every", { enumerable: true, get: function() {
              return every_1.every;
            } });
            var exhaust_1 = __webpack_require__2(337);
            Object.defineProperty(exports2, "exhaust", { enumerable: true, get: function() {
              return exhaust_1.exhaust;
            } });
            var exhaustAll_1 = __webpack_require__2(3977);
            Object.defineProperty(exports2, "exhaustAll", { enumerable: true, get: function() {
              return exhaustAll_1.exhaustAll;
            } });
            var exhaustMap_1 = __webpack_require__2(368);
            Object.defineProperty(exports2, "exhaustMap", { enumerable: true, get: function() {
              return exhaustMap_1.exhaustMap;
            } });
            var expand_1 = __webpack_require__2(7829);
            Object.defineProperty(exports2, "expand", { enumerable: true, get: function() {
              return expand_1.expand;
            } });
            var filter_1 = __webpack_require__2(2763);
            Object.defineProperty(exports2, "filter", { enumerable: true, get: function() {
              return filter_1.filter;
            } });
            var finalize_1 = __webpack_require__2(4106);
            Object.defineProperty(exports2, "finalize", { enumerable: true, get: function() {
              return finalize_1.finalize;
            } });
            var find_1 = __webpack_require__2(8759);
            Object.defineProperty(exports2, "find", { enumerable: true, get: function() {
              return find_1.find;
            } });
            var findIndex_1 = __webpack_require__2(3999);
            Object.defineProperty(exports2, "findIndex", { enumerable: true, get: function() {
              return findIndex_1.findIndex;
            } });
            var first_1 = __webpack_require__2(5194);
            Object.defineProperty(exports2, "first", { enumerable: true, get: function() {
              return first_1.first;
            } });
            var groupBy_1 = __webpack_require__2(1664);
            Object.defineProperty(exports2, "groupBy", { enumerable: true, get: function() {
              return groupBy_1.groupBy;
            } });
            var ignoreElements_1 = __webpack_require__2(3470);
            Object.defineProperty(exports2, "ignoreElements", { enumerable: true, get: function() {
              return ignoreElements_1.ignoreElements;
            } });
            var isEmpty_1 = __webpack_require__2(9549);
            Object.defineProperty(exports2, "isEmpty", { enumerable: true, get: function() {
              return isEmpty_1.isEmpty;
            } });
            var last_1 = __webpack_require__2(9582);
            Object.defineProperty(exports2, "last", { enumerable: true, get: function() {
              return last_1.last;
            } });
            var map_1 = __webpack_require__2(4338);
            Object.defineProperty(exports2, "map", { enumerable: true, get: function() {
              return map_1.map;
            } });
            var mapTo_1 = __webpack_require__2(4791);
            Object.defineProperty(exports2, "mapTo", { enumerable: true, get: function() {
              return mapTo_1.mapTo;
            } });
            var materialize_1 = __webpack_require__2(9318);
            Object.defineProperty(exports2, "materialize", { enumerable: true, get: function() {
              return materialize_1.materialize;
            } });
            var max_1 = __webpack_require__2(7446);
            Object.defineProperty(exports2, "max", { enumerable: true, get: function() {
              return max_1.max;
            } });
            var merge_1 = __webpack_require__2(6094);
            Object.defineProperty(exports2, "merge", { enumerable: true, get: function() {
              return merge_1.merge;
            } });
            var mergeAll_1 = __webpack_require__2(4594);
            Object.defineProperty(exports2, "mergeAll", { enumerable: true, get: function() {
              return mergeAll_1.mergeAll;
            } });
            var flatMap_1 = __webpack_require__2(2735);
            Object.defineProperty(exports2, "flatMap", { enumerable: true, get: function() {
              return flatMap_1.flatMap;
            } });
            var mergeMap_1 = __webpack_require__2(9010);
            Object.defineProperty(exports2, "mergeMap", { enumerable: true, get: function() {
              return mergeMap_1.mergeMap;
            } });
            var mergeMapTo_1 = __webpack_require__2(8983);
            Object.defineProperty(exports2, "mergeMapTo", { enumerable: true, get: function() {
              return mergeMapTo_1.mergeMapTo;
            } });
            var mergeScan_1 = __webpack_require__2(2170);
            Object.defineProperty(exports2, "mergeScan", { enumerable: true, get: function() {
              return mergeScan_1.mergeScan;
            } });
            var mergeWith_1 = __webpack_require__2(3674);
            Object.defineProperty(exports2, "mergeWith", { enumerable: true, get: function() {
              return mergeWith_1.mergeWith;
            } });
            var min_1 = __webpack_require__2(1446);
            Object.defineProperty(exports2, "min", { enumerable: true, get: function() {
              return min_1.min;
            } });
            var multicast_1 = __webpack_require__2(2318);
            Object.defineProperty(exports2, "multicast", { enumerable: true, get: function() {
              return multicast_1.multicast;
            } });
            var observeOn_1 = __webpack_require__2(3165);
            Object.defineProperty(exports2, "observeOn", { enumerable: true, get: function() {
              return observeOn_1.observeOn;
            } });
            var onErrorResumeNextWith_1 = __webpack_require__2(2216);
            Object.defineProperty(exports2, "onErrorResumeNext", { enumerable: true, get: function() {
              return onErrorResumeNextWith_1.onErrorResumeNext;
            } });
            var pairwise_1 = __webpack_require__2(402);
            Object.defineProperty(exports2, "pairwise", { enumerable: true, get: function() {
              return pairwise_1.pairwise;
            } });
            var partition_1 = __webpack_require__2(5960);
            Object.defineProperty(exports2, "partition", { enumerable: true, get: function() {
              return partition_1.partition;
            } });
            var pluck_1 = __webpack_require__2(5658);
            Object.defineProperty(exports2, "pluck", { enumerable: true, get: function() {
              return pluck_1.pluck;
            } });
            var publish_1 = __webpack_require__2(3881);
            Object.defineProperty(exports2, "publish", { enumerable: true, get: function() {
              return publish_1.publish;
            } });
            var publishBehavior_1 = __webpack_require__2(1755);
            Object.defineProperty(exports2, "publishBehavior", { enumerable: true, get: function() {
              return publishBehavior_1.publishBehavior;
            } });
            var publishLast_1 = __webpack_require__2(9801);
            Object.defineProperty(exports2, "publishLast", { enumerable: true, get: function() {
              return publishLast_1.publishLast;
            } });
            var publishReplay_1 = __webpack_require__2(5021);
            Object.defineProperty(exports2, "publishReplay", { enumerable: true, get: function() {
              return publishReplay_1.publishReplay;
            } });
            var race_1 = __webpack_require__2(2749);
            Object.defineProperty(exports2, "race", { enumerable: true, get: function() {
              return race_1.race;
            } });
            var raceWith_1 = __webpack_require__2(9925);
            Object.defineProperty(exports2, "raceWith", { enumerable: true, get: function() {
              return raceWith_1.raceWith;
            } });
            var reduce_1 = __webpack_require__2(1386);
            Object.defineProperty(exports2, "reduce", { enumerable: true, get: function() {
              return reduce_1.reduce;
            } });
            var repeat_1 = __webpack_require__2(1194);
            Object.defineProperty(exports2, "repeat", { enumerable: true, get: function() {
              return repeat_1.repeat;
            } });
            var repeatWhen_1 = __webpack_require__2(7085);
            Object.defineProperty(exports2, "repeatWhen", { enumerable: true, get: function() {
              return repeatWhen_1.repeatWhen;
            } });
            var retry_1 = __webpack_require__2(7524);
            Object.defineProperty(exports2, "retry", { enumerable: true, get: function() {
              return retry_1.retry;
            } });
            var retryWhen_1 = __webpack_require__2(548);
            Object.defineProperty(exports2, "retryWhen", { enumerable: true, get: function() {
              return retryWhen_1.retryWhen;
            } });
            var refCount_1 = __webpack_require__2(2711);
            Object.defineProperty(exports2, "refCount", { enumerable: true, get: function() {
              return refCount_1.refCount;
            } });
            var sample_1 = __webpack_require__2(6577);
            Object.defineProperty(exports2, "sample", { enumerable: true, get: function() {
              return sample_1.sample;
            } });
            var sampleTime_1 = __webpack_require__2(3815);
            Object.defineProperty(exports2, "sampleTime", { enumerable: true, get: function() {
              return sampleTime_1.sampleTime;
            } });
            var scan_1 = __webpack_require__2(7250);
            Object.defineProperty(exports2, "scan", { enumerable: true, get: function() {
              return scan_1.scan;
            } });
            var sequenceEqual_1 = __webpack_require__2(842);
            Object.defineProperty(exports2, "sequenceEqual", { enumerable: true, get: function() {
              return sequenceEqual_1.sequenceEqual;
            } });
            var share_1 = __webpack_require__2(9728);
            Object.defineProperty(exports2, "share", { enumerable: true, get: function() {
              return share_1.share;
            } });
            var shareReplay_1 = __webpack_require__2(7768);
            Object.defineProperty(exports2, "shareReplay", { enumerable: true, get: function() {
              return shareReplay_1.shareReplay;
            } });
            var single_1 = __webpack_require__2(2445);
            Object.defineProperty(exports2, "single", { enumerable: true, get: function() {
              return single_1.single;
            } });
            var skip_1 = __webpack_require__2(6262);
            Object.defineProperty(exports2, "skip", { enumerable: true, get: function() {
              return skip_1.skip;
            } });
            var skipLast_1 = __webpack_require__2(7397);
            Object.defineProperty(exports2, "skipLast", { enumerable: true, get: function() {
              return skipLast_1.skipLast;
            } });
            var skipUntil_1 = __webpack_require__2(9900);
            Object.defineProperty(exports2, "skipUntil", { enumerable: true, get: function() {
              return skipUntil_1.skipUntil;
            } });
            var skipWhile_1 = __webpack_require__2(1620);
            Object.defineProperty(exports2, "skipWhile", { enumerable: true, get: function() {
              return skipWhile_1.skipWhile;
            } });
            var startWith_1 = __webpack_require__2(3424);
            Object.defineProperty(exports2, "startWith", { enumerable: true, get: function() {
              return startWith_1.startWith;
            } });
            var subscribeOn_1 = __webpack_require__2(831);
            Object.defineProperty(exports2, "subscribeOn", { enumerable: true, get: function() {
              return subscribeOn_1.subscribeOn;
            } });
            var switchAll_1 = __webpack_require__2(411);
            Object.defineProperty(exports2, "switchAll", { enumerable: true, get: function() {
              return switchAll_1.switchAll;
            } });
            var switchMap_1 = __webpack_require__2(7222);
            Object.defineProperty(exports2, "switchMap", { enumerable: true, get: function() {
              return switchMap_1.switchMap;
            } });
            var switchMapTo_1 = __webpack_require__2(6464);
            Object.defineProperty(exports2, "switchMapTo", { enumerable: true, get: function() {
              return switchMapTo_1.switchMapTo;
            } });
            var switchScan_1 = __webpack_require__2(4434);
            Object.defineProperty(exports2, "switchScan", { enumerable: true, get: function() {
              return switchScan_1.switchScan;
            } });
            var take_1 = __webpack_require__2(7138);
            Object.defineProperty(exports2, "take", { enumerable: true, get: function() {
              return take_1.take;
            } });
            var takeLast_1 = __webpack_require__2(4288);
            Object.defineProperty(exports2, "takeLast", { enumerable: true, get: function() {
              return takeLast_1.takeLast;
            } });
            var takeUntil_1 = __webpack_require__2(7341);
            Object.defineProperty(exports2, "takeUntil", { enumerable: true, get: function() {
              return takeUntil_1.takeUntil;
            } });
            var takeWhile_1 = __webpack_require__2(653);
            Object.defineProperty(exports2, "takeWhile", { enumerable: true, get: function() {
              return takeWhile_1.takeWhile;
            } });
            var tap_1 = __webpack_require__2(8668);
            Object.defineProperty(exports2, "tap", { enumerable: true, get: function() {
              return tap_1.tap;
            } });
            var throttle_1 = __webpack_require__2(9466);
            Object.defineProperty(exports2, "throttle", { enumerable: true, get: function() {
              return throttle_1.throttle;
            } });
            var throttleTime_1 = __webpack_require__2(9705);
            Object.defineProperty(exports2, "throttleTime", { enumerable: true, get: function() {
              return throttleTime_1.throttleTime;
            } });
            var throwIfEmpty_1 = __webpack_require__2(8062);
            Object.defineProperty(exports2, "throwIfEmpty", { enumerable: true, get: function() {
              return throwIfEmpty_1.throwIfEmpty;
            } });
            var timeInterval_1 = __webpack_require__2(6610);
            Object.defineProperty(exports2, "timeInterval", { enumerable: true, get: function() {
              return timeInterval_1.timeInterval;
            } });
            var timeout_1 = __webpack_require__2(6279);
            Object.defineProperty(exports2, "timeout", { enumerable: true, get: function() {
              return timeout_1.timeout;
            } });
            var timeoutWith_1 = __webpack_require__2(8132);
            Object.defineProperty(exports2, "timeoutWith", { enumerable: true, get: function() {
              return timeoutWith_1.timeoutWith;
            } });
            var timestamp_1 = __webpack_require__2(4553);
            Object.defineProperty(exports2, "timestamp", { enumerable: true, get: function() {
              return timestamp_1.timestamp;
            } });
            var toArray_1 = __webpack_require__2(2378);
            Object.defineProperty(exports2, "toArray", { enumerable: true, get: function() {
              return toArray_1.toArray;
            } });
            var window_1 = __webpack_require__2(4768);
            Object.defineProperty(exports2, "window", { enumerable: true, get: function() {
              return window_1.window;
            } });
            var windowCount_1 = __webpack_require__2(131);
            Object.defineProperty(exports2, "windowCount", { enumerable: true, get: function() {
              return windowCount_1.windowCount;
            } });
            var windowTime_1 = __webpack_require__2(9579);
            Object.defineProperty(exports2, "windowTime", { enumerable: true, get: function() {
              return windowTime_1.windowTime;
            } });
            var windowToggle_1 = __webpack_require__2(752);
            Object.defineProperty(exports2, "windowToggle", { enumerable: true, get: function() {
              return windowToggle_1.windowToggle;
            } });
            var windowWhen_1 = __webpack_require__2(582);
            Object.defineProperty(exports2, "windowWhen", { enumerable: true, get: function() {
              return windowWhen_1.windowWhen;
            } });
            var withLatestFrom_1 = __webpack_require__2(4255);
            Object.defineProperty(exports2, "withLatestFrom", { enumerable: true, get: function() {
              return withLatestFrom_1.withLatestFrom;
            } });
            var zip_1 = __webpack_require__2(3253);
            Object.defineProperty(exports2, "zip", { enumerable: true, get: function() {
              return zip_1.zip;
            } });
            var zipAll_1 = __webpack_require__2(7220);
            Object.defineProperty(exports2, "zipAll", { enumerable: true, get: function() {
              return zipAll_1.zipAll;
            } });
            var zipWith_1 = __webpack_require__2(9287);
            Object.defineProperty(exports2, "zipWith", { enumerable: true, get: function() {
              return zipWith_1.zipWith;
            } });
          }
        ),
        /***/
        1964: (
          /***/
          (module2) => {
            "use strict";
            module2.exports = require_cjs();
          }
        ),
        /***/
        5352: (
          /***/
          (module2) => {
            "use strict";
            module2.exports = require_browser();
          }
        )
        /******/
      };
      var __webpack_module_cache__ = {};
      function __webpack_require__(moduleId) {
        var cachedModule = __webpack_module_cache__[moduleId];
        if (cachedModule !== void 0) {
          return cachedModule.exports;
        }
        var module2 = __webpack_module_cache__[moduleId] = {
          /******/
          id: moduleId,
          /******/
          loaded: false,
          /******/
          exports: {}
          /******/
        };
        __webpack_modules__[moduleId].call(module2.exports, module2, module2.exports, __webpack_require__);
        module2.loaded = true;
        return module2.exports;
      }
      (() => {
        __webpack_require__.n = (module2) => {
          var getter = module2 && module2.__esModule ? (
            /******/
            () => module2["default"]
          ) : (
            /******/
            () => module2
          );
          __webpack_require__.d(getter, { a: getter });
          return getter;
        };
      })();
      (() => {
        __webpack_require__.d = (exports2, definition) => {
          for (var key in definition) {
            if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports2, key)) {
              Object.defineProperty(exports2, key, { enumerable: true, get: definition[key] });
            }
          }
        };
      })();
      (() => {
        __webpack_require__.g = function() {
          if (typeof globalThis === "object")
            return globalThis;
          try {
            return this || new Function("return this")();
          } catch (e) {
            if (typeof window === "object")
              return window;
          }
        }();
      })();
      (() => {
        __webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);
      })();
      (() => {
        __webpack_require__.r = (exports2) => {
          if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
            Object.defineProperty(exports2, Symbol.toStringTag, { value: "Module" });
          }
          Object.defineProperty(exports2, "__esModule", { value: true });
        };
      })();
      (() => {
        __webpack_require__.nmd = (module2) => {
          module2.paths = [];
          if (!module2.children)
            module2.children = [];
          return module2;
        };
      })();
      var __webpack_exports__ = {};
      (() => {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        __webpack_require__.d(__webpack_exports__, {
          AI_MODEL_NAMES: () => (
            /* reexport */
            AI_MODEL_NAMES
          ),
          APP_API_KEY: () => (
            /* reexport */
            APP_API_KEY
          ),
          AiChatbotProfileReference: () => (
            /* reexport */
            AiChatbotProfileReference
          ),
          ApiCallContext: () => (
            /* reexport */
            ApiCallContext
          ),
          ApiIntegrationTypes: () => (
            /* reexport */
            ApiIntegrationTypes
          ),
          AuthIntegrationTypes: () => (
            /* reexport */
            AuthIntegrationTypes
          ),
          BACKEND_API_KEY: () => (
            /* reexport */
            BACKEND_API_KEY
          ),
          BaseQueryBuilder: () => (
            /* reexport */
            BaseQueryBuilder
          ),
          Changes: () => (
            /* reexport */
            Changes
          ),
          ClientConnectionState: () => (
            /* reexport */
            ClientConnectionState
          ),
          CollectionReference: () => (
            /* reexport */
            CollectionReference
          ),
          CronExpression: () => (
            /* reexport */
            CronExpression
          ),
          DEFAULT_SHORT_ID_LENGTH: () => (
            /* reexport */
            DEFAULT_SHORT_ID_LENGTH
          ),
          DatabaseIntegrationTypes: () => (
            /* reexport */
            DatabaseIntegrationTypes
          ),
          DistributedLockContext: () => (
            /* reexport */
            DistributedLockContext
          ),
          DocumentReference: () => (
            /* reexport */
            DocumentReference
          ),
          ENVIRONMENT_IDS: () => (
            /* reexport */
            ENVIRONMENT_IDS
          ),
          EmptyIntrospection: () => (
            /* reexport */
            EmptyIntrospection
          ),
          ExecuteFunctionSecureAnnotations: () => (
            /* reexport */
            ExecuteFunctionSecureAnnotations
          ),
          GraphQLClient: () => (
            /* reexport */
            GraphQLClient
          ),
          GraphqlContext: () => (
            /* reexport */
            GraphqlContext
          ),
          HttpStatus: () => (
            /* reexport */
            http_status_enum_HttpStatus
          ),
          IntegrationCategory: () => (
            /* reexport */
            IntegrationCategory
          ),
          IntegrationSchemaType: () => (
            /* reexport */
            IntegrationSchemaType
          ),
          IntegrationType: () => (
            /* reexport */
            IntegrationType
          ),
          JoinQueryBuilder: () => (
            /* reexport */
            JoinQueryBuilder
          ),
          LogLevel: () => (
            /* reexport */
            LogLevel
          ),
          MutationContext: () => (
            /* reexport */
            MutationContext
          ),
          NativeQueryContext: () => (
            /* reexport */
            NativeQueryContext
          ),
          ObservabilityIntegrationTypes: () => (
            /* reexport */
            ObservabilityIntegrationTypes
          ),
          Pagination: () => (
            /* reexport */
            Pagination
          ),
          QueryBuilder: () => (
            /* reexport */
            QueryBuilder
          ),
          QueryContext: () => (
            /* reexport */
            QueryContext
          ),
          QueryMappingManager: () => (
            /* reexport */
            QueryMappingManager
          ),
          QueueIntegrationTypes: () => (
            /* reexport */
            QueueIntegrationTypes
          ),
          SQUID_CLOUD_IDS: () => (
            /* reexport */
            SQUID_CLOUD_IDS
          ),
          Squid: () => (
            /* reexport */
            Squid
          ),
          SquidPlaceholderId: () => (
            /* reexport */
            SquidPlaceholderId
          ),
          SupportedSquidRegions: () => (
            /* reexport */
            SupportedSquidRegions
          ),
          aggregationPeriodMap: () => (
            /* reexport */
            aggregationPeriodMap
          ),
          allEnvironmentIds: () => (
            /* reexport */
            allEnvironmentIds
          ),
          appIdWithEnvironmentId: () => (
            /* reexport */
            appIdWithEnvironmentId
          ),
          appIdWithEnvironmentIdAndDevId: () => (
            /* reexport */
            appIdWithEnvironmentIdAndDevId
          ),
          applyUpdateMutation: () => (
            /* reexport */
            applyUpdateMutation
          ),
          checkAllHeartbeatProviders: () => (
            /* reexport */
            checkAllHeartbeatProviders
          ),
          compareOperator: () => (
            /* reexport */
            compareOperator
          ),
          convertFromSquidRegion: () => (
            /* reexport */
            convertFromSquidRegion
          ),
          convertInsertToUpdate: () => (
            /* reexport */
            convertInsertToUpdate
          ),
          convertToRunSecrets: () => (
            /* reexport */
            convertToRunSecrets
          ),
          convertToSquidRegion: () => (
            /* reexport */
            convertToSquidRegion
          ),
          datadogLogsUrlMap: () => (
            /* reexport */
            datadogLogsUrlMap
          ),
          datadogRegionMap: () => (
            /* reexport */
            datadogRegionMap
          ),
          deserializeQuery: () => (
            /* reexport */
            deserializeQuery
          ),
          encodeCondition: () => (
            /* reexport */
            encodeCondition
          ),
          generateId: () => (
            /* reexport */
            generateId
          ),
          generateShortId: () => (
            /* reexport */
            generateShortId
          ),
          getQuerySubscriptionId: () => (
            /* reexport */
            getQuerySubscriptionId
          ),
          getSquidDocId: () => (
            /* reexport */
            getSquidDocId
          ),
          getSquidSupportedCloudMap: () => (
            /* reexport */
            getSquidSupportedCloudMap
          ),
          hasDocumentDiff: () => (
            /* reexport */
            hasDocumentDiff
          ),
          isAuthIntegration: () => (
            /* reexport */
            isAuthIntegration
          ),
          isAuthIntegrationType: () => (
            /* reexport */
            isAuthIntegrationType
          ),
          isDataIntegration: () => (
            /* reexport */
            isDataIntegration
          ),
          isDataIntegrationType: () => (
            /* reexport */
            isDataIntegrationType
          ),
          isSimpleCondition: () => (
            /* reexport */
            isSimpleCondition
          ),
          mergeMutations: () => (
            /* reexport */
            mergeMutations
          ),
          newRelicRegionMap: () => (
            /* reexport */
            newRelicRegionMap
          ),
          omitSquidDevId: () => (
            /* reexport */
            omitSquidDevId
          ),
          parseAppId: () => (
            /* reexport */
            parseAppId
          ),
          parseQuerySubscriptionId: () => (
            /* reexport */
            parseQuerySubscriptionId
          ),
          parseSquidDocId: () => (
            /* reexport */
            parseSquidDocId
          ),
          reduceMutations: () => (
            /* reexport */
            reduceMutations
          ),
          sortUpdateMutationProperties: () => (
            /* reexport */
            sortUpdateMutationProperties
          ),
          squidSupportedRegionMap: () => (
            /* reexport */
            squidSupportedRegionMap
          ),
          validateEnvironment: () => (
            /* reexport */
            validateEnvironment
          ),
          verifyWithSquidDevId: () => (
            /* reexport */
            verifyWithSquidDevId
          )
        });
        ;
        const AI_MODEL_NAMES = [
          "gpt-3.5-turbo",
          "gpt-3.5-turbo-1106",
          "gpt-4",
          "claude-2",
          "gpt-4-1106-preview"
        ];
        ;
        class ApiCallContext {
          /** @internal */
          constructor(apiRequest) {
            this.endpointId = apiRequest.endpointId;
            this.url = apiRequest.url;
            this.method = apiRequest.method;
            this.headers = apiRequest.headers;
            this.body = apiRequest.body;
            this.queryParams = apiRequest.queryParams;
            this.pathParams = apiRequest.pathParams;
            this.serverUrlOverride = apiRequest.serverUrlOverride;
          }
        }
        ;
        var CronExpression;
        (function(CronExpression2) {
          CronExpression2["EVERY_SECOND"] = "* * * * * *";
          CronExpression2["EVERY_5_SECONDS"] = "*/5 * * * * *";
          CronExpression2["EVERY_10_SECONDS"] = "*/10 * * * * *";
          CronExpression2["EVERY_30_SECONDS"] = "*/30 * * * * *";
          CronExpression2["EVERY_MINUTE"] = "*/1 * * * *";
          CronExpression2["EVERY_5_MINUTES"] = "0 */5 * * * *";
          CronExpression2["EVERY_10_MINUTES"] = "0 */10 * * * *";
          CronExpression2["EVERY_30_MINUTES"] = "0 */30 * * * *";
          CronExpression2["EVERY_HOUR"] = "0 0-23/1 * * *";
          CronExpression2["EVERY_2_HOURS"] = "0 0-23/2 * * *";
          CronExpression2["EVERY_3_HOURS"] = "0 0-23/3 * * *";
          CronExpression2["EVERY_4_HOURS"] = "0 0-23/4 * * *";
          CronExpression2["EVERY_5_HOURS"] = "0 0-23/5 * * *";
          CronExpression2["EVERY_6_HOURS"] = "0 0-23/6 * * *";
          CronExpression2["EVERY_7_HOURS"] = "0 0-23/7 * * *";
          CronExpression2["EVERY_8_HOURS"] = "0 0-23/8 * * *";
          CronExpression2["EVERY_9_HOURS"] = "0 0-23/9 * * *";
          CronExpression2["EVERY_10_HOURS"] = "0 0-23/10 * * *";
          CronExpression2["EVERY_11_HOURS"] = "0 0-23/11 * * *";
          CronExpression2["EVERY_12_HOURS"] = "0 0-23/12 * * *";
          CronExpression2["EVERY_DAY_AT_1AM"] = "0 01 * * *";
          CronExpression2["EVERY_DAY_AT_2AM"] = "0 02 * * *";
          CronExpression2["EVERY_DAY_AT_3AM"] = "0 03 * * *";
          CronExpression2["EVERY_DAY_AT_4AM"] = "0 04 * * *";
          CronExpression2["EVERY_DAY_AT_5AM"] = "0 05 * * *";
          CronExpression2["EVERY_DAY_AT_6AM"] = "0 06 * * *";
          CronExpression2["EVERY_DAY_AT_7AM"] = "0 07 * * *";
          CronExpression2["EVERY_DAY_AT_8AM"] = "0 08 * * *";
          CronExpression2["EVERY_DAY_AT_9AM"] = "0 09 * * *";
          CronExpression2["EVERY_DAY_AT_10AM"] = "0 10 * * *";
          CronExpression2["EVERY_DAY_AT_11AM"] = "0 11 * * *";
          CronExpression2["EVERY_DAY_AT_NOON"] = "0 12 * * *";
          CronExpression2["EVERY_DAY_AT_1PM"] = "0 13 * * *";
          CronExpression2["EVERY_DAY_AT_2PM"] = "0 14 * * *";
          CronExpression2["EVERY_DAY_AT_3PM"] = "0 15 * * *";
          CronExpression2["EVERY_DAY_AT_4PM"] = "0 16 * * *";
          CronExpression2["EVERY_DAY_AT_5PM"] = "0 17 * * *";
          CronExpression2["EVERY_DAY_AT_6PM"] = "0 18 * * *";
          CronExpression2["EVERY_DAY_AT_7PM"] = "0 19 * * *";
          CronExpression2["EVERY_DAY_AT_8PM"] = "0 20 * * *";
          CronExpression2["EVERY_DAY_AT_9PM"] = "0 21 * * *";
          CronExpression2["EVERY_DAY_AT_10PM"] = "0 22 * * *";
          CronExpression2["EVERY_DAY_AT_11PM"] = "0 23 * * *";
          CronExpression2["EVERY_DAY_AT_MIDNIGHT"] = "0 0 * * *";
          CronExpression2["EVERY_WEEK"] = "0 0 * * 7";
          CronExpression2["EVERY_WEEKDAY"] = "0 0 * * 1-5";
          CronExpression2["EVERY_WEEKEND"] = "0 0 * * 6,7";
          CronExpression2["EVERY_1ST_DAY_OF_MONTH_AT_MIDNIGHT"] = "0 0 1 * *";
          CronExpression2["EVERY_1ST_DAY_OF_MONTH_AT_NOON"] = "0 12 1 * *";
          CronExpression2["EVERY_2ND_HOUR"] = "0 */2 * * *";
          CronExpression2["EVERY_2ND_HOUR_FROM_1AM_THROUGH_11PM"] = "0 1-23/2 * * *";
          CronExpression2["EVERY_2ND_MONTH"] = "0 0 1 */2 *";
          CronExpression2["EVERY_QUARTER"] = "0 0 1 */3 *";
          CronExpression2["EVERY_6_MONTHS"] = "0 0 1 */6 *";
          CronExpression2["EVERY_YEAR"] = "0 0 1 1 *";
          CronExpression2["EVERY_30_MINUTES_BETWEEN_9AM_AND_5PM"] = "0 */30 9-17 * * *";
          CronExpression2["EVERY_30_MINUTES_BETWEEN_9AM_AND_6PM"] = "0 */30 9-18 * * *";
          CronExpression2["EVERY_30_MINUTES_BETWEEN_10AM_AND_7PM"] = "0 */30 10-19 * * *";
          CronExpression2["MONDAY_TO_FRIDAY_AT_1AM"] = "0 0 01 * * 1-5";
          CronExpression2["MONDAY_TO_FRIDAY_AT_2AM"] = "0 0 02 * * 1-5";
          CronExpression2["MONDAY_TO_FRIDAY_AT_3AM"] = "0 0 03 * * 1-5";
          CronExpression2["MONDAY_TO_FRIDAY_AT_4AM"] = "0 0 04 * * 1-5";
          CronExpression2["MONDAY_TO_FRIDAY_AT_5AM"] = "0 0 05 * * 1-5";
          CronExpression2["MONDAY_TO_FRIDAY_AT_6AM"] = "0 0 06 * * 1-5";
          CronExpression2["MONDAY_TO_FRIDAY_AT_7AM"] = "0 0 07 * * 1-5";
          CronExpression2["MONDAY_TO_FRIDAY_AT_8AM"] = "0 0 08 * * 1-5";
          CronExpression2["MONDAY_TO_FRIDAY_AT_9AM"] = "0 0 09 * * 1-5";
          CronExpression2["MONDAY_TO_FRIDAY_AT_09_30AM"] = "0 30 09 * * 1-5";
          CronExpression2["MONDAY_TO_FRIDAY_AT_10AM"] = "0 0 10 * * 1-5";
          CronExpression2["MONDAY_TO_FRIDAY_AT_11AM"] = "0 0 11 * * 1-5";
          CronExpression2["MONDAY_TO_FRIDAY_AT_11_30AM"] = "0 30 11 * * 1-5";
          CronExpression2["MONDAY_TO_FRIDAY_AT_12PM"] = "0 0 12 * * 1-5";
          CronExpression2["MONDAY_TO_FRIDAY_AT_1PM"] = "0 0 13 * * 1-5";
          CronExpression2["MONDAY_TO_FRIDAY_AT_2PM"] = "0 0 14 * * 1-5";
          CronExpression2["MONDAY_TO_FRIDAY_AT_3PM"] = "0 0 15 * * 1-5";
          CronExpression2["MONDAY_TO_FRIDAY_AT_4PM"] = "0 0 16 * * 1-5";
          CronExpression2["MONDAY_TO_FRIDAY_AT_5PM"] = "0 0 17 * * 1-5";
          CronExpression2["MONDAY_TO_FRIDAY_AT_6PM"] = "0 0 18 * * 1-5";
          CronExpression2["MONDAY_TO_FRIDAY_AT_7PM"] = "0 0 19 * * 1-5";
          CronExpression2["MONDAY_TO_FRIDAY_AT_8PM"] = "0 0 20 * * 1-5";
          CronExpression2["MONDAY_TO_FRIDAY_AT_9PM"] = "0 0 21 * * 1-5";
          CronExpression2["MONDAY_TO_FRIDAY_AT_10PM"] = "0 0 22 * * 1-5";
          CronExpression2["MONDAY_TO_FRIDAY_AT_11PM"] = "0 0 23 * * 1-5";
        })(CronExpression || (CronExpression = {}));
        ;
        const BACKEND_API_KEY = "_BACKEND_API_KEY";
        const APP_API_KEY = "APP_API_KEY";
        var dist = __webpack_require__(8975);
        ;
        const ExecuteFunctionSecureAnnotations = [
          "secureDistributedLock",
          "secureQuery",
          "secureMutation",
          "secureNamedQuery",
          "secureNativeQuery",
          "secureGraphQL",
          "secureApi",
          "secureAiChatbotChat",
          "secureAiChatbotMutation",
          "secureQueueWrite",
          "secureQueueRead"
        ];
        function convertToRunSecrets(appSecrets) {
          const result = {
            backendApiKey: (0, dist.truthy)(appSecrets.apiKeys[BACKEND_API_KEY].value, "Cannot find backend API key"),
            custom: {}
          };
          for (const [key, valueWrapper] of Object.entries(appSecrets.custom)) {
            result.custom[key] = valueWrapper.value;
          }
          return result;
        }
        ;
        class BaseQueryBuilder {
          constructor() {
            this.containsEmptyInCondition = false;
          }
          /**
           * A shortcut for where(fieldName, '==', value)
           *
           * @param fieldName The name of the field to query.
           * @param value The value to compare against.
           * @returns The query builder.
           */
          eq(fieldName, value) {
            return this.where(fieldName, "==", value);
          }
          /**
           * A shortcut for where(fieldName, '!=', value)
           * @param fieldName The name of the field to query.
           * @param value The value to compare against.
           * @returns The query builder.
           */
          neq(fieldName, value) {
            return this.where(fieldName, "!=", value);
          }
          /**
           * A shortcut for where(fieldName, 'in', value)
           * @param fieldName The name of the field to query.
           * @param value An array of values to compare against.
           * @returns The query builder.
           */
          in(fieldName, value) {
            return this.where(fieldName, "in", value);
          }
          /**
           * A shortcut for where(fieldName, 'not in', value)
           * @param fieldName The name of the field to query.
           * @param value An array of values to compare against.
           * @returns The query builder.
           */
          nin(fieldName, value) {
            return this.where(fieldName, "not in", value);
          }
          /**
           * A shortcut for where(fieldName, '>', value)
           * @param fieldName The name of the field to query.
           * @param value The value to compare against.
           * @returns The query builder.
           */
          gt(fieldName, value) {
            return this.where(fieldName, ">", value);
          }
          /**
           * A shortcut for where(fieldName, '>=', value)
           * @param fieldName The name of the field to query.
           * @param value The value to compare against.
           * @returns The query builder.
           */
          gte(fieldName, value) {
            return this.where(fieldName, ">=", value);
          }
          /**
           * A shortcut for where(fieldName, '<', value)
           * @param fieldName The name of the field to query.
           * @param value The value to compare against.
           * @returns The query builder.
           */
          lt(fieldName, value) {
            return this.where(fieldName, "<", value);
          }
          /**
           * A shortcut for where(fieldName, '<=', value)
           * @param fieldName The name of the field to query.
           * @param value The value to compare against.
           * @returns The query builder.
           */
          lte(fieldName, value) {
            return this.where(fieldName, "<=", value);
          }
          /**
           * A shortcut for where(fieldName, 'like', pattern).
           *
           * @param fieldName The name of the field to query.
           * @param pattern The pattern to compare against. '%' is the only allowed wildcard
           * @param caseSensitive Whether to use case-sensitive comparison. Defaults to true.
           * @returns The query builder.
           */
          like(fieldName, pattern, caseSensitive) {
            return this.where(fieldName, caseSensitive ? "like_cs" : "like", pattern);
          }
          /**
           * A shortcut for where(fieldName, 'not like', pattern).
           *
           * @param fieldName The name of the field to query.
           * @param pattern The pattern to compare against. '%' is the only allowed wildcard
           * @param caseSensitive Whether to use case-sensitive comparison. Defaults to true.
           * @returns The query builder.
           */
          notLike(fieldName, pattern, caseSensitive) {
            return this.where(fieldName, caseSensitive ? "not like_cs" : "not like", pattern);
          }
        }
        ;
        const ENVIRONMENT_IDS = ["dev", "prod"];
        const allEnvironmentIds = [...ENVIRONMENT_IDS];
        function parseAppId(appId) {
          const [appIdWithoutEnv, environmentId, squidDeveloperId, other] = appId.split(/[_-]/);
          (0, dist.assertTruthy)(!other, "Invalid appId: " + appId);
          return {
            appId: appIdWithoutEnv,
            environmentId: environmentId !== null && environmentId !== void 0 ? environmentId : "prod",
            squidDeveloperId
          };
        }
        function appIdWithEnvironmentId(appId, environmentId) {
          const parsedAppId = parseAppId(appId);
          return `${parsedAppId.appId}${!environmentId || environmentId === "prod" ? "" : `-${environmentId}`}`;
        }
        function appIdWithEnvironmentIdAndDevId(appId, environmentId, developerId) {
          return `${appIdWithEnvironmentId(appId, environmentId)}${developerId ? `-${developerId}` : ""}`;
        }
        function validateEnvironment(appId) {
          const parsedAppId = parseAppId(appId);
          (0, dist.assertTruthy)(parsedAppId.environmentId !== "prod" || !parsedAppId.squidDeveloperId, "Cannot use developer ID in production");
          return parsedAppId;
        }
        function verifyWithSquidDevId(appId) {
          const parsedAppId = parseAppId(appId);
          (0, dist.assertTruthy)(parsedAppId.squidDeveloperId, "Must provide squid developer ID");
        }
        function omitSquidDevId(appId) {
          const parsedAppId = parseAppId(appId);
          return appIdWithEnvironmentId(parsedAppId.appId, parsedAppId.environmentId);
        }
        ;
        class DistributedLockContext {
          /** @internal */
          constructor(mutex) {
            this.mutex = mutex;
          }
        }
        var deep_diff = __webpack_require__(2091);
        var deep_diff_default = __webpack_require__.n(deep_diff);
        var lodash = __webpack_require__(8784);
        var lodash_default = __webpack_require__.n(lodash);
        ;
        function sortKeys(json) {
          if (Array.isArray(json)) {
            return json.map((o) => sortKeys(o));
          }
          if (typeof json !== "object" || json === null || json instanceof Date) {
            return json;
          }
          const keys = Object.keys(json);
          const result = {};
          keys.sort().forEach((key) => {
            result[key] = sortKeys(json[key]);
          });
          return result;
        }
        function normalizeJsonAsString(json) {
          return serializeObj(sortKeys(json));
        }
        function serializeObj(obj) {
          if (obj === void 0)
            return null;
          const objWithReplacedDates = lodash.cloneDeepWith(obj, (value) => {
            return lodash.isDate(value) ? { $date: value.toISOString() } : void 0;
          });
          return JSON.stringify(objWithReplacedDates);
        }
        function deserializeObj(str) {
          const deserializedObj = JSON.parse(str);
          return lodash.cloneDeepWith(deserializedObj, (value) => {
            return lodash.isObject(value) && lodash.has(value, "$date") && Object.keys(value).length === 1 ? new Date(value["$date"]) : void 0;
          });
        }
        function encodeValueForMapping(value) {
          if (value === void 0)
            throw new Error("INVALID_ENCODE_VALUE");
          const serializedValue = serializeObj(value);
          if (typeof Buffer !== "undefined") {
            return Buffer.from(serializedValue, "utf8").toString("base64");
          } else {
            const bytes = new TextEncoder().encode(serializedValue);
            let binary = "";
            for (let i2 = 0; i2 < bytes.length; i2++) {
              binary += String.fromCharCode(bytes[i2]);
            }
            return btoa(binary);
          }
        }
        function decodeValueForMapping(encodedString) {
          let decodedValue;
          if (typeof Buffer !== "undefined") {
            decodedValue = Buffer.from(encodedString, "base64").toString("utf8");
          } else {
            const binary = atob(encodedString);
            const bytes = new Uint8Array(binary.length);
            for (let i2 = 0; i2 < bytes.length; i2++) {
              bytes[i2] = binary.charCodeAt(i2);
            }
            decodedValue = new TextDecoder().decode(bytes);
          }
          return deserializeObj(decodedValue);
        }
        ;
        const SquidPlaceholderId = "__squidId";
        function parseSquidDocId(squidDocId) {
          return deserializeObj(squidDocId);
        }
        function getSquidDocId(...args) {
          const [a, b, c] = args;
          const squidDocIdObjObj = typeof a === "object" ? a : { docId: a, collectionName: b, integrationId: c };
          if (!squidDocIdObjObj.integrationId)
            squidDocIdObjObj.integrationId = void 0;
          return normalizeJsonAsString(squidDocIdObjObj);
        }
        function hasDocumentDiff(beforeDoc, afterDoc) {
          const diffs = deep_diff_default()(beforeDoc, afterDoc) || [];
          const ignoredKeys = ["__docId__", "__ts__"];
          const docIdDiff = diffs.find((diff2) => {
            var _a2;
            return ((_a2 = diff2.path) === null || _a2 === void 0 ? void 0 : _a2[0]) === "__docId__";
          });
          if (docIdDiff) {
            if (docIdDiff.kind !== "E" || !docIdDiff.rhs) {
              throw new Error(`Unexpected diff for __docId__: ${normalizeJsonAsString(docIdDiff)}`);
            }
            const docIdObj = parseSquidDocId(docIdDiff.rhs + "");
            ignoredKeys.push(...Object.keys(docIdObj));
          }
          const diff = diffs === null || diffs === void 0 ? void 0 : diffs.find((diff2) => {
            var _a2;
            if (ignoredKeys.includes((_a2 = diff2.path) === null || _a2 === void 0 ? void 0 : _a2[0]))
              return false;
            switch (diff2.kind) {
              case "N":
                return (0, dist.isNonNullable)(diff2.rhs);
              case "E":
              case "D":
              case "A":
                return true;
            }
            return false;
          });
          return !!diff;
        }
        ;
        class GraphqlContext {
          /**
           * @internal
           */
          constructor(graphQlRequest) {
            this.isGraphiQL = graphQlRequest.isGraphiQL;
            this.query = graphQlRequest.query;
            this.operationName = graphQlRequest.operationName;
            this.variables = graphQlRequest.variables;
          }
        }
        ;
        const EmptyIntrospection = {
          __schema: {
            queryType: { name: "Query", kind: "OBJECT" },
            mutationType: null,
            subscriptionType: null,
            types: [
              {
                name: "Query",
                kind: "OBJECT",
                fields: [
                  {
                    name: "isEmpty",
                    type: {
                      kind: "SCALAR",
                      name: "Boolean"
                    },
                    args: [],
                    isDeprecated: false,
                    deprecationReason: null
                  }
                ],
                interfaces: []
              },
              {
                name: "Boolean",
                kind: "SCALAR"
              }
            ],
            directives: []
          }
        };
        var external_rxjs_ = __webpack_require__(1964);
        ;
        async function checkAllHeartbeatProviders(heartbeatProviders) {
          await Promise.all(Object.entries(heartbeatProviders).map(async ([id, provider]) => {
            try {
              return await (0, external_rxjs_.firstValueFrom)((0, external_rxjs_.from)(provider.checkHeartbeat()).pipe((0, external_rxjs_.timeout)(5e3), (0, external_rxjs_.map)(() => true)));
            } catch (e) {
              console.log(`Error in heartbeat provider: ${id}`, e);
              throw e;
            }
          }));
        }
        ;
        var http_status_enum_HttpStatus;
        (function(HttpStatus2) {
          HttpStatus2[HttpStatus2["CONTINUE"] = 100] = "CONTINUE";
          HttpStatus2[HttpStatus2["SWITCHING_PROTOCOLS"] = 101] = "SWITCHING_PROTOCOLS";
          HttpStatus2[HttpStatus2["PROCESSING"] = 102] = "PROCESSING";
          HttpStatus2[HttpStatus2["EARLYHINTS"] = 103] = "EARLYHINTS";
          HttpStatus2[HttpStatus2["OK"] = 200] = "OK";
          HttpStatus2[HttpStatus2["CREATED"] = 201] = "CREATED";
          HttpStatus2[HttpStatus2["ACCEPTED"] = 202] = "ACCEPTED";
          HttpStatus2[HttpStatus2["NON_AUTHORITATIVE_INFORMATION"] = 203] = "NON_AUTHORITATIVE_INFORMATION";
          HttpStatus2[HttpStatus2["NO_CONTENT"] = 204] = "NO_CONTENT";
          HttpStatus2[HttpStatus2["RESET_CONTENT"] = 205] = "RESET_CONTENT";
          HttpStatus2[HttpStatus2["PARTIAL_CONTENT"] = 206] = "PARTIAL_CONTENT";
          HttpStatus2[HttpStatus2["AMBIGUOUS"] = 300] = "AMBIGUOUS";
          HttpStatus2[HttpStatus2["MOVED_PERMANENTLY"] = 301] = "MOVED_PERMANENTLY";
          HttpStatus2[HttpStatus2["FOUND"] = 302] = "FOUND";
          HttpStatus2[HttpStatus2["SEE_OTHER"] = 303] = "SEE_OTHER";
          HttpStatus2[HttpStatus2["NOT_MODIFIED"] = 304] = "NOT_MODIFIED";
          HttpStatus2[HttpStatus2["TEMPORARY_REDIRECT"] = 307] = "TEMPORARY_REDIRECT";
          HttpStatus2[HttpStatus2["PERMANENT_REDIRECT"] = 308] = "PERMANENT_REDIRECT";
          HttpStatus2[HttpStatus2["BAD_REQUEST"] = 400] = "BAD_REQUEST";
          HttpStatus2[HttpStatus2["UNAUTHORIZED"] = 401] = "UNAUTHORIZED";
          HttpStatus2[HttpStatus2["PAYMENT_REQUIRED"] = 402] = "PAYMENT_REQUIRED";
          HttpStatus2[HttpStatus2["FORBIDDEN"] = 403] = "FORBIDDEN";
          HttpStatus2[HttpStatus2["NOT_FOUND"] = 404] = "NOT_FOUND";
          HttpStatus2[HttpStatus2["METHOD_NOT_ALLOWED"] = 405] = "METHOD_NOT_ALLOWED";
          HttpStatus2[HttpStatus2["NOT_ACCEPTABLE"] = 406] = "NOT_ACCEPTABLE";
          HttpStatus2[HttpStatus2["PROXY_AUTHENTICATION_REQUIRED"] = 407] = "PROXY_AUTHENTICATION_REQUIRED";
          HttpStatus2[HttpStatus2["REQUEST_TIMEOUT"] = 408] = "REQUEST_TIMEOUT";
          HttpStatus2[HttpStatus2["CONFLICT"] = 409] = "CONFLICT";
          HttpStatus2[HttpStatus2["GONE"] = 410] = "GONE";
          HttpStatus2[HttpStatus2["LENGTH_REQUIRED"] = 411] = "LENGTH_REQUIRED";
          HttpStatus2[HttpStatus2["PRECONDITION_FAILED"] = 412] = "PRECONDITION_FAILED";
          HttpStatus2[HttpStatus2["PAYLOAD_TOO_LARGE"] = 413] = "PAYLOAD_TOO_LARGE";
          HttpStatus2[HttpStatus2["URI_TOO_LONG"] = 414] = "URI_TOO_LONG";
          HttpStatus2[HttpStatus2["UNSUPPORTED_MEDIA_TYPE"] = 415] = "UNSUPPORTED_MEDIA_TYPE";
          HttpStatus2[HttpStatus2["REQUESTED_RANGE_NOT_SATISFIABLE"] = 416] = "REQUESTED_RANGE_NOT_SATISFIABLE";
          HttpStatus2[HttpStatus2["EXPECTATION_FAILED"] = 417] = "EXPECTATION_FAILED";
          HttpStatus2[HttpStatus2["I_AM_A_TEAPOT"] = 418] = "I_AM_A_TEAPOT";
          HttpStatus2[HttpStatus2["MISDIRECTED"] = 421] = "MISDIRECTED";
          HttpStatus2[HttpStatus2["UNPROCESSABLE_ENTITY"] = 422] = "UNPROCESSABLE_ENTITY";
          HttpStatus2[HttpStatus2["FAILED_DEPENDENCY"] = 424] = "FAILED_DEPENDENCY";
          HttpStatus2[HttpStatus2["PRECONDITION_REQUIRED"] = 428] = "PRECONDITION_REQUIRED";
          HttpStatus2[HttpStatus2["TOO_MANY_REQUESTS"] = 429] = "TOO_MANY_REQUESTS";
          HttpStatus2[HttpStatus2["INTERNAL_SERVER_ERROR"] = 500] = "INTERNAL_SERVER_ERROR";
          HttpStatus2[HttpStatus2["NOT_IMPLEMENTED"] = 501] = "NOT_IMPLEMENTED";
          HttpStatus2[HttpStatus2["BAD_GATEWAY"] = 502] = "BAD_GATEWAY";
          HttpStatus2[HttpStatus2["SERVICE_UNAVAILABLE"] = 503] = "SERVICE_UNAVAILABLE";
          HttpStatus2[HttpStatus2["GATEWAY_TIMEOUT"] = 504] = "GATEWAY_TIMEOUT";
          HttpStatus2[HttpStatus2["HTTP_VERSION_NOT_SUPPORTED"] = 505] = "HTTP_VERSION_NOT_SUPPORTED";
        })(http_status_enum_HttpStatus || (http_status_enum_HttpStatus = {}));
        ;
        var IntegrationCategory;
        (function(IntegrationCategory2) {
          IntegrationCategory2["database"] = "database";
          IntegrationCategory2["queue"] = "queue";
          IntegrationCategory2["api"] = "api";
          IntegrationCategory2["observability"] = "observability";
          IntegrationCategory2["crm"] = "crm";
          IntegrationCategory2["auth"] = "auth";
          IntegrationCategory2["ai"] = "ai";
        })(IntegrationCategory || (IntegrationCategory = {}));
        var IntegrationType;
        (function(IntegrationType2) {
          IntegrationType2["built_in_db"] = "built_in_db";
          IntegrationType2["mongo"] = "mongo";
          IntegrationType2["mysql"] = "mysql";
          IntegrationType2["mssql"] = "mssql";
          IntegrationType2["postgres"] = "postgres";
          IntegrationType2["cockroach"] = "cockroach";
          IntegrationType2["api"] = "api";
          IntegrationType2["graphql"] = "graphql";
          IntegrationType2["snowflake"] = "snowflake";
          IntegrationType2["datadog"] = "datadog";
          IntegrationType2["newrelic"] = "newrelic";
          IntegrationType2["auth0"] = "auth0";
          IntegrationType2["jwt_rsa"] = "jwt_rsa";
          IntegrationType2["jwt_hmac"] = "jwt_hmac";
          IntegrationType2["ai_chatbot"] = "ai_chatbot";
          IntegrationType2["cognito"] = "cognito";
          IntegrationType2["okta"] = "okta";
          IntegrationType2["descope"] = "descope";
          IntegrationType2["kafka"] = "kafka";
          IntegrationType2["confluent"] = "confluent";
          IntegrationType2["built_in_queue"] = "built_in_queue";
          IntegrationType2["algolia"] = "algolia";
          IntegrationType2["elastic_observability"] = "elastic_observability";
          IntegrationType2["elastic_search"] = "elastic_search";
          IntegrationType2["elastic_enterprise_search"] = "elastic_enterprise_search";
          IntegrationType2["sentry"] = "sentry";
          IntegrationType2["sap_hana"] = "sap_hana";
          IntegrationType2["salesforce_crm"] = "salesforce_crm";
          IntegrationType2["documentdb"] = "documentdb";
          IntegrationType2["dynamodb"] = "dynamodb";
          IntegrationType2["cassandra"] = "cassandra";
          IntegrationType2["clickhouse"] = "clickhouse";
          IntegrationType2["alloydb"] = "alloydb";
          IntegrationType2["spanner"] = "spanner";
          IntegrationType2["db2"] = "db2";
          IntegrationType2["mariadb"] = "mariadb";
          IntegrationType2["oracledb"] = "oracledb";
          IntegrationType2["pinot"] = "pinot";
          IntegrationType2["redis"] = "redis";
          IntegrationType2["xata"] = "xata";
          IntegrationType2["azure_sql"] = "azure_sql";
          IntegrationType2["azure_postgresql"] = "azure_postgresql";
          IntegrationType2["azure_cosmosdb"] = "azure_cosmosdb";
          IntegrationType2["firestore"] = "firestore";
          IntegrationType2["bigquery"] = "bigquery";
          IntegrationType2["cloudsql"] = "cloudsql";
        })(IntegrationType || (IntegrationType = {}));
        var IntegrationSchemaType;
        (function(IntegrationSchemaType2) {
          IntegrationSchemaType2["data"] = "data";
          IntegrationSchemaType2["api"] = "api";
          IntegrationSchemaType2["graphql"] = "graphql";
        })(IntegrationSchemaType || (IntegrationSchemaType = {}));
        ;
        const datadogRegionMap = {
          us1: "US1 - East",
          us3: "US3 - West",
          us5: "US5 - Central",
          eu1: "EU1 - Europe",
          ap1: "AP1 - Asia",
          "us1-fed": "US1-FED (FedRamp)"
        };
        const datadogLogsUrlMap = {
          us1: "https://http-intake.logs.datadoghq.com",
          us3: "https://http-intake.logs.us3.datadoghq.com",
          us5: "https://http-intake.logs.us5.datadoghq.com",
          eu1: "https://http-intake.logs.datadoghq.eu",
          ap1: "https://http-intake.logs.ap1.datadoghq.com",
          "us1-fed": "https://http-intake.logs.ddog-gov.com"
        };
        const newRelicRegionMap = {
          worldwide: "Worldwide",
          eu: "Europe"
        };
        ;
        const DatabaseIntegrationTypes = [
          IntegrationType.built_in_db,
          IntegrationType.mongo,
          IntegrationType.mysql,
          IntegrationType.bigquery,
          IntegrationType.mssql,
          IntegrationType.postgres,
          IntegrationType.cockroach,
          IntegrationType.snowflake,
          IntegrationType.oracledb,
          IntegrationType.pinot
        ];
        const ApiIntegrationTypes = [IntegrationType.api, IntegrationType.graphql];
        const ObservabilityIntegrationTypes = [IntegrationType.datadog, IntegrationType.newrelic];
        const AuthIntegrationTypes = [
          IntegrationType.auth0,
          IntegrationType.jwt_rsa,
          IntegrationType.jwt_hmac,
          IntegrationType.cognito,
          IntegrationType.okta,
          IntegrationType.descope
        ];
        const QueueIntegrationTypes = [
          IntegrationType.built_in_queue,
          IntegrationType.kafka,
          IntegrationType.confluent
        ];
        function isDataIntegrationType(type) {
          return DatabaseIntegrationTypes.includes(type);
        }
        function isDataIntegration(integration) {
          return isDataIntegrationType(integration.type);
        }
        function isAuthIntegrationType(type) {
          return AuthIntegrationTypes.includes(type);
        }
        function isAuthIntegration(integration) {
          return isAuthIntegrationType(integration.type);
        }
        ;
        var LogLevel;
        (function(LogLevel2) {
          LogLevel2["TRACE"] = "trace";
          LogLevel2["DEBUG"] = "debug";
          LogLevel2["INFO"] = "info";
          LogLevel2["WARN"] = "warn";
          LogLevel2["ERROR"] = "error";
        })(LogLevel || (LogLevel = {}));
        ;
        const aggregationPeriodMap = {
          "1m": 1,
          "5m": 5,
          "15m": 15,
          "1h": 60,
          "1d": 1440,
          "1w": 10080
        };
        ;
        class MutationContext {
          /**
           * @internal
           */
          constructor(mutation, beforeAndAfterDocs, serverTimeStamp) {
            this.mutation = mutation;
            this.beforeAndAfterDocs = beforeAndAfterDocs;
            this.serverTimeStamp = serverTimeStamp;
          }
          getMutationType() {
            return this.mutation.type;
          }
          get before() {
            return this.beforeAndAfterDocs.before;
          }
          get after() {
            return this.beforeAndAfterDocs.after;
          }
          /** Returns true if the mutation affects the provided path. */
          affectsPath(path) {
            const before = this.before ? lodash.get(this.before, path) : void 0;
            const after = this.after ? lodash.get(this.after, path) : void 0;
            return !lodash.isEqual(before, after);
          }
        }
        ;
        function getInPath(obj, path, delimiter = ".") {
          const splitPath = path.split(delimiter);
          let value = void 0;
          let currentObj = obj;
          while (currentObj && splitPath.length) {
            const key = (0, dist.truthy)(splitPath.shift());
            if (!(currentObj instanceof Object) || !(key in currentObj)) {
              return void 0;
            }
            value = currentObj[key];
            currentObj = value;
          }
          return value;
        }
        function isJsObject(obj) {
          if (typeof obj !== "object")
            return false;
          return Reflect.getPrototypeOf(obj) === Object.prototype;
        }
        function setInPath(obj, path, value, delimiter = ".") {
          var _a2;
          const splitPath = path.split(delimiter);
          let currentObj = obj;
          while (splitPath.length) {
            const key = (0, dist.truthy)(splitPath.shift());
            if (splitPath.length) {
              const newCurrentObj = isJsObject(currentObj[key]) ? (_a2 = lodash.clone(currentObj[key])) !== null && _a2 !== void 0 ? _a2 : {} : {};
              currentObj[key] = newCurrentObj;
              currentObj = newCurrentObj;
            } else {
              currentObj[key] = value;
            }
          }
        }
        function deleteInPath(obj, path, delimiter = ".") {
          var _a2;
          const splitPath = path.split(delimiter);
          let currentObj = obj;
          while (splitPath.length) {
            const key = (0, dist.truthy)(splitPath.shift());
            if (splitPath.length) {
              const newCurrentObj = isJsObject(currentObj[key]) ? (_a2 = lodash.clone(currentObj[key])) !== null && _a2 !== void 0 ? _a2 : {} : {};
              currentObj[key] = newCurrentObj;
              currentObj = newCurrentObj;
            } else {
              delete currentObj[key];
            }
          }
        }
        function replaceKeyInMap(map2, a, b) {
          if (map2.has(a)) {
            const value = map2.get(a);
            map2.delete(a);
            map2.set(b, value);
          }
        }
        function replaceKeyInRecord(record, a, b) {
          const value = record[a];
          if (typeof value !== "undefined") {
            record[b] = value;
            delete record[a];
          }
        }
        ;
        function applyStringFn(initialValue, propertyMutation) {
          switch (propertyMutation.fn) {
            case "trim":
              if (typeof initialValue !== "string")
                return initialValue;
              return initialValue.trim();
            case "extendString":
              if (initialValue === null || initialValue === void 0)
                return propertyMutation.value;
              return initialValue + propertyMutation.value;
            default:
              throw new Error("Unknown string function: " + JSON.stringify(propertyMutation));
          }
        }
        function applyNumericFn(initialValue, propertyMutation) {
          switch (propertyMutation.fn) {
            case "increment":
              if (initialValue === null || initialValue === void 0)
                return propertyMutation.value;
              return initialValue + propertyMutation.value;
            default:
              throw new Error("Unknown numeric function: " + JSON.stringify(propertyMutation));
          }
        }
        function applyPropertyMutation(property, propertyMutation) {
          switch (propertyMutation.type) {
            case "applyNumericFn":
              return applyNumericFn(property, propertyMutation);
            case "applyStringFn":
              return applyStringFn(property, propertyMutation);
            case "update":
              return typeof propertyMutation.value === "object" ? lodash.cloneDeep(propertyMutation.value) : propertyMutation.value;
            case "removeProperty":
              return void 0;
            default:
              throw new Error("Unknown property mutation type: " + JSON.stringify(propertyMutation));
          }
        }
        function sortUpdateMutationProperties(updateMutation) {
          return Object.entries(updateMutation.properties).sort(([propA], [propB]) => {
            const propADots = propA.split(".").length;
            const propBDots = propB.split(".").length;
            return propADots - propBDots;
          });
        }
        function mergeMutations(mutationA, mutationB) {
          if (mutationB.type === "insert")
            return mutationB;
          if (mutationB.type === "delete")
            return mutationB;
          if (mutationA.type === "delete")
            throw new Error("Cannot delete and then update");
          (0, dist.assertTruthy)(mutationB.type === "update", "Invalid mutation type");
          if (mutationA.type === "update")
            return mergeUpdateMutations(mutationA, mutationB);
          const result = lodash.cloneDeep(mutationA);
          for (const [fieldName, propertyMutationsAr] of sortUpdateMutationProperties(mutationB)) {
            const propertyMutations = propertyMutationsAr;
            for (const propertyMutation of propertyMutations) {
              const value = applyPropertyMutation(getInPath(result.properties, fieldName), propertyMutation);
              if (value === void 0) {
                deleteInPath(result.properties, fieldName);
              } else {
                setInPath(result.properties, fieldName, value);
              }
            }
          }
          return result;
        }
        function mergeUpdateMutations(mutationA, mutationB) {
          const result = lodash.cloneDeep(mutationA);
          mutationB = lodash.cloneDeep(mutationB);
          for (const [aPropName] of sortUpdateMutationProperties(result)) {
            const aPropNameDots = aPropName.split(".").length;
            const isOverriddenByMutationB = Object.entries(mutationB.properties).some(([bPropName]) => {
              return aPropName.startsWith(bPropName + ".") && aPropNameDots > bPropName.split(".").length;
            });
            if (isOverriddenByMutationB) {
              delete result.properties[aPropName];
            }
          }
          for (const [bPropName, bPropValues] of sortUpdateMutationProperties(mutationB)) {
            result.properties[bPropName] = [...result.properties[bPropName] || [], ...bPropValues];
          }
          return result;
        }
        function applyUpdateMutation(doc, updateMutation) {
          if (!doc)
            return void 0;
          const result = Object.assign({}, doc);
          const entries = sortUpdateMutationProperties(updateMutation);
          for (const [fieldName, propertyMutationsAr] of entries) {
            const propertyMutations = propertyMutationsAr;
            for (const propertyMutation of propertyMutations) {
              const value = applyPropertyMutation(getInPath(result, fieldName), propertyMutation);
              if (value === void 0) {
                deleteInPath(result, fieldName);
              } else {
                setInPath(result, fieldName, value);
              }
            }
          }
          return result;
        }
        function convertInsertToUpdate(insertMutation) {
          const result = {
            type: "update",
            squidDocIdObj: insertMutation.squidDocIdObj,
            properties: {}
          };
          for (const [key, value] of Object.entries(insertMutation.properties)) {
            result.properties[key] = [{ type: "update", value }];
          }
          return result;
        }
        function reduceMutations(mutations) {
          let result = [];
          (0, external_rxjs_.from)(mutations).pipe((0, external_rxjs_.groupBy)((mutation) => {
            return `${mutation.squidDocIdObj.integrationId}${mutation.squidDocIdObj.collectionName}/${mutation.squidDocIdObj.docId}`;
          }), (0, external_rxjs_.mergeMap)((mutationsGroup) => mutationsGroup.pipe((0, external_rxjs_.reduce)((mutationA, mutationB) => {
            return mergeMutations(mutationA, mutationB);
          }))), (0, external_rxjs_.toArray)()).subscribe((value) => {
            result = value;
          });
          return result;
        }
        ;
        class NativeQueryContext {
          /** @internal */
          constructor(query, params, clientId) {
            this.query = query;
            this.params = params;
            this.clientId = clientId;
          }
        }
        ;
        class Pagination {
          /** @internal */
          constructor(snapshotEmitter, options = {}) {
            this.internalStateObserver = new external_rxjs_.BehaviorSubject(null);
            this.firstElement = null;
            this.isDestroyed = new external_rxjs_.BehaviorSubject(false);
            this.snapshotSubject = new external_rxjs_.Subject();
            this.onFirstPage = true;
            this.navigatingToLastPage = false;
            this.lastElement = null;
            (0, dist.assertTruthy)(snapshotEmitter.getSortOrders().length > 0, "Unable to paginate results. Please specify a sort order.");
            this.snapshotSubject.pipe((0, external_rxjs_.switchAll)()).subscribe((data) => this.dataReceived(data));
            this.templateSnapshotEmitter = snapshotEmitter.clone();
            this.options = Object.assign({ pageSize: 100, subscribe: true }, options);
            this.goToFirstPage();
          }
          goToFirstPage() {
            this.onFirstPage = true;
            const firstPageSnapshot = this.templateSnapshotEmitter.clone().limit(this.options.pageSize * 3).snapshots(this.options.subscribe);
            this.snapshotSubject.next(firstPageSnapshot);
          }
          static compareValues(a, b) {
            if (lodash_default().isNil(a)) {
              return lodash_default().isNil(b) ? 0 : -1;
            }
            if (lodash_default().isNil(b)) {
              return 1;
            }
            if (a > b) {
              return 1;
            } else if (a < b) {
              return -1;
            } else {
              return 0;
            }
          }
          compare(doc1, doc2) {
            if (lodash_default().isNil(doc2)) {
              return 1;
            }
            for (const so of this.templateSnapshotEmitter.getSortOrders()) {
              const currentComparison = Pagination.compareValues(getInPath(doc1, so.fieldName), getInPath(doc2, so.fieldName));
              if (currentComparison !== 0) {
                if (so.asc) {
                  return currentComparison;
                } else {
                  return -currentComparison;
                }
              }
            }
            return 0;
          }
          async dataReceived(data) {
            const extractedData = data.map((s) => this.templateSnapshotEmitter.extractData(s));
            if (data.length === 0) {
              if (this.onFirstPage) {
                this.internalStateObserver.next({ numBefore: 0, numAfter: 0, data, extractedData });
              } else {
                this.goToFirstPage();
              }
              return;
            }
            if (this.firstElement === null) {
              if (this.lastElement !== null) {
                const numAfter2 = extractedData.filter((s) => this.compare(s, this.lastElement) === 1).length;
                this.firstElement = extractedData[data.length - numAfter2 - this.options.pageSize];
                this.lastElement = null;
              } else if (this.navigatingToLastPage) {
                this.firstElement = extractedData[data.length - this.options.pageSize];
                this.navigatingToLastPage = false;
              }
            }
            const numBefore = extractedData.filter((s) => this.compare(s, this.firstElement) === -1).length;
            const numAfter = Math.max(0, data.length - numBefore - this.options.pageSize);
            if (numBefore === data.length) {
              this.prevInternal({ numBefore, numAfter, data, extractedData });
              return;
            }
            this.internalStateObserver.next({ numBefore, numAfter, data, extractedData });
          }
          doNewQuery(startingDoc, reverseOrder) {
            this.onFirstPage = false;
            if (reverseOrder) {
              const newSnapshotEmitter = this.templateSnapshotEmitter.clone().limit(this.options.pageSize * 3).flipSortOrder();
              if (startingDoc) {
                newSnapshotEmitter.addCompositeCondition(this.templateSnapshotEmitter.getSortOrders().map((sortOrder) => {
                  return {
                    fieldName: sortOrder.fieldName,
                    operator: sortOrder.asc ? "<=" : ">=",
                    value: getInPath(startingDoc, sortOrder.fieldName) || null
                  };
                }));
              }
              this.snapshotSubject.next(newSnapshotEmitter.snapshots(this.options.subscribe).pipe((0, external_rxjs_.map)((s) => s.reverse())));
            } else {
              const newSnapshotEmitter = this.templateSnapshotEmitter.clone().limit(this.options.pageSize * 3);
              if (startingDoc) {
                newSnapshotEmitter.addCompositeCondition(this.templateSnapshotEmitter.getSortOrders().map((sortOrder) => {
                  return {
                    fieldName: sortOrder.fieldName,
                    operator: sortOrder.asc ? ">=" : "<=",
                    value: getInPath(startingDoc, sortOrder.fieldName) || null
                  };
                }));
              }
              this.snapshotSubject.next(newSnapshotEmitter.snapshots(this.options.subscribe));
            }
          }
          async waitForInternalState() {
            const internalState = this.internalStateObserver.value;
            if (internalState !== null) {
              return internalState;
            }
            return await (0, external_rxjs_.firstValueFrom)((0, external_rxjs_.race)(
              // It is possible that we get here and unsubscribe() was called. In that case we might not get any new state,
              // so to avoid stalling we return an empty page in that situation. (We can't return the last page we saw
              // because that has already been deleted, and also because it's possible that we've never seen any data.)
              this.isDestroyed.pipe((0, external_rxjs_.filter)(Boolean), (0, external_rxjs_.map)(() => ({
                data: [],
                extractedData: [],
                numBefore: 0,
                numAfter: 0
              }))),
              this.internalStateObserver.pipe((0, external_rxjs_.filter)((state) => state !== null), (0, external_rxjs_.take)(1))
            ));
          }
          internalStateToState(internalState) {
            const { data, numBefore, numAfter, extractedData } = internalState;
            return {
              data: data.filter((_, i2) => this.compare(extractedData[i2], this.firstElement) !== -1).slice(0, this.options.pageSize),
              hasNext: numAfter > 0,
              hasPrev: numBefore > 0
            };
          }
          /** Unsubscribes from the pagination. */
          unsubscribe() {
            this.isDestroyed.next(true);
            this.isDestroyed.complete();
            this.internalStateObserver.complete();
            this.snapshotSubject.complete();
          }
          prevInternal(internalState) {
            const { numBefore, numAfter, extractedData } = internalState;
            this.firstElement = null;
            this.lastElement = extractedData[numBefore - 1];
            this.internalStateObserver.next(null);
            this.doNewQuery(extractedData[extractedData.length - numAfter - 1], true);
          }
          /** Returns a promise that resolves when the previous page of data is available. */
          async prev() {
            this.prevInternal(await this.waitForInternalState());
            return await this.waitForData();
          }
          /** Returns a promise that resolves when the next page of data is available. */
          async next() {
            const { numBefore, extractedData } = await this.waitForInternalState();
            if (numBefore + this.options.pageSize < extractedData.length) {
              this.firstElement = extractedData[numBefore + this.options.pageSize];
            }
            this.internalStateObserver.next(null);
            this.doNewQuery(extractedData[numBefore], false);
            return await this.waitForData();
          }
          /** Returns a promise that resolves when the page data is available. */
          async waitForData() {
            return this.internalStateToState(await this.waitForInternalState());
          }
          /** Returns an observable that emits the current state of the pagination. */
          observeState() {
            return this.internalStateObserver.pipe((0, external_rxjs_.filter)((state) => state !== null), (0, external_rxjs_.map)((state) => {
              return this.internalStateToState(state);
            }));
          }
          /** Jumps to the first page of the pagination. */
          async first() {
            await this.waitForInternalState();
            this.internalStateObserver.next(null);
            this.firstElement = null;
            this.lastElement = null;
            this.goToFirstPage();
            return await this.waitForData();
          }
          /** Refreshes the current page of the pagination. */
          async refreshPage() {
            const { extractedData } = await this.waitForInternalState();
            this.internalStateObserver.next(null);
            this.doNewQuery(extractedData[0], false);
            return await this.waitForData();
          }
          /**
           * Jumps to the last page of the pagination. This page will always have the last <pageSize> elements of the
           * underlying query, regardless of whether the total document count is evenly divisible by the page size.
           */
          async last() {
            await this.waitForInternalState();
            this.internalStateObserver.next(null);
            this.firstElement = null;
            this.lastElement = null;
            this.navigatingToLastPage = true;
            const lastPageSnapshot = this.templateSnapshotEmitter.clone().limit(this.options.pageSize * 3).flipSortOrder().snapshots(this.options.subscribe).pipe((0, external_rxjs_.map)((s) => s.reverse()));
            this.snapshotSubject.next(lastPageSnapshot);
            return await this.waitForData();
          }
        }
        ;
        function isSimpleCondition(condition) {
          return "fieldName" in condition;
        }
        function encodeCondition(condition) {
          return normalizeJsonAsString(condition);
        }
        class QueryMappingManager {
        }
        function compareOperator(conditionValue, valueInDocument, operator) {
          conditionValue = conditionValue instanceof Date ? conditionValue.getTime() : conditionValue !== null && conditionValue !== void 0 ? conditionValue : null;
          valueInDocument = valueInDocument instanceof Date ? valueInDocument.getTime() : valueInDocument !== null && valueInDocument !== void 0 ? valueInDocument : null;
          if (operator === "==") {
            return lodash_default().isEqual(conditionValue, valueInDocument);
          }
          if (operator === "!=") {
            return !lodash_default().isEqual(conditionValue, valueInDocument);
          }
          switch (operator) {
            case "<":
              if (lodash_default().isNil(conditionValue))
                return false;
              if (lodash_default().isNil(valueInDocument))
                return true;
              return valueInDocument < conditionValue;
            case "<=":
              if (lodash_default().isNil(valueInDocument)) {
                return true;
              }
              if (lodash_default().isNil(conditionValue)) {
                return false;
              }
              return valueInDocument <= conditionValue;
            case ">":
              if (lodash_default().isNil(valueInDocument))
                return false;
              if (lodash_default().isNil(conditionValue))
                return true;
              return valueInDocument > conditionValue;
            case ">=":
              if (lodash_default().isNil(conditionValue)) {
                return true;
              }
              if (lodash_default().isNil(valueInDocument)) {
                return false;
              }
              return valueInDocument >= conditionValue;
            case "like":
              return typeof valueInDocument === "string" && typeof conditionValue === "string" && isStringMatch(valueInDocument, conditionValue, false);
            case "not like":
              return !(typeof valueInDocument === "string" && typeof conditionValue === "string" && isStringMatch(valueInDocument, conditionValue, false));
            case "like_cs":
              return typeof valueInDocument === "string" && typeof conditionValue === "string" && isStringMatch(valueInDocument, conditionValue, true);
            case "not like_cs":
              return !(typeof valueInDocument === "string" && typeof conditionValue === "string" && isStringMatch(valueInDocument, conditionValue, true));
            default:
              throw new Error(`Unsupported operator comparison: ${operator}`);
          }
        }
        function isStringMatch(str, pattern, caseSensitive) {
          if (!caseSensitive) {
            str = str.toLowerCase();
            pattern = pattern.toLowerCase();
          }
          const escapedPattern = pattern.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
          const regexPattern = escapedPattern.replace(/%/g, "[\\s\\S]*");
          const regex = new RegExp(`^${regexPattern}$`);
          return regex.test(str);
        }
        function getQuerySubscriptionId(clientId, clientRequestId) {
          return `${clientId}_${clientRequestId}`;
        }
        function parseQuerySubscriptionId(querySubscriptionId) {
          const splitString = querySubscriptionId.split("_");
          return {
            clientId: splitString[0],
            clientRequestId: splitString[1]
          };
        }
        ;
        const CompareTable = {
          "in:in": (a, b) => a.every((c) => b.includes(c)),
          "in:not in": (a, b) => a.every((c) => !b.includes(c)),
          "not in:not in": (a, b) => b.every((c) => a.includes(c)),
          ">:not in": (a, b) => b.every((c) => a >= c),
          ">=:not in": (a, b) => b.every((c) => a > c),
          "<:not in": (a, b) => b.every((c) => a <= c),
          "<=:not in": (a, b) => b.every((c) => a < c),
          ">:>": (a, b) => a >= b,
          ">=:>": (a, b) => a > b,
          "in:>": (a, b) => a.every((c) => c > b),
          ">:>=": (a, b) => a >= b,
          ">=:>=": (a, b) => a >= b,
          "in:>=": (a, b) => a.every((c) => c >= b),
          "<:<": (a, b) => a <= b,
          "<=:<": (a, b) => a < b,
          "in:<": (a, b) => a.every((c) => c < b),
          "<:<=": (a, b) => a <= b,
          "<=:<=": (a, b) => a <= b,
          "in:<=": (a, b) => a.every((c) => c <= b)
        };
        class QueryContext {
          /**
           * @internal
           */
          constructor(query) {
            this.query = query;
            this.query = query;
            this.parsedConditions = this.parseConditions(this.query.conditions.filter(isSimpleCondition));
          }
          /**
           * The ID of the integration being queried.
           */
          get integrationId() {
            return this.query.integrationId;
          }
          /**
           * The name of the collection being queried.
           */
          get collectionName() {
            return this.query.collectionName;
          }
          /**
           * The query limit if one exists, -1 otherwise.
           */
          get limit() {
            return this.query.limit;
          }
          /**
           * Verifies that the query's sort order aligns with the provided field sorts. The fields specified in the `sorts`
           * parameter must appear in the exact order at the beginning of the query's sort sequence. The query can include
           * additional fields in its sort order, but only after the specified sorts.
           *
           * @param sorts An array of field sorts.
           * @returns Whether the query's sorts matches the provided field sorts.
           */
          sortedBy(sorts) {
            const mismatch = sorts.find((fieldSort, index) => {
              var _a2;
              return !(0, lodash.isEqual)(this.query.sortOrder[index], Object.assign(Object.assign({}, fieldSort), { asc: (_a2 = fieldSort.asc) !== null && _a2 !== void 0 ? _a2 : true }));
            });
            return !mismatch;
          }
          /**
           * Verifies that the query's sort order exactly matches the provided field sorts. The fields specified in the
           * `sorts` parameter must appear in the exact order in the query's sort sequence. No additional sorts may be present
           * in the query.
           *
           * @param sorts An array of field sorts.
           * @returns Whether the query's sorts exactly match the provided field sorts.
           */
          sortedByExact(sorts) {
            if (sorts.length !== this.query.sortOrder.length)
              return false;
            return this.sortedBy(sorts);
          }
          // Subquery
          /**
           * Verifies that the query is a subquery of the specified condition. A subquery is defined as a query that evaluates
           * to a subset of the results that would be obtained by applying the parent condition. The subquery may also include
           * additional conditions, as these only narrow the result set.
           *
           * @param fieldName The name of the field for the condition.
           * @param operator The operator of the condition.
           * @param value The value of the condition.
           * @returns Whether the query is a subquery of the parent condition.
           */
          isSubqueryOf(fieldName, operator, value) {
            return this.isSubqueryOfCondition({
              fieldName,
              operator,
              value
            });
          }
          /**
           * Verifies that the query is a subquery of the specified condition. A subquery is defined as a query that evaluates
           * to a subset of the results that would be obtained by applying the parent condition. The subquery may also include
           * additional conditions, as these only narrow the result set.
           *
           * @param condition The condition to validate.
           * @returns Whether the query is a subquery of the parent condition.
           */
          isSubqueryOfCondition(condition) {
            const conditions = this.parsedConditions.filter((c) => c.fieldName === condition.fieldName);
            return !!conditions.find((c) => this.evaluateSubset(c, condition));
          }
          /**
           * Verifies that the query is a subquery of the specified conditions. A subquery is defined as a query that evaluates
           * to a subset of the results that would be obtained by applying the parent conditions. The subquery may also include
           * additional conditions, as these only narrow the result set.
           *
           * @param conditions The conditions to validate.
           * @returns Whether the query includes subquery of the parent conditions.
           */
          isSubqueryOfConditions(conditions) {
            const parsedConditions = this.parseConditions(conditions);
            return parsedConditions.every((c) => this.isSubqueryOfCondition(c));
          }
          /**
           * Verifies that the query is a subquery of the specified query. A subquery is defined as a query that evaluates
           * to a subset of the results that obtained for the parent query, including sorts and limits.
           *
           * @param query The query to validate.
           * @returns Whether the query is a subquery of the parent query.
           */
          isSubqueryOfQuery(query) {
            if (query.collectionName !== this.collectionName || query.integrationId !== this.integrationId)
              return false;
            const simpleConditions = query.conditions.filter(isSimpleCondition);
            const subsetOfConditions = this.isSubqueryOfConditions(simpleConditions);
            const subsetOfOrder = this.sortedBy(query.sortOrder);
            const withinLimit = query.limit === -1 || this.limit > -1 && this.limit < query.limit;
            return subsetOfConditions && subsetOfOrder && withinLimit;
          }
          /**
           * Returns all conditions that apply to any of the specified field names. This method
           * provides a convenient way to retrieve all conditions that involve a specific set of fields.
           *
           * @param fieldNames The field names for which to retrieve conditions.
           * @returns An array of conditions that involve any of the specified field names.
           */
          getConditionsFor(...fieldNames) {
            return this.parsedConditions.filter((cond) => fieldNames.includes(cond.fieldName));
          }
          /**
           * Returns all conditions that apply to the specified field name. This method provides
           * a convenient way to retrieve all conditions that involve a specific field.
           *
           * @param fieldName The field name for which to retrieve conditions.
           * @returns An array of conditions that involve the specified field name.
           */
          getConditionsForField(fieldName) {
            return this.parsedConditions.filter((cond) => cond.fieldName === fieldName);
          }
          /**
           * Returns true if the given document can be a result of the query.
           * The method does not account for limit and sort order.
           */
          documentMatchesQuery(doc) {
            for (const contextCondition of this.parsedConditions) {
              const fieldNameOrPath = contextCondition.fieldName;
              const operator = contextCondition.operator;
              const valueInDoc = lodash.get(doc, fieldNameOrPath);
              if (operator === "in") {
                if (contextCondition.value.includes(valueInDoc)) {
                  continue;
                }
                return false;
              } else if (operator === "not in") {
                if (contextCondition.value.includes(valueInDoc)) {
                  return false;
                }
                continue;
              }
              if (!compareOperator(contextCondition.value, valueInDoc, operator)) {
                return false;
              }
            }
            return true;
          }
          /**
           * Compares a condition against a given operator and value to determine if the
           * provided condition is a subset of the operator and value. A condition is
           * considered a subset if all values that satisfy (return true for) the
           * condition also satisfy the operator and value.
           *
           * This is done using the underlying CompareTable, which provides a comparison
           * function for each operator pair, or undefined if the comparison would
           * always be false, regardless of the values.
           */
          evaluateSubset(queryCondition, testCondition) {
            const { operator: queryOperator, value: queryValue } = queryCondition;
            const { operator, value } = this.parseConditions([testCondition])[0];
            const compareFunction = CompareTable[`${queryOperator}:${operator}`];
            if (!compareFunction)
              return false;
            return compareFunction(queryValue, value);
          }
          evaluateIncludes(queryCondition, testCondition) {
            const { operator: queryOperator, value: queryValue } = queryCondition;
            const { operator, value } = this.parseConditions([testCondition])[0];
            const sortedQueryValue = Array.isArray(queryValue) ? queryValue.sort() : queryValue;
            const sortedValue = Array.isArray(value) ? value.sort() : value;
            return operator === queryOperator && (0, lodash.isEqual)(sortedValue, sortedQueryValue);
          }
          parseConditions(conditions) {
            const parsedConditions = [];
            const inMap = /* @__PURE__ */ new Map();
            const notInMap = /* @__PURE__ */ new Map();
            conditions.forEach((c) => {
              switch (c.operator) {
                case "==":
                case "in":
                  inMap.set(c.fieldName, (inMap.get(c.fieldName) || []).concat(c.value));
                  break;
                case "!=":
                case "not in":
                  notInMap.set(c.fieldName, (notInMap.get(c.fieldName) || []).concat(c.value));
                  break;
                default:
                  parsedConditions.push(c);
                  break;
              }
            });
            inMap.forEach((value, fieldName) => {
              parsedConditions.push({
                fieldName,
                operator: "in",
                value
              });
            });
            notInMap.forEach((value, fieldName) => {
              parsedConditions.push({
                fieldName,
                operator: "not in",
                value
              });
            });
            return parsedConditions;
          }
        }
        ;
        const SQUID_CLOUD_IDS = ["aws", "gcp", "azure"];
        const SupportedSquidRegions = ["us-east-1.aws"];
        const squidSupportedRegionMap = {
          "us-east-1.aws": { id: "us-east-1", name: "US East (N. Virginia)" },
          ["us-east-1.aws-dev"]: { id: "us-east-1", name: "US East (N. Virginia - Dev)" },
          ["local"]: { id: "local", name: "Local" }
        };
        function getSquidSupportedCloudMap() {
          return {
            aws: {
              id: "aws",
              name: "Amazon Web Services",
              icon: "aws_icon",
              regions: [squidSupportedRegionMap["us-east-1.aws"]].filter(dist.isNonNullable)
            },
            gcp: {
              id: "gcp",
              name: "Google Cloud Platform",
              icon: "gcp_icon",
              tooltip: "Google Cloud (GCP) support is coming soon!",
              regions: []
            },
            azure: {
              id: "azure",
              name: "Microsoft Azure",
              icon: "azure_icon",
              tooltip: "Microsoft Azure support is coming soon!",
              regions: []
            }
          };
        }
        function convertToSquidRegion(cloudId, region) {
          if (region === "local")
            return "local";
          return `${region}.${cloudId}`;
        }
        function convertFromSquidRegion(regionAndCloud) {
          const splitRegion = regionAndCloud.split(".");
          return { cloudId: splitRegion[1], region: splitRegion[0] };
        }
        ;
        var ClientConnectionState;
        (function(ClientConnectionState2) {
          ClientConnectionState2["CONNECTED"] = "CONNECTED";
          ClientConnectionState2["DISCONNECTED"] = "DISCONNECTED";
          ClientConnectionState2["REMOVED"] = "REMOVED";
        })(ClientConnectionState || (ClientConnectionState = {}));
        ;
        ;
        function generateId() {
          let dt = (/* @__PURE__ */ new Date()).getTime();
          return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
            const r = (dt + Math.random() * 16) % 16 | 0;
            dt = Math.floor(dt / 16);
            return (c === "x" ? r : r & 3 | 8).toString(16);
          });
        }
        const DEFAULT_SHORT_ID_LENGTH = 18;
        function generateShortId(length = DEFAULT_SHORT_ID_LENGTH) {
          const characters = "abcdefghijklmnopqrstuvwxyz0123456789";
          let id = "";
          for (let i2 = 0; i2 < length; i2++) {
            id += characters.charAt(Math.floor(Math.random() * characters.length));
          }
          return id;
        }
        ;
        ;
        function isFunction(value) {
          return typeof value === "function";
        }
        ;
        function hasLift(source) {
          return isFunction(source === null || source === void 0 ? void 0 : source.lift);
        }
        function operate(init) {
          return function(source) {
            if (hasLift(source)) {
              return source.lift(function(liftedSource) {
                try {
                  return init(liftedSource, this);
                } catch (err) {
                  this.error(err);
                }
              });
            }
            throw new TypeError("Unable to lift unknown Observable type");
          };
        }
        ;
        var extendStatics = function(d, b) {
          extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
            d2.__proto__ = b2;
          } || function(d2, b2) {
            for (var p in b2)
              if (Object.prototype.hasOwnProperty.call(b2, p))
                d2[p] = b2[p];
          };
          return extendStatics(d, b);
        };
        function __extends(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __2() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__2.prototype = b.prototype, new __2());
        }
        var tslib_es6_assign = function() {
          tslib_es6_assign = Object.assign || function __assign2(t) {
            for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
              s = arguments[i2];
              for (var p in s)
                if (Object.prototype.hasOwnProperty.call(s, p))
                  t[p] = s[p];
            }
            return t;
          };
          return tslib_es6_assign.apply(this, arguments);
        };
        function __rest(s, e) {
          var t = {};
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
              t[p] = s[p];
          if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i2 = 0, p = Object.getOwnPropertySymbols(s); i2 < p.length; i2++) {
              if (e.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i2]))
                t[p[i2]] = s[p[i2]];
            }
          return t;
        }
        function __decorate(decorators, target, key, desc) {
          var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
          if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
          else
            for (var i2 = decorators.length - 1; i2 >= 0; i2--)
              if (d = decorators[i2])
                r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
          return c > 3 && r && Object.defineProperty(target, key, r), r;
        }
        function __param(paramIndex, decorator) {
          return function(target, key) {
            decorator(target, key, paramIndex);
          };
        }
        function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
          function accept(f) {
            if (f !== void 0 && typeof f !== "function")
              throw new TypeError("Function expected");
            return f;
          }
          var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
          var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
          var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
          var _, done = false;
          for (var i2 = decorators.length - 1; i2 >= 0; i2--) {
            var context2 = {};
            for (var p in contextIn)
              context2[p] = p === "access" ? {} : contextIn[p];
            for (var p in contextIn.access)
              context2.access[p] = contextIn.access[p];
            context2.addInitializer = function(f) {
              if (done)
                throw new TypeError("Cannot add initializers after decoration has completed");
              extraInitializers.push(accept(f || null));
            };
            var result = (0, decorators[i2])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context2);
            if (kind === "accessor") {
              if (result === void 0)
                continue;
              if (result === null || typeof result !== "object")
                throw new TypeError("Object expected");
              if (_ = accept(result.get))
                descriptor.get = _;
              if (_ = accept(result.set))
                descriptor.set = _;
              if (_ = accept(result.init))
                initializers.unshift(_);
            } else if (_ = accept(result)) {
              if (kind === "field")
                initializers.unshift(_);
              else
                descriptor[key] = _;
            }
          }
          if (target)
            Object.defineProperty(target, contextIn.name, descriptor);
          done = true;
        }
        ;
        function __runInitializers(thisArg, initializers, value) {
          var useValue = arguments.length > 2;
          for (var i2 = 0; i2 < initializers.length; i2++) {
            value = useValue ? initializers[i2].call(thisArg, value) : initializers[i2].call(thisArg);
          }
          return useValue ? value : void 0;
        }
        ;
        function __propKey(x) {
          return typeof x === "symbol" ? x : "".concat(x);
        }
        ;
        function __setFunctionName(f, name, prefix) {
          if (typeof name === "symbol")
            name = name.description ? "[".concat(name.description, "]") : "";
          return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
        }
        ;
        function __metadata(metadataKey, metadataValue) {
          if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
        }
        function __awaiter(thisArg, _arguments, P, generator) {
          function adopt(value) {
            return value instanceof P ? value : new P(function(resolve) {
              resolve(value);
            });
          }
          return new (P || (P = Promise))(function(resolve, reject) {
            function fulfilled(value) {
              try {
                step(generator.next(value));
              } catch (e) {
                reject(e);
              }
            }
            function rejected(value) {
              try {
                step(generator["throw"](value));
              } catch (e) {
                reject(e);
              }
            }
            function step(result) {
              result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
          });
        }
        function __generator(thisArg, body) {
          var _ = { label: 0, sent: function() {
            if (t[0] & 1)
              throw t[1];
            return t[1];
          }, trys: [], ops: [] }, f, y, t, g;
          return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
            return this;
          }), g;
          function verb(n) {
            return function(v) {
              return step([n, v]);
            };
          }
          function step(op) {
            if (f)
              throw new TypeError("Generator is already executing.");
            while (g && (g = 0, op[0] && (_ = 0)), _)
              try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                  return t;
                if (y = 0, t)
                  op = [op[0] & 2, t.value];
                switch (op[0]) {
                  case 0:
                  case 1:
                    t = op;
                    break;
                  case 4:
                    _.label++;
                    return { value: op[1], done: false };
                  case 5:
                    _.label++;
                    y = op[1];
                    op = [0];
                    continue;
                  case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                  default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                      _ = 0;
                      continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                      _.label = op[1];
                      break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                      _.label = t[1];
                      t = op;
                      break;
                    }
                    if (t && _.label < t[2]) {
                      _.label = t[2];
                      _.ops.push(op);
                      break;
                    }
                    if (t[2])
                      _.ops.pop();
                    _.trys.pop();
                    continue;
                }
                op = body.call(thisArg, _);
              } catch (e) {
                op = [6, e];
                y = 0;
              } finally {
                f = t = 0;
              }
            if (op[0] & 5)
              throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
          }
        }
        var __createBinding = Object.create ? function(o, m, k, k2) {
          if (k2 === void 0)
            k2 = k;
          var desc = Object.getOwnPropertyDescriptor(m, k);
          if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
            desc = { enumerable: true, get: function() {
              return m[k];
            } };
          }
          Object.defineProperty(o, k2, desc);
        } : function(o, m, k, k2) {
          if (k2 === void 0)
            k2 = k;
          o[k2] = m[k];
        };
        function __exportStar(m, o) {
          for (var p in m)
            if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
              __createBinding(o, m, p);
        }
        function __values(o) {
          var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i2 = 0;
          if (m)
            return m.call(o);
          if (o && typeof o.length === "number")
            return {
              next: function() {
                if (o && i2 >= o.length)
                  o = void 0;
                return { value: o && o[i2++], done: !o };
              }
            };
          throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
        }
        function __read(o, n) {
          var m = typeof Symbol === "function" && o[Symbol.iterator];
          if (!m)
            return o;
          var i2 = m.call(o), r, ar = [], e;
          try {
            while ((n === void 0 || n-- > 0) && !(r = i2.next()).done)
              ar.push(r.value);
          } catch (error) {
            e = { error };
          } finally {
            try {
              if (r && !r.done && (m = i2["return"]))
                m.call(i2);
            } finally {
              if (e)
                throw e.error;
            }
          }
          return ar;
        }
        function __spread() {
          for (var ar = [], i2 = 0; i2 < arguments.length; i2++)
            ar = ar.concat(__read(arguments[i2]));
          return ar;
        }
        function __spreadArrays() {
          for (var s = 0, i2 = 0, il = arguments.length; i2 < il; i2++)
            s += arguments[i2].length;
          for (var r = Array(s), k = 0, i2 = 0; i2 < il; i2++)
            for (var a = arguments[i2], j = 0, jl = a.length; j < jl; j++, k++)
              r[k] = a[j];
          return r;
        }
        function tslib_es6_spreadArray(to, from, pack) {
          if (pack || arguments.length === 2)
            for (var i2 = 0, l = from.length, ar; i2 < l; i2++) {
              if (ar || !(i2 in from)) {
                if (!ar)
                  ar = Array.prototype.slice.call(from, 0, i2);
                ar[i2] = from[i2];
              }
            }
          return to.concat(ar || Array.prototype.slice.call(from));
        }
        function __await(v) {
          return this instanceof __await ? (this.v = v, this) : new __await(v);
        }
        function __asyncGenerator(thisArg, _arguments, generator) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var g = generator.apply(thisArg, _arguments || []), i2, q = [];
          return i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
            return this;
          }, i2;
          function verb(n) {
            if (g[n])
              i2[n] = function(v) {
                return new Promise(function(a, b) {
                  q.push([n, v, a, b]) > 1 || resume(n, v);
                });
              };
          }
          function resume(n, v) {
            try {
              step(g[n](v));
            } catch (e) {
              settle(q[0][3], e);
            }
          }
          function step(r) {
            r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
          }
          function fulfill(value) {
            resume("next", value);
          }
          function reject(value) {
            resume("throw", value);
          }
          function settle(f, v) {
            if (f(v), q.shift(), q.length)
              resume(q[0][0], q[0][1]);
          }
        }
        function __asyncDelegator(o) {
          var i2, p;
          return i2 = {}, verb("next"), verb("throw", function(e) {
            throw e;
          }), verb("return"), i2[Symbol.iterator] = function() {
            return this;
          }, i2;
          function verb(n, f) {
            i2[n] = o[n] ? function(v) {
              return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v;
            } : f;
          }
        }
        function __asyncValues(o) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var m = o[Symbol.asyncIterator], i2;
          return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
            return this;
          }, i2);
          function verb(n) {
            i2[n] = o[n] && function(v) {
              return new Promise(function(resolve, reject) {
                v = o[n](v), settle(resolve, reject, v.done, v.value);
              });
            };
          }
          function settle(resolve, reject, d, v) {
            Promise.resolve(v).then(function(v2) {
              resolve({ value: v2, done: d });
            }, reject);
          }
        }
        function __makeTemplateObject(cooked, raw) {
          if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
          } else {
            cooked.raw = raw;
          }
          return cooked;
        }
        ;
        var __setModuleDefault = Object.create ? function(o, v) {
          Object.defineProperty(o, "default", { enumerable: true, value: v });
        } : function(o, v) {
          o["default"] = v;
        };
        function __importStar(mod) {
          if (mod && mod.__esModule)
            return mod;
          var result = {};
          if (mod != null) {
            for (var k in mod)
              if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
                __createBinding(result, mod, k);
          }
          __setModuleDefault(result, mod);
          return result;
        }
        function __importDefault(mod) {
          return mod && mod.__esModule ? mod : { default: mod };
        }
        function __classPrivateFieldGet(receiver, state, kind, f) {
          if (kind === "a" && !f)
            throw new TypeError("Private accessor was defined without a getter");
          if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
            throw new TypeError("Cannot read private member from an object whose class did not declare it");
          return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
        }
        function __classPrivateFieldSet(receiver, state, value, kind, f) {
          if (kind === "m")
            throw new TypeError("Private method is not writable");
          if (kind === "a" && !f)
            throw new TypeError("Private accessor was defined without a setter");
          if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
            throw new TypeError("Cannot write private member to an object whose class did not declare it");
          return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
        }
        function __classPrivateFieldIn(state, receiver) {
          if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function")
            throw new TypeError("Cannot use 'in' operator on non-object");
          return typeof state === "function" ? receiver === state : state.has(receiver);
        }
        function __addDisposableResource(env, value, async) {
          if (value !== null && value !== void 0) {
            if (typeof value !== "object" && typeof value !== "function")
              throw new TypeError("Object expected.");
            var dispose;
            if (async) {
              if (!Symbol.asyncDispose)
                throw new TypeError("Symbol.asyncDispose is not defined.");
              dispose = value[Symbol.asyncDispose];
            }
            if (dispose === void 0) {
              if (!Symbol.dispose)
                throw new TypeError("Symbol.dispose is not defined.");
              dispose = value[Symbol.dispose];
            }
            if (typeof dispose !== "function")
              throw new TypeError("Object not disposable.");
            env.stack.push({ value, dispose, async });
          } else if (async) {
            env.stack.push({ async: true });
          }
          return value;
        }
        var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
          var e = new Error(message);
          return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
        };
        function __disposeResources(env) {
          function fail(e) {
            env.error = env.hasError ? new _SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
            env.hasError = true;
          }
          function next() {
            while (env.stack.length) {
              var rec = env.stack.pop();
              try {
                var result = rec.dispose && rec.dispose.call(rec.value);
                if (rec.async)
                  return Promise.resolve(result).then(next, function(e) {
                    fail(e);
                    return next();
                  });
              } catch (e) {
                fail(e);
              }
            }
            if (env.hasError)
              throw env.error;
          }
          return next();
        }
        const tslib_es6 = {
          __extends,
          __assign: tslib_es6_assign,
          __rest,
          __decorate,
          __param,
          __metadata,
          __awaiter,
          __generator,
          __createBinding,
          __exportStar,
          __values,
          __read,
          __spread,
          __spreadArrays,
          __spreadArray: tslib_es6_spreadArray,
          __await,
          __asyncGenerator,
          __asyncDelegator,
          __asyncValues,
          __makeTemplateObject,
          __importStar,
          __importDefault,
          __classPrivateFieldGet,
          __classPrivateFieldSet,
          __classPrivateFieldIn,
          __addDisposableResource,
          __disposeResources
        };
        ;
        function createErrorClass(createImpl) {
          var _super = function(instance) {
            Error.call(instance);
            instance.stack = new Error().stack;
          };
          var ctorFunc = createImpl(_super);
          ctorFunc.prototype = Object.create(Error.prototype);
          ctorFunc.prototype.constructor = ctorFunc;
          return ctorFunc;
        }
        ;
        var UnsubscriptionError = createErrorClass(function(_super) {
          return function UnsubscriptionErrorImpl(errors) {
            _super(this);
            this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function(err, i2) {
              return i2 + 1 + ") " + err.toString();
            }).join("\n  ") : "";
            this.name = "UnsubscriptionError";
            this.errors = errors;
          };
        });
        ;
        function arrRemove(arr, item) {
          if (arr) {
            var index = arr.indexOf(item);
            0 <= index && arr.splice(index, 1);
          }
        }
        ;
        var Subscription = function() {
          function Subscription2(initialTeardown) {
            this.initialTeardown = initialTeardown;
            this.closed = false;
            this._parentage = null;
            this._finalizers = null;
          }
          Subscription2.prototype.unsubscribe = function() {
            var e_1, _a2, e_2, _b;
            var errors;
            if (!this.closed) {
              this.closed = true;
              var _parentage = this._parentage;
              if (_parentage) {
                this._parentage = null;
                if (Array.isArray(_parentage)) {
                  try {
                    for (var _parentage_1 = __values(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {
                      var parent_1 = _parentage_1_1.value;
                      parent_1.remove(this);
                    }
                  } catch (e_1_1) {
                    e_1 = { error: e_1_1 };
                  } finally {
                    try {
                      if (_parentage_1_1 && !_parentage_1_1.done && (_a2 = _parentage_1.return))
                        _a2.call(_parentage_1);
                    } finally {
                      if (e_1)
                        throw e_1.error;
                    }
                  }
                } else {
                  _parentage.remove(this);
                }
              }
              var initialFinalizer = this.initialTeardown;
              if (isFunction(initialFinalizer)) {
                try {
                  initialFinalizer();
                } catch (e) {
                  errors = e instanceof UnsubscriptionError ? e.errors : [e];
                }
              }
              var _finalizers = this._finalizers;
              if (_finalizers) {
                this._finalizers = null;
                try {
                  for (var _finalizers_1 = __values(_finalizers), _finalizers_1_1 = _finalizers_1.next(); !_finalizers_1_1.done; _finalizers_1_1 = _finalizers_1.next()) {
                    var finalizer = _finalizers_1_1.value;
                    try {
                      execFinalizer(finalizer);
                    } catch (err) {
                      errors = errors !== null && errors !== void 0 ? errors : [];
                      if (err instanceof UnsubscriptionError) {
                        errors = tslib_es6_spreadArray(tslib_es6_spreadArray([], __read(errors)), __read(err.errors));
                      } else {
                        errors.push(err);
                      }
                    }
                  }
                } catch (e_2_1) {
                  e_2 = { error: e_2_1 };
                } finally {
                  try {
                    if (_finalizers_1_1 && !_finalizers_1_1.done && (_b = _finalizers_1.return))
                      _b.call(_finalizers_1);
                  } finally {
                    if (e_2)
                      throw e_2.error;
                  }
                }
              }
              if (errors) {
                throw new UnsubscriptionError(errors);
              }
            }
          };
          Subscription2.prototype.add = function(teardown) {
            var _a2;
            if (teardown && teardown !== this) {
              if (this.closed) {
                execFinalizer(teardown);
              } else {
                if (teardown instanceof Subscription2) {
                  if (teardown.closed || teardown._hasParent(this)) {
                    return;
                  }
                  teardown._addParent(this);
                }
                (this._finalizers = (_a2 = this._finalizers) !== null && _a2 !== void 0 ? _a2 : []).push(teardown);
              }
            }
          };
          Subscription2.prototype._hasParent = function(parent) {
            var _parentage = this._parentage;
            return _parentage === parent || Array.isArray(_parentage) && _parentage.includes(parent);
          };
          Subscription2.prototype._addParent = function(parent) {
            var _parentage = this._parentage;
            this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
          };
          Subscription2.prototype._removeParent = function(parent) {
            var _parentage = this._parentage;
            if (_parentage === parent) {
              this._parentage = null;
            } else if (Array.isArray(_parentage)) {
              arrRemove(_parentage, parent);
            }
          };
          Subscription2.prototype.remove = function(teardown) {
            var _finalizers = this._finalizers;
            _finalizers && arrRemove(_finalizers, teardown);
            if (teardown instanceof Subscription2) {
              teardown._removeParent(this);
            }
          };
          Subscription2.EMPTY = function() {
            var empty = new Subscription2();
            empty.closed = true;
            return empty;
          }();
          return Subscription2;
        }();
        var EMPTY_SUBSCRIPTION = Subscription.EMPTY;
        function isSubscription(value) {
          return value instanceof Subscription || value && "closed" in value && isFunction(value.remove) && isFunction(value.add) && isFunction(value.unsubscribe);
        }
        function execFinalizer(finalizer) {
          if (isFunction(finalizer)) {
            finalizer();
          } else {
            finalizer.unsubscribe();
          }
        }
        ;
        var config_config = {
          onUnhandledError: null,
          onStoppedNotification: null,
          Promise: void 0,
          useDeprecatedSynchronousErrorHandling: false,
          useDeprecatedNextContext: false
        };
        ;
        var timeoutProvider = {
          setTimeout: function(handler, timeout) {
            var args = [];
            for (var _i = 2; _i < arguments.length; _i++) {
              args[_i - 2] = arguments[_i];
            }
            var delegate = timeoutProvider.delegate;
            if (delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) {
              return delegate.setTimeout.apply(delegate, tslib_es6_spreadArray([handler, timeout], __read(args)));
            }
            return setTimeout.apply(void 0, tslib_es6_spreadArray([handler, timeout], __read(args)));
          },
          clearTimeout: function(handle) {
            var delegate = timeoutProvider.delegate;
            return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);
          },
          delegate: void 0
        };
        ;
        function reportUnhandledError(err) {
          timeoutProvider.setTimeout(function() {
            var onUnhandledError = config_config.onUnhandledError;
            if (onUnhandledError) {
              onUnhandledError(err);
            } else {
              throw err;
            }
          });
        }
        ;
        function noop() {
        }
        ;
        var COMPLETE_NOTIFICATION = function() {
          return createNotification("C", void 0, void 0);
        }();
        function errorNotification(error) {
          return createNotification("E", void 0, error);
        }
        function nextNotification(value) {
          return createNotification("N", value, void 0);
        }
        function createNotification(kind, value, error) {
          return {
            kind,
            value,
            error
          };
        }
        ;
        var context = null;
        function errorContext(cb) {
          if (config.useDeprecatedSynchronousErrorHandling) {
            var isRoot = !context;
            if (isRoot) {
              context = { errorThrown: false, error: null };
            }
            cb();
            if (isRoot) {
              var _a2 = context, errorThrown = _a2.errorThrown, error = _a2.error;
              context = null;
              if (errorThrown) {
                throw error;
              }
            }
          } else {
            cb();
          }
        }
        function captureError(err) {
          if (config_config.useDeprecatedSynchronousErrorHandling && context) {
            context.errorThrown = true;
            context.error = err;
          }
        }
        ;
        var Subscriber = function(_super) {
          __extends(Subscriber2, _super);
          function Subscriber2(destination) {
            var _this = _super.call(this) || this;
            _this.isStopped = false;
            if (destination) {
              _this.destination = destination;
              if (isSubscription(destination)) {
                destination.add(_this);
              }
            } else {
              _this.destination = EMPTY_OBSERVER;
            }
            return _this;
          }
          Subscriber2.create = function(next, error, complete) {
            return new SafeSubscriber(next, error, complete);
          };
          Subscriber2.prototype.next = function(value) {
            if (this.isStopped) {
              handleStoppedNotification(nextNotification(value), this);
            } else {
              this._next(value);
            }
          };
          Subscriber2.prototype.error = function(err) {
            if (this.isStopped) {
              handleStoppedNotification(errorNotification(err), this);
            } else {
              this.isStopped = true;
              this._error(err);
            }
          };
          Subscriber2.prototype.complete = function() {
            if (this.isStopped) {
              handleStoppedNotification(COMPLETE_NOTIFICATION, this);
            } else {
              this.isStopped = true;
              this._complete();
            }
          };
          Subscriber2.prototype.unsubscribe = function() {
            if (!this.closed) {
              this.isStopped = true;
              _super.prototype.unsubscribe.call(this);
              this.destination = null;
            }
          };
          Subscriber2.prototype._next = function(value) {
            this.destination.next(value);
          };
          Subscriber2.prototype._error = function(err) {
            try {
              this.destination.error(err);
            } finally {
              this.unsubscribe();
            }
          };
          Subscriber2.prototype._complete = function() {
            try {
              this.destination.complete();
            } finally {
              this.unsubscribe();
            }
          };
          return Subscriber2;
        }(Subscription);
        var _bind = Function.prototype.bind;
        function bind(fn, thisArg) {
          return _bind.call(fn, thisArg);
        }
        var ConsumerObserver = function() {
          function ConsumerObserver2(partialObserver) {
            this.partialObserver = partialObserver;
          }
          ConsumerObserver2.prototype.next = function(value) {
            var partialObserver = this.partialObserver;
            if (partialObserver.next) {
              try {
                partialObserver.next(value);
              } catch (error) {
                handleUnhandledError(error);
              }
            }
          };
          ConsumerObserver2.prototype.error = function(err) {
            var partialObserver = this.partialObserver;
            if (partialObserver.error) {
              try {
                partialObserver.error(err);
              } catch (error) {
                handleUnhandledError(error);
              }
            } else {
              handleUnhandledError(err);
            }
          };
          ConsumerObserver2.prototype.complete = function() {
            var partialObserver = this.partialObserver;
            if (partialObserver.complete) {
              try {
                partialObserver.complete();
              } catch (error) {
                handleUnhandledError(error);
              }
            }
          };
          return ConsumerObserver2;
        }();
        var SafeSubscriber = function(_super) {
          __extends(SafeSubscriber2, _super);
          function SafeSubscriber2(observerOrNext, error, complete) {
            var _this = _super.call(this) || this;
            var partialObserver;
            if (isFunction(observerOrNext) || !observerOrNext) {
              partialObserver = {
                next: observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : void 0,
                error: error !== null && error !== void 0 ? error : void 0,
                complete: complete !== null && complete !== void 0 ? complete : void 0
              };
            } else {
              var context_1;
              if (_this && config_config.useDeprecatedNextContext) {
                context_1 = Object.create(observerOrNext);
                context_1.unsubscribe = function() {
                  return _this.unsubscribe();
                };
                partialObserver = {
                  next: observerOrNext.next && bind(observerOrNext.next, context_1),
                  error: observerOrNext.error && bind(observerOrNext.error, context_1),
                  complete: observerOrNext.complete && bind(observerOrNext.complete, context_1)
                };
              } else {
                partialObserver = observerOrNext;
              }
            }
            _this.destination = new ConsumerObserver(partialObserver);
            return _this;
          }
          return SafeSubscriber2;
        }(Subscriber);
        function handleUnhandledError(error) {
          if (config_config.useDeprecatedSynchronousErrorHandling) {
            captureError(error);
          } else {
            reportUnhandledError(error);
          }
        }
        function defaultErrorHandler(err) {
          throw err;
        }
        function handleStoppedNotification(notification, subscriber) {
          var onStoppedNotification = config_config.onStoppedNotification;
          onStoppedNotification && timeoutProvider.setTimeout(function() {
            return onStoppedNotification(notification, subscriber);
          });
        }
        var EMPTY_OBSERVER = {
          closed: true,
          next: noop,
          error: defaultErrorHandler,
          complete: noop
        };
        ;
        function createOperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {
          return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);
        }
        var OperatorSubscriber = function(_super) {
          __extends(OperatorSubscriber2, _super);
          function OperatorSubscriber2(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {
            var _this = _super.call(this, destination) || this;
            _this.onFinalize = onFinalize;
            _this.shouldUnsubscribe = shouldUnsubscribe;
            _this._next = onNext ? function(value) {
              try {
                onNext(value);
              } catch (err) {
                destination.error(err);
              }
            } : _super.prototype._next;
            _this._error = onError ? function(err) {
              try {
                onError(err);
              } catch (err2) {
                destination.error(err2);
              } finally {
                this.unsubscribe();
              }
            } : _super.prototype._error;
            _this._complete = onComplete ? function() {
              try {
                onComplete();
              } catch (err) {
                destination.error(err);
              } finally {
                this.unsubscribe();
              }
            } : _super.prototype._complete;
            return _this;
          }
          OperatorSubscriber2.prototype.unsubscribe = function() {
            var _a2;
            if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
              var closed_1 = this.closed;
              _super.prototype.unsubscribe.call(this);
              !closed_1 && ((_a2 = this.onFinalize) === null || _a2 === void 0 ? void 0 : _a2.call(this));
            }
          };
          return OperatorSubscriber2;
        }(Subscriber);
        ;
        function map(project, thisArg) {
          return operate(function(source, subscriber) {
            var index = 0;
            source.subscribe(createOperatorSubscriber(subscriber, function(value) {
              subscriber.next(project.call(thisArg, value, index++));
            }));
          });
        }
        ;
        class AiChatbotClient {
          constructor(rpcManager, socketManager, integrationId) {
            this.rpcManager = rpcManager;
            this.socketManager = socketManager;
            this.integrationId = integrationId;
            this.ongoingChatSequences = {};
            this.socketManager.observeNotifications().pipe((0, external_rxjs_.filter)((notification) => notification.type === "aiChatbot"), map((n) => n)).subscribe((notification) => {
              this.handleChatResponse(notification).then();
            });
          }
          /**
           * Retrieves a profile reference for the provided id. A profile reference
           * can be used to create and update profiles, add instructions and context
           * and start chats.
           *
           * @param id - The id of the profile.
           * @returns The profile reference.
           */
          profile(id) {
            return new AiChatbotProfileReference(this, this.integrationId, id);
          }
          /** @internal */
          async mutate(request, file) {
            await this.rpcManager.post("ai/chatbot/mutate", request, file ? [file] : []);
          }
          /**
           * Sends a prompt to the specified profile id.
           *
           * @param profileId - The profile id.
           * @param prompt - The prompt.
           * @param options - The options to send to the chat model.
           * @returns An observable that emits when a new response token is received. The emitted value is the entire response
           * that has been received so far.
           */
          chat(profileId, prompt, options) {
            const clientRequestId = generateId();
            let accumulatedValue = "";
            const subject = new external_rxjs_.Subject();
            const tokenSequence = new external_rxjs_.Subject();
            this.ongoingChatSequences[clientRequestId] = tokenSequence;
            tokenSequence.pipe((0, external_rxjs_.concatMap)(({ value, complete }) => {
              if (complete) {
                return (0, external_rxjs_.of)({ value, complete });
              }
              return (0, external_rxjs_.of)(value).pipe((0, external_rxjs_.delay)(5), map((char) => ({ value: char, complete: false })));
            }), (0, external_rxjs_.takeWhile)(({ complete }) => !complete, true)).subscribe({
              next: ({ value }) => {
                accumulatedValue += value;
                subject.next(accumulatedValue);
              },
              error: (e) => {
                console.error(e);
              },
              complete: () => {
                subject.complete();
              }
            });
            const request = {
              profileId,
              prompt,
              options,
              integrationId: this.integrationId,
              clientRequestId
            };
            this.rpcManager.post("ai/chatbot/chat", request).catch((e) => {
              subject.error(e);
              subject.complete();
            });
            return subject.pipe((0, external_rxjs_.finalize)(() => {
              delete this.ongoingChatSequences[clientRequestId];
            }), (0, external_rxjs_.share)());
          }
          async handleChatResponse(message) {
            const tokenSequence = this.ongoingChatSequences[message.clientRequestId];
            if (!tokenSequence) {
              return;
            }
            const { token, complete } = message.payload;
            if (complete && !token.length) {
              tokenSequence.next({ value: "", complete: true });
            } else {
              for (let i2 = 0; i2 < token.length; i2++) {
                tokenSequence.next({ value: token[i2], complete: complete && i2 === token.length - 1 });
              }
            }
          }
        }
        class AiChatbotProfileReference {
          constructor(client, integrationId, profileId) {
            this.client = client;
            this.integrationId = integrationId;
            this.profileId = profileId;
          }
          /**
           * Sends a prompt to the current profile.
           *
           * @param prompt - The prompt.
           * @param options - The chat options.
           * @returns An observable that emits when a new response token is received. The emitted value is the entire response
           * that has been received so far.
           */
          chat(prompt, options) {
            return this.client.chat(this.profileId, prompt, options);
          }
          /**
           * Retrieves a context reference for the current profile. A context reference can be used to add a new context entry
           * to the profile, or update/delete an existing entry context.
           *
           * @param id - The id of the context entry. If no id is passed, an id will be
           * generated and the reference will point to a new context entry.
           * @returns The context reference.
           */
          context(id) {
            return new AiChatbotContextReference(this.client, this.integrationId, this.profileId, id);
          }
          /**
           * Retrieves an instruction reference for the current profile. An instruction reference can be used to add a new
           * instruction entry to the profile, or update/delete an existing instruction entry.
           *
           * @param id - The id of the instruction entry. If no id is passed, an id will be
           * generated and the reference will point to a new instruction entry.
           * @returns The instruction reference.
           */
          instruction(id) {
            return new AiChatbotInstructionReference(this.client, this.integrationId, this.profileId, id);
          }
          /**
           * Adds a new profile to the chatbot. This will result in an error if a profile already exists with the same id.
           *
           * @param data An object containing options for creating the profile.
           * @param data.modelName - The name of the OpenAI model (`gpt-3.5, `gpt-4` or `claude-2`).
           * @param data.isPublic - Whether the chat functionality of the profile can be accessed without security rules.
           * @returns A promise that resolves when the profile is successfully created.
           */
          insert(data) {
            const { modelName, isPublic = false } = data;
            const request = {
              type: "insert",
              resource: "profile",
              profileId: this.profileId,
              payload: {
                modelName,
                isPublic,
                strictContext: false
              },
              integrationId: this.integrationId
            };
            return this.client.mutate(request);
          }
          /**
           * Updates an existing chatbot profile. This will result in an error if a profile has not yet been created for the
           * current profile id.
           *
           * @param data An object containing options for updating the profile.
           * @param data.modelName - The name of the OpenAI model (`gpt-3.5, `gpt-4` or `claude-2`).
           * @param data.isPublic - Whether the chat functionality of the profile can be accessed without security rules.
           * @returns A promise that resolves when the profile is successfully updated.
           */
          update(data) {
            const { modelName, isPublic } = data;
            const request = {
              type: "update",
              resource: "profile",
              profileId: this.profileId,
              payload: {
                modelName,
                isPublic,
                strictContext: false
              },
              integrationId: this.integrationId
            };
            return this.client.mutate(request);
          }
          /**
           * Deletes an existing chatbot profile. This will result in an error if a profile has not yet been created for the
           * current profile id.
           *
           * @returns A promise that resolves when the profile is successfully deleted.
           */
          delete() {
            const request = {
              type: "delete",
              resource: "profile",
              profileId: this.profileId,
              integrationId: this.integrationId,
              payload: {}
            };
            return this.client.mutate(request);
          }
        }
        class AiChatbotContextReference {
          constructor(client, integrationId, profileId, id) {
            this.client = client;
            this.integrationId = integrationId;
            this.profileId = profileId;
            this.id = id || generateId();
          }
          /**
           * Adds a new context entry to the chatbot profile. This will result in an error if an entry already exists with
           * the same id.
           *
           * @param data An object containing options for creating the entry.
           * @param data.title - The title of the entry.
           * @param data.context - The context data.
           * @param file - The file to insert.
           * @returns A promise that resolves when the context is successfully created.
           */
          insert(data, file) {
            const { title, context: context2 } = data;
            const request = {
              type: "insert",
              resource: "context",
              profileId: this.profileId,
              integrationId: this.integrationId,
              payload: {
                id: this.id,
                title,
                context: context2
              }
            };
            return this.client.mutate(request, file);
          }
          /**
           * Updates an existing context entry on the chatbot profile. This will result in an error if an entry has not yet
           * been created for the current context id.
           *
           * @param data An object containing options for updated the entry.
           * @param data.title - The title of the entry.
           * @param data.context - The context data.
           * @returns A promise that resolves when the context is successfully updated.
           */
          update(data) {
            const { title, context: context2 } = data;
            const request = {
              type: "update",
              resource: "context",
              profileId: this.profileId,
              integrationId: this.integrationId,
              payload: {
                id: this.id,
                title,
                context: context2
              }
            };
            return this.client.mutate(request);
          }
          /**
           * Deletes an existing context entry on the chatbot profile. This will result in an error if an entry has not yet
           * been created for the current context id.
           *
           * @returns A promise that resolves when the context is successfully deleted.
           */
          delete() {
            const request = {
              type: "delete",
              resource: "context",
              profileId: this.profileId,
              integrationId: this.integrationId,
              payload: {
                id: this.id
              }
            };
            return this.client.mutate(request);
          }
        }
        class AiChatbotInstructionReference {
          constructor(client, integrationId, profileId, id) {
            this.client = client;
            this.integrationId = integrationId;
            this.profileId = profileId;
            this.id = id || generateId();
          }
          /**
           * Adds a new instruction entry to the chatbot profile. This will result in an error if an entry already exists with
           * the same id.
           *
           * @param data An object containing options for creating the entry.
           * @param data.instruction - The instruction data.
           * @returns A promise that resolves when the instruction is successfully created.
           */
          insert(data) {
            const { instruction } = data;
            const request = {
              type: "insert",
              resource: "instruction",
              profileId: this.profileId,
              integrationId: this.integrationId,
              payload: {
                id: this.id,
                instruction
              }
            };
            return this.client.mutate(request);
          }
          /**
           * Updates an existing instruction entry on the chatbot profile. This will result in an error if an entry has not
           * yet been created for the current instruction id.
           *
           * @param data An object containing options for updated the entry.
           * @param data.instruction - The instruction data.
           * @returns A promise that resolves when the instruction is successfully updated.
           */
          update(data) {
            const { instruction } = data;
            const request = {
              type: "update",
              resource: "instruction",
              profileId: this.profileId,
              integrationId: this.integrationId,
              payload: {
                id: this.id,
                instruction
              }
            };
            return this.client.mutate(request);
          }
          /**
           * Deletes an existing instruction entry on the chatbot profile. This will result in an error if an entry has not
           * yet been created for the current instruction id.
           *
           * @returns A promise that resolves when the instruction is successfully deleted.
           */
          delete() {
            const request = {
              type: "delete",
              resource: "instruction",
              profileId: this.profileId,
              integrationId: this.integrationId,
              payload: {
                id: this.id
              }
            };
            return this.client.mutate(request);
          }
        }
        ;
        function assertValidateTruthy(value, message, statusCode = HttpStatus.BAD_REQUEST, details) {
          assertTruthy(value, () => new ValidationError(message, statusCode, details));
        }
        function assert_validateTruthy(value, message, statusCode = HttpStatus.BAD_REQUEST, details) {
          return truthy(value, () => new ValidationError(message, statusCode, details));
        }
        ;
        class validation_ValidationError extends /* unused pure expression or super */
        null {
          constructor(error, statusCode, details) {
            super(error);
            this.statusCode = statusCode;
            this.details = details;
          }
        }
        function validatePathPart(part) {
          if (!part || !part.match(/^[a-zA-Z][a-zA-Z0-9!@#$%^&*~_]{0,49}$/)) {
            throw new Error("A document id and a collection id can contain only a-z, A-Z, 0-9,!@#$%^&*~_, startingwith a letter, at least one character, and up to 50.");
          }
        }
        function validateCollectionName(collectionName) {
          if (typeof collectionName !== "string" || !collectionName) {
            throw new Error("Collection path has to be a non empty string");
          }
          validatePathPart(collectionName);
        }
        function validateFieldName(fieldName) {
          if (!fieldName || typeof fieldName !== "string") {
            throw new Error("Field name has to be a non-empty string");
          }
          if (fieldName === "__docId__") {
            return;
          }
          if (!fieldName.match(/^[a-zA-Z_$][a-zA-Z0-9!@#$%^&*~_ ]{0,49}$/)) {
            throw new Error("A Field name can contain only a-z, A-Z, 0-9,!@#$%^&*~_, starting with a letter, at least one character, and up to 50. Field name: " + fieldName);
          }
        }
        function isValidId(id) {
          return typeof id === "string" && !!id && id.length <= 50 && /^[a-zA-Z0-9_-]+$/.test(id);
        }
        function validateId(id, message) {
          validateTruthy(isValidId(id), message, HttpStatus.BAD_REQUEST);
        }
        function validateFieldSort(fieldSort) {
          if (!(fieldSort instanceof Object)) {
            throw new Error("Field sort has to be an object");
          }
          (0, dist.assertTruthy)(hasOnlyKeys(fieldSort, ["fieldName", "asc"]), "Field sort should only contain a fieldName and asc");
          (0, dist.assertTruthy)(isRightType(fieldSort.asc, "boolean"), "Asc needs to be boolean");
          validateFieldName(fieldSort.fieldName);
        }
        function validateOpenIdProvider(openIdProvider) {
          assertTruthy(openIdProvider, "INVALID_PROVIDER");
          validateOpenIdProviderType(openIdProvider.providerType);
          assertTruthy(openIdProvider.providerType, "INVALID_CLIENT_ID");
          assertTruthy(openIdProvider.clientId, "INVALID_CLIENT_ID");
          assertTruthy(openIdProvider.domain, "INVALID_DOMAIN");
          return openIdProvider;
        }
        function validateOpenIdProviderType(providerType) {
          const providerArray = ["auth0"];
          assertTruthy(providerArray.includes(providerType), "INVALID_OPEN_ID_PROVIDER_TYPE");
        }
        function validateDeleteMutation(mutation) {
          if (!mutation || mutation.type !== "delete") {
            throw new Error("Mutation has to be non empty with type delete.");
          }
        }
        function validateInsertMutation(mutation) {
          if (!mutation || mutation.type !== "insert") {
            throw new Error("Mutation has to be non empty with type insert.");
          }
          if (!mutation.properties || typeof mutation.properties !== "object") {
            throw new Error("The properties in insert mutation need to be a JSON object.");
          }
          for (const [fieldName] of Object.entries(mutation.properties)) {
            validateFieldName(fieldName);
          }
        }
        function validateUpdatePropertyMutation(propertyMutation) {
          if (!propertyMutation || propertyMutation.type !== "update") {
            throw new Error("Update value property mutation has to be of type update");
          }
          if (propertyMutation.value === void 0) {
            throw new Error("Value has to exist in an update value property mutation..");
          }
        }
        function validateApplyNumericFnPropertyMutation(propertyMutation) {
          if (!propertyMutation || propertyMutation.type !== "applyNumericFn") {
            throw new Error("Apply numeric fn mutation has to be of type applyNumericFn");
          }
          if (!["increment"].includes(propertyMutation.fn)) {
            throw new Error("Invalid fn for apply numeric fn.");
          }
          if (typeof propertyMutation.value !== "number") {
            throw new Error("The value in an apply numeric fn function has to be numeric.");
          }
        }
        function validateApplyStringFnPropertyMutation(propertyMutation) {
          if (!propertyMutation || propertyMutation.type !== "applyStringFn") {
            throw new Error("Apply string fn mutation has to be of type applyStringFn");
          }
          if (!["trim", "extendString"].includes(propertyMutation.fn)) {
            throw new Error("Invalid fn for apply string fn.");
          }
          if (typeof propertyMutation.value !== "string") {
            throw new Error("The value in an apply string fn function has to be a string.");
          }
        }
        function validatePropertyMutation(propertyMutation) {
          if (!propertyMutation || typeof propertyMutation !== "object") {
            throw new Error("Property mutation need to be a JSON object.");
          }
          if (!["update", "applyNumericFn", "applyStringFn"].includes(propertyMutation.type)) {
            throw new Error(`Property mutation can be of type 'update', 'applyNumericFn', 'applyStringFn'`);
          }
          switch (propertyMutation.type) {
            case "update":
              validateUpdatePropertyMutation(propertyMutation);
              break;
            case "applyNumericFn":
              validateApplyNumericFnPropertyMutation(propertyMutation);
              break;
            case "applyStringFn":
              validateApplyStringFnPropertyMutation(propertyMutation);
              break;
          }
        }
        function validateUpdateMutation(mutation) {
          if (!mutation || mutation.type !== "update") {
            throw new Error("Mutation has to be non empty with type update.");
          }
          if (!mutation.properties || typeof mutation.properties !== "object") {
            throw new Error("The properties in update mutation need to be a JSON object.");
          }
          const entries = Object.entries(mutation.properties);
          for (const [fieldName, propertyMutations] of entries) {
            validateFieldName(fieldName);
            for (const propertyMutation of propertyMutations) {
              validatePropertyMutation(propertyMutation);
            }
          }
        }
        function validateMutation(mutation) {
          if (!mutation) {
            throw new Error("Mutation cannot be empty");
          }
          if (!["insert", "delete", "update"].includes(mutation.type)) {
            throw new Error(`Mutation type has to be one of 'insert', 'delete', or 'update'`);
          }
          validateCollectionName(mutation.squidDocIdObj.collectionName);
          validatePathPart(mutation.squidDocIdObj.docId);
          switch (mutation.type) {
            case "delete":
              validateDeleteMutation(mutation);
              break;
            case "insert":
              validateInsertMutation(mutation);
              break;
            case "update":
              validateUpdateMutation(mutation);
              break;
          }
        }
        function validateMutations(mutations) {
          if (!mutations || !(mutations instanceof Array) || !mutations.length) {
            throw new Error("The list of mutations has to be a non-empty array.");
          }
          for (const mutation of mutations) {
            validateMutation(mutation);
          }
        }
        function validateQueryLimit(limit) {
          (0, dist.assertTruthy)(isRightType(limit, "number"), "Limit needs to be a number");
          if (limit === -1)
            return;
          (0, dist.assertTruthy)(limit > 0, "query limit has to be greater than 0");
          (0, dist.assertTruthy)(Math.floor(limit) === limit, "query limit has to be an integer");
          (0, dist.assertTruthy)(limit <= 2e4, "Limit can be maximum 20000");
        }
        function isNotEmpty(value) {
          validateCorrectStringType(value);
          return typeof value === "string" && !!value;
        }
        function validateCorrectStringType(value) {
          if (value !== null && value !== void 0 && typeof value !== "string") {
            throw new Error(`Unexpected input type ${typeof value}`);
          }
        }
        function isRightType(value, type) {
          if (Array.isArray(value)) {
            return value.every((element) => typeof element === type);
          }
          return typeof value === type;
        }
        function hasOnlyKeys(obj, keys) {
          return !Array.isArray(obj) && [...Object.keys(obj)].every((key) => keys.includes(key));
        }
        ;
        class QueryBuilderFactory {
          constructor(querySubscriptionManager, localQueryManager, documentReferenceFactory, documentIdentityService) {
            this.querySubscriptionManager = querySubscriptionManager;
            this.localQueryManager = localQueryManager;
            this.documentReferenceFactory = documentReferenceFactory;
            this.documentIdentityService = documentIdentityService;
          }
          getForDocument(squidDocId) {
            const { collectionName, integrationId, docId } = parseSquidDocId(squidDocId);
            const docIdAsJson = deserializeObj(docId);
            const query = this.get(collectionName, integrationId);
            Object.entries(docIdAsJson).forEach(([fieldName, fieldValue]) => {
              query.where(fieldName, "==", fieldValue);
            });
            return query;
          }
          get(collectionName, integrationId) {
            return new QueryBuilder(collectionName, integrationId, this.querySubscriptionManager, this.localQueryManager, this.documentReferenceFactory, this, this.documentIdentityService);
          }
        }
        class DereferenceEmitter {
          constructor(queryBuilder) {
            this.queryBuilder = queryBuilder;
          }
          /** @inheritDoc */
          peek() {
            return this.queryBuilder.peek().map((ref) => ref.data);
          }
          /** @inheritDoc */
          snapshot() {
            return (0, external_rxjs_.firstValueFrom)(this.snapshots(false));
          }
          /** @inheritDoc */
          snapshots(subscribe) {
            return this.queryBuilder.snapshots(subscribe).pipe(map((refs) => {
              return refs.map((ref) => ref.data);
            }));
          }
          getSortOrders() {
            return this.queryBuilder.getSortOrders();
          }
          clone() {
            return new DereferenceEmitter(this.queryBuilder.clone());
          }
          addCompositeCondition(conditions) {
            this.queryBuilder.addCompositeCondition(conditions);
            return this;
          }
          limit(limit) {
            this.queryBuilder.limit(limit);
            return this;
          }
          getLimit() {
            return this.queryBuilder.getLimit();
          }
          flipSortOrder() {
            this.queryBuilder.flipSortOrder();
            return this;
          }
          extractData(data) {
            return data;
          }
          serialize() {
            return Object.assign(Object.assign({}, this.queryBuilder.serialize()), { dereference: true });
          }
          paginate(options) {
            return new Pagination(this, options);
          }
        }
        class QueryBuilder extends BaseQueryBuilder {
          /**
           * @internal
           */
          constructor(collectionName, integrationId, querySubscriptionManager, localQueryManager, documentReferenceFactory, queryBuilderFactory, documentIdentityService) {
            super();
            this.collectionName = collectionName;
            this.integrationId = integrationId;
            this.querySubscriptionManager = querySubscriptionManager;
            this.localQueryManager = localQueryManager;
            this.documentReferenceFactory = documentReferenceFactory;
            this.queryBuilderFactory = queryBuilderFactory;
            this.documentIdentityService = documentIdentityService;
            this.forceFetchFromServer = false;
            this.query = {
              integrationId,
              collectionName,
              conditions: [],
              limit: -1,
              sortOrder: []
            };
          }
          /** @inheritDoc */
          where(fieldName, operator, value) {
            if (operator === "in" || operator === "not in") {
              const values = Array.isArray(value) ? [...value] : [value];
              if (operator === "in" && values.length === 0) {
                this.containsEmptyInCondition = true;
              }
              for (const value2 of values) {
                this.query.conditions.push({
                  fieldName,
                  operator: operator === "in" ? "==" : "!=",
                  value: value2
                });
              }
              return this;
            }
            this.query.conditions.push({
              fieldName,
              operator,
              value
            });
            return this;
          }
          /** @inheritDoc */
          limit(limit) {
            validateQueryLimit(limit);
            this.query.limit = limit;
            return this;
          }
          getLimit() {
            return this.query.limit;
          }
          limitBy(limit, ...fields) {
            const sorts = this.query.sortOrder.map((s) => {
              return s.fieldName;
            });
            (0, dist.assertTruthy)(lodash.isEqual(fields.sort(), sorts.slice(0, fields.length).sort()), "All fields in limitBy must be appear in the first fields in the sortBy list.");
            this.query.limitBy = { limit, fields, reverseSort: false };
            return this;
          }
          /** @inheritDoc */
          sortBy(fieldName, asc = true) {
            const fieldSort = { asc, fieldName };
            validateFieldSort(fieldSort);
            (0, dist.assertTruthy)(!this.query.sortOrder.some((so) => so.fieldName === fieldName), `${fieldName} already in the sort list.`);
            this.query.sortOrder.push(fieldSort);
            return this;
          }
          /**
           * @internal
           */
          build() {
            const mergedConditions = this.mergeConditions();
            return Object.assign(Object.assign({}, this.query), { conditions: mergedConditions });
          }
          mergeConditions() {
            const simpleConditions = this.query.conditions.filter(isSimpleCondition);
            const result = [];
            const groupByFieldName = lodash.groupBy(simpleConditions || [], (condition) => condition.fieldName);
            for (const fieldNameGroup of Object.values(groupByFieldName)) {
              const groupByOperator = lodash.groupBy(fieldNameGroup, (operator) => operator.operator);
              for (const [operator, operatorGroup] of Object.entries(groupByOperator)) {
                if (operator === "==" || operator === "!=") {
                  result.push(...operatorGroup);
                  continue;
                }
                const sorted = lodash.sortBy(operatorGroup, (o) => o.value);
                if (operator === ">" || operator === ">=") {
                  result.push(sorted[sorted.length - 1]);
                } else if (operator === "<" || operator === "<=") {
                  result.push(sorted[0]);
                } else {
                  result.push(sorted[0]);
                }
              }
            }
            return [...this.query.conditions.filter((c) => !isSimpleCondition(c)), ...result];
          }
          // noinspection JSUnusedGlobalSymbols
          getSortOrder() {
            return this.query.sortOrder;
          }
          /**
           * @inheritDoc
           */
          snapshot() {
            return (0, external_rxjs_.firstValueFrom)(this.snapshots(false));
          }
          /**
           * Forces the query to return data from the server even if there is a query that already returned the requested
           * result.
           */
          setForceFetchFromServer() {
            this.forceFetchFromServer = true;
            return this;
          }
          /**
           * @inheritDoc
           */
          peek() {
            return this.localQueryManager.peek(this.build());
          }
          /**
           * @inheritDoc
           */
          snapshots(subscribe = true) {
            if (this.containsEmptyInCondition) {
              return new external_rxjs_.BehaviorSubject([]);
            }
            const query = this.build();
            return this.querySubscriptionManager.processQuery(query, this.collectionName, {}, {}, subscribe, this.forceFetchFromServer).pipe(map((docs) => {
              return docs.map((docRecord) => {
                (0, dist.assertTruthy)(Object.keys(docRecord).length === 1);
                const doc = docRecord[this.collectionName];
                const squidDocId = getSquidDocId((0, dist.truthy)(doc).__docId__, this.collectionName, this.integrationId);
                return this.documentReferenceFactory.create(squidDocId, this.queryBuilderFactory);
              });
            }));
          }
          /**
           * @inheritDoc
           */
          changes() {
            let beforeDocMap = void 0;
            let beforeDocSet = /* @__PURE__ */ new Set();
            return this.snapshots().pipe((0, external_rxjs_.combineLatestWith)(this.documentIdentityService.observeChanges().pipe((0, external_rxjs_.switchMap)((idResolutionMap) => {
              Object.entries(idResolutionMap).forEach(([squidDocId, newSquidDocId]) => {
                replaceKeyInRecord(beforeDocMap || {}, squidDocId, newSquidDocId);
              });
              return external_rxjs_.NEVER;
            }), (0, external_rxjs_.startWith)({}))), map(([data]) => {
              let inserts = [];
              const updates = [];
              const deletes = [];
              if (!beforeDocMap) {
                inserts = data;
              } else {
                for (const docAfter of data) {
                  const squidDocId = docAfter.squidDocId;
                  const docAfterData = docAfter.dataRef;
                  if (beforeDocSet.has(docAfterData)) {
                    delete beforeDocMap[squidDocId];
                    beforeDocSet.delete(docAfterData);
                    continue;
                  }
                  if (beforeDocMap[squidDocId]) {
                    updates.push(docAfter);
                    const beforeDoc = beforeDocMap[squidDocId];
                    delete beforeDocMap[squidDocId];
                    beforeDocSet.delete(beforeDoc);
                  } else {
                    inserts.push(docAfter);
                  }
                }
                for (const beforeDocData of beforeDocSet) {
                  deletes.push(beforeDocData);
                }
              }
              beforeDocMap = {};
              beforeDocSet = /* @__PURE__ */ new Set();
              for (const afterDoc of data) {
                const afterDocData = afterDoc.dataRef;
                beforeDocMap[afterDoc.squidDocId] = afterDocData;
                beforeDocSet.add(afterDocData);
              }
              return new Changes(inserts, updates, deletes);
            }));
          }
          /**
           * A unique hash for the query. Identical queries should return the same hash
           * value.
           *
           * @returns The query's hash string.
           */
          get hash() {
            return encodeValueForMapping(this.build());
          }
          /** @inheritDoc */
          dereference() {
            return new DereferenceEmitter(this);
          }
          getSortOrders() {
            return this.query.sortOrder;
          }
          clone() {
            const res = new QueryBuilder(this.collectionName, this.integrationId, this.querySubscriptionManager, this.localQueryManager, this.documentReferenceFactory, this.queryBuilderFactory, this.documentIdentityService);
            res.query = lodash.cloneDeep(this.query);
            res.containsEmptyInCondition = this.containsEmptyInCondition;
            return res;
          }
          addCompositeCondition(conditions) {
            if (!conditions.length) {
              return this;
            }
            this.query.conditions.push({ fields: conditions });
            return this;
          }
          flipSortOrder() {
            this.query.sortOrder = this.query.sortOrder.map((sort) => {
              return Object.assign(Object.assign({}, sort), { asc: !sort.asc });
            });
            if (this.query.limitBy) {
              this.query.limitBy.reverseSort = !this.query.limitBy.reverseSort;
            }
            return this;
          }
          serialize() {
            return {
              type: "simple",
              dereference: false,
              query: this.build()
            };
          }
          extractData(data) {
            return data.dataRef;
          }
          paginate(options) {
            return new Pagination(this, options);
          }
        }
        class Changes {
          // noinspection JSUnusedGlobalSymbols
          constructor(inserts, updates, deletes) {
            this.inserts = inserts;
            this.updates = updates;
            this.deletes = deletes;
          }
        }
        ;
        class JoinQueryBuilder extends BaseQueryBuilder {
          /**
           * @internal
           */
          constructor(collectionName, integrationId, querySubscriptionManager, documentReferenceFactory, queryBuilderFactory, rootAlias, latestAlias, leftToRight, joins, joinConditions, queryBuilder) {
            super();
            this.collectionName = collectionName;
            this.integrationId = integrationId;
            this.querySubscriptionManager = querySubscriptionManager;
            this.documentReferenceFactory = documentReferenceFactory;
            this.queryBuilderFactory = queryBuilderFactory;
            this.rootAlias = rootAlias;
            this.latestAlias = latestAlias;
            this.leftToRight = leftToRight;
            this.joins = joins;
            this.joinConditions = joinConditions;
            this.queryBuilder = queryBuilder;
          }
          /**
           * Adds a condition to the query.
           *
           * @param fieldName The name of the field to query
           * @param operator The operator to use
           * @param value The value to compare against
           * @returns The query builder
           */
          where(fieldName, operator, value) {
            this.queryBuilder.where(fieldName, operator, value);
            return this;
          }
          /**
           * Sets a limit to the number of results returned by the query. The maximum limit is 20,000 and the default is 1,000
           * if none is provided.
           *
           * @param limit The maximum number of results to return
           * @returns The query builder
           */
          limit(limit) {
            this.queryBuilder.limit(limit);
            return this;
          }
          getLimit() {
            return this.queryBuilder.getLimit();
          }
          /**
           * Adds a sort order to the query. You can add multiple sort orders to the query. The order in which you add them
           * determines the order in which they are applied.
           * @param fieldName The name of the field to sort by
           * @param asc Whether to sort in ascending order. Defaults to true.
           * @returns The query builder
           */
          sortBy(fieldName, asc = true) {
            this.queryBuilder.sortBy(fieldName, asc);
            return this;
          }
          join(queryBuilder, alias, joinFields, options) {
            var _a2, _b;
            const leftAlias = (_a2 = options === null || options === void 0 ? void 0 : options.leftAlias) !== null && _a2 !== void 0 ? _a2 : this.latestAlias;
            const joinCondition = Object.assign(Object.assign({}, joinFields), { leftAlias, isInner: (_b = options === null || options === void 0 ? void 0 : options.isInner) !== null && _b !== void 0 ? _b : false });
            const newAliases = Object.assign(Object.assign({}, this.leftToRight), { [alias]: [] });
            newAliases[leftAlias].push(alias);
            return new JoinQueryBuilder(this.collectionName, this.integrationId, this.querySubscriptionManager, this.documentReferenceFactory, this.queryBuilderFactory, this.rootAlias, alias, newAliases, Object.assign(Object.assign({}, this.joins), { [alias]: queryBuilder.build() }), Object.assign(Object.assign({}, this.joinConditions), { [alias]: joinCondition }), this.queryBuilder);
          }
          /** @inheritDoc */
          snapshot() {
            return (0, external_rxjs_.firstValueFrom)(this.snapshots(false));
          }
          /** @inheritDoc */
          snapshots(subscribe = true) {
            if (this.containsEmptyInCondition) {
              return new external_rxjs_.BehaviorSubject([]);
            }
            return this.querySubscriptionManager.processQuery(this.build(), this.rootAlias, lodash.cloneDeep(this.joins), lodash.cloneDeep(this.joinConditions), subscribe, false).pipe(map((docs) => docs.map((docRecord) => {
              const result = {};
              for (const [alias, doc] of Object.entries(docRecord)) {
                const collectionName = alias === this.rootAlias ? this.collectionName : this.joins[alias].collectionName;
                const integrationId = alias === this.rootAlias ? this.integrationId : this.joins[alias].integrationId;
                const squidDocId = doc ? getSquidDocId(doc.__docId__, collectionName, integrationId) : void 0;
                result[alias] = squidDocId ? this.documentReferenceFactory.create(squidDocId, this.queryBuilderFactory) : void 0;
              }
              return result;
            })));
          }
          /**
           * @inheritDoc
           */
          peek() {
            throw new Error("peek is not currently supported for join queries");
          }
          /** @inheritDoc */
          grouped() {
            return new GroupedJoin(this);
          }
          /** @inheritDoc */
          dereference() {
            return new DereferencedJoin(this);
          }
          /**
           * @internal
           */
          build() {
            return this.queryBuilder.build();
          }
          getSortOrders() {
            return this.queryBuilder.getSortOrders();
          }
          clone() {
            const res = new JoinQueryBuilder(this.collectionName, this.integrationId, this.querySubscriptionManager, this.documentReferenceFactory, this.queryBuilderFactory, this.rootAlias, this.latestAlias, lodash.cloneDeep(this.leftToRight), lodash.cloneDeep(this.joins), lodash.cloneDeep(this.joinConditions), this.queryBuilder.clone());
            res.containsEmptyInCondition = this.containsEmptyInCondition;
            return res;
          }
          addCompositeCondition(conditions) {
            this.queryBuilder.addCompositeCondition(conditions);
            return this;
          }
          flipSortOrder() {
            this.queryBuilder.flipSortOrder();
            return this;
          }
          extractData(data) {
            return data[this.rootAlias].dataRef;
          }
          serialize() {
            return {
              type: "join",
              grouped: false,
              dereference: false,
              root: {
                alias: this.rootAlias,
                query: this.build()
              },
              leftToRight: this.leftToRight,
              joins: this.joins,
              joinConditions: this.joinConditions
            };
          }
          paginate(options) {
            return new Pagination(this, options);
          }
        }
        class DereferencedJoin {
          constructor(joinQueryBuilder) {
            this.joinQueryBuilder = joinQueryBuilder;
          }
          /** @inheritDoc */
          grouped() {
            return this.joinQueryBuilder.grouped().dereference();
          }
          /** @inheritDoc */
          snapshot() {
            return (0, external_rxjs_.firstValueFrom)(this.snapshots(false));
          }
          /** @inheritDoc */
          snapshots(subscribe) {
            return this.joinQueryBuilder.snapshots(subscribe).pipe(map((docs) => {
              return docs.map((doc) => {
                return lodash.mapValues(doc, (doc1) => {
                  return doc1 === null || doc1 === void 0 ? void 0 : doc1.data;
                });
              });
            }));
          }
          /**
           * @inheritDoc
           */
          peek() {
            throw new Error("peek is not currently supported for join queries");
          }
          getSortOrders() {
            return this.joinQueryBuilder.getSortOrders();
          }
          clone() {
            return new DereferencedJoin(this.joinQueryBuilder.clone());
          }
          addCompositeCondition(conditions) {
            this.joinQueryBuilder.addCompositeCondition(conditions);
            return this;
          }
          flipSortOrder() {
            this.joinQueryBuilder.flipSortOrder();
            return this;
          }
          limit(limit) {
            this.joinQueryBuilder.limit(limit);
            return this;
          }
          extractData(data) {
            return data[this.joinQueryBuilder.rootAlias];
          }
          paginate(options) {
            return new Pagination(this, options);
          }
          serialize() {
            return Object.assign(Object.assign({}, this.joinQueryBuilder.serialize()), { dereference: true });
          }
          getLimit() {
            return this.joinQueryBuilder.getLimit();
          }
        }
        class DereferencedGroupedJoin {
          constructor(groupedJoin) {
            this.groupedJoin = groupedJoin;
          }
          /** @inheritDoc */
          snapshot() {
            return (0, external_rxjs_.firstValueFrom)(this.snapshots(false));
          }
          /** @inheritDoc */
          snapshots(subscribe) {
            return this.groupedJoin.snapshots(subscribe).pipe(map((docs) => {
              return docs.map((doc) => {
                return this.dereference(doc, this.groupedJoin.joinQueryBuilder.rootAlias);
              });
            }));
          }
          /**
           * @inheritDoc
           */
          peek() {
            throw new Error("peek is not currently supported for join queries");
          }
          dereference(doc, rootAlias) {
            const rights = this.groupedJoin.joinQueryBuilder.leftToRight[rootAlias];
            if (rights.length) {
              const ret = { [rootAlias]: doc[rootAlias].data };
              for (const right of rights) {
                ret[right] = doc[right].map((doc1) => this.dereference(doc1, right));
              }
              return ret;
            } else {
              return doc.data;
            }
          }
          /** @internal */
          getSortOrders() {
            return this.groupedJoin.getSortOrders();
          }
          /** @internal */
          clone() {
            return new DereferencedGroupedJoin(this.groupedJoin.clone());
          }
          /** @internal */
          addCompositeCondition(conditions) {
            this.groupedJoin.addCompositeCondition(conditions);
            return this;
          }
          /** @internal */
          flipSortOrder() {
            this.groupedJoin.flipSortOrder();
            return this;
          }
          /** @internal */
          limit(limit) {
            this.groupedJoin.limit(limit);
            return this;
          }
          /** @internal */
          getLimit() {
            return this.groupedJoin.getLimit();
          }
          /** @internal */
          extractData(data) {
            return data[this.groupedJoin.joinQueryBuilder.rootAlias];
          }
          serialize() {
            return Object.assign(Object.assign({}, this.groupedJoin.joinQueryBuilder.serialize()), { dereference: true, grouped: true });
          }
          paginate(options) {
            return new Pagination(this, options);
          }
        }
        class GroupedJoin {
          /** internal */
          constructor(joinQueryBuilder) {
            this.joinQueryBuilder = joinQueryBuilder;
          }
          /** @inheritDoc */
          snapshot() {
            return (0, external_rxjs_.firstValueFrom)(this.snapshots(false));
          }
          /** @inheritDoc */
          snapshots(subscribe) {
            return this.joinQueryBuilder.snapshots(subscribe).pipe(map((docs) => {
              return this.groupData(docs, this.joinQueryBuilder.rootAlias);
            }));
          }
          /**
           * @inheritDoc
           */
          peek() {
            throw new Error("peek is not currently supported for join queries");
          }
          /** @inheritDoc */
          dereference() {
            return new DereferencedGroupedJoin(this);
          }
          groupData(input, rootAlias) {
            const oneLevelGroup = lodash.groupBy(input, (inputRow) => {
              var _a2;
              return (_a2 = inputRow[rootAlias]) === null || _a2 === void 0 ? void 0 : _a2.squidDocId;
            });
            return Object.values(oneLevelGroup).filter((value) => {
              return value[0][rootAlias] !== void 0;
            }).map((value) => {
              const rights = this.joinQueryBuilder.leftToRight[rootAlias];
              const actualValue = value[0][rootAlias];
              if (rights.length === 0) {
                return actualValue;
              }
              const ret = {
                [rootAlias]: actualValue
              };
              for (const right of rights) {
                ret[right] = this.groupData(value, right);
              }
              return ret;
            });
          }
          getSortOrders() {
            return this.joinQueryBuilder.getSortOrders();
          }
          clone() {
            return new GroupedJoin(this.joinQueryBuilder.clone());
          }
          addCompositeCondition(conditions) {
            this.joinQueryBuilder.addCompositeCondition(conditions);
            return this;
          }
          flipSortOrder() {
            this.joinQueryBuilder.flipSortOrder();
            return this;
          }
          limit(limit) {
            this.joinQueryBuilder.limit(limit);
            return this;
          }
          getLimit() {
            return this.joinQueryBuilder.getLimit();
          }
          extractData(data) {
            if (Object.keys(this.joinQueryBuilder.leftToRight).length > 1) {
              return data[this.joinQueryBuilder.rootAlias].dataRef;
            } else {
              return data.dataRef;
            }
          }
          serialize() {
            return Object.assign(Object.assign({}, this.joinQueryBuilder.serialize()), { grouped: true });
          }
          paginate(options) {
            return new Pagination(this, options);
          }
        }
        ;
        class CollectionReference {
          /**
           * @internal
           */
          constructor(collectionName, integrationId, documentReferenceFactory, queryBuilderFactory, querySubscriptionManager) {
            this.collectionName = collectionName;
            this.integrationId = integrationId;
            this.documentReferenceFactory = documentReferenceFactory;
            this.queryBuilderFactory = queryBuilderFactory;
            this.querySubscriptionManager = querySubscriptionManager;
            this.refId = generateId();
          }
          /**
           * Returns a document reference for the given document id.
           * The document id is an object that maps the primary keys of the collection (as defined in the Squid Cloud Console)
           * to their values. There are a few exceptions:
           * 1 - String document id is only supported for the `built_in_db` when a schema was not defined.
           * 2 - Not all the fields in the document id are required. If a field is not provided, it will be generated on the
           *     server once the document is created (if the integration supports it).
           * 3 - When a document id is not provided, it will be treated as an empty object or empty string.
           * 4 - When the document id is just a `string` and not provided (applies only for the `built_in_db`), it will be
           *    generated on the server.
           * 5 - If the collection in the `built_in_db` does not have a schema, the document id must be provided as a string.
           *
           * Examples:
           * ```typescript
           * // For a collection in the built_in_db that does not have a schema
           * const docRef = collectionRef.doc('my-doc-id');
           * const docRef = collectionRef.doc({id: my-doc-id'});
           *
           * // For a collection with a single primary key field called "id"
           * const docRef = collectionRef.doc({id: 'my-doc-id'});
           *
           * // For a collection with a composite primary key
           * const docRef = collectionRef.doc({id1: 'my-doc-id1', id2: 'my-doc-id2'});
           * const docRef = collectionRef.doc({id1: 'my-doc-id1'}); // id2 will be generated on the server if the integration
           * supports it
           *
           * // For a collection from the `built_in_db` without a defined schema when an id is not provided
           *  const docRef = collectionRef.doc(); // The id will be generated on the server
           * ```
           *
           * @param docId The document id as an object for the different fields in the primary key or a string.
           * @returns A document reference for the given document id.
           */
          doc(docId) {
            if (docId && typeof docId !== "string" && typeof docId !== "object" && !Array.isArray(docId)) {
              throw new Error("Invalid doc id. Can be only object or string.");
            }
            if (this.integrationId !== IntegrationType.built_in_db) {
              if (!docId) {
                docId = { [SquidPlaceholderId]: generateId() };
              } else if (typeof docId !== "object") {
                throw new Error("Invalid doc id. String doc ids are only supported for the built_in_db integration. For all other integrations, the doc id must be an object.");
              }
            } else if (!docId || typeof docId === "string") {
              docId = { __id: docId || generateId() };
            } else {
              docId = { __id: normalizeJsonAsString(docId) };
            }
            const docIdAsJsonString = normalizeJsonAsString(docId);
            const squidDocId = getSquidDocId(docIdAsJsonString, this.collectionName, this.integrationId);
            return this.documentReferenceFactory.create(squidDocId, this.queryBuilderFactory);
          }
          /**
           * Creates a `QueryBuilder` that can be used to query the collection.
           *
           * @returns A `QueryBuilder` that can be used to query the collection.
           */
          query() {
            return this.queryBuilderFactory.get(this.collectionName, this.integrationId);
          }
          /**
           * Creates a `JoinQueryBuilder` that can be used to query the collection
           * Note that when using a join query, you have to provide an alias for the query and for every other query
           * participating in the join.
           *
           * @param alias The alias for the query.
           * @returns A `JoinQueryBuilder` that can be used to query the collection and joins with other queries.
           */
          joinQuery(alias) {
            return new JoinQueryBuilder(this.collectionName, this.integrationId, this.querySubscriptionManager, this.documentReferenceFactory, this.queryBuilderFactory, alias, alias, { [alias]: [] }, {}, {}, this.query());
          }
          /**
           * Performs `or` on a list of queries. All the queries need to be on the same collection.
           * The result will be a merge of all the queries sorted by the same sort condition of the first query.
           * Duplicate items will be removed.
           * @param builders The list of query builders to merge. (A query builder can be returned from the {@link query}
           *   method).
           * @returns A query builder that can be used to perform the `or` operation.
           */
          or(...builders) {
            return new MergedQueryBuilder(...builders);
          }
        }
        class MergedQueryBuilder {
          /** @internal */
          constructor(...snapshotEmitters) {
            if (snapshotEmitters.length === 0)
              throw new Error("At least one query builder must be provided");
            this.snapshotEmitters = snapshotEmitters.map((builder) => builder.clone());
            const maxLimit = Math.max(...this.snapshotEmitters.map((builder) => {
              const limit = builder.getLimit();
              return limit === -1 ? 1e3 : limit;
            }));
            this.snapshotEmitters.forEach((builder) => builder.limit(maxLimit));
            const sortOrder = this.snapshotEmitters[0].getSortOrders();
            for (const builder of this.snapshotEmitters) {
              const builderSortOrder = builder.getSortOrders();
              if (builderSortOrder.length !== sortOrder.length) {
                throw new Error("All the queries must have the same sort order");
              }
              for (let i2 = 0; i2 < sortOrder.length; i2++) {
                if (builderSortOrder[i2].fieldName !== sortOrder[i2].fieldName || builderSortOrder[i2].asc !== sortOrder[i2].asc) {
                  throw new Error("All the queries must have the same sort order");
                }
              }
            }
          }
          /**
           * @inheritDoc
           */
          snapshot() {
            return (0, external_rxjs_.firstValueFrom)(this.snapshots(false));
          }
          /**
           * @inheritDoc
           */
          snapshots(subscribe = true) {
            const observables = this.snapshotEmitters.map((builder) => builder.snapshots(subscribe));
            return this.or(this.snapshotEmitters[0].getSortOrders(), ...observables);
          }
          /**
           * @inheritDoc
           */
          peek() {
            throw new Error("peek is not currently supported for merged queries");
          }
          or(sort, ...observables) {
            return (0, external_rxjs_.combineLatest)([...observables]).pipe((0, external_rxjs_.map)((results) => {
              const seenData = /* @__PURE__ */ new Set();
              const flatResult = results.flat();
              const result = [];
              for (const record of flatResult) {
                if (seenData.has(this.extractData(record))) {
                  continue;
                }
                seenData.add(this.extractData(record));
                result.push(record);
              }
              return result.sort((a, b) => {
                for (const { fieldName, asc } of sort) {
                  const aVal = getInPath(this.extractData(a), fieldName);
                  const bVal = getInPath(this.extractData(b), fieldName);
                  const isEqual = compareOperator(aVal, bVal, "==");
                  if (isEqual) {
                    return 0;
                  }
                  if (compareOperator(bVal, aVal, "<")) {
                    return asc ? -1 : 1;
                  }
                  return asc ? 1 : -1;
                }
                return 0;
              }).slice(0, this.getLimit());
            }));
          }
          clone() {
            return new MergedQueryBuilder(...this.snapshotEmitters.map((builder) => builder.clone()));
          }
          getSortOrders() {
            return this.snapshotEmitters[0].getSortOrders();
          }
          addCompositeCondition(conditions) {
            for (const builder of this.snapshotEmitters) {
              builder.addCompositeCondition(conditions);
            }
            return this;
          }
          limit(limit) {
            this.snapshotEmitters.forEach((builder) => builder.limit(limit));
            return this;
          }
          getLimit() {
            return this.snapshotEmitters[0].getLimit();
          }
          flipSortOrder() {
            this.snapshotEmitters.forEach((builder) => builder.flipSortOrder());
            return this;
          }
          serialize() {
            return {
              type: "merged",
              queries: this.snapshotEmitters.map((s) => s.serialize())
            };
          }
          extractData(data) {
            return this.snapshotEmitters[0].extractData(data);
          }
          paginate(options) {
            return new Pagination(this, options);
          }
        }
        ;
        class DocumentReference {
          /**
           * @internal
           */
          constructor(_squidDocId, dataManager, queryBuilderFactory) {
            this._squidDocId = _squidDocId;
            this.dataManager = dataManager;
            this.queryBuilderFactory = queryBuilderFactory;
            this.refId = generateId();
          }
          /**
           * @internal
           */
          get squidDocId() {
            return this._squidDocId;
          }
          /**
           * Returns the document data. Throws an error if the document does not exist.
           *
           * @returns The document data.
           * @throws Error if the document does not exist.
           */
          get data() {
            return lodash.cloneDeep(this.dataRef);
          }
          /**
           * Returns a read-only internal copy of the document data. This works similar to `this.data`, except it does not
           * perform a defensive copy. The caller may not modify this object, on penalty of unexpected behavior.
           *
           * @returns The document data.
           * @throws Error if the document does not exist.
           */
          get dataRef() {
            const getError = () => {
              const { collectionName, integrationId, docId } = parseSquidDocId(this.squidDocId);
              return `No data found for document reference: ${JSON.stringify({
                docId,
                collectionName,
                integrationId
              }, null, 2)}`;
            };
            return (0, dist.truthy)(this.dataManager.getProperties(this.squidDocId), getError);
          }
          /**
           * Returns whether data has been populated for this document reference. Data
           * will not present if a document has not been queried, does not exist, or
           * has been deleted.
           *
           * @returns Whether the document has data.
           */
          get hasData() {
            return !!this.dataManager.getProperties(this.squidDocId);
          }
          /**
           * A promise that resolves with the latest data from the server or undefined if the document does not exist on the
           * server.
           *
           * @returns A promise that resolves with latest data from the server or undefined if the document does not exist on
           * the server.
           */
          async snapshot() {
            if (this.isTracked() && this.hasData)
              return this.data;
            const results = await this.queryBuilderFactory.getForDocument(this.squidDocId).dereference().snapshot();
            (0, dist.truthy)(results.length <= 1, "Got more than one doc for the same id:" + this.squidDocId);
            return results.length ? results[0] : void 0;
          }
          /**
           * Returns an observable that emits the latest data from the server or undefined if the document is deleted or does
           * not exist on the server.
           *
           * @returns An observable that emits the latest data from the server or undefined if the document is deleted or does
           * not exist on the server.
           */
          snapshots() {
            return this.queryBuilderFactory.getForDocument(this.squidDocId).dereference().snapshots().pipe((0, external_rxjs_.map)((results) => {
              (0, dist.truthy)(results.length <= 1, "Got more than one doc for the same id:" + this.squidDocId);
              return results.length ? results[0] : void 0;
            }));
          }
          /**
           * Returns the data that is currently available on the client or undefined if data has not yet been populated.
           *
           * @returns The data that is currently available on the client or undefined if data has not yet been populated.
           */
          peek() {
            return this.isTracked() && this.hasData ? this.data : void 0;
          }
          /**
           * Returns whether the locally available version of the document may not be the latest version on the server.
           *
           * @returns Whether the locally available version of the document may not be the latest version on the server.
           */
          isDirty() {
            return this.dataManager.isDirty(this.squidDocId);
          }
          isTracked() {
            return this.dataManager.isTracked(this.squidDocId);
          }
          /**
           * Updates the document with the given data.
           * The `update` will be reflected optimistically locally and will be applied to the server later.
           * If a transactionId is provided, the `update` will be applied to the server as an atomic operation together with
           * the rest of the operations in the transaction and the `update` will not reflect locally until the transaction is
           * completed locally.
           *
           * The returned promise will resolve once the `update` has been applied to the server or immediately if the `update`
           * is part of a transaction.
           *
           * @param data The data to update - can be partial.
           * @param transactionId The transaction to use for this operation. If not provided, the operation will be applied
           *   immediately.
           */
          async update(data, transactionId) {
            const properties = {};
            Object.entries(data).forEach(([fieldName, value]) => {
              const propertyMutation = value !== void 0 ? {
                type: "update",
                value
              } : {
                type: "removeProperty"
              };
              properties[fieldName] = [propertyMutation];
            });
            const mutation = {
              type: "update",
              squidDocIdObj: parseSquidDocId(this.squidDocId),
              properties
            };
            return this.dataManager.applyOutgoingMutation(mutation, transactionId);
          }
          /**
           * Similar to {@link update}, but only updates the given path.
           * @param path The path to update.
           * @param value The value to set at the given path.
           * @param transactionId The transaction to use for this operation. If not provided, the operation will be applied
           *   immediately.
           */
          async setInPath(path, value, transactionId) {
            return this.update({ [path]: lodash.cloneDeep(value) }, transactionId);
          }
          /**
           * Similar to `update`, but only deletes the given path.
           * @param path The path to delete.
           * @param transactionId The transaction to use for this operation. If not provided, the operation will be applied
           *   immediately.
           */
          async deleteInPath(path, transactionId) {
            return this.update({ [path]: void 0 }, transactionId);
          }
          /**
           * Increments the value at the given path by the given value. The value may be both positive and negative.
           * @param path The path to the value to increment.
           * @param value The value to increment by.
           * @param transactionId The transaction to use for this operation. If not provided, the operation will be applied
           *   immediately.
           */
          incrementInPath(path, value, transactionId) {
            const propertyMutation = {
              type: "applyNumericFn",
              fn: "increment",
              value
            };
            const mutation = {
              type: "update",
              squidDocIdObj: parseSquidDocId(this.squidDocId),
              properties: {
                [path]: [propertyMutation]
              }
            };
            return this.dataManager.applyOutgoingMutation(mutation, transactionId);
          }
          /**
           * Decrements the value at the given path by the given value. The value may be both positive and negative.
           * @param path The path to the value to decrement.
           * @param value The value to decrement by.
           * @param transactionId The transaction to use for this operation. If not provided, the operation will be applied
           *   immediately.
           */
          decrementInPath(path, value, transactionId) {
            return this.incrementInPath(path, -value, transactionId);
          }
          /**
           * Inserts the document with the given data. If the document already exists, the operation will be treated as
           * `upsert`. The `insert` will be reflected optimistically locally and will be applied to the server later. If a
           * transactionId is provided, the `insert` will be applied to the server as an atomic operation together with the
           * rest
           * of the operations in the transaction and the `insert` will not reflect locally until the transaction is completed
           * locally.
           *
           * The returned promise will resolve once the `insert` has been applied to the server or immediately if the `insert`
           * is part of a transaction.
           *
           * @param data The data to insert.
           * @param transactionId The transaction to use for this operation. If not provided, the operation will be applied
           *   immediately.
           */
          async insert(data, transactionId) {
            const squidDocIdObj = parseSquidDocId(this.squidDocId);
            const integrationId = squidDocIdObj.integrationId;
            let docIdProps = deserializeObj(squidDocIdObj.docId);
            if (docIdProps[SquidPlaceholderId])
              docIdProps = {};
            if (integrationId === IntegrationType.built_in_db && docIdProps.__id) {
              try {
                const idProps = deserializeObj(docIdProps.__id);
                docIdProps = Object.assign(Object.assign({}, docIdProps), idProps);
              } catch (_a2) {
              }
            }
            const mutation = {
              type: "insert",
              squidDocIdObj,
              properties: Object.assign(Object.assign(Object.assign({}, data), { __docId__: squidDocIdObj.docId }), docIdProps)
            };
            return this.dataManager.applyOutgoingMutation(mutation, transactionId);
          }
          /**
           * Deletes the document.
           * The `delete` will be reflected optimistically locally and will be applied to the server later.
           * If a transactionId is provided, the `delete` will be applied to the server as an atomic operation together with
           * the rest of the operations in the transaction and the `delete` will not reflect locally until the transaction is
           * completed locally.
           *
           * The returned promise will resolve once the `delete` has been applied to the server or immediately if the `delete`
           * is part of a transaction.
           *
           * @param transactionId The transaction to use for this operation. If not provided, the operation will be applied
           *   immediately.
           */
          async delete(transactionId) {
            const mutation = {
              type: "delete",
              squidDocIdObj: parseSquidDocId(this.squidDocId)
            };
            return this.dataManager.applyOutgoingMutation(mutation, transactionId);
          }
          /**
           * @internal
           */
          migrateDocIds(idResolutionMap) {
            const newSquidDocId = idResolutionMap[this.squidDocId];
            if (newSquidDocId) {
              this._squidDocId = newSquidDocId;
            }
          }
        }
        ;
        var genericMessage = "Invariant Violation";
        var _a = Object.setPrototypeOf, setPrototypeOf = _a === void 0 ? function(obj, proto) {
          obj.__proto__ = proto;
          return obj;
        } : _a;
        var InvariantError = (
          /** @class */
          function(_super) {
            __extends(InvariantError2, _super);
            function InvariantError2(message) {
              if (message === void 0) {
                message = genericMessage;
              }
              var _this = _super.call(this, typeof message === "number" ? genericMessage + ": " + message + " (see https://github.com/apollographql/invariant-packages)" : message) || this;
              _this.framesToPop = 1;
              _this.name = genericMessage;
              setPrototypeOf(_this, InvariantError2.prototype);
              return _this;
            }
            return InvariantError2;
          }(Error)
        );
        function invariant(condition, message) {
          if (!condition) {
            throw new InvariantError(message);
          }
        }
        var verbosityLevels = ["debug", "log", "warn", "error", "silent"];
        var verbosityLevel = verbosityLevels.indexOf("log");
        function wrapConsoleMethod(name) {
          return function() {
            if (verbosityLevels.indexOf(name) >= verbosityLevel) {
              var method = console[name] || console.log;
              return method.apply(console, arguments);
            }
          };
        }
        (function(invariant2) {
          invariant2.debug = wrapConsoleMethod("debug");
          invariant2.log = wrapConsoleMethod("log");
          invariant2.warn = wrapConsoleMethod("warn");
          invariant2.error = wrapConsoleMethod("error");
        })(invariant || (invariant = {}));
        function setVerbosity(level) {
          var old = verbosityLevels[verbosityLevel];
          verbosityLevel = Math.max(0, verbosityLevels.indexOf(level));
          return old;
        }
        const lib_invariant = (
          /* unused pure expression or super */
          null
        );
        ;
        function maybe(thunk) {
          try {
            return thunk();
          } catch (_a2) {
          }
        }
        ;
        const globals_global = maybe(function() {
          return globalThis;
        }) || maybe(function() {
          return window;
        }) || maybe(function() {
          return self;
        }) || maybe(function() {
          return global;
        }) || maybe(function() {
          return maybe.constructor("return this")();
        });
        ;
        var __ = "__";
        var GLOBAL_KEY = [__, __].join("DEV");
        function getDEV() {
          try {
            return Boolean(__DEV__);
          } catch (_a2) {
            Object.defineProperty(globals_global, GLOBAL_KEY, {
              value: maybe(function() {
                return "production";
              }) !== "production",
              enumerable: false,
              configurable: true,
              writable: true
            });
            return globals_global[GLOBAL_KEY];
          }
        }
        const DEV = getDEV();
        ;
        function process_maybe(thunk) {
          try {
            return thunk();
          } catch (_) {
          }
        }
        var safeGlobal = process_maybe(function() {
          return globalThis;
        }) || process_maybe(function() {
          return window;
        }) || process_maybe(function() {
          return self;
        }) || process_maybe(function() {
          return global;
        }) || // We don't expect the Function constructor ever to be invoked at runtime, as
        // long as at least one of globalThis, window, self, or global is defined, so
        // we are under no obligation to make it easy for static analysis tools to
        // detect syntactic usage of the Function constructor. If you think you can
        // improve your static analysis to detect this obfuscation, think again. This
        // is an arms race you cannot win, at least not in JavaScript.
        process_maybe(function() {
          return process_maybe.constructor("return this")();
        });
        var needToRemove = false;
        function install() {
          if (safeGlobal && !process_maybe(function() {
            return "production";
          }) && !process_maybe(function() {
            return process;
          })) {
            Object.defineProperty(safeGlobal, "process", {
              value: {
                env: {
                  // This default needs to be "production" instead of "development", to
                  // avoid the problem https://github.com/graphql/graphql-js/pull/2894
                  // will eventually solve, once merged and released.
                  NODE_ENV: "production"
                }
              },
              // Let anyone else change global.process as they see fit, but hide it from
              // Object.keys(global) enumeration.
              configurable: true,
              enumerable: false,
              writable: true
            });
            needToRemove = true;
          }
        }
        install();
        function remove() {
          if (needToRemove) {
            delete safeGlobal.process;
            needToRemove = false;
          }
        }
        ;
        function devAssert(condition, message) {
          const booleanCondition = Boolean(condition);
          if (!booleanCondition) {
            throw new Error(message);
          }
        }
        ;
        const MAX_ARRAY_LENGTH = 10;
        const MAX_RECURSIVE_DEPTH = 2;
        function inspect(value) {
          return formatValue(value, []);
        }
        function formatValue(value, seenValues) {
          switch (typeof value) {
            case "string":
              return JSON.stringify(value);
            case "function":
              return value.name ? `[function ${value.name}]` : "[function]";
            case "object":
              return formatObjectValue(value, seenValues);
            default:
              return String(value);
          }
        }
        function formatObjectValue(value, previouslySeenValues) {
          if (value === null) {
            return "null";
          }
          if (previouslySeenValues.includes(value)) {
            return "[Circular]";
          }
          const seenValues = [...previouslySeenValues, value];
          if (isJSONable(value)) {
            const jsonValue = value.toJSON();
            if (jsonValue !== value) {
              return typeof jsonValue === "string" ? jsonValue : formatValue(jsonValue, seenValues);
            }
          } else if (Array.isArray(value)) {
            return formatArray(value, seenValues);
          }
          return formatObject(value, seenValues);
        }
        function isJSONable(value) {
          return typeof value.toJSON === "function";
        }
        function formatObject(object, seenValues) {
          const entries = Object.entries(object);
          if (entries.length === 0) {
            return "{}";
          }
          if (seenValues.length > MAX_RECURSIVE_DEPTH) {
            return "[" + getObjectTag(object) + "]";
          }
          const properties = entries.map(
            ([key, value]) => key + ": " + formatValue(value, seenValues)
          );
          return "{ " + properties.join(", ") + " }";
        }
        function formatArray(array, seenValues) {
          if (array.length === 0) {
            return "[]";
          }
          if (seenValues.length > MAX_RECURSIVE_DEPTH) {
            return "[Array]";
          }
          const len = Math.min(MAX_ARRAY_LENGTH, array.length);
          const remaining = array.length - len;
          const items = [];
          for (let i2 = 0; i2 < len; ++i2) {
            items.push(formatValue(array[i2], seenValues));
          }
          if (remaining === 1) {
            items.push("... 1 more item");
          } else if (remaining > 1) {
            items.push(`... ${remaining} more items`);
          }
          return "[" + items.join(", ") + "]";
        }
        function getObjectTag(object) {
          const tag = Object.prototype.toString.call(object).replace(/^\[object /, "").replace(/]$/, "");
          if (tag === "Object" && typeof object.constructor === "function") {
            const name = object.constructor.name;
            if (typeof name === "string" && name !== "") {
              return name;
            }
          }
          return tag;
        }
        ;
        const instanceOf = (
          /* c8 ignore next 6 */
          // FIXME: https://github.com/graphql/graphql-js/issues/2317
          // eslint-disable-next-line no-undef
          true ? function instanceOf2(value, constructor) {
            return value instanceof constructor;
          } : 0
        );
        ;
        class Source {
          constructor(body, name = "GraphQL request", locationOffset = {
            line: 1,
            column: 1
          }) {
            typeof body === "string" || devAssert(false, `Body must be a string. Received: ${inspect(body)}.`);
            this.body = body;
            this.name = name;
            this.locationOffset = locationOffset;
            this.locationOffset.line > 0 || devAssert(
              false,
              "line in locationOffset is 1-indexed and must be positive."
            );
            this.locationOffset.column > 0 || devAssert(
              false,
              "column in locationOffset is 1-indexed and must be positive."
            );
          }
          get [Symbol.toStringTag]() {
            return "Source";
          }
        }
        function isSource(source) {
          return instanceOf(source, Source);
        }
        ;
        function removeTemporaryGlobals() {
          return typeof Source === "function" ? remove() : remove();
        }
        ;
        function checkDEV() {
          __DEV__ ? invariant("boolean" === typeof DEV, DEV) : invariant("boolean" === typeof DEV, 39);
        }
        removeTemporaryGlobals();
        checkDEV();
        ;
        function _createForOfIteratorHelperLoose(o, allowArrayLike) {
          var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
          if (it)
            return (it = it.call(o)).next.bind(it);
          if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
            if (it)
              o = it;
            var i2 = 0;
            return function() {
              if (i2 >= o.length)
                return { done: true };
              return { done: false, value: o[i2++] };
            };
          }
          throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        function _unsupportedIterableToArray(o, minLen) {
          if (!o)
            return;
          if (typeof o === "string")
            return _arrayLikeToArray(o, minLen);
          var n = Object.prototype.toString.call(o).slice(8, -1);
          if (n === "Object" && o.constructor)
            n = o.constructor.name;
          if (n === "Map" || n === "Set")
            return Array.from(o);
          if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
            return _arrayLikeToArray(o, minLen);
        }
        function _arrayLikeToArray(arr, len) {
          if (len == null || len > arr.length)
            len = arr.length;
          for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) {
            arr2[i2] = arr[i2];
          }
          return arr2;
        }
        function _defineProperties(target, props) {
          for (var i2 = 0; i2 < props.length; i2++) {
            var descriptor = props[i2];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor)
              descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        function _createClass(Constructor, protoProps, staticProps) {
          if (protoProps)
            _defineProperties(Constructor.prototype, protoProps);
          if (staticProps)
            _defineProperties(Constructor, staticProps);
          Object.defineProperty(Constructor, "prototype", { writable: false });
          return Constructor;
        }
        var hasSymbols = function() {
          return typeof Symbol === "function";
        };
        var hasSymbol = function(name) {
          return hasSymbols() && Boolean(Symbol[name]);
        };
        var getSymbol = function(name) {
          return hasSymbol(name) ? Symbol[name] : "@@" + name;
        };
        if (hasSymbols() && !hasSymbol("observable")) {
          Symbol.observable = Symbol("observable");
        }
        var SymbolIterator = getSymbol("iterator");
        var SymbolObservable = getSymbol("observable");
        var SymbolSpecies = getSymbol("species");
        function getMethod(obj, key) {
          var value = obj[key];
          if (value == null)
            return void 0;
          if (typeof value !== "function")
            throw new TypeError(value + " is not a function");
          return value;
        }
        function getSpecies(obj) {
          var ctor = obj.constructor;
          if (ctor !== void 0) {
            ctor = ctor[SymbolSpecies];
            if (ctor === null) {
              ctor = void 0;
            }
          }
          return ctor !== void 0 ? ctor : Observable;
        }
        function isObservable(x) {
          return x instanceof Observable;
        }
        function hostReportError(e) {
          if (hostReportError.log) {
            hostReportError.log(e);
          } else {
            setTimeout(function() {
              throw e;
            });
          }
        }
        function enqueue(fn) {
          Promise.resolve().then(function() {
            try {
              fn();
            } catch (e) {
              hostReportError(e);
            }
          });
        }
        function cleanupSubscription(subscription) {
          var cleanup = subscription._cleanup;
          if (cleanup === void 0)
            return;
          subscription._cleanup = void 0;
          if (!cleanup) {
            return;
          }
          try {
            if (typeof cleanup === "function") {
              cleanup();
            } else {
              var unsubscribe = getMethod(cleanup, "unsubscribe");
              if (unsubscribe) {
                unsubscribe.call(cleanup);
              }
            }
          } catch (e) {
            hostReportError(e);
          }
        }
        function closeSubscription(subscription) {
          subscription._observer = void 0;
          subscription._queue = void 0;
          subscription._state = "closed";
        }
        function flushSubscription(subscription) {
          var queue = subscription._queue;
          if (!queue) {
            return;
          }
          subscription._queue = void 0;
          subscription._state = "ready";
          for (var i2 = 0; i2 < queue.length; ++i2) {
            notifySubscription(subscription, queue[i2].type, queue[i2].value);
            if (subscription._state === "closed")
              break;
          }
        }
        function notifySubscription(subscription, type, value) {
          subscription._state = "running";
          var observer = subscription._observer;
          try {
            var m = getMethod(observer, type);
            switch (type) {
              case "next":
                if (m)
                  m.call(observer, value);
                break;
              case "error":
                closeSubscription(subscription);
                if (m)
                  m.call(observer, value);
                else
                  throw value;
                break;
              case "complete":
                closeSubscription(subscription);
                if (m)
                  m.call(observer);
                break;
            }
          } catch (e) {
            hostReportError(e);
          }
          if (subscription._state === "closed")
            cleanupSubscription(subscription);
          else if (subscription._state === "running")
            subscription._state = "ready";
        }
        function onNotify(subscription, type, value) {
          if (subscription._state === "closed")
            return;
          if (subscription._state === "buffering") {
            subscription._queue.push({
              type,
              value
            });
            return;
          }
          if (subscription._state !== "ready") {
            subscription._state = "buffering";
            subscription._queue = [{
              type,
              value
            }];
            enqueue(function() {
              return flushSubscription(subscription);
            });
            return;
          }
          notifySubscription(subscription, type, value);
        }
        var module_Subscription = function() {
          function Subscription2(observer, subscriber) {
            this._cleanup = void 0;
            this._observer = observer;
            this._queue = void 0;
            this._state = "initializing";
            var subscriptionObserver = new SubscriptionObserver(this);
            try {
              this._cleanup = subscriber.call(void 0, subscriptionObserver);
            } catch (e) {
              subscriptionObserver.error(e);
            }
            if (this._state === "initializing")
              this._state = "ready";
          }
          var _proto = Subscription2.prototype;
          _proto.unsubscribe = function unsubscribe() {
            if (this._state !== "closed") {
              closeSubscription(this);
              cleanupSubscription(this);
            }
          };
          _createClass(Subscription2, [{
            key: "closed",
            get: function() {
              return this._state === "closed";
            }
          }]);
          return Subscription2;
        }();
        var SubscriptionObserver = function() {
          function SubscriptionObserver2(subscription) {
            this._subscription = subscription;
          }
          var _proto2 = SubscriptionObserver2.prototype;
          _proto2.next = function next(value) {
            onNotify(this._subscription, "next", value);
          };
          _proto2.error = function error(value) {
            onNotify(this._subscription, "error", value);
          };
          _proto2.complete = function complete() {
            onNotify(this._subscription, "complete");
          };
          _createClass(SubscriptionObserver2, [{
            key: "closed",
            get: function() {
              return this._subscription._state === "closed";
            }
          }]);
          return SubscriptionObserver2;
        }();
        var Observable = function() {
          function Observable2(subscriber) {
            if (!(this instanceof Observable2))
              throw new TypeError("Observable cannot be called as a function");
            if (typeof subscriber !== "function")
              throw new TypeError("Observable initializer must be a function");
            this._subscriber = subscriber;
          }
          var _proto3 = Observable2.prototype;
          _proto3.subscribe = function subscribe(observer) {
            if (typeof observer !== "object" || observer === null) {
              observer = {
                next: observer,
                error: arguments[1],
                complete: arguments[2]
              };
            }
            return new module_Subscription(observer, this._subscriber);
          };
          _proto3.forEach = function forEach2(fn) {
            var _this = this;
            return new Promise(function(resolve, reject) {
              if (typeof fn !== "function") {
                reject(new TypeError(fn + " is not a function"));
                return;
              }
              function done() {
                subscription.unsubscribe();
                resolve();
              }
              var subscription = _this.subscribe({
                next: function(value) {
                  try {
                    fn(value, done);
                  } catch (e) {
                    reject(e);
                    subscription.unsubscribe();
                  }
                },
                error: reject,
                complete: resolve
              });
            });
          };
          _proto3.map = function map2(fn) {
            var _this2 = this;
            if (typeof fn !== "function")
              throw new TypeError(fn + " is not a function");
            var C = getSpecies(this);
            return new C(function(observer) {
              return _this2.subscribe({
                next: function(value) {
                  try {
                    value = fn(value);
                  } catch (e) {
                    return observer.error(e);
                  }
                  observer.next(value);
                },
                error: function(e) {
                  observer.error(e);
                },
                complete: function() {
                  observer.complete();
                }
              });
            });
          };
          _proto3.filter = function filter2(fn) {
            var _this3 = this;
            if (typeof fn !== "function")
              throw new TypeError(fn + " is not a function");
            var C = getSpecies(this);
            return new C(function(observer) {
              return _this3.subscribe({
                next: function(value) {
                  try {
                    if (!fn(value))
                      return;
                  } catch (e) {
                    return observer.error(e);
                  }
                  observer.next(value);
                },
                error: function(e) {
                  observer.error(e);
                },
                complete: function() {
                  observer.complete();
                }
              });
            });
          };
          _proto3.reduce = function reduce(fn) {
            var _this4 = this;
            if (typeof fn !== "function")
              throw new TypeError(fn + " is not a function");
            var C = getSpecies(this);
            var hasSeed = arguments.length > 1;
            var hasValue = false;
            var seed = arguments[1];
            var acc = seed;
            return new C(function(observer) {
              return _this4.subscribe({
                next: function(value) {
                  var first = !hasValue;
                  hasValue = true;
                  if (!first || hasSeed) {
                    try {
                      acc = fn(acc, value);
                    } catch (e) {
                      return observer.error(e);
                    }
                  } else {
                    acc = value;
                  }
                },
                error: function(e) {
                  observer.error(e);
                },
                complete: function() {
                  if (!hasValue && !hasSeed)
                    return observer.error(new TypeError("Cannot reduce an empty sequence"));
                  observer.next(acc);
                  observer.complete();
                }
              });
            });
          };
          _proto3.concat = function concat() {
            var _this5 = this;
            for (var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++) {
              sources[_key] = arguments[_key];
            }
            var C = getSpecies(this);
            return new C(function(observer) {
              var subscription;
              var index = 0;
              function startNext(next) {
                subscription = next.subscribe({
                  next: function(v) {
                    observer.next(v);
                  },
                  error: function(e) {
                    observer.error(e);
                  },
                  complete: function() {
                    if (index === sources.length) {
                      subscription = void 0;
                      observer.complete();
                    } else {
                      startNext(C.from(sources[index++]));
                    }
                  }
                });
              }
              startNext(_this5);
              return function() {
                if (subscription) {
                  subscription.unsubscribe();
                  subscription = void 0;
                }
              };
            });
          };
          _proto3.flatMap = function flatMap(fn) {
            var _this6 = this;
            if (typeof fn !== "function")
              throw new TypeError(fn + " is not a function");
            var C = getSpecies(this);
            return new C(function(observer) {
              var subscriptions = [];
              var outer = _this6.subscribe({
                next: function(value) {
                  if (fn) {
                    try {
                      value = fn(value);
                    } catch (e) {
                      return observer.error(e);
                    }
                  }
                  var inner = C.from(value).subscribe({
                    next: function(value2) {
                      observer.next(value2);
                    },
                    error: function(e) {
                      observer.error(e);
                    },
                    complete: function() {
                      var i2 = subscriptions.indexOf(inner);
                      if (i2 >= 0)
                        subscriptions.splice(i2, 1);
                      completeIfDone();
                    }
                  });
                  subscriptions.push(inner);
                },
                error: function(e) {
                  observer.error(e);
                },
                complete: function() {
                  completeIfDone();
                }
              });
              function completeIfDone() {
                if (outer.closed && subscriptions.length === 0)
                  observer.complete();
              }
              return function() {
                subscriptions.forEach(function(s) {
                  return s.unsubscribe();
                });
                outer.unsubscribe();
              };
            });
          };
          _proto3[SymbolObservable] = function() {
            return this;
          };
          Observable2.from = function from(x) {
            var C = typeof this === "function" ? this : Observable2;
            if (x == null)
              throw new TypeError(x + " is not an object");
            var method = getMethod(x, SymbolObservable);
            if (method) {
              var observable = method.call(x);
              if (Object(observable) !== observable)
                throw new TypeError(observable + " is not an object");
              if (isObservable(observable) && observable.constructor === C)
                return observable;
              return new C(function(observer) {
                return observable.subscribe(observer);
              });
            }
            if (hasSymbol("iterator")) {
              method = getMethod(x, SymbolIterator);
              if (method) {
                return new C(function(observer) {
                  enqueue(function() {
                    if (observer.closed)
                      return;
                    for (var _iterator = _createForOfIteratorHelperLoose(method.call(x)), _step; !(_step = _iterator()).done; ) {
                      var item = _step.value;
                      observer.next(item);
                      if (observer.closed)
                        return;
                    }
                    observer.complete();
                  });
                });
              }
            }
            if (Array.isArray(x)) {
              return new C(function(observer) {
                enqueue(function() {
                  if (observer.closed)
                    return;
                  for (var i2 = 0; i2 < x.length; ++i2) {
                    observer.next(x[i2]);
                    if (observer.closed)
                      return;
                  }
                  observer.complete();
                });
              });
            }
            throw new TypeError(x + " is not observable");
          };
          Observable2.of = function of() {
            for (var _len2 = arguments.length, items = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
              items[_key2] = arguments[_key2];
            }
            var C = typeof this === "function" ? this : Observable2;
            return new C(function(observer) {
              enqueue(function() {
                if (observer.closed)
                  return;
                for (var i2 = 0; i2 < items.length; ++i2) {
                  observer.next(items[i2]);
                  if (observer.closed)
                    return;
                }
                observer.complete();
              });
            });
          };
          _createClass(Observable2, null, [{
            key: SymbolSpecies,
            get: function() {
              return this;
            }
          }]);
          return Observable2;
        }();
        if (hasSymbols()) {
          Object.defineProperty(Observable, Symbol("extensions"), {
            value: {
              symbol: SymbolObservable,
              hostReportError
            },
            configurable: true
          });
        }
        ;
        function createOperation(starting, operation) {
          var context2 = tslib_es6_assign({}, starting);
          var setContext = function(next) {
            if (typeof next === "function") {
              context2 = tslib_es6_assign(tslib_es6_assign({}, context2), next(context2));
            } else {
              context2 = tslib_es6_assign(tslib_es6_assign({}, context2), next);
            }
          };
          var getContext = function() {
            return tslib_es6_assign({}, context2);
          };
          Object.defineProperty(operation, "setContext", {
            enumerable: false,
            value: setContext
          });
          Object.defineProperty(operation, "getContext", {
            enumerable: false,
            value: getContext
          });
          return operation;
        }
        ;
        function isNonNullObject(obj) {
          return obj !== null && typeof obj === "object";
        }
        ;
        function getFragmentQueryDocument(document2, fragmentName) {
          var actualFragmentName = fragmentName;
          var fragments = [];
          document2.definitions.forEach(function(definition) {
            if (definition.kind === "OperationDefinition") {
              throw __DEV__ ? new InvariantError("Found a ".concat(definition.operation, " operation").concat(definition.name ? " named '".concat(definition.name.value, "'") : "", ". ") + "No operations are allowed when using a fragment as a query. Only fragments are allowed.") : new InvariantError(44);
            }
            if (definition.kind === "FragmentDefinition") {
              fragments.push(definition);
            }
          });
          if (typeof actualFragmentName === "undefined") {
            __DEV__ ? invariant(fragments.length === 1, "Found ".concat(fragments.length, " fragments. `fragmentName` must be provided when there is not exactly 1 fragment.")) : invariant(fragments.length === 1, 45);
            actualFragmentName = fragments[0].name.value;
          }
          var query = tslib_es6_assign(tslib_es6_assign({}, document2), { definitions: tslib_es6_spreadArray([
            {
              kind: "OperationDefinition",
              operation: "query",
              selectionSet: {
                kind: "SelectionSet",
                selections: [
                  {
                    kind: "FragmentSpread",
                    name: {
                      kind: "Name",
                      value: actualFragmentName
                    }
                  }
                ]
              }
            }
          ], document2.definitions, true) });
          return query;
        }
        function createFragmentMap(fragments) {
          if (fragments === void 0) {
            fragments = [];
          }
          var symTable = {};
          fragments.forEach(function(fragment) {
            symTable[fragment.name.value] = fragment;
          });
          return symTable;
        }
        function getFragmentFromSelection(selection, fragmentMap) {
          switch (selection.kind) {
            case "InlineFragment":
              return selection;
            case "FragmentSpread": {
              var fragmentName = selection.name.value;
              if (typeof fragmentMap === "function") {
                return fragmentMap(fragmentName);
              }
              var fragment = fragmentMap && fragmentMap[fragmentName];
              __DEV__ ? invariant(fragment, "No fragment named ".concat(fragmentName)) : invariant(fragment, 46);
              return fragment || null;
            }
            default:
              return null;
          }
        }
        ;
        function makeReference(id) {
          return { __ref: String(id) };
        }
        function isReference(obj) {
          return Boolean(obj && typeof obj === "object" && typeof obj.__ref === "string");
        }
        function isDocumentNode(value) {
          return isNonNullObject(value) && value.kind === "Document" && Array.isArray(value.definitions);
        }
        function isStringValue(value) {
          return value.kind === "StringValue";
        }
        function isBooleanValue(value) {
          return value.kind === "BooleanValue";
        }
        function isIntValue(value) {
          return value.kind === "IntValue";
        }
        function isFloatValue(value) {
          return value.kind === "FloatValue";
        }
        function isVariable(value) {
          return value.kind === "Variable";
        }
        function isObjectValue(value) {
          return value.kind === "ObjectValue";
        }
        function isListValue(value) {
          return value.kind === "ListValue";
        }
        function isEnumValue(value) {
          return value.kind === "EnumValue";
        }
        function isNullValue(value) {
          return value.kind === "NullValue";
        }
        function valueToObjectRepresentation(argObj, name, value, variables) {
          if (isIntValue(value) || isFloatValue(value)) {
            argObj[name.value] = Number(value.value);
          } else if (isBooleanValue(value) || isStringValue(value)) {
            argObj[name.value] = value.value;
          } else if (isObjectValue(value)) {
            var nestedArgObj_1 = {};
            value.fields.map(function(obj) {
              return valueToObjectRepresentation(nestedArgObj_1, obj.name, obj.value, variables);
            });
            argObj[name.value] = nestedArgObj_1;
          } else if (isVariable(value)) {
            var variableValue = (variables || {})[value.name.value];
            argObj[name.value] = variableValue;
          } else if (isListValue(value)) {
            argObj[name.value] = value.values.map(function(listValue) {
              var nestedArgArrayObj = {};
              valueToObjectRepresentation(nestedArgArrayObj, name, listValue, variables);
              return nestedArgArrayObj[name.value];
            });
          } else if (isEnumValue(value)) {
            argObj[name.value] = value.value;
          } else if (isNullValue(value)) {
            argObj[name.value] = null;
          } else {
            throw __DEV__ ? new InvariantError('The inline argument "'.concat(name.value, '" of kind "').concat(value.kind, '"') + "is not supported. Use variables instead of inline arguments to overcome this limitation.") : new InvariantError(55);
          }
        }
        function storeKeyNameFromField(field, variables) {
          var directivesObj = null;
          if (field.directives) {
            directivesObj = {};
            field.directives.forEach(function(directive) {
              directivesObj[directive.name.value] = {};
              if (directive.arguments) {
                directive.arguments.forEach(function(_a2) {
                  var name = _a2.name, value = _a2.value;
                  return valueToObjectRepresentation(directivesObj[directive.name.value], name, value, variables);
                });
              }
            });
          }
          var argObj = null;
          if (field.arguments && field.arguments.length) {
            argObj = {};
            field.arguments.forEach(function(_a2) {
              var name = _a2.name, value = _a2.value;
              return valueToObjectRepresentation(argObj, name, value, variables);
            });
          }
          return getStoreKeyName(field.name.value, argObj, directivesObj);
        }
        var KNOWN_DIRECTIVES = [
          "connection",
          "include",
          "skip",
          "client",
          "rest",
          "export"
        ];
        var getStoreKeyName = Object.assign(function(fieldName, args, directives) {
          if (args && directives && directives["connection"] && directives["connection"]["key"]) {
            if (directives["connection"]["filter"] && directives["connection"]["filter"].length > 0) {
              var filterKeys = directives["connection"]["filter"] ? directives["connection"]["filter"] : [];
              filterKeys.sort();
              var filteredArgs_1 = {};
              filterKeys.forEach(function(key) {
                filteredArgs_1[key] = args[key];
              });
              return "".concat(directives["connection"]["key"], "(").concat(stringify(filteredArgs_1), ")");
            } else {
              return directives["connection"]["key"];
            }
          }
          var completeFieldName = fieldName;
          if (args) {
            var stringifiedArgs = stringify(args);
            completeFieldName += "(".concat(stringifiedArgs, ")");
          }
          if (directives) {
            Object.keys(directives).forEach(function(key) {
              if (KNOWN_DIRECTIVES.indexOf(key) !== -1)
                return;
              if (directives[key] && Object.keys(directives[key]).length) {
                completeFieldName += "@".concat(key, "(").concat(stringify(directives[key]), ")");
              } else {
                completeFieldName += "@".concat(key);
              }
            });
          }
          return completeFieldName;
        }, {
          setStringify: function(s) {
            var previous = stringify;
            stringify = s;
            return previous;
          }
        });
        var stringify = function defaultStringify(value) {
          return JSON.stringify(value, stringifyReplacer);
        };
        function stringifyReplacer(_key, value) {
          if (isNonNullObject(value) && !Array.isArray(value)) {
            value = Object.keys(value).sort().reduce(function(copy, key) {
              copy[key] = value[key];
              return copy;
            }, {});
          }
          return value;
        }
        function argumentsObjectFromField(field, variables) {
          if (field.arguments && field.arguments.length) {
            var argObj_1 = {};
            field.arguments.forEach(function(_a2) {
              var name = _a2.name, value = _a2.value;
              return valueToObjectRepresentation(argObj_1, name, value, variables);
            });
            return argObj_1;
          }
          return null;
        }
        function resultKeyNameFromField(field) {
          return field.alias ? field.alias.value : field.name.value;
        }
        function getTypenameFromResult(result, selectionSet, fragmentMap) {
          if (typeof result.__typename === "string") {
            return result.__typename;
          }
          for (var _i = 0, _a2 = selectionSet.selections; _i < _a2.length; _i++) {
            var selection = _a2[_i];
            if (storeUtils_isField(selection)) {
              if (selection.name.value === "__typename") {
                return result[resultKeyNameFromField(selection)];
              }
            } else {
              var typename = getTypenameFromResult(result, getFragmentFromSelection(selection, fragmentMap).selectionSet, fragmentMap);
              if (typeof typename === "string") {
                return typename;
              }
            }
          }
        }
        function storeUtils_isField(selection) {
          return selection.kind === "Field";
        }
        function isInlineFragment(selection) {
          return selection.kind === "InlineFragment";
        }
        ;
        function checkDocument(doc) {
          __DEV__ ? invariant(doc && doc.kind === "Document", 'Expecting a parsed GraphQL document. Perhaps you need to wrap the query string in a "gql" tag? http://docs.apollostack.com/apollo-client/core.html#gql') : invariant(doc && doc.kind === "Document", 47);
          var operations = doc.definitions.filter(function(d) {
            return d.kind !== "FragmentDefinition";
          }).map(function(definition) {
            if (definition.kind !== "OperationDefinition") {
              throw __DEV__ ? new InvariantError('Schema type definitions not allowed in queries. Found: "'.concat(definition.kind, '"')) : new InvariantError(48);
            }
            return definition;
          });
          __DEV__ ? invariant(operations.length <= 1, "Ambiguous GraphQL document: contains ".concat(operations.length, " operations")) : invariant(operations.length <= 1, 49);
          return doc;
        }
        function getOperationDefinition(doc) {
          checkDocument(doc);
          return doc.definitions.filter(function(definition) {
            return definition.kind === "OperationDefinition";
          })[0];
        }
        function getOperationName(doc) {
          return doc.definitions.filter(function(definition) {
            return definition.kind === "OperationDefinition" && definition.name;
          }).map(function(x) {
            return x.name.value;
          })[0] || null;
        }
        function getFragmentDefinitions(doc) {
          return doc.definitions.filter(function(definition) {
            return definition.kind === "FragmentDefinition";
          });
        }
        function getQueryDefinition(doc) {
          var queryDef = getOperationDefinition(doc);
          __DEV__ ? invariant(queryDef && queryDef.operation === "query", "Must contain a query definition.") : invariant(queryDef && queryDef.operation === "query", 50);
          return queryDef;
        }
        function getFragmentDefinition(doc) {
          __DEV__ ? invariant(doc.kind === "Document", 'Expecting a parsed GraphQL document. Perhaps you need to wrap the query string in a "gql" tag? http://docs.apollostack.com/apollo-client/core.html#gql') : invariant(doc.kind === "Document", 51);
          __DEV__ ? invariant(doc.definitions.length <= 1, "Fragment must have exactly one definition.") : invariant(doc.definitions.length <= 1, 52);
          var fragmentDef = doc.definitions[0];
          __DEV__ ? invariant(fragmentDef.kind === "FragmentDefinition", "Must be a fragment definition.") : invariant(fragmentDef.kind === "FragmentDefinition", 53);
          return fragmentDef;
        }
        function getMainDefinition(queryDoc) {
          checkDocument(queryDoc);
          var fragmentDefinition;
          for (var _i = 0, _a2 = queryDoc.definitions; _i < _a2.length; _i++) {
            var definition = _a2[_i];
            if (definition.kind === "OperationDefinition") {
              var operation = definition.operation;
              if (operation === "query" || operation === "mutation" || operation === "subscription") {
                return definition;
              }
            }
            if (definition.kind === "FragmentDefinition" && !fragmentDefinition) {
              fragmentDefinition = definition;
            }
          }
          if (fragmentDefinition) {
            return fragmentDefinition;
          }
          throw __DEV__ ? new InvariantError("Expected a parsed GraphQL query with a query, mutation, subscription, or a fragment.") : new InvariantError(54);
        }
        function getDefaultValues(definition) {
          var defaultValues = /* @__PURE__ */ Object.create(null);
          var defs = definition && definition.variableDefinitions;
          if (defs && defs.length) {
            defs.forEach(function(def) {
              if (def.defaultValue) {
                valueToObjectRepresentation(defaultValues, def.variable.name, def.defaultValue);
              }
            });
          }
          return defaultValues;
        }
        ;
        function transformOperation(operation) {
          var transformedOperation = {
            variables: operation.variables || {},
            extensions: operation.extensions || {},
            operationName: operation.operationName,
            query: operation.query
          };
          if (!transformedOperation.operationName) {
            transformedOperation.operationName = typeof transformedOperation.query !== "string" ? getOperationName(transformedOperation.query) || void 0 : "";
          }
          return transformedOperation;
        }
        ;
        function validateOperation(operation) {
          var OPERATION_FIELDS = [
            "query",
            "operationName",
            "variables",
            "extensions",
            "context"
          ];
          for (var _i = 0, _a2 = Object.keys(operation); _i < _a2.length; _i++) {
            var key = _a2[_i];
            if (OPERATION_FIELDS.indexOf(key) < 0) {
              throw __DEV__ ? new InvariantError("illegal argument: ".concat(key)) : new InvariantError(27);
            }
          }
          return operation;
        }
        ;
        function passthrough(op, forward) {
          return forward ? forward(op) : Observable.of();
        }
        function toLink(handler) {
          return typeof handler === "function" ? new ApolloLink(handler) : handler;
        }
        function isTerminating(link) {
          return link.request.length <= 1;
        }
        var LinkError = function(_super) {
          __extends(LinkError2, _super);
          function LinkError2(message, link) {
            var _this = _super.call(this, message) || this;
            _this.link = link;
            return _this;
          }
          return LinkError2;
        }(Error);
        var ApolloLink = function() {
          function ApolloLink2(request) {
            if (request)
              this.request = request;
          }
          ApolloLink2.empty = function() {
            return new ApolloLink2(function() {
              return Observable.of();
            });
          };
          ApolloLink2.from = function(links) {
            if (links.length === 0)
              return ApolloLink2.empty();
            return links.map(toLink).reduce(function(x, y) {
              return x.concat(y);
            });
          };
          ApolloLink2.split = function(test, left, right) {
            var leftLink = toLink(left);
            var rightLink = toLink(right || new ApolloLink2(passthrough));
            if (isTerminating(leftLink) && isTerminating(rightLink)) {
              return new ApolloLink2(function(operation) {
                return test(operation) ? leftLink.request(operation) || Observable.of() : rightLink.request(operation) || Observable.of();
              });
            } else {
              return new ApolloLink2(function(operation, forward) {
                return test(operation) ? leftLink.request(operation, forward) || Observable.of() : rightLink.request(operation, forward) || Observable.of();
              });
            }
          };
          ApolloLink2.execute = function(link, operation) {
            return link.request(createOperation(operation.context, transformOperation(validateOperation(operation)))) || Observable.of();
          };
          ApolloLink2.concat = function(first, second) {
            var firstLink = toLink(first);
            if (isTerminating(firstLink)) {
              __DEV__ && invariant.warn(new LinkError("You are calling concat on a terminating link, which will have no effect", firstLink));
              return firstLink;
            }
            var nextLink = toLink(second);
            if (isTerminating(nextLink)) {
              return new ApolloLink2(function(operation) {
                return firstLink.request(operation, function(op) {
                  return nextLink.request(op) || Observable.of();
                }) || Observable.of();
              });
            } else {
              return new ApolloLink2(function(operation, forward) {
                return firstLink.request(operation, function(op) {
                  return nextLink.request(op, forward) || Observable.of();
                }) || Observable.of();
              });
            }
          };
          ApolloLink2.prototype.split = function(test, left, right) {
            return this.concat(ApolloLink2.split(test, left, right || new ApolloLink2(passthrough)));
          };
          ApolloLink2.prototype.concat = function(next) {
            return ApolloLink2.concat(this, next);
          };
          ApolloLink2.prototype.request = function(operation, forward) {
            throw __DEV__ ? new InvariantError("request is not implemented") : new InvariantError(22);
          };
          ApolloLink2.prototype.onError = function(error, observer) {
            if (observer && observer.error) {
              observer.error(error);
              return false;
            }
            throw error;
          };
          ApolloLink2.prototype.setOnError = function(fn) {
            this.onError = fn;
            return this;
          };
          return ApolloLink2;
        }();
        ;
        var execute = ApolloLink.execute;
        ;
        var version = "3.7.9";
        ;
        class Location {
          /**
           * The character offset at which this Node begins.
           */
          /**
           * The character offset at which this Node ends.
           */
          /**
           * The Token at which this Node begins.
           */
          /**
           * The Token at which this Node ends.
           */
          /**
           * The Source document the AST represents.
           */
          constructor(startToken, endToken, source) {
            this.start = startToken.start;
            this.end = endToken.end;
            this.startToken = startToken;
            this.endToken = endToken;
            this.source = source;
          }
          get [Symbol.toStringTag]() {
            return "Location";
          }
          toJSON() {
            return {
              start: this.start,
              end: this.end
            };
          }
        }
        class Token {
          /**
           * The kind of Token.
           */
          /**
           * The character offset at which this Node begins.
           */
          /**
           * The character offset at which this Node ends.
           */
          /**
           * The 1-indexed line number on which this Token appears.
           */
          /**
           * The 1-indexed column number at which this Token begins.
           */
          /**
           * For non-punctuation tokens, represents the interpreted value of the token.
           *
           * Note: is undefined for punctuation tokens, but typed as string for
           * convenience in the parser.
           */
          /**
           * Tokens exist as nodes in a double-linked-list amongst all tokens
           * including ignored tokens. <SOF> is always the first node and <EOF>
           * the last.
           */
          constructor(kind, start, end, line, column, value) {
            this.kind = kind;
            this.start = start;
            this.end = end;
            this.line = line;
            this.column = column;
            this.value = value;
            this.prev = null;
            this.next = null;
          }
          get [Symbol.toStringTag]() {
            return "Token";
          }
          toJSON() {
            return {
              kind: this.kind,
              value: this.value,
              line: this.line,
              column: this.column
            };
          }
        }
        const QueryDocumentKeys = {
          Name: [],
          Document: ["definitions"],
          OperationDefinition: [
            "name",
            "variableDefinitions",
            "directives",
            "selectionSet"
          ],
          VariableDefinition: ["variable", "type", "defaultValue", "directives"],
          Variable: ["name"],
          SelectionSet: ["selections"],
          Field: ["alias", "name", "arguments", "directives", "selectionSet"],
          Argument: ["name", "value"],
          FragmentSpread: ["name", "directives"],
          InlineFragment: ["typeCondition", "directives", "selectionSet"],
          FragmentDefinition: [
            "name",
            // Note: fragment variable definitions are deprecated and will removed in v17.0.0
            "variableDefinitions",
            "typeCondition",
            "directives",
            "selectionSet"
          ],
          IntValue: [],
          FloatValue: [],
          StringValue: [],
          BooleanValue: [],
          NullValue: [],
          EnumValue: [],
          ListValue: ["values"],
          ObjectValue: ["fields"],
          ObjectField: ["name", "value"],
          Directive: ["name", "arguments"],
          NamedType: ["name"],
          ListType: ["type"],
          NonNullType: ["type"],
          SchemaDefinition: ["description", "directives", "operationTypes"],
          OperationTypeDefinition: ["type"],
          ScalarTypeDefinition: ["description", "name", "directives"],
          ObjectTypeDefinition: [
            "description",
            "name",
            "interfaces",
            "directives",
            "fields"
          ],
          FieldDefinition: ["description", "name", "arguments", "type", "directives"],
          InputValueDefinition: [
            "description",
            "name",
            "type",
            "defaultValue",
            "directives"
          ],
          InterfaceTypeDefinition: [
            "description",
            "name",
            "interfaces",
            "directives",
            "fields"
          ],
          UnionTypeDefinition: ["description", "name", "directives", "types"],
          EnumTypeDefinition: ["description", "name", "directives", "values"],
          EnumValueDefinition: ["description", "name", "directives"],
          InputObjectTypeDefinition: ["description", "name", "directives", "fields"],
          DirectiveDefinition: ["description", "name", "arguments", "locations"],
          SchemaExtension: ["directives", "operationTypes"],
          ScalarTypeExtension: ["name", "directives"],
          ObjectTypeExtension: ["name", "interfaces", "directives", "fields"],
          InterfaceTypeExtension: ["name", "interfaces", "directives", "fields"],
          UnionTypeExtension: ["name", "directives", "types"],
          EnumTypeExtension: ["name", "directives", "values"],
          InputObjectTypeExtension: ["name", "directives", "fields"]
        };
        const kindValues = new Set(Object.keys(QueryDocumentKeys));
        function isNode(maybeNode) {
          const maybeKind = maybeNode === null || maybeNode === void 0 ? void 0 : maybeNode.kind;
          return typeof maybeKind === "string" && kindValues.has(maybeKind);
        }
        var OperationTypeNode;
        (function(OperationTypeNode2) {
          OperationTypeNode2["QUERY"] = "query";
          OperationTypeNode2["MUTATION"] = "mutation";
          OperationTypeNode2["SUBSCRIPTION"] = "subscription";
        })(OperationTypeNode || (OperationTypeNode = {}));
        ;
        var kinds_Kind;
        (function(Kind2) {
          Kind2["NAME"] = "Name";
          Kind2["DOCUMENT"] = "Document";
          Kind2["OPERATION_DEFINITION"] = "OperationDefinition";
          Kind2["VARIABLE_DEFINITION"] = "VariableDefinition";
          Kind2["SELECTION_SET"] = "SelectionSet";
          Kind2["FIELD"] = "Field";
          Kind2["ARGUMENT"] = "Argument";
          Kind2["FRAGMENT_SPREAD"] = "FragmentSpread";
          Kind2["INLINE_FRAGMENT"] = "InlineFragment";
          Kind2["FRAGMENT_DEFINITION"] = "FragmentDefinition";
          Kind2["VARIABLE"] = "Variable";
          Kind2["INT"] = "IntValue";
          Kind2["FLOAT"] = "FloatValue";
          Kind2["STRING"] = "StringValue";
          Kind2["BOOLEAN"] = "BooleanValue";
          Kind2["NULL"] = "NullValue";
          Kind2["ENUM"] = "EnumValue";
          Kind2["LIST"] = "ListValue";
          Kind2["OBJECT"] = "ObjectValue";
          Kind2["OBJECT_FIELD"] = "ObjectField";
          Kind2["DIRECTIVE"] = "Directive";
          Kind2["NAMED_TYPE"] = "NamedType";
          Kind2["LIST_TYPE"] = "ListType";
          Kind2["NON_NULL_TYPE"] = "NonNullType";
          Kind2["SCHEMA_DEFINITION"] = "SchemaDefinition";
          Kind2["OPERATION_TYPE_DEFINITION"] = "OperationTypeDefinition";
          Kind2["SCALAR_TYPE_DEFINITION"] = "ScalarTypeDefinition";
          Kind2["OBJECT_TYPE_DEFINITION"] = "ObjectTypeDefinition";
          Kind2["FIELD_DEFINITION"] = "FieldDefinition";
          Kind2["INPUT_VALUE_DEFINITION"] = "InputValueDefinition";
          Kind2["INTERFACE_TYPE_DEFINITION"] = "InterfaceTypeDefinition";
          Kind2["UNION_TYPE_DEFINITION"] = "UnionTypeDefinition";
          Kind2["ENUM_TYPE_DEFINITION"] = "EnumTypeDefinition";
          Kind2["ENUM_VALUE_DEFINITION"] = "EnumValueDefinition";
          Kind2["INPUT_OBJECT_TYPE_DEFINITION"] = "InputObjectTypeDefinition";
          Kind2["DIRECTIVE_DEFINITION"] = "DirectiveDefinition";
          Kind2["SCHEMA_EXTENSION"] = "SchemaExtension";
          Kind2["SCALAR_TYPE_EXTENSION"] = "ScalarTypeExtension";
          Kind2["OBJECT_TYPE_EXTENSION"] = "ObjectTypeExtension";
          Kind2["INTERFACE_TYPE_EXTENSION"] = "InterfaceTypeExtension";
          Kind2["UNION_TYPE_EXTENSION"] = "UnionTypeExtension";
          Kind2["ENUM_TYPE_EXTENSION"] = "EnumTypeExtension";
          Kind2["INPUT_OBJECT_TYPE_EXTENSION"] = "InputObjectTypeExtension";
        })(kinds_Kind || (kinds_Kind = {}));
        ;
        const BREAK = Object.freeze({});
        function visitor_visit(root, visitor, visitorKeys = QueryDocumentKeys) {
          const enterLeaveMap = /* @__PURE__ */ new Map();
          for (const kind of Object.values(kinds_Kind)) {
            enterLeaveMap.set(kind, getEnterLeaveForKind(visitor, kind));
          }
          let stack = void 0;
          let inArray = Array.isArray(root);
          let keys = [root];
          let index = -1;
          let edits = [];
          let node = root;
          let key = void 0;
          let parent = void 0;
          const path = [];
          const ancestors = [];
          do {
            index++;
            const isLeaving = index === keys.length;
            const isEdited = isLeaving && edits.length !== 0;
            if (isLeaving) {
              key = ancestors.length === 0 ? void 0 : path[path.length - 1];
              node = parent;
              parent = ancestors.pop();
              if (isEdited) {
                if (inArray) {
                  node = node.slice();
                  let editOffset = 0;
                  for (const [editKey, editValue] of edits) {
                    const arrayKey = editKey - editOffset;
                    if (editValue === null) {
                      node.splice(arrayKey, 1);
                      editOffset++;
                    } else {
                      node[arrayKey] = editValue;
                    }
                  }
                } else {
                  node = Object.defineProperties(
                    {},
                    Object.getOwnPropertyDescriptors(node)
                  );
                  for (const [editKey, editValue] of edits) {
                    node[editKey] = editValue;
                  }
                }
              }
              index = stack.index;
              keys = stack.keys;
              edits = stack.edits;
              inArray = stack.inArray;
              stack = stack.prev;
            } else if (parent) {
              key = inArray ? index : keys[index];
              node = parent[key];
              if (node === null || node === void 0) {
                continue;
              }
              path.push(key);
            }
            let result;
            if (!Array.isArray(node)) {
              var _enterLeaveMap$get, _enterLeaveMap$get2;
              isNode(node) || devAssert(false, `Invalid AST Node: ${inspect(node)}.`);
              const visitFn = isLeaving ? (_enterLeaveMap$get = enterLeaveMap.get(node.kind)) === null || _enterLeaveMap$get === void 0 ? void 0 : _enterLeaveMap$get.leave : (_enterLeaveMap$get2 = enterLeaveMap.get(node.kind)) === null || _enterLeaveMap$get2 === void 0 ? void 0 : _enterLeaveMap$get2.enter;
              result = visitFn === null || visitFn === void 0 ? void 0 : visitFn.call(visitor, node, key, parent, path, ancestors);
              if (result === BREAK) {
                break;
              }
              if (result === false) {
                if (!isLeaving) {
                  path.pop();
                  continue;
                }
              } else if (result !== void 0) {
                edits.push([key, result]);
                if (!isLeaving) {
                  if (isNode(result)) {
                    node = result;
                  } else {
                    path.pop();
                    continue;
                  }
                }
              }
            }
            if (result === void 0 && isEdited) {
              edits.push([key, node]);
            }
            if (isLeaving) {
              path.pop();
            } else {
              var _node$kind;
              stack = {
                inArray,
                index,
                keys,
                edits,
                prev: stack
              };
              inArray = Array.isArray(node);
              keys = inArray ? node : (_node$kind = visitorKeys[node.kind]) !== null && _node$kind !== void 0 ? _node$kind : [];
              index = -1;
              edits = [];
              if (parent) {
                ancestors.push(parent);
              }
              parent = node;
            }
          } while (stack !== void 0);
          if (edits.length !== 0) {
            return edits[edits.length - 1][1];
          }
          return root;
        }
        function visitInParallel(visitors) {
          const skipping = new Array(visitors.length).fill(null);
          const mergedVisitor = /* @__PURE__ */ Object.create(null);
          for (const kind of Object.values(Kind)) {
            let hasVisitor = false;
            const enterList = new Array(visitors.length).fill(void 0);
            const leaveList = new Array(visitors.length).fill(void 0);
            for (let i2 = 0; i2 < visitors.length; ++i2) {
              const { enter, leave } = getEnterLeaveForKind(visitors[i2], kind);
              hasVisitor || (hasVisitor = enter != null || leave != null);
              enterList[i2] = enter;
              leaveList[i2] = leave;
            }
            if (!hasVisitor) {
              continue;
            }
            const mergedEnterLeave = {
              enter(...args) {
                const node = args[0];
                for (let i2 = 0; i2 < visitors.length; i2++) {
                  if (skipping[i2] === null) {
                    var _enterList$i;
                    const result = (_enterList$i = enterList[i2]) === null || _enterList$i === void 0 ? void 0 : _enterList$i.apply(visitors[i2], args);
                    if (result === false) {
                      skipping[i2] = node;
                    } else if (result === BREAK) {
                      skipping[i2] = BREAK;
                    } else if (result !== void 0) {
                      return result;
                    }
                  }
                }
              },
              leave(...args) {
                const node = args[0];
                for (let i2 = 0; i2 < visitors.length; i2++) {
                  if (skipping[i2] === null) {
                    var _leaveList$i;
                    const result = (_leaveList$i = leaveList[i2]) === null || _leaveList$i === void 0 ? void 0 : _leaveList$i.apply(visitors[i2], args);
                    if (result === BREAK) {
                      skipping[i2] = BREAK;
                    } else if (result !== void 0 && result !== false) {
                      return result;
                    }
                  } else if (skipping[i2] === node) {
                    skipping[i2] = null;
                  }
                }
              }
            };
            mergedVisitor[kind] = mergedEnterLeave;
          }
          return mergedVisitor;
        }
        function getEnterLeaveForKind(visitor, kind) {
          const kindVisitor = visitor[kind];
          if (typeof kindVisitor === "object") {
            return kindVisitor;
          } else if (typeof kindVisitor === "function") {
            return {
              enter: kindVisitor,
              leave: void 0
            };
          }
          return {
            enter: visitor.enter,
            leave: visitor.leave
          };
        }
        function getVisitFn(visitor, kind, isLeaving) {
          const { enter, leave } = getEnterLeaveForKind(visitor, kind);
          return isLeaving ? leave : enter;
        }
        ;
        function shouldInclude(_a2, variables) {
          var directives = _a2.directives;
          if (!directives || !directives.length) {
            return true;
          }
          return getInclusionDirectives(directives).every(function(_a3) {
            var directive = _a3.directive, ifArgument = _a3.ifArgument;
            var evaledValue = false;
            if (ifArgument.value.kind === "Variable") {
              evaledValue = variables && variables[ifArgument.value.name.value];
              __DEV__ ? invariant(evaledValue !== void 0, "Invalid variable referenced in @".concat(directive.name.value, " directive.")) : invariant(evaledValue !== void 0, 40);
            } else {
              evaledValue = ifArgument.value.value;
            }
            return directive.name.value === "skip" ? !evaledValue : evaledValue;
          });
        }
        function getDirectiveNames(root) {
          var names = [];
          visit(root, {
            Directive: function(node) {
              names.push(node.name.value);
            }
          });
          return names;
        }
        var hasAnyDirectives = function(names, root) {
          return hasDirectives(names, root, false);
        };
        var hasAllDirectives = function(names, root) {
          return hasDirectives(names, root, true);
        };
        function hasDirectives(names, root, all) {
          var nameSet = new Set(names);
          var uniqueCount = nameSet.size;
          visitor_visit(root, {
            Directive: function(node) {
              if (nameSet.delete(node.name.value) && (!all || !nameSet.size)) {
                return BREAK;
              }
            }
          });
          return all ? !nameSet.size : nameSet.size < uniqueCount;
        }
        function hasClientExports(document2) {
          return document2 && hasDirectives(["client", "export"], document2, true);
        }
        function isInclusionDirective(_a2) {
          var value = _a2.name.value;
          return value === "skip" || value === "include";
        }
        function getInclusionDirectives(directives) {
          var result = [];
          if (directives && directives.length) {
            directives.forEach(function(directive) {
              if (!isInclusionDirective(directive))
                return;
              var directiveArguments = directive.arguments;
              var directiveName = directive.name.value;
              __DEV__ ? invariant(directiveArguments && directiveArguments.length === 1, "Incorrect number of arguments for the @".concat(directiveName, " directive.")) : invariant(directiveArguments && directiveArguments.length === 1, 41);
              var ifArgument = directiveArguments[0];
              __DEV__ ? invariant(ifArgument.name && ifArgument.name.value === "if", "Invalid argument for the @".concat(directiveName, " directive.")) : invariant(ifArgument.name && ifArgument.name.value === "if", 42);
              var ifValue = ifArgument.value;
              __DEV__ ? invariant(ifValue && (ifValue.kind === "Variable" || ifValue.kind === "BooleanValue"), "Argument for the @".concat(directiveName, " directive must be a variable or a boolean value.")) : invariant(ifValue && (ifValue.kind === "Variable" || ifValue.kind === "BooleanValue"), 43);
              result.push({ directive, ifArgument });
            });
          }
          return result;
        }
        ;
        var serializeFetchParameter = function(p, label) {
          var serialized;
          try {
            serialized = JSON.stringify(p);
          } catch (e) {
            var parseError = __DEV__ ? new InvariantError("Network request failed. ".concat(label, " is not serializable: ").concat(e.message)) : new InvariantError(24);
            parseError.parseError = e;
            throw parseError;
          }
          return serialized;
        };
        ;
        var selectURI = function(operation, fallbackURI) {
          var context2 = operation.getContext();
          var contextURI = context2.uri;
          if (contextURI) {
            return contextURI;
          } else if (typeof fallbackURI === "function") {
            return fallbackURI(operation);
          } else {
            return fallbackURI || "/graphql";
          }
        };
        ;
        var canUseWeakMap = typeof WeakMap === "function" && maybe(function() {
          return navigator.product;
        }) !== "ReactNative";
        var canUseWeakSet = typeof WeakSet === "function";
        var canUseSymbol = typeof Symbol === "function" && typeof Symbol.for === "function";
        var canUseAsyncIteratorSymbol = canUseSymbol && Symbol.asyncIterator;
        var canUseDOM = typeof maybe(function() {
          return window.document.createElement;
        }) === "function";
        var usingJSDOM = maybe(function() {
          return navigator.userAgent.indexOf("jsdom") >= 0;
        }) || false;
        var canUseLayoutEffect = canUseDOM && !usingJSDOM;
        ;
        function isNodeResponse(value) {
          return !!value.body;
        }
        function isReadableStream(value) {
          return !!value.getReader;
        }
        function isAsyncIterableIterator(value) {
          return !!(canUseAsyncIteratorSymbol && value[Symbol.asyncIterator]);
        }
        function isStreamableBlob(value) {
          return !!value.stream;
        }
        function isBlob(value) {
          return !!value.arrayBuffer;
        }
        function isNodeReadableStream(value) {
          return !!value.pipe;
        }
        ;
        function asyncIterator(source) {
          var _a2;
          var iterator = source[Symbol.asyncIterator]();
          return _a2 = {
            next: function() {
              return iterator.next();
            }
          }, _a2[Symbol.asyncIterator] = function() {
            return this;
          }, _a2;
        }
        ;
        function nodeStreamIterator(stream) {
          var cleanup = null;
          var error = null;
          var done = false;
          var data = [];
          var waiting = [];
          function onData(chunk) {
            if (error)
              return;
            if (waiting.length) {
              var shiftedArr = waiting.shift();
              if (Array.isArray(shiftedArr) && shiftedArr[0]) {
                return shiftedArr[0]({ value: chunk, done: false });
              }
            }
            data.push(chunk);
          }
          function onError(err) {
            error = err;
            var all = waiting.slice();
            all.forEach(function(pair) {
              pair[1](err);
            });
            !cleanup || cleanup();
          }
          function onEnd() {
            done = true;
            var all = waiting.slice();
            all.forEach(function(pair) {
              pair[0]({ value: void 0, done: true });
            });
            !cleanup || cleanup();
          }
          cleanup = function() {
            cleanup = null;
            stream.removeListener("data", onData);
            stream.removeListener("error", onError);
            stream.removeListener("end", onEnd);
            stream.removeListener("finish", onEnd);
            stream.removeListener("close", onEnd);
          };
          stream.on("data", onData);
          stream.on("error", onError);
          stream.on("end", onEnd);
          stream.on("finish", onEnd);
          stream.on("close", onEnd);
          function getNext() {
            return new Promise(function(resolve, reject) {
              if (error)
                return reject(error);
              if (data.length)
                return resolve({ value: data.shift(), done: false });
              if (done)
                return resolve({ value: void 0, done: true });
              waiting.push([resolve, reject]);
            });
          }
          var iterator = {
            next: function() {
              return getNext();
            }
          };
          if (canUseAsyncIteratorSymbol) {
            iterator[Symbol.asyncIterator] = function() {
              return this;
            };
          }
          return iterator;
        }
        ;
        function promiseIterator(promise) {
          var resolved = false;
          var iterator = {
            next: function() {
              if (resolved)
                return Promise.resolve({
                  value: void 0,
                  done: true
                });
              resolved = true;
              return new Promise(function(resolve, reject) {
                promise.then(function(value) {
                  resolve({ value, done: false });
                }).catch(reject);
              });
            }
          };
          if (canUseAsyncIteratorSymbol) {
            iterator[Symbol.asyncIterator] = function() {
              return this;
            };
          }
          return iterator;
        }
        ;
        function readerIterator(reader) {
          var iterator = {
            next: function() {
              return reader.read();
            }
          };
          if (canUseAsyncIteratorSymbol) {
            iterator[Symbol.asyncIterator] = function() {
              return this;
            };
          }
          return iterator;
        }
        ;
        function responseIterator(response) {
          var body = response;
          if (isNodeResponse(response))
            body = response.body;
          if (isAsyncIterableIterator(body))
            return asyncIterator(body);
          if (isReadableStream(body))
            return readerIterator(body.getReader());
          if (isStreamableBlob(body)) {
            return readerIterator(body.stream().getReader());
          }
          if (isBlob(body))
            return promiseIterator(body.arrayBuffer());
          if (isNodeReadableStream(body))
            return nodeStreamIterator(body);
          throw new Error("Unknown body type for responseIterator. Please pass a streamable response.");
        }
        ;
        var throwServerError = function(response, result, message) {
          var error = new Error(message);
          error.name = "ServerError";
          error.response = response;
          error.statusCode = response.status;
          error.result = result;
          throw error;
        };
        ;
        var parseAndCheckHttpResponse_hasOwnProperty = Object.prototype.hasOwnProperty;
        function readMultipartBody(response, observer) {
          var _a2, _b, _c;
          return __awaiter(this, void 0, void 0, function() {
            var decoder, contentType, delimiter, boundaryVal, boundary, buffer, iterator, running, _d, value, done, chunk, bi, message, i2, headers, contentType_1, body, result;
            var _e;
            return __generator(this, function(_f) {
              switch (_f.label) {
                case 0:
                  if (TextDecoder === void 0) {
                    throw new Error("TextDecoder must be defined in the environment: please import a polyfill.");
                  }
                  decoder = new TextDecoder("utf-8");
                  contentType = (_a2 = response.headers) === null || _a2 === void 0 ? void 0 : _a2.get("content-type");
                  delimiter = "boundary=";
                  boundaryVal = (contentType === null || contentType === void 0 ? void 0 : contentType.includes(delimiter)) ? contentType === null || contentType === void 0 ? void 0 : contentType.substring((contentType === null || contentType === void 0 ? void 0 : contentType.indexOf(delimiter)) + delimiter.length).replace(/['"]/g, "").replace(/\;(.*)/gm, "").trim() : "-";
                  boundary = "--".concat(boundaryVal);
                  buffer = "";
                  iterator = responseIterator(response);
                  running = true;
                  _f.label = 1;
                case 1:
                  if (!running)
                    return [3, 3];
                  return [4, iterator.next()];
                case 2:
                  _d = _f.sent(), value = _d.value, done = _d.done;
                  chunk = typeof value === "string" ? value : decoder.decode(value);
                  running = !done;
                  buffer += chunk;
                  bi = buffer.indexOf(boundary);
                  while (bi > -1) {
                    message = void 0;
                    _e = [
                      buffer.slice(0, bi),
                      buffer.slice(bi + boundary.length)
                    ], message = _e[0], buffer = _e[1];
                    if (message.trim()) {
                      i2 = message.indexOf("\r\n\r\n");
                      headers = parseHeaders(message.slice(0, i2));
                      contentType_1 = headers["content-type"];
                      if (contentType_1 && contentType_1.toLowerCase().indexOf("application/json") === -1) {
                        throw new Error("Unsupported patch content type: application/json is required.");
                      }
                      body = message.slice(i2);
                      try {
                        result = parseJsonBody(response, body.replace("\r\n", ""));
                        if (Object.keys(result).length > 1 || "data" in result || "incremental" in result || "errors" in result) {
                          (_b = observer.next) === null || _b === void 0 ? void 0 : _b.call(observer, result);
                        }
                      } catch (err) {
                        handleError(err, observer);
                      }
                    }
                    bi = buffer.indexOf(boundary);
                  }
                  return [3, 1];
                case 3:
                  (_c = observer.complete) === null || _c === void 0 ? void 0 : _c.call(observer);
                  return [2];
              }
            });
          });
        }
        function parseHeaders(headerText) {
          var headersInit = {};
          headerText.split("\n").forEach(function(line) {
            var i2 = line.indexOf(":");
            if (i2 > -1) {
              var name_1 = line.slice(0, i2).trim().toLowerCase();
              var value = line.slice(i2 + 1).trim();
              headersInit[name_1] = value;
            }
          });
          return headersInit;
        }
        function parseJsonBody(response, bodyText) {
          if (response.status >= 300) {
            var getResult = function() {
              try {
                return JSON.parse(bodyText);
              } catch (err) {
                return bodyText;
              }
            };
            throwServerError(response, getResult(), "Response not successful: Received status code ".concat(response.status));
          }
          try {
            return JSON.parse(bodyText);
          } catch (err) {
            var parseError = err;
            parseError.name = "ServerParseError";
            parseError.response = response;
            parseError.statusCode = response.status;
            parseError.bodyText = bodyText;
            throw parseError;
          }
        }
        function handleError(err, observer) {
          var _a2, _b;
          if (err.name === "AbortError")
            return;
          if (err.result && err.result.errors && err.result.data) {
            (_a2 = observer.next) === null || _a2 === void 0 ? void 0 : _a2.call(observer, err.result);
          }
          (_b = observer.error) === null || _b === void 0 ? void 0 : _b.call(observer, err);
        }
        function readJsonBody(response, operation, observer) {
          parseAndCheckHttpResponse(operation)(response).then(function(result) {
            var _a2, _b;
            (_a2 = observer.next) === null || _a2 === void 0 ? void 0 : _a2.call(observer, result);
            (_b = observer.complete) === null || _b === void 0 ? void 0 : _b.call(observer);
          }).catch(function(err) {
            return handleError(err, observer);
          });
        }
        function parseAndCheckHttpResponse(operations) {
          return function(response) {
            return response.text().then(function(bodyText) {
              return parseJsonBody(response, bodyText);
            }).then(function(result) {
              if (response.status >= 300) {
                throwServerError(response, result, "Response not successful: Received status code ".concat(response.status));
              }
              if (!Array.isArray(result) && !parseAndCheckHttpResponse_hasOwnProperty.call(result, "data") && !parseAndCheckHttpResponse_hasOwnProperty.call(result, "errors")) {
                throwServerError(response, result, "Server response was missing for query '".concat(Array.isArray(operations) ? operations.map(function(op) {
                  return op.operationName;
                }) : operations.operationName, "'."));
              }
              return result;
            });
          };
        }
        ;
        var checkFetcher = function(fetcher) {
          if (!fetcher && typeof fetch === "undefined") {
            throw __DEV__ ? new InvariantError(`
"fetch" has not been found globally and no fetcher has been configured. To fix this, install a fetch package (like https://www.npmjs.com/package/cross-fetch), instantiate the fetcher, and pass it into your HttpLink constructor. For example:

import fetch from 'cross-fetch';
import { ApolloClient, HttpLink } from '@apollo/client';
const client = new ApolloClient({
  link: new HttpLink({ uri: '/graphql', fetch })
});
    `) : new InvariantError(23);
          }
        };
        ;
        function isWhiteSpace(code) {
          return code === 9 || code === 32;
        }
        function isDigit(code) {
          return code >= 48 && code <= 57;
        }
        function isLetter(code) {
          return code >= 97 && code <= 122 || // A-Z
          code >= 65 && code <= 90;
        }
        function isNameStart(code) {
          return isLetter(code) || code === 95;
        }
        function isNameContinue(code) {
          return isLetter(code) || isDigit(code) || code === 95;
        }
        ;
        function dedentBlockStringLines(lines) {
          var _firstNonEmptyLine2;
          let commonIndent = Number.MAX_SAFE_INTEGER;
          let firstNonEmptyLine = null;
          let lastNonEmptyLine = -1;
          for (let i2 = 0; i2 < lines.length; ++i2) {
            var _firstNonEmptyLine;
            const line = lines[i2];
            const indent2 = leadingWhitespace(line);
            if (indent2 === line.length) {
              continue;
            }
            firstNonEmptyLine = (_firstNonEmptyLine = firstNonEmptyLine) !== null && _firstNonEmptyLine !== void 0 ? _firstNonEmptyLine : i2;
            lastNonEmptyLine = i2;
            if (i2 !== 0 && indent2 < commonIndent) {
              commonIndent = indent2;
            }
          }
          return lines.map((line, i2) => i2 === 0 ? line : line.slice(commonIndent)).slice(
            (_firstNonEmptyLine2 = firstNonEmptyLine) !== null && _firstNonEmptyLine2 !== void 0 ? _firstNonEmptyLine2 : 0,
            lastNonEmptyLine + 1
          );
        }
        function leadingWhitespace(str) {
          let i2 = 0;
          while (i2 < str.length && isWhiteSpace(str.charCodeAt(i2))) {
            ++i2;
          }
          return i2;
        }
        function isPrintableAsBlockString(value) {
          if (value === "") {
            return true;
          }
          let isEmptyLine = true;
          let hasIndent = false;
          let hasCommonIndent = true;
          let seenNonEmptyLine = false;
          for (let i2 = 0; i2 < value.length; ++i2) {
            switch (value.codePointAt(i2)) {
              case 0:
              case 1:
              case 2:
              case 3:
              case 4:
              case 5:
              case 6:
              case 7:
              case 8:
              case 11:
              case 12:
              case 14:
              case 15:
                return false;
              case 13:
                return false;
              case 10:
                if (isEmptyLine && !seenNonEmptyLine) {
                  return false;
                }
                seenNonEmptyLine = true;
                isEmptyLine = true;
                hasIndent = false;
                break;
              case 9:
              case 32:
                hasIndent || (hasIndent = isEmptyLine);
                break;
              default:
                hasCommonIndent && (hasCommonIndent = hasIndent);
                isEmptyLine = false;
            }
          }
          if (isEmptyLine) {
            return false;
          }
          if (hasCommonIndent && seenNonEmptyLine) {
            return false;
          }
          return true;
        }
        function printBlockString(value, options) {
          const escapedValue = value.replace(/"""/g, '\\"""');
          const lines = escapedValue.split(/\r\n|[\n\r]/g);
          const isSingleLine = lines.length === 1;
          const forceLeadingNewLine = lines.length > 1 && lines.slice(1).every((line) => line.length === 0 || isWhiteSpace(line.charCodeAt(0)));
          const hasTrailingTripleQuotes = escapedValue.endsWith('\\"""');
          const hasTrailingQuote = value.endsWith('"') && !hasTrailingTripleQuotes;
          const hasTrailingSlash = value.endsWith("\\");
          const forceTrailingNewline = hasTrailingQuote || hasTrailingSlash;
          const printAsMultipleLines = !(options !== null && options !== void 0 && options.minimize) && // add leading and trailing new lines only if it improves readability
          (!isSingleLine || value.length > 70 || forceTrailingNewline || forceLeadingNewLine || hasTrailingTripleQuotes);
          let result = "";
          const skipLeadingNewLine = isSingleLine && isWhiteSpace(value.charCodeAt(0));
          if (printAsMultipleLines && !skipLeadingNewLine || forceLeadingNewLine) {
            result += "\n";
          }
          result += escapedValue;
          if (printAsMultipleLines || forceTrailingNewline) {
            result += "\n";
          }
          return '"""' + result + '"""';
        }
        ;
        function printString(str) {
          return `"${str.replace(escapedRegExp, escapedReplacer)}"`;
        }
        const escapedRegExp = /[\x00-\x1f\x22\x5c\x7f-\x9f]/g;
        function escapedReplacer(str) {
          return escapeSequences[str.charCodeAt(0)];
        }
        const escapeSequences = [
          "\\u0000",
          "\\u0001",
          "\\u0002",
          "\\u0003",
          "\\u0004",
          "\\u0005",
          "\\u0006",
          "\\u0007",
          "\\b",
          "\\t",
          "\\n",
          "\\u000B",
          "\\f",
          "\\r",
          "\\u000E",
          "\\u000F",
          "\\u0010",
          "\\u0011",
          "\\u0012",
          "\\u0013",
          "\\u0014",
          "\\u0015",
          "\\u0016",
          "\\u0017",
          "\\u0018",
          "\\u0019",
          "\\u001A",
          "\\u001B",
          "\\u001C",
          "\\u001D",
          "\\u001E",
          "\\u001F",
          "",
          "",
          '\\"',
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          // 2F
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          // 3F
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          // 4F
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "\\\\",
          "",
          "",
          "",
          // 5F
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          // 6F
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "",
          "\\u007F",
          "\\u0080",
          "\\u0081",
          "\\u0082",
          "\\u0083",
          "\\u0084",
          "\\u0085",
          "\\u0086",
          "\\u0087",
          "\\u0088",
          "\\u0089",
          "\\u008A",
          "\\u008B",
          "\\u008C",
          "\\u008D",
          "\\u008E",
          "\\u008F",
          "\\u0090",
          "\\u0091",
          "\\u0092",
          "\\u0093",
          "\\u0094",
          "\\u0095",
          "\\u0096",
          "\\u0097",
          "\\u0098",
          "\\u0099",
          "\\u009A",
          "\\u009B",
          "\\u009C",
          "\\u009D",
          "\\u009E",
          "\\u009F"
        ];
        ;
        function print(ast) {
          return visitor_visit(ast, printDocASTReducer);
        }
        const MAX_LINE_LENGTH = 80;
        const printDocASTReducer = {
          Name: {
            leave: (node) => node.value
          },
          Variable: {
            leave: (node) => "$" + node.name
          },
          // Document
          Document: {
            leave: (node) => join(node.definitions, "\n\n")
          },
          OperationDefinition: {
            leave(node) {
              const varDefs = wrap("(", join(node.variableDefinitions, ", "), ")");
              const prefix = join(
                [
                  node.operation,
                  join([node.name, varDefs]),
                  join(node.directives, " ")
                ],
                " "
              );
              return (prefix === "query" ? "" : prefix + " ") + node.selectionSet;
            }
          },
          VariableDefinition: {
            leave: ({ variable, type, defaultValue, directives }) => variable + ": " + type + wrap(" = ", defaultValue) + wrap(" ", join(directives, " "))
          },
          SelectionSet: {
            leave: ({ selections }) => block(selections)
          },
          Field: {
            leave({ alias, name, arguments: args, directives, selectionSet }) {
              const prefix = wrap("", alias, ": ") + name;
              let argsLine = prefix + wrap("(", join(args, ", "), ")");
              if (argsLine.length > MAX_LINE_LENGTH) {
                argsLine = prefix + wrap("(\n", indent(join(args, "\n")), "\n)");
              }
              return join([argsLine, join(directives, " "), selectionSet], " ");
            }
          },
          Argument: {
            leave: ({ name, value }) => name + ": " + value
          },
          // Fragments
          FragmentSpread: {
            leave: ({ name, directives }) => "..." + name + wrap(" ", join(directives, " "))
          },
          InlineFragment: {
            leave: ({ typeCondition, directives, selectionSet }) => join(
              [
                "...",
                wrap("on ", typeCondition),
                join(directives, " "),
                selectionSet
              ],
              " "
            )
          },
          FragmentDefinition: {
            leave: ({ name, typeCondition, variableDefinitions, directives, selectionSet }) => (
              // or removed in the future.
              `fragment ${name}${wrap("(", join(variableDefinitions, ", "), ")")} on ${typeCondition} ${wrap("", join(directives, " "), " ")}` + selectionSet
            )
          },
          // Value
          IntValue: {
            leave: ({ value }) => value
          },
          FloatValue: {
            leave: ({ value }) => value
          },
          StringValue: {
            leave: ({ value, block: isBlockString }) => isBlockString ? printBlockString(value) : printString(value)
          },
          BooleanValue: {
            leave: ({ value }) => value ? "true" : "false"
          },
          NullValue: {
            leave: () => "null"
          },
          EnumValue: {
            leave: ({ value }) => value
          },
          ListValue: {
            leave: ({ values }) => "[" + join(values, ", ") + "]"
          },
          ObjectValue: {
            leave: ({ fields }) => "{" + join(fields, ", ") + "}"
          },
          ObjectField: {
            leave: ({ name, value }) => name + ": " + value
          },
          // Directive
          Directive: {
            leave: ({ name, arguments: args }) => "@" + name + wrap("(", join(args, ", "), ")")
          },
          // Type
          NamedType: {
            leave: ({ name }) => name
          },
          ListType: {
            leave: ({ type }) => "[" + type + "]"
          },
          NonNullType: {
            leave: ({ type }) => type + "!"
          },
          // Type System Definitions
          SchemaDefinition: {
            leave: ({ description, directives, operationTypes }) => wrap("", description, "\n") + join(["schema", join(directives, " "), block(operationTypes)], " ")
          },
          OperationTypeDefinition: {
            leave: ({ operation, type }) => operation + ": " + type
          },
          ScalarTypeDefinition: {
            leave: ({ description, name, directives }) => wrap("", description, "\n") + join(["scalar", name, join(directives, " ")], " ")
          },
          ObjectTypeDefinition: {
            leave: ({ description, name, interfaces, directives, fields }) => wrap("", description, "\n") + join(
              [
                "type",
                name,
                wrap("implements ", join(interfaces, " & ")),
                join(directives, " "),
                block(fields)
              ],
              " "
            )
          },
          FieldDefinition: {
            leave: ({ description, name, arguments: args, type, directives }) => wrap("", description, "\n") + name + (hasMultilineItems(args) ? wrap("(\n", indent(join(args, "\n")), "\n)") : wrap("(", join(args, ", "), ")")) + ": " + type + wrap(" ", join(directives, " "))
          },
          InputValueDefinition: {
            leave: ({ description, name, type, defaultValue, directives }) => wrap("", description, "\n") + join(
              [name + ": " + type, wrap("= ", defaultValue), join(directives, " ")],
              " "
            )
          },
          InterfaceTypeDefinition: {
            leave: ({ description, name, interfaces, directives, fields }) => wrap("", description, "\n") + join(
              [
                "interface",
                name,
                wrap("implements ", join(interfaces, " & ")),
                join(directives, " "),
                block(fields)
              ],
              " "
            )
          },
          UnionTypeDefinition: {
            leave: ({ description, name, directives, types }) => wrap("", description, "\n") + join(
              ["union", name, join(directives, " "), wrap("= ", join(types, " | "))],
              " "
            )
          },
          EnumTypeDefinition: {
            leave: ({ description, name, directives, values }) => wrap("", description, "\n") + join(["enum", name, join(directives, " "), block(values)], " ")
          },
          EnumValueDefinition: {
            leave: ({ description, name, directives }) => wrap("", description, "\n") + join([name, join(directives, " ")], " ")
          },
          InputObjectTypeDefinition: {
            leave: ({ description, name, directives, fields }) => wrap("", description, "\n") + join(["input", name, join(directives, " "), block(fields)], " ")
          },
          DirectiveDefinition: {
            leave: ({ description, name, arguments: args, repeatable, locations }) => wrap("", description, "\n") + "directive @" + name + (hasMultilineItems(args) ? wrap("(\n", indent(join(args, "\n")), "\n)") : wrap("(", join(args, ", "), ")")) + (repeatable ? " repeatable" : "") + " on " + join(locations, " | ")
          },
          SchemaExtension: {
            leave: ({ directives, operationTypes }) => join(
              ["extend schema", join(directives, " "), block(operationTypes)],
              " "
            )
          },
          ScalarTypeExtension: {
            leave: ({ name, directives }) => join(["extend scalar", name, join(directives, " ")], " ")
          },
          ObjectTypeExtension: {
            leave: ({ name, interfaces, directives, fields }) => join(
              [
                "extend type",
                name,
                wrap("implements ", join(interfaces, " & ")),
                join(directives, " "),
                block(fields)
              ],
              " "
            )
          },
          InterfaceTypeExtension: {
            leave: ({ name, interfaces, directives, fields }) => join(
              [
                "extend interface",
                name,
                wrap("implements ", join(interfaces, " & ")),
                join(directives, " "),
                block(fields)
              ],
              " "
            )
          },
          UnionTypeExtension: {
            leave: ({ name, directives, types }) => join(
              [
                "extend union",
                name,
                join(directives, " "),
                wrap("= ", join(types, " | "))
              ],
              " "
            )
          },
          EnumTypeExtension: {
            leave: ({ name, directives, values }) => join(["extend enum", name, join(directives, " "), block(values)], " ")
          },
          InputObjectTypeExtension: {
            leave: ({ name, directives, fields }) => join(["extend input", name, join(directives, " "), block(fields)], " ")
          }
        };
        function join(maybeArray, separator = "") {
          var _maybeArray$filter$jo;
          return (_maybeArray$filter$jo = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.filter((x) => x).join(separator)) !== null && _maybeArray$filter$jo !== void 0 ? _maybeArray$filter$jo : "";
        }
        function block(array) {
          return wrap("{\n", indent(join(array, "\n")), "\n}");
        }
        function wrap(start, maybeString, end = "") {
          return maybeString != null && maybeString !== "" ? start + maybeString + end : "";
        }
        function indent(str) {
          return wrap("  ", str.replace(/\n/g, "\n  "));
        }
        function hasMultilineItems(maybeArray) {
          var _maybeArray$some;
          return (_maybeArray$some = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.some((str) => str.includes("\n"))) !== null && _maybeArray$some !== void 0 ? _maybeArray$some : false;
        }
        ;
        ;
        var defaultHttpOptions = {
          includeQuery: true,
          includeExtensions: false,
          preserveHeaderCase: false
        };
        var defaultHeaders = {
          accept: "*/*",
          "content-type": "application/json"
        };
        var defaultOptions = {
          method: "POST"
        };
        var fallbackHttpConfig = {
          http: defaultHttpOptions,
          headers: defaultHeaders,
          options: defaultOptions
        };
        var defaultPrinter = function(ast, printer) {
          return printer(ast);
        };
        function selectHttpOptionsAndBody(operation, fallbackConfig) {
          var configs = [];
          for (var _i = 2; _i < arguments.length; _i++) {
            configs[_i - 2] = arguments[_i];
          }
          configs.unshift(fallbackConfig);
          return selectHttpOptionsAndBodyInternal.apply(void 0, __spreadArray([
            operation,
            defaultPrinter
          ], configs, false));
        }
        function selectHttpOptionsAndBodyInternal(operation, printer) {
          var configs = [];
          for (var _i = 2; _i < arguments.length; _i++) {
            configs[_i - 2] = arguments[_i];
          }
          var options = {};
          var http = {};
          configs.forEach(function(config2) {
            options = tslib_es6_assign(tslib_es6_assign(tslib_es6_assign({}, options), config2.options), { headers: tslib_es6_assign(tslib_es6_assign({}, options.headers), config2.headers) });
            if (config2.credentials) {
              options.credentials = config2.credentials;
            }
            http = tslib_es6_assign(tslib_es6_assign({}, http), config2.http);
          });
          if (options.headers) {
            options.headers = removeDuplicateHeaders(options.headers, http.preserveHeaderCase);
          }
          var operationName = operation.operationName, extensions = operation.extensions, variables = operation.variables, query = operation.query;
          var body = { operationName, variables };
          if (http.includeExtensions)
            body.extensions = extensions;
          if (http.includeQuery)
            body.query = printer(query, print);
          return {
            options,
            body
          };
        }
        ;
        function removeDuplicateHeaders(headers, preserveHeaderCase) {
          if (!preserveHeaderCase) {
            var normalizedHeaders_1 = /* @__PURE__ */ Object.create(null);
            Object.keys(Object(headers)).forEach(function(name) {
              normalizedHeaders_1[name.toLowerCase()] = headers[name];
            });
            return normalizedHeaders_1;
          }
          var headerData = /* @__PURE__ */ Object.create(null);
          Object.keys(Object(headers)).forEach(function(name) {
            headerData[name.toLowerCase()] = { originalName: name, value: headers[name] };
          });
          var normalizedHeaders = /* @__PURE__ */ Object.create(null);
          Object.keys(headerData).forEach(function(name) {
            normalizedHeaders[headerData[name].originalName] = headerData[name].value;
          });
          return normalizedHeaders;
        }
        ;
        var createSignalIfSupported = function() {
          if (typeof AbortController === "undefined")
            return { controller: false, signal: false };
          var controller = new AbortController();
          var signal = controller.signal;
          return { controller, signal };
        };
        ;
        function rewriteURIForGET(chosenURI, body) {
          var queryParams = [];
          var addQueryParam = function(key, value) {
            queryParams.push("".concat(key, "=").concat(encodeURIComponent(value)));
          };
          if ("query" in body) {
            addQueryParam("query", body.query);
          }
          if (body.operationName) {
            addQueryParam("operationName", body.operationName);
          }
          if (body.variables) {
            var serializedVariables = void 0;
            try {
              serializedVariables = serializeFetchParameter(body.variables, "Variables map");
            } catch (parseError) {
              return { parseError };
            }
            addQueryParam("variables", serializedVariables);
          }
          if (body.extensions) {
            var serializedExtensions = void 0;
            try {
              serializedExtensions = serializeFetchParameter(body.extensions, "Extensions map");
            } catch (parseError) {
              return { parseError };
            }
            addQueryParam("extensions", serializedExtensions);
          }
          var fragment = "", preFragment = chosenURI;
          var fragmentStart = chosenURI.indexOf("#");
          if (fragmentStart !== -1) {
            fragment = chosenURI.substr(fragmentStart);
            preFragment = chosenURI.substr(0, fragmentStart);
          }
          var queryParamsPrefix = preFragment.indexOf("?") === -1 ? "?" : "&";
          var newURI = preFragment + queryParamsPrefix + queryParams.join("&") + fragment;
          return { newURI };
        }
        ;
        function fromError(errorValue) {
          return new Observable(function(observer) {
            observer.error(errorValue);
          });
        }
        ;
        var backupFetch = maybe(function() {
          return fetch;
        });
        var createHttpLink = function(linkOptions) {
          if (linkOptions === void 0) {
            linkOptions = {};
          }
          var _a2 = linkOptions.uri, uri = _a2 === void 0 ? "/graphql" : _a2, preferredFetch = linkOptions.fetch, _b = linkOptions.print, print2 = _b === void 0 ? defaultPrinter : _b, includeExtensions = linkOptions.includeExtensions, preserveHeaderCase = linkOptions.preserveHeaderCase, useGETForQueries = linkOptions.useGETForQueries, _c = linkOptions.includeUnusedVariables, includeUnusedVariables = _c === void 0 ? false : _c, requestOptions = __rest(linkOptions, ["uri", "fetch", "print", "includeExtensions", "preserveHeaderCase", "useGETForQueries", "includeUnusedVariables"]);
          if (__DEV__) {
            checkFetcher(preferredFetch || backupFetch);
          }
          var linkConfig = {
            http: { includeExtensions, preserveHeaderCase },
            options: requestOptions.fetchOptions,
            credentials: requestOptions.credentials,
            headers: requestOptions.headers
          };
          return new ApolloLink(function(operation) {
            var chosenURI = selectURI(operation, uri);
            var context2 = operation.getContext();
            var clientAwarenessHeaders = {};
            if (context2.clientAwareness) {
              var _a3 = context2.clientAwareness, name_1 = _a3.name, version2 = _a3.version;
              if (name_1) {
                clientAwarenessHeaders["apollographql-client-name"] = name_1;
              }
              if (version2) {
                clientAwarenessHeaders["apollographql-client-version"] = version2;
              }
            }
            var contextHeaders = tslib_es6_assign(tslib_es6_assign({}, clientAwarenessHeaders), context2.headers);
            var contextConfig = {
              http: context2.http,
              options: context2.fetchOptions,
              credentials: context2.credentials,
              headers: contextHeaders
            };
            var _b2 = selectHttpOptionsAndBodyInternal(operation, print2, fallbackHttpConfig, linkConfig, contextConfig), options = _b2.options, body = _b2.body;
            if (body.variables && !includeUnusedVariables) {
              var unusedNames_1 = new Set(Object.keys(body.variables));
              visitor_visit(operation.query, {
                Variable: function(node, _key, parent) {
                  if (parent && parent.kind !== "VariableDefinition") {
                    unusedNames_1.delete(node.name.value);
                  }
                }
              });
              if (unusedNames_1.size) {
                body.variables = tslib_es6_assign({}, body.variables);
                unusedNames_1.forEach(function(name) {
                  delete body.variables[name];
                });
              }
            }
            var controller;
            if (!options.signal) {
              var _c2 = createSignalIfSupported(), _controller = _c2.controller, signal = _c2.signal;
              controller = _controller;
              if (controller)
                options.signal = signal;
            }
            var definitionIsMutation = function(d) {
              return d.kind === "OperationDefinition" && d.operation === "mutation";
            };
            if (useGETForQueries && !operation.query.definitions.some(definitionIsMutation)) {
              options.method = "GET";
            }
            if (hasDirectives(["defer"], operation.query)) {
              options.headers = options.headers || {};
              options.headers.accept = "multipart/mixed; deferSpec=20220824, application/json";
            }
            if (options.method === "GET") {
              var _d = rewriteURIForGET(chosenURI, body), newURI = _d.newURI, parseError = _d.parseError;
              if (parseError) {
                return fromError(parseError);
              }
              chosenURI = newURI;
            } else {
              try {
                options.body = serializeFetchParameter(body, "Payload");
              } catch (parseError2) {
                return fromError(parseError2);
              }
            }
            return new Observable(function(observer) {
              var currentFetch = preferredFetch || maybe(function() {
                return fetch;
              }) || backupFetch;
              currentFetch(chosenURI, options).then(function(response) {
                var _a4;
                operation.setContext({ response });
                var ctype = (_a4 = response.headers) === null || _a4 === void 0 ? void 0 : _a4.get("content-type");
                if (ctype !== null && /^multipart\/mixed/i.test(ctype)) {
                  return readMultipartBody(response, observer);
                } else {
                  return readJsonBody(response, operation, observer);
                }
              }).catch(function(err) {
                return handleError(err, observer);
              });
              return function() {
                if (controller)
                  controller.abort();
              };
            });
          });
        };
        ;
        var HttpLink = function(_super) {
          __extends(HttpLink2, _super);
          function HttpLink2(options) {
            if (options === void 0) {
              options = {};
            }
            var _this = _super.call(this, createHttpLink(options).request) || this;
            _this.options = options;
            return _this;
          }
          return HttpLink2;
        }(ApolloLink);
        ;
        var equality_esm_a = Object.prototype, equality_esm_toString = equality_esm_a.toString, equality_esm_hasOwnProperty = equality_esm_a.hasOwnProperty;
        var fnToStr = Function.prototype.toString;
        var previousComparisons = /* @__PURE__ */ new Map();
        function equal(a, b) {
          try {
            return check(a, b);
          } finally {
            previousComparisons.clear();
          }
        }
        function check(a, b) {
          if (a === b) {
            return true;
          }
          var aTag = equality_esm_toString.call(a);
          var bTag = equality_esm_toString.call(b);
          if (aTag !== bTag) {
            return false;
          }
          switch (aTag) {
            case "[object Array]":
              if (a.length !== b.length)
                return false;
            case "[object Object]": {
              if (previouslyCompared(a, b))
                return true;
              var aKeys = definedKeys(a);
              var bKeys = definedKeys(b);
              var keyCount = aKeys.length;
              if (keyCount !== bKeys.length)
                return false;
              for (var k = 0; k < keyCount; ++k) {
                if (!equality_esm_hasOwnProperty.call(b, aKeys[k])) {
                  return false;
                }
              }
              for (var k = 0; k < keyCount; ++k) {
                var key = aKeys[k];
                if (!check(a[key], b[key])) {
                  return false;
                }
              }
              return true;
            }
            case "[object Error]":
              return a.name === b.name && a.message === b.message;
            case "[object Number]":
              if (a !== a)
                return b !== b;
            case "[object Boolean]":
            case "[object Date]":
              return +a === +b;
            case "[object RegExp]":
            case "[object String]":
              return a == "".concat(b);
            case "[object Map]":
            case "[object Set]": {
              if (a.size !== b.size)
                return false;
              if (previouslyCompared(a, b))
                return true;
              var aIterator = a.entries();
              var isMap = aTag === "[object Map]";
              while (true) {
                var info = aIterator.next();
                if (info.done)
                  break;
                var _a2 = info.value, aKey = _a2[0], aValue = _a2[1];
                if (!b.has(aKey)) {
                  return false;
                }
                if (isMap && !check(aValue, b.get(aKey))) {
                  return false;
                }
              }
              return true;
            }
            case "[object Uint16Array]":
            case "[object Uint8Array]":
            case "[object Uint32Array]":
            case "[object Int32Array]":
            case "[object Int8Array]":
            case "[object Int16Array]":
            case "[object ArrayBuffer]":
              a = new Uint8Array(a);
              b = new Uint8Array(b);
            case "[object DataView]": {
              var len = a.byteLength;
              if (len === b.byteLength) {
                while (len-- && a[len] === b[len]) {
                }
              }
              return len === -1;
            }
            case "[object AsyncFunction]":
            case "[object GeneratorFunction]":
            case "[object AsyncGeneratorFunction]":
            case "[object Function]": {
              var aCode = fnToStr.call(a);
              if (aCode !== fnToStr.call(b)) {
                return false;
              }
              return !endsWith(aCode, nativeCodeSuffix);
            }
          }
          return false;
        }
        function definedKeys(obj) {
          return Object.keys(obj).filter(isDefinedKey, obj);
        }
        function isDefinedKey(key) {
          return this[key] !== void 0;
        }
        var nativeCodeSuffix = "{ [native code] }";
        function endsWith(full, suffix) {
          var fromIndex = full.length - suffix.length;
          return fromIndex >= 0 && full.indexOf(suffix, fromIndex) === fromIndex;
        }
        function previouslyCompared(a, b) {
          var bSet = previousComparisons.get(a);
          if (bSet) {
            if (bSet.has(b))
              return true;
          } else {
            previousComparisons.set(a, bSet = /* @__PURE__ */ new Set());
          }
          bSet.add(b);
          return false;
        }
        ;
        var arrays_isArray = Array.isArray;
        function isNonEmptyArray(value) {
          return Array.isArray(value) && value.length > 0;
        }
        ;
        var mergeDeep_hasOwnProperty = Object.prototype.hasOwnProperty;
        function mergeDeep() {
          var sources = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            sources[_i] = arguments[_i];
          }
          return mergeDeepArray(sources);
        }
        function mergeDeepArray(sources) {
          var target = sources[0] || {};
          var count = sources.length;
          if (count > 1) {
            var merger = new DeepMerger();
            for (var i2 = 1; i2 < count; ++i2) {
              target = merger.merge(target, sources[i2]);
            }
          }
          return target;
        }
        var defaultReconciler = function(target, source, property) {
          return this.merge(target[property], source[property]);
        };
        var DeepMerger = function() {
          function DeepMerger2(reconciler) {
            if (reconciler === void 0) {
              reconciler = defaultReconciler;
            }
            this.reconciler = reconciler;
            this.isObject = isNonNullObject;
            this.pastCopies = /* @__PURE__ */ new Set();
          }
          DeepMerger2.prototype.merge = function(target, source) {
            var _this = this;
            var context2 = [];
            for (var _i = 2; _i < arguments.length; _i++) {
              context2[_i - 2] = arguments[_i];
            }
            if (isNonNullObject(source) && isNonNullObject(target)) {
              Object.keys(source).forEach(function(sourceKey) {
                if (mergeDeep_hasOwnProperty.call(target, sourceKey)) {
                  var targetValue = target[sourceKey];
                  if (source[sourceKey] !== targetValue) {
                    var result = _this.reconciler.apply(_this, tslib_es6_spreadArray([target, source, sourceKey], context2, false));
                    if (result !== targetValue) {
                      target = _this.shallowCopyForMerge(target);
                      target[sourceKey] = result;
                    }
                  }
                } else {
                  target = _this.shallowCopyForMerge(target);
                  target[sourceKey] = source[sourceKey];
                }
              });
              return target;
            }
            return source;
          };
          DeepMerger2.prototype.shallowCopyForMerge = function(value) {
            if (isNonNullObject(value)) {
              if (!this.pastCopies.has(value)) {
                if (Array.isArray(value)) {
                  value = value.slice(0);
                } else {
                  value = tslib_es6_assign({ __proto__: Object.getPrototypeOf(value) }, value);
                }
                this.pastCopies.add(value);
              }
            }
            return value;
          };
          return DeepMerger2;
        }();
        ;
        function isExecutionPatchIncrementalResult(value) {
          return "incremental" in value;
        }
        function isExecutionPatchInitialResult(value) {
          return "hasNext" in value && "data" in value;
        }
        function isExecutionPatchResult(value) {
          return isExecutionPatchIncrementalResult(value) || isExecutionPatchInitialResult(value);
        }
        function mergeIncrementalData(prevResult, result) {
          var mergedData = prevResult;
          var merger = new DeepMerger();
          if (isExecutionPatchIncrementalResult(result) && isNonEmptyArray(result.incremental)) {
            result.incremental.forEach(function(_a2) {
              var data = _a2.data, path = _a2.path;
              for (var i2 = path.length - 1; i2 >= 0; --i2) {
                var key = path[i2];
                var isNumericKey = !isNaN(+key);
                var parent_1 = isNumericKey ? [] : {};
                parent_1[key] = data;
                data = parent_1;
              }
              mergedData = merger.merge(mergedData, data);
            });
          }
          return mergedData;
        }
        ;
        var defaultMakeData = function() {
          return /* @__PURE__ */ Object.create(null);
        };
        var trie_esm_a = Array.prototype, forEach = trie_esm_a.forEach, slice = trie_esm_a.slice;
        var Trie = (
          /** @class */
          function() {
            function Trie2(weakness, makeData) {
              if (weakness === void 0) {
                weakness = true;
              }
              if (makeData === void 0) {
                makeData = defaultMakeData;
              }
              this.weakness = weakness;
              this.makeData = makeData;
            }
            Trie2.prototype.lookup = function() {
              var array = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                array[_i] = arguments[_i];
              }
              return this.lookupArray(array);
            };
            Trie2.prototype.lookupArray = function(array) {
              var node = this;
              forEach.call(array, function(key) {
                return node = node.getChildTrie(key);
              });
              return node.data || (node.data = this.makeData(slice.call(array)));
            };
            Trie2.prototype.getChildTrie = function(key) {
              var map2 = this.weakness && isObjRef(key) ? this.weak || (this.weak = /* @__PURE__ */ new WeakMap()) : this.strong || (this.strong = /* @__PURE__ */ new Map());
              var child = map2.get(key);
              if (!child)
                map2.set(key, child = new Trie2(this.weakness, this.makeData));
              return child;
            };
            return Trie2;
          }()
        );
        function isObjRef(value) {
          switch (typeof value) {
            case "object":
              if (value === null)
                break;
            case "function":
              return true;
          }
          return false;
        }
        ;
        function shallowCopy(value) {
          if (isNonNullObject(value)) {
            return arrays_isArray(value) ? value.slice(0) : tslib_es6_assign({ __proto__: Object.getPrototypeOf(value) }, value);
          }
          return value;
        }
        var ObjectCanon = function() {
          function ObjectCanon2() {
            this.known = new (canUseWeakSet ? WeakSet : Set)();
            this.pool = new Trie(canUseWeakMap);
            this.passes = /* @__PURE__ */ new WeakMap();
            this.keysByJSON = /* @__PURE__ */ new Map();
            this.empty = this.admit({});
          }
          ObjectCanon2.prototype.isKnown = function(value) {
            return isNonNullObject(value) && this.known.has(value);
          };
          ObjectCanon2.prototype.pass = function(value) {
            if (isNonNullObject(value)) {
              var copy = shallowCopy(value);
              this.passes.set(copy, value);
              return copy;
            }
            return value;
          };
          ObjectCanon2.prototype.admit = function(value) {
            var _this = this;
            if (isNonNullObject(value)) {
              var original = this.passes.get(value);
              if (original)
                return original;
              var proto = Object.getPrototypeOf(value);
              switch (proto) {
                case Array.prototype: {
                  if (this.known.has(value))
                    return value;
                  var array = value.map(this.admit, this);
                  var node = this.pool.lookupArray(array);
                  if (!node.array) {
                    this.known.add(node.array = array);
                    if (__DEV__) {
                      Object.freeze(array);
                    }
                  }
                  return node.array;
                }
                case null:
                case Object.prototype: {
                  if (this.known.has(value))
                    return value;
                  var proto_1 = Object.getPrototypeOf(value);
                  var array_1 = [proto_1];
                  var keys = this.sortedKeys(value);
                  array_1.push(keys.json);
                  var firstValueIndex_1 = array_1.length;
                  keys.sorted.forEach(function(key) {
                    array_1.push(_this.admit(value[key]));
                  });
                  var node = this.pool.lookupArray(array_1);
                  if (!node.object) {
                    var obj_1 = node.object = Object.create(proto_1);
                    this.known.add(obj_1);
                    keys.sorted.forEach(function(key, i2) {
                      obj_1[key] = array_1[firstValueIndex_1 + i2];
                    });
                    if (__DEV__) {
                      Object.freeze(obj_1);
                    }
                  }
                  return node.object;
                }
              }
            }
            return value;
          };
          ObjectCanon2.prototype.sortedKeys = function(obj) {
            var keys = Object.keys(obj);
            var node = this.pool.lookupArray(keys);
            if (!node.keys) {
              keys.sort();
              var json = JSON.stringify(keys);
              if (!(node.keys = this.keysByJSON.get(json))) {
                this.keysByJSON.set(json, node.keys = { sorted: keys, json });
              }
            }
            return node.keys;
          };
          return ObjectCanon2;
        }();
        var canonicalStringify = Object.assign(function(value) {
          if (isNonNullObject(value)) {
            if (stringifyCanon === void 0) {
              resetCanonicalStringify();
            }
            var canonical = stringifyCanon.admit(value);
            var json = stringifyCache.get(canonical);
            if (json === void 0) {
              stringifyCache.set(canonical, json = JSON.stringify(canonical));
            }
            return json;
          }
          return JSON.stringify(value);
        }, {
          reset: resetCanonicalStringify
        });
        var stringifyCanon;
        var stringifyCache;
        function resetCanonicalStringify() {
          stringifyCanon = new ObjectCanon();
          stringifyCache = new (canUseWeakMap ? WeakMap : Map)();
        }
        ;
        function asyncMap(observable, mapFn, catchFn) {
          return new Observable(function(observer) {
            var next = observer.next, error = observer.error, complete = observer.complete;
            var activeCallbackCount = 0;
            var completed = false;
            var promiseQueue = {
              then: function(callback) {
                return new Promise(function(resolve) {
                  return resolve(callback());
                });
              }
            };
            function makeCallback(examiner, delegate) {
              if (examiner) {
                return function(arg) {
                  ++activeCallbackCount;
                  var both = function() {
                    return examiner(arg);
                  };
                  promiseQueue = promiseQueue.then(both, both).then(function(result) {
                    --activeCallbackCount;
                    next && next.call(observer, result);
                    if (completed) {
                      handler.complete();
                    }
                  }, function(error2) {
                    --activeCallbackCount;
                    throw error2;
                  }).catch(function(caught) {
                    error && error.call(observer, caught);
                  });
                };
              } else {
                return function(arg) {
                  return delegate && delegate.call(observer, arg);
                };
              }
            }
            var handler = {
              next: makeCallback(mapFn, next),
              error: makeCallback(catchFn, error),
              complete: function() {
                completed = true;
                if (!activeCallbackCount) {
                  complete && complete.call(observer);
                }
              }
            };
            var sub = observable.subscribe(handler);
            return function() {
              return sub.unsubscribe();
            };
          });
        }
        ;
        function graphQLResultHasError(result) {
          var errors = getGraphQLErrorsFromResult(result);
          return isNonEmptyArray(errors);
        }
        function getGraphQLErrorsFromResult(result) {
          var graphQLErrors = isNonEmptyArray(result.errors) ? result.errors.slice(0) : [];
          if (isExecutionPatchIncrementalResult(result) && isNonEmptyArray(result.incremental)) {
            result.incremental.forEach(function(incrementalResult) {
              if (incrementalResult.errors) {
                graphQLErrors.push.apply(graphQLErrors, incrementalResult.errors);
              }
            });
          }
          return graphQLErrors;
        }
        ;
        var TYPENAME_FIELD = {
          kind: kinds_Kind.FIELD,
          name: {
            kind: kinds_Kind.NAME,
            value: "__typename"
          }
        };
        function isEmpty(op, fragmentMap) {
          return !op || op.selectionSet.selections.every(function(selection) {
            return selection.kind === kinds_Kind.FRAGMENT_SPREAD && isEmpty(fragmentMap[selection.name.value], fragmentMap);
          });
        }
        function nullIfDocIsEmpty(doc) {
          return isEmpty(getOperationDefinition(doc) || getFragmentDefinition(doc), createFragmentMap(getFragmentDefinitions(doc))) ? null : doc;
        }
        function getDirectiveMatcher(directives) {
          var nameSet = /* @__PURE__ */ new Set();
          var tests = [];
          directives.forEach(function(directive) {
            if (directive.name) {
              nameSet.add(directive.name);
            } else if (directive.test) {
              tests.push(directive.test);
            }
          });
          return function(directive) {
            return nameSet.has(directive.name.value) || tests.some(function(test) {
              return test(directive);
            });
          };
        }
        function makeInUseGetterFunction(defaultKey) {
          var map2 = /* @__PURE__ */ new Map();
          return function inUseGetterFunction(key) {
            if (key === void 0) {
              key = defaultKey;
            }
            var inUse = map2.get(key);
            if (!inUse) {
              map2.set(key, inUse = {
                variables: /* @__PURE__ */ new Set(),
                fragmentSpreads: /* @__PURE__ */ new Set()
              });
            }
            return inUse;
          };
        }
        function removeDirectivesFromDocument(directives, doc) {
          var getInUseByOperationName = makeInUseGetterFunction("");
          var getInUseByFragmentName = makeInUseGetterFunction("");
          var getInUse = function(ancestors) {
            for (var p = 0, ancestor = void 0; p < ancestors.length && (ancestor = ancestors[p]); ++p) {
              if (arrays_isArray(ancestor))
                continue;
              if (ancestor.kind === kinds_Kind.OPERATION_DEFINITION) {
                return getInUseByOperationName(ancestor.name && ancestor.name.value);
              }
              if (ancestor.kind === kinds_Kind.FRAGMENT_DEFINITION) {
                return getInUseByFragmentName(ancestor.name.value);
              }
            }
            __DEV__ && invariant.error("Could not find operation or fragment");
            return null;
          };
          var operationCount = 0;
          for (var i2 = doc.definitions.length - 1; i2 >= 0; --i2) {
            if (doc.definitions[i2].kind === kinds_Kind.OPERATION_DEFINITION) {
              ++operationCount;
            }
          }
          var directiveMatcher = getDirectiveMatcher(directives);
          var hasRemoveDirective = directives.some(function(directive) {
            return directive.remove;
          });
          var shouldRemoveField = function(nodeDirectives) {
            return hasRemoveDirective && nodeDirectives && nodeDirectives.some(directiveMatcher);
          };
          var originalFragmentDefsByPath = /* @__PURE__ */ new Map();
          var firstVisitMadeChanges = false;
          var fieldOrInlineFragmentVisitor = {
            enter: function(node) {
              if (shouldRemoveField(node.directives)) {
                firstVisitMadeChanges = true;
                return null;
              }
            }
          };
          var docWithoutDirectiveSubtrees = visitor_visit(doc, {
            Field: fieldOrInlineFragmentVisitor,
            InlineFragment: fieldOrInlineFragmentVisitor,
            VariableDefinition: {
              enter: function() {
                return false;
              }
            },
            Variable: {
              enter: function(node, _key, _parent, _path, ancestors) {
                var inUse = getInUse(ancestors);
                if (inUse) {
                  inUse.variables.add(node.name.value);
                }
              }
            },
            FragmentSpread: {
              enter: function(node, _key, _parent, _path, ancestors) {
                if (shouldRemoveField(node.directives)) {
                  firstVisitMadeChanges = true;
                  return null;
                }
                var inUse = getInUse(ancestors);
                if (inUse) {
                  inUse.fragmentSpreads.add(node.name.value);
                }
              }
            },
            FragmentDefinition: {
              enter: function(node, _key, _parent, path) {
                originalFragmentDefsByPath.set(JSON.stringify(path), node);
              },
              leave: function(node, _key, _parent, path) {
                var originalNode = originalFragmentDefsByPath.get(JSON.stringify(path));
                if (node === originalNode) {
                  return node;
                }
                if (operationCount > 0 && node.selectionSet.selections.every(function(selection) {
                  return selection.kind === kinds_Kind.FIELD && selection.name.value === "__typename";
                })) {
                  getInUseByFragmentName(node.name.value).removed = true;
                  firstVisitMadeChanges = true;
                  return null;
                }
              }
            },
            Directive: {
              leave: function(node) {
                if (directiveMatcher(node)) {
                  firstVisitMadeChanges = true;
                  return null;
                }
              }
            }
          });
          if (!firstVisitMadeChanges) {
            return doc;
          }
          var populateTransitiveVars = function(inUse) {
            if (!inUse.transitiveVars) {
              inUse.transitiveVars = new Set(inUse.variables);
              if (!inUse.removed) {
                inUse.fragmentSpreads.forEach(function(childFragmentName) {
                  populateTransitiveVars(getInUseByFragmentName(childFragmentName)).transitiveVars.forEach(function(varName) {
                    inUse.transitiveVars.add(varName);
                  });
                });
              }
            }
            return inUse;
          };
          var allFragmentNamesUsed = /* @__PURE__ */ new Set();
          docWithoutDirectiveSubtrees.definitions.forEach(function(def) {
            if (def.kind === kinds_Kind.OPERATION_DEFINITION) {
              populateTransitiveVars(getInUseByOperationName(def.name && def.name.value)).fragmentSpreads.forEach(function(childFragmentName) {
                allFragmentNamesUsed.add(childFragmentName);
              });
            } else if (def.kind === kinds_Kind.FRAGMENT_DEFINITION && operationCount === 0 && !getInUseByFragmentName(def.name.value).removed) {
              allFragmentNamesUsed.add(def.name.value);
            }
          });
          allFragmentNamesUsed.forEach(function(fragmentName) {
            populateTransitiveVars(getInUseByFragmentName(fragmentName)).fragmentSpreads.forEach(function(childFragmentName) {
              allFragmentNamesUsed.add(childFragmentName);
            });
          });
          var fragmentWillBeRemoved = function(fragmentName) {
            return !!(!allFragmentNamesUsed.has(fragmentName) || getInUseByFragmentName(fragmentName).removed);
          };
          var enterVisitor = {
            enter: function(node) {
              if (fragmentWillBeRemoved(node.name.value)) {
                return null;
              }
            }
          };
          return nullIfDocIsEmpty(visitor_visit(docWithoutDirectiveSubtrees, {
            FragmentSpread: enterVisitor,
            FragmentDefinition: enterVisitor,
            OperationDefinition: {
              leave: function(node) {
                if (node.variableDefinitions) {
                  var usedVariableNames_1 = populateTransitiveVars(getInUseByOperationName(node.name && node.name.value)).transitiveVars;
                  if (usedVariableNames_1.size < node.variableDefinitions.length) {
                    return tslib_es6_assign(tslib_es6_assign({}, node), { variableDefinitions: node.variableDefinitions.filter(function(varDef) {
                      return usedVariableNames_1.has(varDef.variable.name.value);
                    }) });
                  }
                }
              }
            }
          }));
        }
        var addTypenameToDocument = Object.assign(function(doc) {
          return visitor_visit(doc, {
            SelectionSet: {
              enter: function(node, _key, parent) {
                if (parent && parent.kind === kinds_Kind.OPERATION_DEFINITION) {
                  return;
                }
                var selections = node.selections;
                if (!selections) {
                  return;
                }
                var skip = selections.some(function(selection) {
                  return storeUtils_isField(selection) && (selection.name.value === "__typename" || selection.name.value.lastIndexOf("__", 0) === 0);
                });
                if (skip) {
                  return;
                }
                var field = parent;
                if (storeUtils_isField(field) && field.directives && field.directives.some(function(d) {
                  return d.name.value === "export";
                })) {
                  return;
                }
                return tslib_es6_assign(tslib_es6_assign({}, node), { selections: tslib_es6_spreadArray(tslib_es6_spreadArray([], selections, true), [TYPENAME_FIELD], false) });
              }
            }
          });
        }, {
          added: function(field) {
            return field === TYPENAME_FIELD;
          }
        });
        var connectionRemoveConfig = {
          test: function(directive) {
            var willRemove = directive.name.value === "connection";
            if (willRemove) {
              if (!directive.arguments || !directive.arguments.some(function(arg) {
                return arg.name.value === "key";
              })) {
                __DEV__ && invariant.warn("Removing an @connection directive even though it does not have a key. You may want to use the key parameter to specify a store key.");
              }
            }
            return willRemove;
          }
        };
        function removeConnectionDirectiveFromDocument(doc) {
          return removeDirectivesFromDocument([connectionRemoveConfig], checkDocument(doc));
        }
        function hasDirectivesInSelectionSet(directives, selectionSet, nestedCheck) {
          if (nestedCheck === void 0) {
            nestedCheck = true;
          }
          return !!selectionSet && selectionSet.selections && selectionSet.selections.some(function(selection) {
            return hasDirectivesInSelection(directives, selection, nestedCheck);
          });
        }
        function hasDirectivesInSelection(directives, selection, nestedCheck) {
          if (nestedCheck === void 0) {
            nestedCheck = true;
          }
          if (!isField(selection)) {
            return true;
          }
          if (!selection.directives) {
            return false;
          }
          return selection.directives.some(getDirectiveMatcher(directives)) || nestedCheck && hasDirectivesInSelectionSet(directives, selection.selectionSet, nestedCheck);
        }
        function getArgumentMatcher(config2) {
          return function argumentMatcher(argument) {
            return config2.some(function(aConfig) {
              return argument.value && argument.value.kind === Kind.VARIABLE && argument.value.name && (aConfig.name === argument.value.name.value || aConfig.test && aConfig.test(argument));
            });
          };
        }
        function removeArgumentsFromDocument(config2, doc) {
          var argMatcher = getArgumentMatcher(config2);
          return nullIfDocIsEmpty(visit(doc, {
            OperationDefinition: {
              enter: function(node) {
                return __assign(__assign({}, node), { variableDefinitions: node.variableDefinitions ? node.variableDefinitions.filter(function(varDef) {
                  return !config2.some(function(arg) {
                    return arg.name === varDef.variable.name.value;
                  });
                }) : [] });
              }
            },
            Field: {
              enter: function(node) {
                var shouldRemoveField = config2.some(function(argConfig) {
                  return argConfig.remove;
                });
                if (shouldRemoveField) {
                  var argMatchCount_1 = 0;
                  if (node.arguments) {
                    node.arguments.forEach(function(arg) {
                      if (argMatcher(arg)) {
                        argMatchCount_1 += 1;
                      }
                    });
                  }
                  if (argMatchCount_1 === 1) {
                    return null;
                  }
                }
              }
            },
            Argument: {
              enter: function(node) {
                if (argMatcher(node)) {
                  return null;
                }
              }
            }
          }));
        }
        function removeFragmentSpreadFromDocument(config2, doc) {
          function enter(node) {
            if (config2.some(function(def) {
              return def.name === node.name.value;
            })) {
              return null;
            }
          }
          return nullIfDocIsEmpty(visit(doc, {
            FragmentSpread: { enter },
            FragmentDefinition: { enter }
          }));
        }
        function buildQueryFromSelectionSet(document2) {
          var definition = getMainDefinition(document2);
          var definitionOperation = definition.operation;
          if (definitionOperation === "query") {
            return document2;
          }
          var modifiedDoc = visitor_visit(document2, {
            OperationDefinition: {
              enter: function(node) {
                return tslib_es6_assign(tslib_es6_assign({}, node), { operation: "query" });
              }
            }
          });
          return modifiedDoc;
        }
        function removeClientSetsFromDocument(document2) {
          checkDocument(document2);
          var modifiedDoc = removeDirectivesFromDocument([
            {
              test: function(directive) {
                return directive.name.value === "client";
              },
              remove: true
            }
          ], document2);
          return modifiedDoc;
        }
        ;
        var prefixCounts = /* @__PURE__ */ new Map();
        function makeUniqueId(prefix) {
          var count = prefixCounts.get(prefix) || 1;
          prefixCounts.set(prefix, count + 1);
          return "".concat(prefix, ":").concat(count, ":").concat(Math.random().toString(36).slice(2));
        }
        ;
        function iterateObserversSafely(observers, method, argument) {
          var observersWithMethod = [];
          observers.forEach(function(obs) {
            return obs[method] && observersWithMethod.push(obs);
          });
          observersWithMethod.forEach(function(obs) {
            return obs[method](argument);
          });
        }
        ;
        function fixObservableSubclass(subclass) {
          function set(key) {
            Object.defineProperty(subclass, key, { value: Observable });
          }
          if (canUseSymbol && Symbol.species) {
            set(Symbol.species);
          }
          set("@@species");
          return subclass;
        }
        ;
        function isPromiseLike(value) {
          return value && typeof value.then === "function";
        }
        var Concast = function(_super) {
          __extends(Concast2, _super);
          function Concast2(sources) {
            var _this = _super.call(this, function(observer) {
              _this.addObserver(observer);
              return function() {
                return _this.removeObserver(observer);
              };
            }) || this;
            _this.observers = /* @__PURE__ */ new Set();
            _this.promise = new Promise(function(resolve, reject) {
              _this.resolve = resolve;
              _this.reject = reject;
            });
            _this.handlers = {
              next: function(result) {
                if (_this.sub !== null) {
                  _this.latest = ["next", result];
                  _this.notify("next", result);
                  iterateObserversSafely(_this.observers, "next", result);
                }
              },
              error: function(error) {
                var sub = _this.sub;
                if (sub !== null) {
                  if (sub)
                    setTimeout(function() {
                      return sub.unsubscribe();
                    });
                  _this.sub = null;
                  _this.latest = ["error", error];
                  _this.reject(error);
                  _this.notify("error", error);
                  iterateObserversSafely(_this.observers, "error", error);
                }
              },
              complete: function() {
                var _a2 = _this, sub = _a2.sub, _b = _a2.sources, sources2 = _b === void 0 ? [] : _b;
                if (sub !== null) {
                  var value = sources2.shift();
                  if (!value) {
                    if (sub)
                      setTimeout(function() {
                        return sub.unsubscribe();
                      });
                    _this.sub = null;
                    if (_this.latest && _this.latest[0] === "next") {
                      _this.resolve(_this.latest[1]);
                    } else {
                      _this.resolve();
                    }
                    _this.notify("complete");
                    iterateObserversSafely(_this.observers, "complete");
                  } else if (isPromiseLike(value)) {
                    value.then(function(obs) {
                      return _this.sub = obs.subscribe(_this.handlers);
                    });
                  } else {
                    _this.sub = value.subscribe(_this.handlers);
                  }
                }
              }
            };
            _this.nextResultListeners = /* @__PURE__ */ new Set();
            _this.cancel = function(reason) {
              _this.reject(reason);
              _this.sources = [];
              _this.handlers.complete();
            };
            _this.promise.catch(function(_) {
            });
            if (typeof sources === "function") {
              sources = [new Observable(sources)];
            }
            if (isPromiseLike(sources)) {
              sources.then(function(iterable) {
                return _this.start(iterable);
              }, _this.handlers.error);
            } else {
              _this.start(sources);
            }
            return _this;
          }
          Concast2.prototype.start = function(sources) {
            if (this.sub !== void 0)
              return;
            this.sources = Array.from(sources);
            this.handlers.complete();
          };
          Concast2.prototype.deliverLastMessage = function(observer) {
            if (this.latest) {
              var nextOrError = this.latest[0];
              var method = observer[nextOrError];
              if (method) {
                method.call(observer, this.latest[1]);
              }
              if (this.sub === null && nextOrError === "next" && observer.complete) {
                observer.complete();
              }
            }
          };
          Concast2.prototype.addObserver = function(observer) {
            if (!this.observers.has(observer)) {
              this.deliverLastMessage(observer);
              this.observers.add(observer);
            }
          };
          Concast2.prototype.removeObserver = function(observer) {
            if (this.observers.delete(observer) && this.observers.size < 1) {
              this.handlers.complete();
            }
          };
          Concast2.prototype.notify = function(method, arg) {
            var nextResultListeners = this.nextResultListeners;
            if (nextResultListeners.size) {
              this.nextResultListeners = /* @__PURE__ */ new Set();
              nextResultListeners.forEach(function(listener) {
                return listener(method, arg);
              });
            }
          };
          Concast2.prototype.beforeNext = function(callback) {
            var called = false;
            this.nextResultListeners.add(function(method, arg) {
              if (!called) {
                called = true;
                callback(method, arg);
              }
            });
          };
          return Concast2;
        }(Observable);
        fixObservableSubclass(Concast);
        ;
        function isApolloError(err) {
          return err.hasOwnProperty("graphQLErrors");
        }
        var generateErrorMessage = function(err) {
          var message = "";
          if (isNonEmptyArray(err.graphQLErrors) || isNonEmptyArray(err.clientErrors)) {
            var errors = (err.graphQLErrors || []).concat(err.clientErrors || []);
            errors.forEach(function(error) {
              var errorMessage = error ? error.message : "Error message not found.";
              message += "".concat(errorMessage, "\n");
            });
          }
          if (err.networkError) {
            message += "".concat(err.networkError.message, "\n");
          }
          message = message.replace(/\n$/, "");
          return message;
        };
        var ApolloError = function(_super) {
          __extends(ApolloError2, _super);
          function ApolloError2(_a2) {
            var graphQLErrors = _a2.graphQLErrors, clientErrors = _a2.clientErrors, networkError = _a2.networkError, errorMessage = _a2.errorMessage, extraInfo = _a2.extraInfo;
            var _this = _super.call(this, errorMessage) || this;
            _this.name = "ApolloError";
            _this.graphQLErrors = graphQLErrors || [];
            _this.clientErrors = clientErrors || [];
            _this.networkError = networkError || null;
            _this.message = errorMessage || generateErrorMessage(_this);
            _this.extraInfo = extraInfo;
            _this.__proto__ = ApolloError2.prototype;
            return _this;
          }
          return ApolloError2;
        }(Error);
        ;
        var NetworkStatus;
        (function(NetworkStatus2) {
          NetworkStatus2[NetworkStatus2["loading"] = 1] = "loading";
          NetworkStatus2[NetworkStatus2["setVariables"] = 2] = "setVariables";
          NetworkStatus2[NetworkStatus2["fetchMore"] = 3] = "fetchMore";
          NetworkStatus2[NetworkStatus2["refetch"] = 4] = "refetch";
          NetworkStatus2[NetworkStatus2["poll"] = 6] = "poll";
          NetworkStatus2[NetworkStatus2["ready"] = 7] = "ready";
          NetworkStatus2[NetworkStatus2["error"] = 8] = "error";
        })(NetworkStatus || (NetworkStatus = {}));
        function isNetworkRequestInFlight(networkStatus) {
          return networkStatus ? networkStatus < 7 : false;
        }
        ;
        var cloneDeep_toString = Object.prototype.toString;
        function cloneDeep(value) {
          return cloneDeepHelper(value);
        }
        function cloneDeepHelper(val, seen) {
          switch (cloneDeep_toString.call(val)) {
            case "[object Array]": {
              seen = seen || /* @__PURE__ */ new Map();
              if (seen.has(val))
                return seen.get(val);
              var copy_1 = val.slice(0);
              seen.set(val, copy_1);
              copy_1.forEach(function(child, i2) {
                copy_1[i2] = cloneDeepHelper(child, seen);
              });
              return copy_1;
            }
            case "[object Object]": {
              seen = seen || /* @__PURE__ */ new Map();
              if (seen.has(val))
                return seen.get(val);
              var copy_2 = Object.create(Object.getPrototypeOf(val));
              seen.set(val, copy_2);
              Object.keys(val).forEach(function(key) {
                copy_2[key] = cloneDeepHelper(val[key], seen);
              });
              return copy_2;
            }
            default:
              return val;
          }
        }
        ;
        function compact() {
          var objects = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            objects[_i] = arguments[_i];
          }
          var result = /* @__PURE__ */ Object.create(null);
          objects.forEach(function(obj) {
            if (!obj)
              return;
            Object.keys(obj).forEach(function(key) {
              var value = obj[key];
              if (value !== void 0) {
                result[key] = value;
              }
            });
          });
          return result;
        }
        ;
        var ObservableQuery_assign = Object.assign, ObservableQuery_hasOwnProperty = Object.hasOwnProperty;
        var ObservableQuery = function(_super) {
          __extends(ObservableQuery2, _super);
          function ObservableQuery2(_a2) {
            var queryManager = _a2.queryManager, queryInfo = _a2.queryInfo, options = _a2.options;
            var _this = _super.call(this, function(observer) {
              try {
                var subObserver = observer._subscription._observer;
                if (subObserver && !subObserver.error) {
                  subObserver.error = defaultSubscriptionObserverErrorCallback;
                }
              } catch (_a3) {
              }
              var first = !_this.observers.size;
              _this.observers.add(observer);
              var last = _this.last;
              if (last && last.error) {
                observer.error && observer.error(last.error);
              } else if (last && last.result) {
                observer.next && observer.next(last.result);
              }
              if (first) {
                _this.reobserve().catch(function() {
                });
              }
              return function() {
                if (_this.observers.delete(observer) && !_this.observers.size) {
                  _this.tearDownQuery();
                }
              };
            }) || this;
            _this.observers = /* @__PURE__ */ new Set();
            _this.subscriptions = /* @__PURE__ */ new Set();
            _this.queryInfo = queryInfo;
            _this.queryManager = queryManager;
            _this.isTornDown = false;
            var _b = queryManager.defaultOptions.watchQuery, _c = _b === void 0 ? {} : _b, _d = _c.fetchPolicy, defaultFetchPolicy = _d === void 0 ? "cache-first" : _d;
            var _e = options.fetchPolicy, fetchPolicy = _e === void 0 ? defaultFetchPolicy : _e, _f = options.initialFetchPolicy, initialFetchPolicy = _f === void 0 ? fetchPolicy === "standby" ? defaultFetchPolicy : fetchPolicy : _f;
            _this.options = tslib_es6_assign(tslib_es6_assign({}, options), { initialFetchPolicy, fetchPolicy });
            _this.queryId = queryInfo.queryId || queryManager.generateQueryId();
            var opDef = getOperationDefinition(_this.query);
            _this.queryName = opDef && opDef.name && opDef.name.value;
            return _this;
          }
          Object.defineProperty(ObservableQuery2.prototype, "query", {
            get: function() {
              return this.queryManager.transform(this.options.query).document;
            },
            enumerable: false,
            configurable: true
          });
          Object.defineProperty(ObservableQuery2.prototype, "variables", {
            get: function() {
              return this.options.variables;
            },
            enumerable: false,
            configurable: true
          });
          ObservableQuery2.prototype.result = function() {
            var _this = this;
            return new Promise(function(resolve, reject) {
              var observer = {
                next: function(result) {
                  resolve(result);
                  _this.observers.delete(observer);
                  if (!_this.observers.size) {
                    _this.queryManager.removeQuery(_this.queryId);
                  }
                  setTimeout(function() {
                    subscription.unsubscribe();
                  }, 0);
                },
                error: reject
              };
              var subscription = _this.subscribe(observer);
            });
          };
          ObservableQuery2.prototype.getCurrentResult = function(saveAsLastResult) {
            if (saveAsLastResult === void 0) {
              saveAsLastResult = true;
            }
            var lastResult = this.getLastResult(true);
            var networkStatus = this.queryInfo.networkStatus || lastResult && lastResult.networkStatus || NetworkStatus.ready;
            var result = tslib_es6_assign(tslib_es6_assign({}, lastResult), { loading: isNetworkRequestInFlight(networkStatus), networkStatus });
            var _a2 = this.options.fetchPolicy, fetchPolicy = _a2 === void 0 ? "cache-first" : _a2;
            if (fetchPolicy === "network-only" || fetchPolicy === "no-cache" || fetchPolicy === "standby" || this.queryManager.transform(this.options.query).hasForcedResolvers) {
            } else {
              var diff = this.queryInfo.getDiff();
              if (diff.complete || this.options.returnPartialData) {
                result.data = diff.result;
              }
              if (equal(result.data, {})) {
                result.data = void 0;
              }
              if (diff.complete) {
                delete result.partial;
                if (diff.complete && result.networkStatus === NetworkStatus.loading && (fetchPolicy === "cache-first" || fetchPolicy === "cache-only")) {
                  result.networkStatus = NetworkStatus.ready;
                  result.loading = false;
                }
              } else {
                result.partial = true;
              }
              if (__DEV__ && !diff.complete && !this.options.partialRefetch && !result.loading && !result.data && !result.error) {
                logMissingFieldErrors(diff.missing);
              }
            }
            if (saveAsLastResult) {
              this.updateLastResult(result);
            }
            return result;
          };
          ObservableQuery2.prototype.isDifferentFromLastResult = function(newResult, variables) {
            return !this.last || !equal(this.last.result, newResult) || variables && !equal(this.last.variables, variables);
          };
          ObservableQuery2.prototype.getLast = function(key, variablesMustMatch) {
            var last = this.last;
            if (last && last[key] && (!variablesMustMatch || equal(last.variables, this.variables))) {
              return last[key];
            }
          };
          ObservableQuery2.prototype.getLastResult = function(variablesMustMatch) {
            return this.getLast("result", variablesMustMatch);
          };
          ObservableQuery2.prototype.getLastError = function(variablesMustMatch) {
            return this.getLast("error", variablesMustMatch);
          };
          ObservableQuery2.prototype.resetLastResults = function() {
            delete this.last;
            this.isTornDown = false;
          };
          ObservableQuery2.prototype.resetQueryStoreErrors = function() {
            this.queryManager.resetErrors(this.queryId);
          };
          ObservableQuery2.prototype.refetch = function(variables) {
            var _a2;
            var reobserveOptions = {
              pollInterval: 0
            };
            var fetchPolicy = this.options.fetchPolicy;
            if (fetchPolicy === "cache-and-network") {
              reobserveOptions.fetchPolicy = fetchPolicy;
            } else if (fetchPolicy === "no-cache") {
              reobserveOptions.fetchPolicy = "no-cache";
            } else {
              reobserveOptions.fetchPolicy = "network-only";
            }
            if (__DEV__ && variables && ObservableQuery_hasOwnProperty.call(variables, "variables")) {
              var queryDef = getQueryDefinition(this.query);
              var vars = queryDef.variableDefinitions;
              if (!vars || !vars.some(function(v) {
                return v.variable.name.value === "variables";
              })) {
                __DEV__ && invariant.warn("Called refetch(".concat(JSON.stringify(variables), ") for query ").concat(((_a2 = queryDef.name) === null || _a2 === void 0 ? void 0 : _a2.value) || JSON.stringify(queryDef), ", which does not declare a $variables variable.\nDid you mean to call refetch(variables) instead of refetch({ variables })?"));
              }
            }
            if (variables && !equal(this.options.variables, variables)) {
              reobserveOptions.variables = this.options.variables = tslib_es6_assign(tslib_es6_assign({}, this.options.variables), variables);
            }
            this.queryInfo.resetLastWrite();
            return this.reobserve(reobserveOptions, NetworkStatus.refetch);
          };
          ObservableQuery2.prototype.fetchMore = function(fetchMoreOptions) {
            var _this = this;
            var combinedOptions = tslib_es6_assign(tslib_es6_assign({}, fetchMoreOptions.query ? fetchMoreOptions : tslib_es6_assign(tslib_es6_assign(tslib_es6_assign(tslib_es6_assign({}, this.options), { query: this.query }), fetchMoreOptions), { variables: tslib_es6_assign(tslib_es6_assign({}, this.options.variables), fetchMoreOptions.variables) })), { fetchPolicy: "no-cache" });
            var qid = this.queryManager.generateQueryId();
            var queryInfo = this.queryInfo;
            var originalNetworkStatus = queryInfo.networkStatus;
            queryInfo.networkStatus = NetworkStatus.fetchMore;
            if (combinedOptions.notifyOnNetworkStatusChange) {
              this.observe();
            }
            var updatedQuerySet = /* @__PURE__ */ new Set();
            return this.queryManager.fetchQuery(qid, combinedOptions, NetworkStatus.fetchMore).then(function(fetchMoreResult) {
              _this.queryManager.removeQuery(qid);
              if (queryInfo.networkStatus === NetworkStatus.fetchMore) {
                queryInfo.networkStatus = originalNetworkStatus;
              }
              _this.queryManager.cache.batch({
                update: function(cache) {
                  var updateQuery = fetchMoreOptions.updateQuery;
                  if (updateQuery) {
                    cache.updateQuery({
                      query: _this.query,
                      variables: _this.variables,
                      returnPartialData: true,
                      optimistic: false
                    }, function(previous) {
                      return updateQuery(previous, {
                        fetchMoreResult: fetchMoreResult.data,
                        variables: combinedOptions.variables
                      });
                    });
                  } else {
                    cache.writeQuery({
                      query: combinedOptions.query,
                      variables: combinedOptions.variables,
                      data: fetchMoreResult.data
                    });
                  }
                },
                onWatchUpdated: function(watch) {
                  updatedQuerySet.add(watch.query);
                }
              });
              return fetchMoreResult;
            }).finally(function() {
              if (!updatedQuerySet.has(_this.query)) {
                reobserveCacheFirst(_this);
              }
            });
          };
          ObservableQuery2.prototype.subscribeToMore = function(options) {
            var _this = this;
            var subscription = this.queryManager.startGraphQLSubscription({
              query: options.document,
              variables: options.variables,
              context: options.context
            }).subscribe({
              next: function(subscriptionData) {
                var updateQuery = options.updateQuery;
                if (updateQuery) {
                  _this.updateQuery(function(previous, _a2) {
                    var variables = _a2.variables;
                    return updateQuery(previous, {
                      subscriptionData,
                      variables
                    });
                  });
                }
              },
              error: function(err) {
                if (options.onError) {
                  options.onError(err);
                  return;
                }
                __DEV__ && invariant.error("Unhandled GraphQL subscription error", err);
              }
            });
            this.subscriptions.add(subscription);
            return function() {
              if (_this.subscriptions.delete(subscription)) {
                subscription.unsubscribe();
              }
            };
          };
          ObservableQuery2.prototype.setOptions = function(newOptions) {
            return this.reobserve(newOptions);
          };
          ObservableQuery2.prototype.setVariables = function(variables) {
            if (equal(this.variables, variables)) {
              return this.observers.size ? this.result() : Promise.resolve();
            }
            this.options.variables = variables;
            if (!this.observers.size) {
              return Promise.resolve();
            }
            return this.reobserve({
              fetchPolicy: this.options.initialFetchPolicy,
              variables
            }, NetworkStatus.setVariables);
          };
          ObservableQuery2.prototype.updateQuery = function(mapFn) {
            var queryManager = this.queryManager;
            var result = queryManager.cache.diff({
              query: this.options.query,
              variables: this.variables,
              returnPartialData: true,
              optimistic: false
            }).result;
            var newResult = mapFn(result, {
              variables: this.variables
            });
            if (newResult) {
              queryManager.cache.writeQuery({
                query: this.options.query,
                data: newResult,
                variables: this.variables
              });
              queryManager.broadcastQueries();
            }
          };
          ObservableQuery2.prototype.startPolling = function(pollInterval) {
            this.options.pollInterval = pollInterval;
            this.updatePolling();
          };
          ObservableQuery2.prototype.stopPolling = function() {
            this.options.pollInterval = 0;
            this.updatePolling();
          };
          ObservableQuery2.prototype.applyNextFetchPolicy = function(reason, options) {
            if (options.nextFetchPolicy) {
              var _a2 = options.fetchPolicy, fetchPolicy = _a2 === void 0 ? "cache-first" : _a2, _b = options.initialFetchPolicy, initialFetchPolicy = _b === void 0 ? fetchPolicy : _b;
              if (fetchPolicy === "standby") {
              } else if (typeof options.nextFetchPolicy === "function") {
                options.fetchPolicy = options.nextFetchPolicy(fetchPolicy, {
                  reason,
                  options,
                  observable: this,
                  initialFetchPolicy
                });
              } else if (reason === "variables-changed") {
                options.fetchPolicy = initialFetchPolicy;
              } else {
                options.fetchPolicy = options.nextFetchPolicy;
              }
            }
            return options.fetchPolicy;
          };
          ObservableQuery2.prototype.fetch = function(options, newNetworkStatus) {
            this.queryManager.setObservableQuery(this);
            return this.queryManager.fetchQueryObservable(this.queryId, options, newNetworkStatus);
          };
          ObservableQuery2.prototype.updatePolling = function() {
            var _this = this;
            if (this.queryManager.ssrMode) {
              return;
            }
            var _a2 = this, pollingInfo = _a2.pollingInfo, pollInterval = _a2.options.pollInterval;
            if (!pollInterval) {
              if (pollingInfo) {
                clearTimeout(pollingInfo.timeout);
                delete this.pollingInfo;
              }
              return;
            }
            if (pollingInfo && pollingInfo.interval === pollInterval) {
              return;
            }
            __DEV__ ? invariant(pollInterval, "Attempted to start a polling query without a polling interval.") : invariant(pollInterval, 13);
            var info = pollingInfo || (this.pollingInfo = {});
            info.interval = pollInterval;
            var maybeFetch = function() {
              if (_this.pollingInfo) {
                if (!isNetworkRequestInFlight(_this.queryInfo.networkStatus)) {
                  _this.reobserve({
                    fetchPolicy: _this.options.initialFetchPolicy === "no-cache" ? "no-cache" : "network-only"
                  }, NetworkStatus.poll).then(poll, poll);
                } else {
                  poll();
                }
              }
              ;
            };
            var poll = function() {
              var info2 = _this.pollingInfo;
              if (info2) {
                clearTimeout(info2.timeout);
                info2.timeout = setTimeout(maybeFetch, info2.interval);
              }
            };
            poll();
          };
          ObservableQuery2.prototype.updateLastResult = function(newResult, variables) {
            if (variables === void 0) {
              variables = this.variables;
            }
            this.last = tslib_es6_assign(tslib_es6_assign({}, this.last), { result: this.queryManager.assumeImmutableResults ? newResult : cloneDeep(newResult), variables });
            if (!isNonEmptyArray(newResult.errors)) {
              delete this.last.error;
            }
            return this.last;
          };
          ObservableQuery2.prototype.reobserve = function(newOptions, newNetworkStatus) {
            var _this = this;
            this.isTornDown = false;
            var useDisposableConcast = newNetworkStatus === NetworkStatus.refetch || newNetworkStatus === NetworkStatus.fetchMore || newNetworkStatus === NetworkStatus.poll;
            var oldVariables = this.options.variables;
            var oldFetchPolicy = this.options.fetchPolicy;
            var mergedOptions = compact(this.options, newOptions || {});
            var options = useDisposableConcast ? mergedOptions : ObservableQuery_assign(this.options, mergedOptions);
            if (!useDisposableConcast) {
              this.updatePolling();
              if (newOptions && newOptions.variables && !equal(newOptions.variables, oldVariables) && options.fetchPolicy !== "standby" && options.fetchPolicy === oldFetchPolicy) {
                this.applyNextFetchPolicy("variables-changed", options);
                if (newNetworkStatus === void 0) {
                  newNetworkStatus = NetworkStatus.setVariables;
                }
              }
            }
            var variables = options.variables && tslib_es6_assign({}, options.variables);
            var concast = this.fetch(options, newNetworkStatus);
            var observer = {
              next: function(result) {
                _this.reportResult(result, variables);
              },
              error: function(error) {
                _this.reportError(error, variables);
              }
            };
            if (!useDisposableConcast) {
              if (this.concast && this.observer) {
                this.concast.removeObserver(this.observer);
              }
              this.concast = concast;
              this.observer = observer;
            }
            concast.addObserver(observer);
            return concast.promise;
          };
          ObservableQuery2.prototype.observe = function() {
            this.reportResult(this.getCurrentResult(false), this.variables);
          };
          ObservableQuery2.prototype.reportResult = function(result, variables) {
            var lastError = this.getLastError();
            if (lastError || this.isDifferentFromLastResult(result, variables)) {
              if (lastError || !result.partial || this.options.returnPartialData) {
                this.updateLastResult(result, variables);
              }
              iterateObserversSafely(this.observers, "next", result);
            }
          };
          ObservableQuery2.prototype.reportError = function(error, variables) {
            var errorResult = tslib_es6_assign(tslib_es6_assign({}, this.getLastResult()), { error, errors: error.graphQLErrors, networkStatus: NetworkStatus.error, loading: false });
            this.updateLastResult(errorResult, variables);
            iterateObserversSafely(this.observers, "error", this.last.error = error);
          };
          ObservableQuery2.prototype.hasObservers = function() {
            return this.observers.size > 0;
          };
          ObservableQuery2.prototype.tearDownQuery = function() {
            if (this.isTornDown)
              return;
            if (this.concast && this.observer) {
              this.concast.removeObserver(this.observer);
              delete this.concast;
              delete this.observer;
            }
            this.stopPolling();
            this.subscriptions.forEach(function(sub) {
              return sub.unsubscribe();
            });
            this.subscriptions.clear();
            this.queryManager.stopQuery(this.queryId);
            this.observers.clear();
            this.isTornDown = true;
          };
          return ObservableQuery2;
        }(Observable);
        fixObservableSubclass(ObservableQuery);
        function reobserveCacheFirst(obsQuery) {
          var _a2 = obsQuery.options, fetchPolicy = _a2.fetchPolicy, nextFetchPolicy = _a2.nextFetchPolicy;
          if (fetchPolicy === "cache-and-network" || fetchPolicy === "network-only") {
            return obsQuery.reobserve({
              fetchPolicy: "cache-first",
              nextFetchPolicy: function() {
                this.nextFetchPolicy = nextFetchPolicy;
                if (typeof nextFetchPolicy === "function") {
                  return nextFetchPolicy.apply(this, arguments);
                }
                return fetchPolicy;
              }
            });
          }
          return obsQuery.reobserve();
        }
        function defaultSubscriptionObserverErrorCallback(error) {
          __DEV__ && invariant.error("Unhandled error", error.message, error.stack);
        }
        function logMissingFieldErrors(missing) {
          if (__DEV__ && missing) {
            __DEV__ && invariant.debug("Missing cache result fields: ".concat(JSON.stringify(missing)), missing);
          }
        }
        ;
        function isDefinitionNode(node) {
          return isExecutableDefinitionNode(node) || isTypeSystemDefinitionNode(node) || isTypeSystemExtensionNode(node);
        }
        function isExecutableDefinitionNode(node) {
          return node.kind === Kind.OPERATION_DEFINITION || node.kind === Kind.FRAGMENT_DEFINITION;
        }
        function isSelectionNode(node) {
          return node.kind === kinds_Kind.FIELD || node.kind === kinds_Kind.FRAGMENT_SPREAD || node.kind === kinds_Kind.INLINE_FRAGMENT;
        }
        function isValueNode(node) {
          return node.kind === Kind.VARIABLE || node.kind === Kind.INT || node.kind === Kind.FLOAT || node.kind === Kind.STRING || node.kind === Kind.BOOLEAN || node.kind === Kind.NULL || node.kind === Kind.ENUM || node.kind === Kind.LIST || node.kind === Kind.OBJECT;
        }
        function isConstValueNode(node) {
          return isValueNode(node) && (node.kind === Kind.LIST ? node.values.some(isConstValueNode) : node.kind === Kind.OBJECT ? node.fields.some((field) => isConstValueNode(field.value)) : node.kind !== Kind.VARIABLE);
        }
        function isTypeNode(node) {
          return node.kind === Kind.NAMED_TYPE || node.kind === Kind.LIST_TYPE || node.kind === Kind.NON_NULL_TYPE;
        }
        function isTypeSystemDefinitionNode(node) {
          return node.kind === Kind.SCHEMA_DEFINITION || isTypeDefinitionNode(node) || node.kind === Kind.DIRECTIVE_DEFINITION;
        }
        function isTypeDefinitionNode(node) {
          return node.kind === Kind.SCALAR_TYPE_DEFINITION || node.kind === Kind.OBJECT_TYPE_DEFINITION || node.kind === Kind.INTERFACE_TYPE_DEFINITION || node.kind === Kind.UNION_TYPE_DEFINITION || node.kind === Kind.ENUM_TYPE_DEFINITION || node.kind === Kind.INPUT_OBJECT_TYPE_DEFINITION;
        }
        function isTypeSystemExtensionNode(node) {
          return node.kind === Kind.SCHEMA_EXTENSION || isTypeExtensionNode(node);
        }
        function isTypeExtensionNode(node) {
          return node.kind === Kind.SCALAR_TYPE_EXTENSION || node.kind === Kind.OBJECT_TYPE_EXTENSION || node.kind === Kind.INTERFACE_TYPE_EXTENSION || node.kind === Kind.UNION_TYPE_EXTENSION || node.kind === Kind.ENUM_TYPE_EXTENSION || node.kind === Kind.INPUT_OBJECT_TYPE_EXTENSION;
        }
        ;
        var currentContext = null;
        var MISSING_VALUE = {};
        var idCounter = 1;
        var makeSlotClass = function() {
          return (
            /** @class */
            function() {
              function Slot2() {
                this.id = [
                  "slot",
                  idCounter++,
                  Date.now(),
                  Math.random().toString(36).slice(2)
                ].join(":");
              }
              Slot2.prototype.hasValue = function() {
                for (var context_1 = currentContext; context_1; context_1 = context_1.parent) {
                  if (this.id in context_1.slots) {
                    var value = context_1.slots[this.id];
                    if (value === MISSING_VALUE)
                      break;
                    if (context_1 !== currentContext) {
                      currentContext.slots[this.id] = value;
                    }
                    return true;
                  }
                }
                if (currentContext) {
                  currentContext.slots[this.id] = MISSING_VALUE;
                }
                return false;
              };
              Slot2.prototype.getValue = function() {
                if (this.hasValue()) {
                  return currentContext.slots[this.id];
                }
              };
              Slot2.prototype.withValue = function(value, callback, args, thisArg) {
                var _a2;
                var slots = (_a2 = {
                  __proto__: null
                }, _a2[this.id] = value, _a2);
                var parent = currentContext;
                currentContext = { parent, slots };
                try {
                  return callback.apply(thisArg, args);
                } finally {
                  currentContext = parent;
                }
              };
              Slot2.bind = function(callback) {
                var context2 = currentContext;
                return function() {
                  var saved = currentContext;
                  try {
                    currentContext = context2;
                    return callback.apply(this, arguments);
                  } finally {
                    currentContext = saved;
                  }
                };
              };
              Slot2.noContext = function(callback, args, thisArg) {
                if (currentContext) {
                  var saved = currentContext;
                  try {
                    currentContext = null;
                    return callback.apply(thisArg, args);
                  } finally {
                    currentContext = saved;
                  }
                } else {
                  return callback.apply(thisArg, args);
                }
              };
              return Slot2;
            }()
          );
        };
        function context_esm_maybe(fn) {
          try {
            return fn();
          } catch (ignored) {
          }
        }
        var globalKey = "@wry/context:Slot";
        var host = (
          // Prefer globalThis when available.
          // https://github.com/benjamn/wryware/issues/347
          context_esm_maybe(function() {
            return globalThis;
          }) || // Fall back to global, which works in Node.js and may be converted by some
          // bundlers to the appropriate identifier (window, self, ...) depending on the
          // bundling target. https://github.com/endojs/endo/issues/576#issuecomment-1178515224
          context_esm_maybe(function() {
            return __webpack_require__.g;
          }) || // Otherwise, use a dummy host that's local to this module. We used to fall
          // back to using the Array constructor as a namespace, but that was flagged in
          // https://github.com/benjamn/wryware/issues/347, and can be avoided.
          /* @__PURE__ */ Object.create(null)
        );
        var globalHost = host;
        var Slot = globalHost[globalKey] || // Earlier versions of this package stored the globalKey property on the Array
        // constructor, so we check there as well, to prevent Slot class duplication.
        Array[globalKey] || function(Slot2) {
          try {
            Object.defineProperty(globalHost, globalKey, {
              value: Slot2,
              enumerable: false,
              writable: false,
              // When it was possible for globalHost to be the Array constructor (a
              // legacy Slot dedup strategy), it was important for the property to be
              // configurable:true so it could be deleted. That does not seem to be as
              // important when globalHost is the global object, but I don't want to
              // cause similar problems again, and configurable:true seems safest.
              // https://github.com/endojs/endo/issues/576#issuecomment-1178274008
              configurable: true
            });
          } finally {
            return Slot2;
          }
        }(makeSlotClass());
        var context_esm_bind = Slot.bind, noContext = Slot.noContext;
        function setTimeoutWithContext(callback, delay) {
          return setTimeout(context_esm_bind(callback), delay);
        }
        function asyncFromGen(genFn) {
          return function() {
            var gen = genFn.apply(this, arguments);
            var boundNext = context_esm_bind(gen.next);
            var boundThrow = context_esm_bind(gen.throw);
            return new Promise(function(resolve, reject) {
              function invoke(method, argument) {
                try {
                  var result = method.call(gen, argument);
                } catch (error) {
                  return reject(error);
                }
                var next = result.done ? resolve : invokeNext;
                if (context_esm_isPromiseLike(result.value)) {
                  result.value.then(next, result.done ? reject : invokeThrow);
                } else {
                  next(result.value);
                }
              }
              var invokeNext = function(value) {
                return invoke(boundNext, value);
              };
              var invokeThrow = function(error) {
                return invoke(boundThrow, error);
              };
              invokeNext();
            });
          };
        }
        function context_esm_isPromiseLike(value) {
          return value && typeof value.then === "function";
        }
        var wrappedFibers = (
          /* unused pure expression or super */
          null
        );
        function wrapYieldingFiberMethods(Fiber) {
          if (wrappedFibers.indexOf(Fiber) < 0) {
            var wrap2 = function(obj, method) {
              var fn = obj[method];
              obj[method] = function() {
                return noContext(fn, arguments, this);
              };
            };
            wrap2(Fiber, "yield");
            wrap2(Fiber.prototype, "run");
            wrap2(Fiber.prototype, "throwInto");
            wrappedFibers.push(Fiber);
          }
          return Fiber;
        }
        ;
        function defaultDispose() {
        }
        var Cache = (
          /** @class */
          function() {
            function Cache2(max, dispose) {
              if (max === void 0) {
                max = Infinity;
              }
              if (dispose === void 0) {
                dispose = defaultDispose;
              }
              this.max = max;
              this.dispose = dispose;
              this.map = /* @__PURE__ */ new Map();
              this.newest = null;
              this.oldest = null;
            }
            Cache2.prototype.has = function(key) {
              return this.map.has(key);
            };
            Cache2.prototype.get = function(key) {
              var node = this.getNode(key);
              return node && node.value;
            };
            Cache2.prototype.getNode = function(key) {
              var node = this.map.get(key);
              if (node && node !== this.newest) {
                var older = node.older, newer = node.newer;
                if (newer) {
                  newer.older = older;
                }
                if (older) {
                  older.newer = newer;
                }
                node.older = this.newest;
                node.older.newer = node;
                node.newer = null;
                this.newest = node;
                if (node === this.oldest) {
                  this.oldest = newer;
                }
              }
              return node;
            };
            Cache2.prototype.set = function(key, value) {
              var node = this.getNode(key);
              if (node) {
                return node.value = value;
              }
              node = {
                key,
                value,
                newer: null,
                older: this.newest
              };
              if (this.newest) {
                this.newest.newer = node;
              }
              this.newest = node;
              this.oldest = this.oldest || node;
              this.map.set(key, node);
              return node.value;
            };
            Cache2.prototype.clean = function() {
              while (this.oldest && this.map.size > this.max) {
                this.delete(this.oldest.key);
              }
            };
            Cache2.prototype.delete = function(key) {
              var node = this.map.get(key);
              if (node) {
                if (node === this.newest) {
                  this.newest = node.older;
                }
                if (node === this.oldest) {
                  this.oldest = node.newer;
                }
                if (node.newer) {
                  node.newer.older = node.older;
                }
                if (node.older) {
                  node.older.newer = node.newer;
                }
                this.map.delete(key);
                this.dispose(node.value, key);
                return true;
              }
              return false;
            };
            return Cache2;
          }()
        );
        var parentEntrySlot = new Slot();
        var bundle_esm_a;
        var bundle_esm_hasOwnProperty = Object.prototype.hasOwnProperty;
        var toArray = (bundle_esm_a = Array.from, bundle_esm_a === void 0 ? function(collection) {
          var array = [];
          collection.forEach(function(item) {
            return array.push(item);
          });
          return array;
        } : bundle_esm_a);
        function maybeUnsubscribe(entryOrDep) {
          var unsubscribe = entryOrDep.unsubscribe;
          if (typeof unsubscribe === "function") {
            entryOrDep.unsubscribe = void 0;
            unsubscribe();
          }
        }
        var emptySetPool = [];
        var POOL_TARGET_SIZE = 100;
        function assert(condition, optionalMessage) {
          if (!condition) {
            throw new Error(optionalMessage || "assertion failure");
          }
        }
        function valueIs(a, b) {
          var len = a.length;
          return (
            // Unknown values are not equal to each other.
            len > 0 && // Both values must be ordinary (or both exceptional) to be equal.
            len === b.length && // The underlying value or exception must be the same.
            a[len - 1] === b[len - 1]
          );
        }
        function valueGet(value) {
          switch (value.length) {
            case 0:
              throw new Error("unknown value");
            case 1:
              return value[0];
            case 2:
              throw value[1];
          }
        }
        function valueCopy(value) {
          return value.slice(0);
        }
        var Entry = (
          /** @class */
          function() {
            function Entry2(fn) {
              this.fn = fn;
              this.parents = /* @__PURE__ */ new Set();
              this.childValues = /* @__PURE__ */ new Map();
              this.dirtyChildren = null;
              this.dirty = true;
              this.recomputing = false;
              this.value = [];
              this.deps = null;
              ++Entry2.count;
            }
            Entry2.prototype.peek = function() {
              if (this.value.length === 1 && !mightBeDirty(this)) {
                rememberParent(this);
                return this.value[0];
              }
            };
            Entry2.prototype.recompute = function(args) {
              assert(!this.recomputing, "already recomputing");
              rememberParent(this);
              return mightBeDirty(this) ? reallyRecompute(this, args) : valueGet(this.value);
            };
            Entry2.prototype.setDirty = function() {
              if (this.dirty)
                return;
              this.dirty = true;
              this.value.length = 0;
              reportDirty(this);
              maybeUnsubscribe(this);
            };
            Entry2.prototype.dispose = function() {
              var _this = this;
              this.setDirty();
              forgetChildren(this);
              eachParent(this, function(parent, child) {
                parent.setDirty();
                forgetChild(parent, _this);
              });
            };
            Entry2.prototype.forget = function() {
              this.dispose();
            };
            Entry2.prototype.dependOn = function(dep2) {
              dep2.add(this);
              if (!this.deps) {
                this.deps = emptySetPool.pop() || /* @__PURE__ */ new Set();
              }
              this.deps.add(dep2);
            };
            Entry2.prototype.forgetDeps = function() {
              var _this = this;
              if (this.deps) {
                toArray(this.deps).forEach(function(dep2) {
                  return dep2.delete(_this);
                });
                this.deps.clear();
                emptySetPool.push(this.deps);
                this.deps = null;
              }
            };
            Entry2.count = 0;
            return Entry2;
          }()
        );
        function rememberParent(child) {
          var parent = parentEntrySlot.getValue();
          if (parent) {
            child.parents.add(parent);
            if (!parent.childValues.has(child)) {
              parent.childValues.set(child, []);
            }
            if (mightBeDirty(child)) {
              reportDirtyChild(parent, child);
            } else {
              reportCleanChild(parent, child);
            }
            return parent;
          }
        }
        function reallyRecompute(entry, args) {
          forgetChildren(entry);
          parentEntrySlot.withValue(entry, recomputeNewValue, [entry, args]);
          if (maybeSubscribe(entry, args)) {
            setClean(entry);
          }
          return valueGet(entry.value);
        }
        function recomputeNewValue(entry, args) {
          entry.recomputing = true;
          entry.value.length = 0;
          try {
            entry.value[0] = entry.fn.apply(null, args);
          } catch (e) {
            entry.value[1] = e;
          }
          entry.recomputing = false;
        }
        function mightBeDirty(entry) {
          return entry.dirty || !!(entry.dirtyChildren && entry.dirtyChildren.size);
        }
        function setClean(entry) {
          entry.dirty = false;
          if (mightBeDirty(entry)) {
            return;
          }
          reportClean(entry);
        }
        function reportDirty(child) {
          eachParent(child, reportDirtyChild);
        }
        function reportClean(child) {
          eachParent(child, reportCleanChild);
        }
        function eachParent(child, callback) {
          var parentCount = child.parents.size;
          if (parentCount) {
            var parents = toArray(child.parents);
            for (var i2 = 0; i2 < parentCount; ++i2) {
              callback(parents[i2], child);
            }
          }
        }
        function reportDirtyChild(parent, child) {
          assert(parent.childValues.has(child));
          assert(mightBeDirty(child));
          var parentWasClean = !mightBeDirty(parent);
          if (!parent.dirtyChildren) {
            parent.dirtyChildren = emptySetPool.pop() || /* @__PURE__ */ new Set();
          } else if (parent.dirtyChildren.has(child)) {
            return;
          }
          parent.dirtyChildren.add(child);
          if (parentWasClean) {
            reportDirty(parent);
          }
        }
        function reportCleanChild(parent, child) {
          assert(parent.childValues.has(child));
          assert(!mightBeDirty(child));
          var childValue = parent.childValues.get(child);
          if (childValue.length === 0) {
            parent.childValues.set(child, valueCopy(child.value));
          } else if (!valueIs(childValue, child.value)) {
            parent.setDirty();
          }
          removeDirtyChild(parent, child);
          if (mightBeDirty(parent)) {
            return;
          }
          reportClean(parent);
        }
        function removeDirtyChild(parent, child) {
          var dc = parent.dirtyChildren;
          if (dc) {
            dc.delete(child);
            if (dc.size === 0) {
              if (emptySetPool.length < POOL_TARGET_SIZE) {
                emptySetPool.push(dc);
              }
              parent.dirtyChildren = null;
            }
          }
        }
        function forgetChildren(parent) {
          if (parent.childValues.size > 0) {
            parent.childValues.forEach(function(_value, child) {
              forgetChild(parent, child);
            });
          }
          parent.forgetDeps();
          assert(parent.dirtyChildren === null);
        }
        function forgetChild(parent, child) {
          child.parents.delete(parent);
          parent.childValues.delete(child);
          removeDirtyChild(parent, child);
        }
        function maybeSubscribe(entry, args) {
          if (typeof entry.subscribe === "function") {
            try {
              maybeUnsubscribe(entry);
              entry.unsubscribe = entry.subscribe.apply(null, args);
            } catch (e) {
              entry.setDirty();
              return false;
            }
          }
          return true;
        }
        var EntryMethods = {
          setDirty: true,
          dispose: true,
          forget: true
          // Fully remove parent Entry from LRU cache and computation graph
        };
        function dep(options) {
          var depsByKey = /* @__PURE__ */ new Map();
          var subscribe = options && options.subscribe;
          function depend(key) {
            var parent = parentEntrySlot.getValue();
            if (parent) {
              var dep_1 = depsByKey.get(key);
              if (!dep_1) {
                depsByKey.set(key, dep_1 = /* @__PURE__ */ new Set());
              }
              parent.dependOn(dep_1);
              if (typeof subscribe === "function") {
                maybeUnsubscribe(dep_1);
                dep_1.unsubscribe = subscribe(key);
              }
            }
          }
          depend.dirty = function dirty(key, entryMethodName) {
            var dep2 = depsByKey.get(key);
            if (dep2) {
              var m_1 = entryMethodName && bundle_esm_hasOwnProperty.call(EntryMethods, entryMethodName) ? entryMethodName : "setDirty";
              toArray(dep2).forEach(function(entry) {
                return entry[m_1]();
              });
              depsByKey.delete(key);
              maybeUnsubscribe(dep2);
            }
          };
          return depend;
        }
        function makeDefaultMakeCacheKeyFunction() {
          var keyTrie = new Trie(typeof WeakMap === "function");
          return function() {
            return keyTrie.lookupArray(arguments);
          };
        }
        var defaultMakeCacheKey = makeDefaultMakeCacheKeyFunction();
        var caches = /* @__PURE__ */ new Set();
        function bundle_esm_wrap(originalFunction, options) {
          if (options === void 0) {
            options = /* @__PURE__ */ Object.create(null);
          }
          var cache = new Cache(options.max || Math.pow(2, 16), function(entry) {
            return entry.dispose();
          });
          var keyArgs = options.keyArgs;
          var makeCacheKey = options.makeCacheKey || makeDefaultMakeCacheKeyFunction();
          var optimistic = function() {
            var key = makeCacheKey.apply(null, keyArgs ? keyArgs.apply(null, arguments) : arguments);
            if (key === void 0) {
              return originalFunction.apply(null, arguments);
            }
            var entry = cache.get(key);
            if (!entry) {
              cache.set(key, entry = new Entry(originalFunction));
              entry.subscribe = options.subscribe;
              entry.forget = function() {
                return cache.delete(key);
              };
            }
            var value = entry.recompute(Array.prototype.slice.call(arguments));
            cache.set(key, entry);
            caches.add(cache);
            if (!parentEntrySlot.hasValue()) {
              caches.forEach(function(cache2) {
                return cache2.clean();
              });
              caches.clear();
            }
            return value;
          };
          Object.defineProperty(optimistic, "size", {
            get: function() {
              return cache["map"].size;
            },
            configurable: false,
            enumerable: false
          });
          function dirtyKey(key) {
            var entry = cache.get(key);
            if (entry) {
              entry.setDirty();
            }
          }
          optimistic.dirtyKey = dirtyKey;
          optimistic.dirty = function dirty() {
            dirtyKey(makeCacheKey.apply(null, arguments));
          };
          function peekKey(key) {
            var entry = cache.get(key);
            if (entry) {
              return entry.peek();
            }
          }
          optimistic.peekKey = peekKey;
          optimistic.peek = function peek() {
            return peekKey(makeCacheKey.apply(null, arguments));
          };
          function forgetKey(key) {
            return cache.delete(key);
          }
          optimistic.forgetKey = forgetKey;
          optimistic.forget = function forget() {
            return forgetKey(makeCacheKey.apply(null, arguments));
          };
          optimistic.makeCacheKey = makeCacheKey;
          optimistic.getKey = keyArgs ? function getKey() {
            return makeCacheKey.apply(null, keyArgs.apply(null, arguments));
          } : makeCacheKey;
          return Object.freeze(optimistic);
        }
        ;
        var cacheSlot = new Slot();
        var cacheInfoMap = /* @__PURE__ */ new WeakMap();
        function getCacheInfo(cache) {
          var info = cacheInfoMap.get(cache);
          if (!info) {
            cacheInfoMap.set(cache, info = {
              vars: /* @__PURE__ */ new Set(),
              dep: dep()
            });
          }
          return info;
        }
        function forgetCache(cache) {
          getCacheInfo(cache).vars.forEach(function(rv) {
            return rv.forgetCache(cache);
          });
        }
        function recallCache(cache) {
          getCacheInfo(cache).vars.forEach(function(rv) {
            return rv.attachCache(cache);
          });
        }
        function makeVar(value) {
          var caches2 = /* @__PURE__ */ new Set();
          var listeners = /* @__PURE__ */ new Set();
          var rv = function(newValue) {
            if (arguments.length > 0) {
              if (value !== newValue) {
                value = newValue;
                caches2.forEach(function(cache2) {
                  getCacheInfo(cache2).dep.dirty(rv);
                  broadcast(cache2);
                });
                var oldListeners = Array.from(listeners);
                listeners.clear();
                oldListeners.forEach(function(listener) {
                  return listener(value);
                });
              }
            } else {
              var cache = cacheSlot.getValue();
              if (cache) {
                attach(cache);
                getCacheInfo(cache).dep(rv);
              }
            }
            return value;
          };
          rv.onNextChange = function(listener) {
            listeners.add(listener);
            return function() {
              listeners.delete(listener);
            };
          };
          var attach = rv.attachCache = function(cache) {
            caches2.add(cache);
            getCacheInfo(cache).vars.add(rv);
            return rv;
          };
          rv.forgetCache = function(cache) {
            return caches2.delete(cache);
          };
          return rv;
        }
        function broadcast(cache) {
          if (cache.broadcastWatches) {
            cache.broadcastWatches();
          }
        }
        ;
        var LocalState = function() {
          function LocalState2(_a2) {
            var cache = _a2.cache, client = _a2.client, resolvers = _a2.resolvers, fragmentMatcher = _a2.fragmentMatcher;
            this.selectionsToResolveCache = /* @__PURE__ */ new WeakMap();
            this.cache = cache;
            if (client) {
              this.client = client;
            }
            if (resolvers) {
              this.addResolvers(resolvers);
            }
            if (fragmentMatcher) {
              this.setFragmentMatcher(fragmentMatcher);
            }
          }
          LocalState2.prototype.addResolvers = function(resolvers) {
            var _this = this;
            this.resolvers = this.resolvers || {};
            if (Array.isArray(resolvers)) {
              resolvers.forEach(function(resolverGroup) {
                _this.resolvers = mergeDeep(_this.resolvers, resolverGroup);
              });
            } else {
              this.resolvers = mergeDeep(this.resolvers, resolvers);
            }
          };
          LocalState2.prototype.setResolvers = function(resolvers) {
            this.resolvers = {};
            this.addResolvers(resolvers);
          };
          LocalState2.prototype.getResolvers = function() {
            return this.resolvers || {};
          };
          LocalState2.prototype.runResolvers = function(_a2) {
            var document2 = _a2.document, remoteResult = _a2.remoteResult, context2 = _a2.context, variables = _a2.variables, _b = _a2.onlyRunForcedResolvers, onlyRunForcedResolvers = _b === void 0 ? false : _b;
            return __awaiter(this, void 0, void 0, function() {
              return __generator(this, function(_c) {
                if (document2) {
                  return [2, this.resolveDocument(document2, remoteResult.data, context2, variables, this.fragmentMatcher, onlyRunForcedResolvers).then(function(localResult) {
                    return tslib_es6_assign(tslib_es6_assign({}, remoteResult), { data: localResult.result });
                  })];
                }
                return [2, remoteResult];
              });
            });
          };
          LocalState2.prototype.setFragmentMatcher = function(fragmentMatcher) {
            this.fragmentMatcher = fragmentMatcher;
          };
          LocalState2.prototype.getFragmentMatcher = function() {
            return this.fragmentMatcher;
          };
          LocalState2.prototype.clientQuery = function(document2) {
            if (hasDirectives(["client"], document2)) {
              if (this.resolvers) {
                return document2;
              }
            }
            return null;
          };
          LocalState2.prototype.serverQuery = function(document2) {
            return removeClientSetsFromDocument(document2);
          };
          LocalState2.prototype.prepareContext = function(context2) {
            var cache = this.cache;
            return tslib_es6_assign(tslib_es6_assign({}, context2), { cache, getCacheKey: function(obj) {
              return cache.identify(obj);
            } });
          };
          LocalState2.prototype.addExportedVariables = function(document2, variables, context2) {
            if (variables === void 0) {
              variables = {};
            }
            if (context2 === void 0) {
              context2 = {};
            }
            return __awaiter(this, void 0, void 0, function() {
              return __generator(this, function(_a2) {
                if (document2) {
                  return [2, this.resolveDocument(document2, this.buildRootValueFromCache(document2, variables) || {}, this.prepareContext(context2), variables).then(function(data) {
                    return tslib_es6_assign(tslib_es6_assign({}, variables), data.exportedVariables);
                  })];
                }
                return [2, tslib_es6_assign({}, variables)];
              });
            });
          };
          LocalState2.prototype.shouldForceResolvers = function(document2) {
            var forceResolvers = false;
            visitor_visit(document2, {
              Directive: {
                enter: function(node) {
                  if (node.name.value === "client" && node.arguments) {
                    forceResolvers = node.arguments.some(function(arg) {
                      return arg.name.value === "always" && arg.value.kind === "BooleanValue" && arg.value.value === true;
                    });
                    if (forceResolvers) {
                      return BREAK;
                    }
                  }
                }
              }
            });
            return forceResolvers;
          };
          LocalState2.prototype.buildRootValueFromCache = function(document2, variables) {
            return this.cache.diff({
              query: buildQueryFromSelectionSet(document2),
              variables,
              returnPartialData: true,
              optimistic: false
            }).result;
          };
          LocalState2.prototype.resolveDocument = function(document2, rootValue, context2, variables, fragmentMatcher, onlyRunForcedResolvers) {
            if (context2 === void 0) {
              context2 = {};
            }
            if (variables === void 0) {
              variables = {};
            }
            if (fragmentMatcher === void 0) {
              fragmentMatcher = function() {
                return true;
              };
            }
            if (onlyRunForcedResolvers === void 0) {
              onlyRunForcedResolvers = false;
            }
            return __awaiter(this, void 0, void 0, function() {
              var mainDefinition, fragments, fragmentMap, selectionsToResolve, definitionOperation, defaultOperationType, _a2, cache, client, execContext, isClientFieldDescendant;
              return __generator(this, function(_b) {
                mainDefinition = getMainDefinition(document2);
                fragments = getFragmentDefinitions(document2);
                fragmentMap = createFragmentMap(fragments);
                selectionsToResolve = this.collectSelectionsToResolve(mainDefinition, fragmentMap);
                definitionOperation = mainDefinition.operation;
                defaultOperationType = definitionOperation ? definitionOperation.charAt(0).toUpperCase() + definitionOperation.slice(1) : "Query";
                _a2 = this, cache = _a2.cache, client = _a2.client;
                execContext = {
                  fragmentMap,
                  context: tslib_es6_assign(tslib_es6_assign({}, context2), { cache, client }),
                  variables,
                  fragmentMatcher,
                  defaultOperationType,
                  exportedVariables: {},
                  selectionsToResolve,
                  onlyRunForcedResolvers
                };
                isClientFieldDescendant = false;
                return [2, this.resolveSelectionSet(mainDefinition.selectionSet, isClientFieldDescendant, rootValue, execContext).then(function(result) {
                  return {
                    result,
                    exportedVariables: execContext.exportedVariables
                  };
                })];
              });
            });
          };
          LocalState2.prototype.resolveSelectionSet = function(selectionSet, isClientFieldDescendant, rootValue, execContext) {
            return __awaiter(this, void 0, void 0, function() {
              var fragmentMap, context2, variables, resultsToMerge, execute2;
              var _this = this;
              return __generator(this, function(_a2) {
                fragmentMap = execContext.fragmentMap, context2 = execContext.context, variables = execContext.variables;
                resultsToMerge = [rootValue];
                execute2 = function(selection) {
                  return __awaiter(_this, void 0, void 0, function() {
                    var fragment, typeCondition;
                    return __generator(this, function(_a3) {
                      if (!isClientFieldDescendant && !execContext.selectionsToResolve.has(selection)) {
                        return [2];
                      }
                      if (!shouldInclude(selection, variables)) {
                        return [2];
                      }
                      if (storeUtils_isField(selection)) {
                        return [2, this.resolveField(selection, isClientFieldDescendant, rootValue, execContext).then(function(fieldResult) {
                          var _a4;
                          if (typeof fieldResult !== "undefined") {
                            resultsToMerge.push((_a4 = {}, _a4[resultKeyNameFromField(selection)] = fieldResult, _a4));
                          }
                        })];
                      }
                      if (isInlineFragment(selection)) {
                        fragment = selection;
                      } else {
                        fragment = fragmentMap[selection.name.value];
                        __DEV__ ? invariant(fragment, "No fragment named ".concat(selection.name.value)) : invariant(fragment, 11);
                      }
                      if (fragment && fragment.typeCondition) {
                        typeCondition = fragment.typeCondition.name.value;
                        if (execContext.fragmentMatcher(rootValue, typeCondition, context2)) {
                          return [2, this.resolveSelectionSet(fragment.selectionSet, isClientFieldDescendant, rootValue, execContext).then(function(fragmentResult) {
                            resultsToMerge.push(fragmentResult);
                          })];
                        }
                      }
                      return [2];
                    });
                  });
                };
                return [2, Promise.all(selectionSet.selections.map(execute2)).then(function() {
                  return mergeDeepArray(resultsToMerge);
                })];
              });
            });
          };
          LocalState2.prototype.resolveField = function(field, isClientFieldDescendant, rootValue, execContext) {
            return __awaiter(this, void 0, void 0, function() {
              var variables, fieldName, aliasedFieldName, aliasUsed, defaultResult, resultPromise, resolverType, resolverMap, resolve;
              var _this = this;
              return __generator(this, function(_a2) {
                if (!rootValue) {
                  return [2, null];
                }
                variables = execContext.variables;
                fieldName = field.name.value;
                aliasedFieldName = resultKeyNameFromField(field);
                aliasUsed = fieldName !== aliasedFieldName;
                defaultResult = rootValue[aliasedFieldName] || rootValue[fieldName];
                resultPromise = Promise.resolve(defaultResult);
                if (!execContext.onlyRunForcedResolvers || this.shouldForceResolvers(field)) {
                  resolverType = rootValue.__typename || execContext.defaultOperationType;
                  resolverMap = this.resolvers && this.resolvers[resolverType];
                  if (resolverMap) {
                    resolve = resolverMap[aliasUsed ? fieldName : aliasedFieldName];
                    if (resolve) {
                      resultPromise = Promise.resolve(cacheSlot.withValue(this.cache, resolve, [
                        rootValue,
                        argumentsObjectFromField(field, variables),
                        execContext.context,
                        { field, fragmentMap: execContext.fragmentMap }
                      ]));
                    }
                  }
                }
                return [2, resultPromise.then(function(result) {
                  var _a3, _b;
                  if (result === void 0) {
                    result = defaultResult;
                  }
                  if (field.directives) {
                    field.directives.forEach(function(directive) {
                      if (directive.name.value === "export" && directive.arguments) {
                        directive.arguments.forEach(function(arg) {
                          if (arg.name.value === "as" && arg.value.kind === "StringValue") {
                            execContext.exportedVariables[arg.value.value] = result;
                          }
                        });
                      }
                    });
                  }
                  if (!field.selectionSet) {
                    return result;
                  }
                  if (result == null) {
                    return result;
                  }
                  var isClientField = (_b = (_a3 = field.directives) === null || _a3 === void 0 ? void 0 : _a3.some(function(d) {
                    return d.name.value === "client";
                  })) !== null && _b !== void 0 ? _b : false;
                  if (Array.isArray(result)) {
                    return _this.resolveSubSelectedArray(field, isClientFieldDescendant || isClientField, result, execContext);
                  }
                  if (field.selectionSet) {
                    return _this.resolveSelectionSet(field.selectionSet, isClientFieldDescendant || isClientField, result, execContext);
                  }
                })];
              });
            });
          };
          LocalState2.prototype.resolveSubSelectedArray = function(field, isClientFieldDescendant, result, execContext) {
            var _this = this;
            return Promise.all(result.map(function(item) {
              if (item === null) {
                return null;
              }
              if (Array.isArray(item)) {
                return _this.resolveSubSelectedArray(field, isClientFieldDescendant, item, execContext);
              }
              if (field.selectionSet) {
                return _this.resolveSelectionSet(field.selectionSet, isClientFieldDescendant, item, execContext);
              }
            }));
          };
          LocalState2.prototype.collectSelectionsToResolve = function(mainDefinition, fragmentMap) {
            var isSingleASTNode = function(node) {
              return !Array.isArray(node);
            };
            var selectionsToResolveCache = this.selectionsToResolveCache;
            function collectByDefinition(definitionNode) {
              if (!selectionsToResolveCache.has(definitionNode)) {
                var matches_1 = /* @__PURE__ */ new Set();
                selectionsToResolveCache.set(definitionNode, matches_1);
                visitor_visit(definitionNode, {
                  Directive: function(node, _, __2, ___, ancestors) {
                    if (node.name.value === "client") {
                      ancestors.forEach(function(node2) {
                        if (isSingleASTNode(node2) && isSelectionNode(node2)) {
                          matches_1.add(node2);
                        }
                      });
                    }
                  },
                  FragmentSpread: function(spread, _, __2, ___, ancestors) {
                    var fragment = fragmentMap[spread.name.value];
                    __DEV__ ? invariant(fragment, "No fragment named ".concat(spread.name.value)) : invariant(fragment, 12);
                    var fragmentSelections = collectByDefinition(fragment);
                    if (fragmentSelections.size > 0) {
                      ancestors.forEach(function(node) {
                        if (isSingleASTNode(node) && isSelectionNode(node)) {
                          matches_1.add(node);
                        }
                      });
                      matches_1.add(spread);
                      fragmentSelections.forEach(function(selection) {
                        matches_1.add(selection);
                      });
                    }
                  }
                });
              }
              return selectionsToResolveCache.get(definitionNode);
            }
            return collectByDefinition(mainDefinition);
          };
          return LocalState2;
        }();
        ;
        ;
        var destructiveMethodCounts = new (canUseWeakMap ? WeakMap : Map)();
        function wrapDestructiveCacheMethod(cache, methodName) {
          var original = cache[methodName];
          if (typeof original === "function") {
            cache[methodName] = function() {
              destructiveMethodCounts.set(cache, (destructiveMethodCounts.get(cache) + 1) % 1e15);
              return original.apply(this, arguments);
            };
          }
        }
        function cancelNotifyTimeout(info) {
          if (info["notifyTimeout"]) {
            clearTimeout(info["notifyTimeout"]);
            info["notifyTimeout"] = void 0;
          }
        }
        var QueryInfo = function() {
          function QueryInfo2(queryManager, queryId) {
            if (queryId === void 0) {
              queryId = queryManager.generateQueryId();
            }
            this.queryId = queryId;
            this.listeners = /* @__PURE__ */ new Set();
            this.document = null;
            this.lastRequestId = 1;
            this.subscriptions = /* @__PURE__ */ new Set();
            this.stopped = false;
            this.dirty = false;
            this.observableQuery = null;
            var cache = this.cache = queryManager.cache;
            if (!destructiveMethodCounts.has(cache)) {
              destructiveMethodCounts.set(cache, 0);
              wrapDestructiveCacheMethod(cache, "evict");
              wrapDestructiveCacheMethod(cache, "modify");
              wrapDestructiveCacheMethod(cache, "reset");
            }
          }
          QueryInfo2.prototype.init = function(query) {
            var networkStatus = query.networkStatus || NetworkStatus.loading;
            if (this.variables && this.networkStatus !== NetworkStatus.loading && !equal(this.variables, query.variables)) {
              networkStatus = NetworkStatus.setVariables;
            }
            if (!equal(query.variables, this.variables)) {
              this.lastDiff = void 0;
            }
            Object.assign(this, {
              document: query.document,
              variables: query.variables,
              networkError: null,
              graphQLErrors: this.graphQLErrors || [],
              networkStatus
            });
            if (query.observableQuery) {
              this.setObservableQuery(query.observableQuery);
            }
            if (query.lastRequestId) {
              this.lastRequestId = query.lastRequestId;
            }
            return this;
          };
          QueryInfo2.prototype.reset = function() {
            cancelNotifyTimeout(this);
            this.dirty = false;
          };
          QueryInfo2.prototype.getDiff = function(variables) {
            if (variables === void 0) {
              variables = this.variables;
            }
            var options = this.getDiffOptions(variables);
            if (this.lastDiff && equal(options, this.lastDiff.options)) {
              return this.lastDiff.diff;
            }
            this.updateWatch(this.variables = variables);
            var oq = this.observableQuery;
            if (oq && oq.options.fetchPolicy === "no-cache") {
              return { complete: false };
            }
            var diff = this.cache.diff(options);
            this.updateLastDiff(diff, options);
            return diff;
          };
          QueryInfo2.prototype.updateLastDiff = function(diff, options) {
            this.lastDiff = diff ? {
              diff,
              options: options || this.getDiffOptions()
            } : void 0;
          };
          QueryInfo2.prototype.getDiffOptions = function(variables) {
            var _a2;
            if (variables === void 0) {
              variables = this.variables;
            }
            return {
              query: this.document,
              variables,
              returnPartialData: true,
              optimistic: true,
              canonizeResults: (_a2 = this.observableQuery) === null || _a2 === void 0 ? void 0 : _a2.options.canonizeResults
            };
          };
          QueryInfo2.prototype.setDiff = function(diff) {
            var _this = this;
            var oldDiff = this.lastDiff && this.lastDiff.diff;
            this.updateLastDiff(diff);
            if (!this.dirty && !equal(oldDiff && oldDiff.result, diff && diff.result)) {
              this.dirty = true;
              if (!this.notifyTimeout) {
                this.notifyTimeout = setTimeout(function() {
                  return _this.notify();
                }, 0);
              }
            }
          };
          QueryInfo2.prototype.setObservableQuery = function(oq) {
            var _this = this;
            if (oq === this.observableQuery)
              return;
            if (this.oqListener) {
              this.listeners.delete(this.oqListener);
            }
            this.observableQuery = oq;
            if (oq) {
              oq["queryInfo"] = this;
              this.listeners.add(this.oqListener = function() {
                var diff = _this.getDiff();
                if (diff.fromOptimisticTransaction) {
                  oq["observe"]();
                } else {
                  reobserveCacheFirst(oq);
                }
              });
            } else {
              delete this.oqListener;
            }
          };
          QueryInfo2.prototype.notify = function() {
            var _this = this;
            cancelNotifyTimeout(this);
            if (this.shouldNotify()) {
              this.listeners.forEach(function(listener) {
                return listener(_this);
              });
            }
            this.dirty = false;
          };
          QueryInfo2.prototype.shouldNotify = function() {
            if (!this.dirty || !this.listeners.size) {
              return false;
            }
            if (isNetworkRequestInFlight(this.networkStatus) && this.observableQuery) {
              var fetchPolicy = this.observableQuery.options.fetchPolicy;
              if (fetchPolicy !== "cache-only" && fetchPolicy !== "cache-and-network") {
                return false;
              }
            }
            return true;
          };
          QueryInfo2.prototype.stop = function() {
            if (!this.stopped) {
              this.stopped = true;
              this.reset();
              this.cancel();
              this.cancel = QueryInfo2.prototype.cancel;
              this.subscriptions.forEach(function(sub) {
                return sub.unsubscribe();
              });
              var oq = this.observableQuery;
              if (oq)
                oq.stopPolling();
            }
          };
          QueryInfo2.prototype.cancel = function() {
          };
          QueryInfo2.prototype.updateWatch = function(variables) {
            var _this = this;
            if (variables === void 0) {
              variables = this.variables;
            }
            var oq = this.observableQuery;
            if (oq && oq.options.fetchPolicy === "no-cache") {
              return;
            }
            var watchOptions = tslib_es6_assign(tslib_es6_assign({}, this.getDiffOptions(variables)), { watcher: this, callback: function(diff) {
              return _this.setDiff(diff);
            } });
            if (!this.lastWatch || !equal(watchOptions, this.lastWatch)) {
              this.cancel();
              this.cancel = this.cache.watch(this.lastWatch = watchOptions);
            }
          };
          QueryInfo2.prototype.resetLastWrite = function() {
            this.lastWrite = void 0;
          };
          QueryInfo2.prototype.shouldWrite = function(result, variables) {
            var lastWrite = this.lastWrite;
            return !(lastWrite && lastWrite.dmCount === destructiveMethodCounts.get(this.cache) && equal(variables, lastWrite.variables) && equal(result.data, lastWrite.result.data));
          };
          QueryInfo2.prototype.markResult = function(result, document2, options, cacheWriteBehavior) {
            var _this = this;
            var merger = new DeepMerger();
            var graphQLErrors = isNonEmptyArray(result.errors) ? result.errors.slice(0) : [];
            this.reset();
            if ("incremental" in result && isNonEmptyArray(result.incremental)) {
              var mergedData = mergeIncrementalData(this.getDiff().result, result);
              result.data = mergedData;
            } else if ("hasNext" in result && result.hasNext) {
              var diff = this.getDiff();
              result.data = merger.merge(diff.result, result.data);
            }
            this.graphQLErrors = graphQLErrors;
            if (options.fetchPolicy === "no-cache") {
              this.updateLastDiff({ result: result.data, complete: true }, this.getDiffOptions(options.variables));
            } else if (cacheWriteBehavior !== 0) {
              if (shouldWriteResult(result, options.errorPolicy)) {
                this.cache.performTransaction(function(cache) {
                  if (_this.shouldWrite(result, options.variables)) {
                    cache.writeQuery({
                      query: document2,
                      data: result.data,
                      variables: options.variables,
                      overwrite: cacheWriteBehavior === 1
                    });
                    _this.lastWrite = {
                      result,
                      variables: options.variables,
                      dmCount: destructiveMethodCounts.get(_this.cache)
                    };
                  } else {
                    if (_this.lastDiff && _this.lastDiff.diff.complete) {
                      result.data = _this.lastDiff.diff.result;
                      return;
                    }
                  }
                  var diffOptions = _this.getDiffOptions(options.variables);
                  var diff2 = cache.diff(diffOptions);
                  if (!_this.stopped) {
                    _this.updateWatch(options.variables);
                  }
                  _this.updateLastDiff(diff2, diffOptions);
                  if (diff2.complete) {
                    result.data = diff2.result;
                  }
                });
              } else {
                this.lastWrite = void 0;
              }
            }
          };
          QueryInfo2.prototype.markReady = function() {
            this.networkError = null;
            return this.networkStatus = NetworkStatus.ready;
          };
          QueryInfo2.prototype.markError = function(error) {
            this.networkStatus = NetworkStatus.error;
            this.lastWrite = void 0;
            this.reset();
            if (error.graphQLErrors) {
              this.graphQLErrors = error.graphQLErrors;
            }
            if (error.networkError) {
              this.networkError = error.networkError;
            }
            return error;
          };
          return QueryInfo2;
        }();
        function shouldWriteResult(result, errorPolicy) {
          if (errorPolicy === void 0) {
            errorPolicy = "none";
          }
          var ignoreErrors = errorPolicy === "ignore" || errorPolicy === "all";
          var writeWithErrors = !graphQLResultHasError(result);
          if (!writeWithErrors && ignoreErrors && result.data) {
            writeWithErrors = true;
          }
          return writeWithErrors;
        }
        ;
        var QueryManager_hasOwnProperty = Object.prototype.hasOwnProperty;
        var QueryManager = function() {
          function QueryManager2(_a2) {
            var cache = _a2.cache, link = _a2.link, defaultOptions2 = _a2.defaultOptions, _b = _a2.queryDeduplication, queryDeduplication = _b === void 0 ? false : _b, onBroadcast = _a2.onBroadcast, _c = _a2.ssrMode, ssrMode = _c === void 0 ? false : _c, _d = _a2.clientAwareness, clientAwareness = _d === void 0 ? {} : _d, localState = _a2.localState, assumeImmutableResults = _a2.assumeImmutableResults;
            this.clientAwareness = {};
            this.queries = /* @__PURE__ */ new Map();
            this.fetchCancelFns = /* @__PURE__ */ new Map();
            this.transformCache = new (canUseWeakMap ? WeakMap : Map)();
            this.queryIdCounter = 1;
            this.requestIdCounter = 1;
            this.mutationIdCounter = 1;
            this.inFlightLinkObservables = /* @__PURE__ */ new Map();
            this.cache = cache;
            this.link = link;
            this.defaultOptions = defaultOptions2 || /* @__PURE__ */ Object.create(null);
            this.queryDeduplication = queryDeduplication;
            this.clientAwareness = clientAwareness;
            this.localState = localState || new LocalState({ cache });
            this.ssrMode = ssrMode;
            this.assumeImmutableResults = !!assumeImmutableResults;
            if (this.onBroadcast = onBroadcast) {
              this.mutationStore = /* @__PURE__ */ Object.create(null);
            }
          }
          QueryManager2.prototype.stop = function() {
            var _this = this;
            this.queries.forEach(function(_info, queryId) {
              _this.stopQueryNoBroadcast(queryId);
            });
            this.cancelPendingFetches(__DEV__ ? new InvariantError("QueryManager stopped while query was in flight") : new InvariantError(14));
          };
          QueryManager2.prototype.cancelPendingFetches = function(error) {
            this.fetchCancelFns.forEach(function(cancel) {
              return cancel(error);
            });
            this.fetchCancelFns.clear();
          };
          QueryManager2.prototype.mutate = function(_a2) {
            var _b, _c;
            var mutation = _a2.mutation, variables = _a2.variables, optimisticResponse = _a2.optimisticResponse, updateQueries = _a2.updateQueries, _d = _a2.refetchQueries, refetchQueries = _d === void 0 ? [] : _d, _e = _a2.awaitRefetchQueries, awaitRefetchQueries = _e === void 0 ? false : _e, updateWithProxyFn = _a2.update, onQueryUpdated = _a2.onQueryUpdated, _f = _a2.fetchPolicy, fetchPolicy = _f === void 0 ? ((_b = this.defaultOptions.mutate) === null || _b === void 0 ? void 0 : _b.fetchPolicy) || "network-only" : _f, _g = _a2.errorPolicy, errorPolicy = _g === void 0 ? ((_c = this.defaultOptions.mutate) === null || _c === void 0 ? void 0 : _c.errorPolicy) || "none" : _g, keepRootFields = _a2.keepRootFields, context2 = _a2.context;
            return __awaiter(this, void 0, void 0, function() {
              var mutationId, _h, document2, hasClientExports2, mutationStoreValue, self2;
              return __generator(this, function(_j) {
                switch (_j.label) {
                  case 0:
                    __DEV__ ? invariant(mutation, "mutation option is required. You must specify your GraphQL document in the mutation option.") : invariant(mutation, 15);
                    __DEV__ ? invariant(fetchPolicy === "network-only" || fetchPolicy === "no-cache", "Mutations support only 'network-only' or 'no-cache' fetchPolicy strings. The default `network-only` behavior automatically writes mutation results to the cache. Passing `no-cache` skips the cache write.") : invariant(fetchPolicy === "network-only" || fetchPolicy === "no-cache", 16);
                    mutationId = this.generateMutationId();
                    _h = this.transform(mutation), document2 = _h.document, hasClientExports2 = _h.hasClientExports;
                    mutation = this.cache.transformForLink(document2);
                    variables = this.getVariables(mutation, variables);
                    if (!hasClientExports2)
                      return [3, 2];
                    return [4, this.localState.addExportedVariables(mutation, variables, context2)];
                  case 1:
                    variables = _j.sent();
                    _j.label = 2;
                  case 2:
                    mutationStoreValue = this.mutationStore && (this.mutationStore[mutationId] = {
                      mutation,
                      variables,
                      loading: true,
                      error: null
                    });
                    if (optimisticResponse) {
                      this.markMutationOptimistic(optimisticResponse, {
                        mutationId,
                        document: mutation,
                        variables,
                        fetchPolicy,
                        errorPolicy,
                        context: context2,
                        updateQueries,
                        update: updateWithProxyFn,
                        keepRootFields
                      });
                    }
                    this.broadcastQueries();
                    self2 = this;
                    return [2, new Promise(function(resolve, reject) {
                      return asyncMap(self2.getObservableFromLink(mutation, tslib_es6_assign(tslib_es6_assign({}, context2), { optimisticResponse }), variables, false), function(result) {
                        if (graphQLResultHasError(result) && errorPolicy === "none") {
                          throw new ApolloError({
                            graphQLErrors: getGraphQLErrorsFromResult(result)
                          });
                        }
                        if (mutationStoreValue) {
                          mutationStoreValue.loading = false;
                          mutationStoreValue.error = null;
                        }
                        var storeResult = tslib_es6_assign({}, result);
                        if (typeof refetchQueries === "function") {
                          refetchQueries = refetchQueries(storeResult);
                        }
                        if (errorPolicy === "ignore" && graphQLResultHasError(storeResult)) {
                          delete storeResult.errors;
                        }
                        return self2.markMutationResult({
                          mutationId,
                          result: storeResult,
                          document: mutation,
                          variables,
                          fetchPolicy,
                          errorPolicy,
                          context: context2,
                          update: updateWithProxyFn,
                          updateQueries,
                          awaitRefetchQueries,
                          refetchQueries,
                          removeOptimistic: optimisticResponse ? mutationId : void 0,
                          onQueryUpdated,
                          keepRootFields
                        });
                      }).subscribe({
                        next: function(storeResult) {
                          self2.broadcastQueries();
                          if (!("hasNext" in storeResult) || storeResult.hasNext === false) {
                            resolve(storeResult);
                          }
                        },
                        error: function(err) {
                          if (mutationStoreValue) {
                            mutationStoreValue.loading = false;
                            mutationStoreValue.error = err;
                          }
                          if (optimisticResponse) {
                            self2.cache.removeOptimistic(mutationId);
                          }
                          self2.broadcastQueries();
                          reject(err instanceof ApolloError ? err : new ApolloError({
                            networkError: err
                          }));
                        }
                      });
                    })];
                }
              });
            });
          };
          QueryManager2.prototype.markMutationResult = function(mutation, cache) {
            var _this = this;
            if (cache === void 0) {
              cache = this.cache;
            }
            var result = mutation.result;
            var cacheWrites = [];
            var skipCache = mutation.fetchPolicy === "no-cache";
            if (!skipCache && shouldWriteResult(result, mutation.errorPolicy)) {
              if (!isExecutionPatchIncrementalResult(result)) {
                cacheWrites.push({
                  result: result.data,
                  dataId: "ROOT_MUTATION",
                  query: mutation.document,
                  variables: mutation.variables
                });
              }
              if (isExecutionPatchIncrementalResult(result) && isNonEmptyArray(result.incremental)) {
                var diff = cache.diff({
                  id: "ROOT_MUTATION",
                  query: this.transform(mutation.document).asQuery,
                  variables: mutation.variables,
                  optimistic: false,
                  returnPartialData: true
                });
                var mergedData = void 0;
                if (diff.result) {
                  mergedData = mergeIncrementalData(diff.result, result);
                }
                if (typeof mergedData !== "undefined") {
                  result.data = mergedData;
                  cacheWrites.push({
                    result: mergedData,
                    dataId: "ROOT_MUTATION",
                    query: mutation.document,
                    variables: mutation.variables
                  });
                }
              }
              var updateQueries_1 = mutation.updateQueries;
              if (updateQueries_1) {
                this.queries.forEach(function(_a2, queryId) {
                  var observableQuery = _a2.observableQuery;
                  var queryName = observableQuery && observableQuery.queryName;
                  if (!queryName || !QueryManager_hasOwnProperty.call(updateQueries_1, queryName)) {
                    return;
                  }
                  var updater = updateQueries_1[queryName];
                  var _b = _this.queries.get(queryId), document2 = _b.document, variables = _b.variables;
                  var _c = cache.diff({
                    query: document2,
                    variables,
                    returnPartialData: true,
                    optimistic: false
                  }), currentQueryResult = _c.result, complete = _c.complete;
                  if (complete && currentQueryResult) {
                    var nextQueryResult = updater(currentQueryResult, {
                      mutationResult: result,
                      queryName: document2 && getOperationName(document2) || void 0,
                      queryVariables: variables
                    });
                    if (nextQueryResult) {
                      cacheWrites.push({
                        result: nextQueryResult,
                        dataId: "ROOT_QUERY",
                        query: document2,
                        variables
                      });
                    }
                  }
                });
              }
            }
            if (cacheWrites.length > 0 || mutation.refetchQueries || mutation.update || mutation.onQueryUpdated || mutation.removeOptimistic) {
              var results_1 = [];
              this.refetchQueries({
                updateCache: function(cache2) {
                  if (!skipCache) {
                    cacheWrites.forEach(function(write) {
                      return cache2.write(write);
                    });
                  }
                  var update = mutation.update;
                  var isFinalResult = !isExecutionPatchResult(result) || isExecutionPatchIncrementalResult(result) && !result.hasNext;
                  if (update) {
                    if (!skipCache) {
                      var diff2 = cache2.diff({
                        id: "ROOT_MUTATION",
                        query: _this.transform(mutation.document).asQuery,
                        variables: mutation.variables,
                        optimistic: false,
                        returnPartialData: true
                      });
                      if (diff2.complete) {
                        result = tslib_es6_assign(tslib_es6_assign({}, result), { data: diff2.result });
                        if ("incremental" in result) {
                          delete result.incremental;
                        }
                        if ("hasNext" in result) {
                          delete result.hasNext;
                        }
                      }
                    }
                    if (isFinalResult) {
                      update(cache2, result, {
                        context: mutation.context,
                        variables: mutation.variables
                      });
                    }
                  }
                  if (!skipCache && !mutation.keepRootFields && isFinalResult) {
                    cache2.modify({
                      id: "ROOT_MUTATION",
                      fields: function(value, _a2) {
                        var fieldName = _a2.fieldName, DELETE2 = _a2.DELETE;
                        return fieldName === "__typename" ? value : DELETE2;
                      }
                    });
                  }
                },
                include: mutation.refetchQueries,
                optimistic: false,
                removeOptimistic: mutation.removeOptimistic,
                onQueryUpdated: mutation.onQueryUpdated || null
              }).forEach(function(result2) {
                return results_1.push(result2);
              });
              if (mutation.awaitRefetchQueries || mutation.onQueryUpdated) {
                return Promise.all(results_1).then(function() {
                  return result;
                });
              }
            }
            return Promise.resolve(result);
          };
          QueryManager2.prototype.markMutationOptimistic = function(optimisticResponse, mutation) {
            var _this = this;
            var data = typeof optimisticResponse === "function" ? optimisticResponse(mutation.variables) : optimisticResponse;
            return this.cache.recordOptimisticTransaction(function(cache) {
              try {
                _this.markMutationResult(tslib_es6_assign(tslib_es6_assign({}, mutation), { result: { data } }), cache);
              } catch (error) {
                __DEV__ && invariant.error(error);
              }
            }, mutation.mutationId);
          };
          QueryManager2.prototype.fetchQuery = function(queryId, options, networkStatus) {
            return this.fetchQueryObservable(queryId, options, networkStatus).promise;
          };
          QueryManager2.prototype.getQueryStore = function() {
            var store = /* @__PURE__ */ Object.create(null);
            this.queries.forEach(function(info, queryId) {
              store[queryId] = {
                variables: info.variables,
                networkStatus: info.networkStatus,
                networkError: info.networkError,
                graphQLErrors: info.graphQLErrors
              };
            });
            return store;
          };
          QueryManager2.prototype.resetErrors = function(queryId) {
            var queryInfo = this.queries.get(queryId);
            if (queryInfo) {
              queryInfo.networkError = void 0;
              queryInfo.graphQLErrors = [];
            }
          };
          QueryManager2.prototype.transform = function(document2) {
            var transformCache = this.transformCache;
            if (!transformCache.has(document2)) {
              var transformed = this.cache.transformDocument(document2);
              var noConnection = removeConnectionDirectiveFromDocument(transformed);
              var clientQuery = this.localState.clientQuery(transformed);
              var serverQuery = noConnection && this.localState.serverQuery(noConnection);
              var cacheEntry_1 = {
                document: transformed,
                hasClientExports: hasClientExports(transformed),
                hasForcedResolvers: this.localState.shouldForceResolvers(transformed),
                clientQuery,
                serverQuery,
                defaultVars: getDefaultValues(getOperationDefinition(transformed)),
                asQuery: tslib_es6_assign(tslib_es6_assign({}, transformed), { definitions: transformed.definitions.map(function(def) {
                  if (def.kind === "OperationDefinition" && def.operation !== "query") {
                    return tslib_es6_assign(tslib_es6_assign({}, def), { operation: "query" });
                  }
                  return def;
                }) })
              };
              var add = function(doc) {
                if (doc && !transformCache.has(doc)) {
                  transformCache.set(doc, cacheEntry_1);
                }
              };
              add(document2);
              add(transformed);
              add(clientQuery);
              add(serverQuery);
            }
            return transformCache.get(document2);
          };
          QueryManager2.prototype.getVariables = function(document2, variables) {
            return tslib_es6_assign(tslib_es6_assign({}, this.transform(document2).defaultVars), variables);
          };
          QueryManager2.prototype.watchQuery = function(options) {
            options = tslib_es6_assign(tslib_es6_assign({}, options), { variables: this.getVariables(options.query, options.variables) });
            if (typeof options.notifyOnNetworkStatusChange === "undefined") {
              options.notifyOnNetworkStatusChange = false;
            }
            var queryInfo = new QueryInfo(this);
            var observable = new ObservableQuery({
              queryManager: this,
              queryInfo,
              options
            });
            this.queries.set(observable.queryId, queryInfo);
            queryInfo.init({
              document: observable.query,
              observableQuery: observable,
              variables: observable.variables
            });
            return observable;
          };
          QueryManager2.prototype.query = function(options, queryId) {
            var _this = this;
            if (queryId === void 0) {
              queryId = this.generateQueryId();
            }
            __DEV__ ? invariant(options.query, "query option is required. You must specify your GraphQL document in the query option.") : invariant(options.query, 17);
            __DEV__ ? invariant(options.query.kind === "Document", 'You must wrap the query string in a "gql" tag.') : invariant(options.query.kind === "Document", 18);
            __DEV__ ? invariant(!options.returnPartialData, "returnPartialData option only supported on watchQuery.") : invariant(!options.returnPartialData, 19);
            __DEV__ ? invariant(!options.pollInterval, "pollInterval option only supported on watchQuery.") : invariant(!options.pollInterval, 20);
            return this.fetchQuery(queryId, options).finally(function() {
              return _this.stopQuery(queryId);
            });
          };
          QueryManager2.prototype.generateQueryId = function() {
            return String(this.queryIdCounter++);
          };
          QueryManager2.prototype.generateRequestId = function() {
            return this.requestIdCounter++;
          };
          QueryManager2.prototype.generateMutationId = function() {
            return String(this.mutationIdCounter++);
          };
          QueryManager2.prototype.stopQueryInStore = function(queryId) {
            this.stopQueryInStoreNoBroadcast(queryId);
            this.broadcastQueries();
          };
          QueryManager2.prototype.stopQueryInStoreNoBroadcast = function(queryId) {
            var queryInfo = this.queries.get(queryId);
            if (queryInfo)
              queryInfo.stop();
          };
          QueryManager2.prototype.clearStore = function(options) {
            if (options === void 0) {
              options = {
                discardWatches: true
              };
            }
            this.cancelPendingFetches(__DEV__ ? new InvariantError("Store reset while query was in flight (not completed in link chain)") : new InvariantError(21));
            this.queries.forEach(function(queryInfo) {
              if (queryInfo.observableQuery) {
                queryInfo.networkStatus = NetworkStatus.loading;
              } else {
                queryInfo.stop();
              }
            });
            if (this.mutationStore) {
              this.mutationStore = /* @__PURE__ */ Object.create(null);
            }
            return this.cache.reset(options);
          };
          QueryManager2.prototype.getObservableQueries = function(include) {
            var _this = this;
            if (include === void 0) {
              include = "active";
            }
            var queries = /* @__PURE__ */ new Map();
            var queryNamesAndDocs = /* @__PURE__ */ new Map();
            var legacyQueryOptions = /* @__PURE__ */ new Set();
            if (Array.isArray(include)) {
              include.forEach(function(desc) {
                if (typeof desc === "string") {
                  queryNamesAndDocs.set(desc, false);
                } else if (isDocumentNode(desc)) {
                  queryNamesAndDocs.set(_this.transform(desc).document, false);
                } else if (isNonNullObject(desc) && desc.query) {
                  legacyQueryOptions.add(desc);
                }
              });
            }
            this.queries.forEach(function(_a2, queryId) {
              var oq = _a2.observableQuery, document2 = _a2.document;
              if (oq) {
                if (include === "all") {
                  queries.set(queryId, oq);
                  return;
                }
                var queryName = oq.queryName, fetchPolicy = oq.options.fetchPolicy;
                if (fetchPolicy === "standby" || include === "active" && !oq.hasObservers()) {
                  return;
                }
                if (include === "active" || queryName && queryNamesAndDocs.has(queryName) || document2 && queryNamesAndDocs.has(document2)) {
                  queries.set(queryId, oq);
                  if (queryName)
                    queryNamesAndDocs.set(queryName, true);
                  if (document2)
                    queryNamesAndDocs.set(document2, true);
                }
              }
            });
            if (legacyQueryOptions.size) {
              legacyQueryOptions.forEach(function(options) {
                var queryId = makeUniqueId("legacyOneTimeQuery");
                var queryInfo = _this.getQuery(queryId).init({
                  document: options.query,
                  variables: options.variables
                });
                var oq = new ObservableQuery({
                  queryManager: _this,
                  queryInfo,
                  options: tslib_es6_assign(tslib_es6_assign({}, options), { fetchPolicy: "network-only" })
                });
                invariant(oq.queryId === queryId);
                queryInfo.setObservableQuery(oq);
                queries.set(queryId, oq);
              });
            }
            if (__DEV__ && queryNamesAndDocs.size) {
              queryNamesAndDocs.forEach(function(included, nameOrDoc) {
                if (!included) {
                  __DEV__ && invariant.warn("Unknown query ".concat(typeof nameOrDoc === "string" ? "named " : "").concat(JSON.stringify(nameOrDoc, null, 2), " requested in refetchQueries options.include array"));
                }
              });
            }
            return queries;
          };
          QueryManager2.prototype.reFetchObservableQueries = function(includeStandby) {
            var _this = this;
            if (includeStandby === void 0) {
              includeStandby = false;
            }
            var observableQueryPromises = [];
            this.getObservableQueries(includeStandby ? "all" : "active").forEach(function(observableQuery, queryId) {
              var fetchPolicy = observableQuery.options.fetchPolicy;
              observableQuery.resetLastResults();
              if (includeStandby || fetchPolicy !== "standby" && fetchPolicy !== "cache-only") {
                observableQueryPromises.push(observableQuery.refetch());
              }
              _this.getQuery(queryId).setDiff(null);
            });
            this.broadcastQueries();
            return Promise.all(observableQueryPromises);
          };
          QueryManager2.prototype.setObservableQuery = function(observableQuery) {
            this.getQuery(observableQuery.queryId).setObservableQuery(observableQuery);
          };
          QueryManager2.prototype.startGraphQLSubscription = function(_a2) {
            var _this = this;
            var query = _a2.query, fetchPolicy = _a2.fetchPolicy, errorPolicy = _a2.errorPolicy, variables = _a2.variables, _b = _a2.context, context2 = _b === void 0 ? {} : _b;
            query = this.transform(query).document;
            variables = this.getVariables(query, variables);
            var makeObservable = function(variables2) {
              return _this.getObservableFromLink(query, context2, variables2).map(function(result) {
                if (fetchPolicy !== "no-cache") {
                  if (shouldWriteResult(result, errorPolicy)) {
                    _this.cache.write({
                      query,
                      result: result.data,
                      dataId: "ROOT_SUBSCRIPTION",
                      variables: variables2
                    });
                  }
                  _this.broadcastQueries();
                }
                if (graphQLResultHasError(result)) {
                  throw new ApolloError({
                    graphQLErrors: result.errors
                  });
                }
                return result;
              });
            };
            if (this.transform(query).hasClientExports) {
              var observablePromise_1 = this.localState.addExportedVariables(query, variables, context2).then(makeObservable);
              return new Observable(function(observer) {
                var sub = null;
                observablePromise_1.then(function(observable) {
                  return sub = observable.subscribe(observer);
                }, observer.error);
                return function() {
                  return sub && sub.unsubscribe();
                };
              });
            }
            return makeObservable(variables);
          };
          QueryManager2.prototype.stopQuery = function(queryId) {
            this.stopQueryNoBroadcast(queryId);
            this.broadcastQueries();
          };
          QueryManager2.prototype.stopQueryNoBroadcast = function(queryId) {
            this.stopQueryInStoreNoBroadcast(queryId);
            this.removeQuery(queryId);
          };
          QueryManager2.prototype.removeQuery = function(queryId) {
            this.fetchCancelFns.delete(queryId);
            if (this.queries.has(queryId)) {
              this.getQuery(queryId).stop();
              this.queries.delete(queryId);
            }
          };
          QueryManager2.prototype.broadcastQueries = function() {
            if (this.onBroadcast)
              this.onBroadcast();
            this.queries.forEach(function(info) {
              return info.notify();
            });
          };
          QueryManager2.prototype.getLocalState = function() {
            return this.localState;
          };
          QueryManager2.prototype.getObservableFromLink = function(query, context2, variables, deduplication) {
            var _this = this;
            var _a2;
            if (deduplication === void 0) {
              deduplication = (_a2 = context2 === null || context2 === void 0 ? void 0 : context2.queryDeduplication) !== null && _a2 !== void 0 ? _a2 : this.queryDeduplication;
            }
            var observable;
            var serverQuery = this.transform(query).serverQuery;
            if (serverQuery) {
              var _b = this, inFlightLinkObservables_1 = _b.inFlightLinkObservables, link = _b.link;
              var operation = {
                query: serverQuery,
                variables,
                operationName: getOperationName(serverQuery) || void 0,
                context: this.prepareContext(tslib_es6_assign(tslib_es6_assign({}, context2), { forceFetch: !deduplication }))
              };
              context2 = operation.context;
              if (deduplication) {
                var byVariables_1 = inFlightLinkObservables_1.get(serverQuery) || /* @__PURE__ */ new Map();
                inFlightLinkObservables_1.set(serverQuery, byVariables_1);
                var varJson_1 = canonicalStringify(variables);
                observable = byVariables_1.get(varJson_1);
                if (!observable) {
                  var concast = new Concast([
                    execute(link, operation)
                  ]);
                  byVariables_1.set(varJson_1, observable = concast);
                  concast.beforeNext(function() {
                    if (byVariables_1.delete(varJson_1) && byVariables_1.size < 1) {
                      inFlightLinkObservables_1.delete(serverQuery);
                    }
                  });
                }
              } else {
                observable = new Concast([
                  execute(link, operation)
                ]);
              }
            } else {
              observable = new Concast([
                Observable.of({ data: {} })
              ]);
              context2 = this.prepareContext(context2);
            }
            var clientQuery = this.transform(query).clientQuery;
            if (clientQuery) {
              observable = asyncMap(observable, function(result) {
                return _this.localState.runResolvers({
                  document: clientQuery,
                  remoteResult: result,
                  context: context2,
                  variables
                });
              });
            }
            return observable;
          };
          QueryManager2.prototype.getResultsFromLink = function(queryInfo, cacheWriteBehavior, options) {
            var requestId = queryInfo.lastRequestId = this.generateRequestId();
            var linkDocument = this.cache.transformForLink(this.transform(queryInfo.document).document);
            return asyncMap(this.getObservableFromLink(linkDocument, options.context, options.variables), function(result) {
              var graphQLErrors = getGraphQLErrorsFromResult(result);
              var hasErrors = graphQLErrors.length > 0;
              if (requestId >= queryInfo.lastRequestId) {
                if (hasErrors && options.errorPolicy === "none") {
                  throw queryInfo.markError(new ApolloError({
                    graphQLErrors
                  }));
                }
                queryInfo.markResult(result, linkDocument, options, cacheWriteBehavior);
                queryInfo.markReady();
              }
              var aqr = {
                data: result.data,
                loading: false,
                networkStatus: NetworkStatus.ready
              };
              if (hasErrors && options.errorPolicy !== "ignore") {
                aqr.errors = graphQLErrors;
                aqr.networkStatus = NetworkStatus.error;
              }
              return aqr;
            }, function(networkError) {
              var error = isApolloError(networkError) ? networkError : new ApolloError({ networkError });
              if (requestId >= queryInfo.lastRequestId) {
                queryInfo.markError(error);
              }
              throw error;
            });
          };
          QueryManager2.prototype.fetchQueryObservable = function(queryId, options, networkStatus) {
            var _this = this;
            if (networkStatus === void 0) {
              networkStatus = NetworkStatus.loading;
            }
            var query = this.transform(options.query).document;
            var variables = this.getVariables(query, options.variables);
            var queryInfo = this.getQuery(queryId);
            var defaults = this.defaultOptions.watchQuery;
            var _a2 = options.fetchPolicy, fetchPolicy = _a2 === void 0 ? defaults && defaults.fetchPolicy || "cache-first" : _a2, _b = options.errorPolicy, errorPolicy = _b === void 0 ? defaults && defaults.errorPolicy || "none" : _b, _c = options.returnPartialData, returnPartialData = _c === void 0 ? false : _c, _d = options.notifyOnNetworkStatusChange, notifyOnNetworkStatusChange = _d === void 0 ? false : _d, _e = options.context, context2 = _e === void 0 ? {} : _e;
            var normalized = Object.assign({}, options, {
              query,
              variables,
              fetchPolicy,
              errorPolicy,
              returnPartialData,
              notifyOnNetworkStatusChange,
              context: context2
            });
            var fromVariables = function(variables2) {
              normalized.variables = variables2;
              var concastSources = _this.fetchQueryByPolicy(queryInfo, normalized, networkStatus);
              if (normalized.fetchPolicy !== "standby" && concastSources.length > 0 && queryInfo.observableQuery) {
                queryInfo.observableQuery["applyNextFetchPolicy"]("after-fetch", options);
              }
              return concastSources;
            };
            var cleanupCancelFn = function() {
              return _this.fetchCancelFns.delete(queryId);
            };
            this.fetchCancelFns.set(queryId, function(reason) {
              cleanupCancelFn();
              setTimeout(function() {
                return concast.cancel(reason);
              });
            });
            var concast = new Concast(this.transform(normalized.query).hasClientExports ? this.localState.addExportedVariables(normalized.query, normalized.variables, normalized.context).then(fromVariables) : fromVariables(normalized.variables));
            concast.promise.then(cleanupCancelFn, cleanupCancelFn);
            return concast;
          };
          QueryManager2.prototype.refetchQueries = function(_a2) {
            var _this = this;
            var updateCache = _a2.updateCache, include = _a2.include, _b = _a2.optimistic, optimistic = _b === void 0 ? false : _b, _c = _a2.removeOptimistic, removeOptimistic = _c === void 0 ? optimistic ? makeUniqueId("refetchQueries") : void 0 : _c, onQueryUpdated = _a2.onQueryUpdated;
            var includedQueriesById = /* @__PURE__ */ new Map();
            if (include) {
              this.getObservableQueries(include).forEach(function(oq, queryId) {
                includedQueriesById.set(queryId, {
                  oq,
                  lastDiff: _this.getQuery(queryId).getDiff()
                });
              });
            }
            var results = /* @__PURE__ */ new Map();
            if (updateCache) {
              this.cache.batch({
                update: updateCache,
                optimistic: optimistic && removeOptimistic || false,
                removeOptimistic,
                onWatchUpdated: function(watch, diff, lastDiff) {
                  var oq = watch.watcher instanceof QueryInfo && watch.watcher.observableQuery;
                  if (oq) {
                    if (onQueryUpdated) {
                      includedQueriesById.delete(oq.queryId);
                      var result = onQueryUpdated(oq, diff, lastDiff);
                      if (result === true) {
                        result = oq.refetch();
                      }
                      if (result !== false) {
                        results.set(oq, result);
                      }
                      return result;
                    }
                    if (onQueryUpdated !== null) {
                      includedQueriesById.set(oq.queryId, { oq, lastDiff, diff });
                    }
                  }
                }
              });
            }
            if (includedQueriesById.size) {
              includedQueriesById.forEach(function(_a3, queryId) {
                var oq = _a3.oq, lastDiff = _a3.lastDiff, diff = _a3.diff;
                var result;
                if (onQueryUpdated) {
                  if (!diff) {
                    var info = oq["queryInfo"];
                    info.reset();
                    diff = info.getDiff();
                  }
                  result = onQueryUpdated(oq, diff, lastDiff);
                }
                if (!onQueryUpdated || result === true) {
                  result = oq.refetch();
                }
                if (result !== false) {
                  results.set(oq, result);
                }
                if (queryId.indexOf("legacyOneTimeQuery") >= 0) {
                  _this.stopQueryNoBroadcast(queryId);
                }
              });
            }
            if (removeOptimistic) {
              this.cache.removeOptimistic(removeOptimistic);
            }
            return results;
          };
          QueryManager2.prototype.fetchQueryByPolicy = function(queryInfo, _a2, networkStatus) {
            var _this = this;
            var query = _a2.query, variables = _a2.variables, fetchPolicy = _a2.fetchPolicy, refetchWritePolicy = _a2.refetchWritePolicy, errorPolicy = _a2.errorPolicy, returnPartialData = _a2.returnPartialData, context2 = _a2.context, notifyOnNetworkStatusChange = _a2.notifyOnNetworkStatusChange;
            var oldNetworkStatus = queryInfo.networkStatus;
            queryInfo.init({
              document: this.transform(query).document,
              variables,
              networkStatus
            });
            var readCache = function() {
              return queryInfo.getDiff(variables);
            };
            var resultsFromCache = function(diff2, networkStatus2) {
              if (networkStatus2 === void 0) {
                networkStatus2 = queryInfo.networkStatus || NetworkStatus.loading;
              }
              var data = diff2.result;
              if (__DEV__ && !returnPartialData && !equal(data, {})) {
                logMissingFieldErrors(diff2.missing);
              }
              var fromData = function(data2) {
                return Observable.of(tslib_es6_assign({ data: data2, loading: isNetworkRequestInFlight(networkStatus2), networkStatus: networkStatus2 }, diff2.complete ? null : { partial: true }));
              };
              if (data && _this.transform(query).hasForcedResolvers) {
                return _this.localState.runResolvers({
                  document: query,
                  remoteResult: { data },
                  context: context2,
                  variables,
                  onlyRunForcedResolvers: true
                }).then(function(resolved) {
                  return fromData(resolved.data || void 0);
                });
              }
              if (errorPolicy === "none" && networkStatus2 === NetworkStatus.refetch && Array.isArray(diff2.missing)) {
                return fromData(void 0);
              }
              return fromData(data);
            };
            var cacheWriteBehavior = fetchPolicy === "no-cache" ? 0 : networkStatus === NetworkStatus.refetch && refetchWritePolicy !== "merge" ? 1 : 2;
            var resultsFromLink = function() {
              return _this.getResultsFromLink(queryInfo, cacheWriteBehavior, {
                variables,
                context: context2,
                fetchPolicy,
                errorPolicy
              });
            };
            var shouldNotify = notifyOnNetworkStatusChange && typeof oldNetworkStatus === "number" && oldNetworkStatus !== networkStatus && isNetworkRequestInFlight(networkStatus);
            switch (fetchPolicy) {
              default:
              case "cache-first": {
                var diff = readCache();
                if (diff.complete) {
                  return [
                    resultsFromCache(diff, queryInfo.markReady())
                  ];
                }
                if (returnPartialData || shouldNotify) {
                  return [
                    resultsFromCache(diff),
                    resultsFromLink()
                  ];
                }
                return [
                  resultsFromLink()
                ];
              }
              case "cache-and-network": {
                var diff = readCache();
                if (diff.complete || returnPartialData || shouldNotify) {
                  return [
                    resultsFromCache(diff),
                    resultsFromLink()
                  ];
                }
                return [
                  resultsFromLink()
                ];
              }
              case "cache-only":
                return [
                  resultsFromCache(readCache(), queryInfo.markReady())
                ];
              case "network-only":
                if (shouldNotify) {
                  return [
                    resultsFromCache(readCache()),
                    resultsFromLink()
                  ];
                }
                return [resultsFromLink()];
              case "no-cache":
                if (shouldNotify) {
                  return [
                    resultsFromCache(queryInfo.getDiff()),
                    resultsFromLink()
                  ];
                }
                return [resultsFromLink()];
              case "standby":
                return [];
            }
          };
          QueryManager2.prototype.getQuery = function(queryId) {
            if (queryId && !this.queries.has(queryId)) {
              this.queries.set(queryId, new QueryInfo(this, queryId));
            }
            return this.queries.get(queryId);
          };
          QueryManager2.prototype.prepareContext = function(context2) {
            if (context2 === void 0) {
              context2 = {};
            }
            var newContext = this.localState.prepareContext(context2);
            return tslib_es6_assign(tslib_es6_assign({}, newContext), { clientAwareness: this.clientAwareness });
          };
          return QueryManager2;
        }();
        ;
        function mergeOptions(defaults, options) {
          return compact(defaults, options, options.variables && {
            variables: tslib_es6_assign(tslib_es6_assign({}, defaults && defaults.variables), options.variables)
          });
        }
        ;
        var hasSuggestedDevtools = false;
        var ApolloClient = function() {
          function ApolloClient2(options) {
            var _this = this;
            this.resetStoreCallbacks = [];
            this.clearStoreCallbacks = [];
            var uri = options.uri, credentials = options.credentials, headers = options.headers, cache = options.cache, _a2 = options.ssrMode, ssrMode = _a2 === void 0 ? false : _a2, _b = options.ssrForceFetchDelay, ssrForceFetchDelay = _b === void 0 ? 0 : _b, _c = options.connectToDevTools, connectToDevTools = _c === void 0 ? typeof window === "object" && !window.__APOLLO_CLIENT__ && __DEV__ : _c, _d = options.queryDeduplication, queryDeduplication = _d === void 0 ? true : _d, defaultOptions2 = options.defaultOptions, _e = options.assumeImmutableResults, assumeImmutableResults = _e === void 0 ? false : _e, resolvers = options.resolvers, typeDefs = options.typeDefs, fragmentMatcher = options.fragmentMatcher, clientAwarenessName = options.name, clientAwarenessVersion = options.version;
            var link = options.link;
            if (!link) {
              link = uri ? new HttpLink({ uri, credentials, headers }) : ApolloLink.empty();
            }
            if (!cache) {
              throw __DEV__ ? new InvariantError("To initialize Apollo Client, you must specify a 'cache' property in the options object. \nFor more information, please visit: https://go.apollo.dev/c/docs") : new InvariantError(9);
            }
            this.link = link;
            this.cache = cache;
            this.disableNetworkFetches = ssrMode || ssrForceFetchDelay > 0;
            this.queryDeduplication = queryDeduplication;
            this.defaultOptions = defaultOptions2 || /* @__PURE__ */ Object.create(null);
            this.typeDefs = typeDefs;
            if (ssrForceFetchDelay) {
              setTimeout(function() {
                return _this.disableNetworkFetches = false;
              }, ssrForceFetchDelay);
            }
            this.watchQuery = this.watchQuery.bind(this);
            this.query = this.query.bind(this);
            this.mutate = this.mutate.bind(this);
            this.resetStore = this.resetStore.bind(this);
            this.reFetchObservableQueries = this.reFetchObservableQueries.bind(this);
            if (connectToDevTools && typeof window === "object") {
              window.__APOLLO_CLIENT__ = this;
            }
            if (!hasSuggestedDevtools && connectToDevTools && __DEV__) {
              hasSuggestedDevtools = true;
              if (typeof window !== "undefined" && window.document && window.top === window.self && !window.__APOLLO_DEVTOOLS_GLOBAL_HOOK__) {
                var nav = window.navigator;
                var ua = nav && nav.userAgent;
                var url = void 0;
                if (typeof ua === "string") {
                  if (ua.indexOf("Chrome/") > -1) {
                    url = "https://chrome.google.com/webstore/detail/apollo-client-developer-t/jdkknkkbebbapilgoeccciglkfbmbnfm";
                  } else if (ua.indexOf("Firefox/") > -1) {
                    url = "https://addons.mozilla.org/en-US/firefox/addon/apollo-developer-tools/";
                  }
                }
                if (url) {
                  __DEV__ && invariant.log("Download the Apollo DevTools for a better development experience: " + url);
                }
              }
            }
            this.version = version;
            this.localState = new LocalState({
              cache,
              client: this,
              resolvers,
              fragmentMatcher
            });
            this.queryManager = new QueryManager({
              cache: this.cache,
              link: this.link,
              defaultOptions: this.defaultOptions,
              queryDeduplication,
              ssrMode,
              clientAwareness: {
                name: clientAwarenessName,
                version: clientAwarenessVersion
              },
              localState: this.localState,
              assumeImmutableResults,
              onBroadcast: connectToDevTools ? function() {
                if (_this.devToolsHookCb) {
                  _this.devToolsHookCb({
                    action: {},
                    state: {
                      queries: _this.queryManager.getQueryStore(),
                      mutations: _this.queryManager.mutationStore || {}
                    },
                    dataWithOptimisticResults: _this.cache.extract(true)
                  });
                }
              } : void 0
            });
          }
          ApolloClient2.prototype.stop = function() {
            this.queryManager.stop();
          };
          ApolloClient2.prototype.watchQuery = function(options) {
            if (this.defaultOptions.watchQuery) {
              options = mergeOptions(this.defaultOptions.watchQuery, options);
            }
            if (this.disableNetworkFetches && (options.fetchPolicy === "network-only" || options.fetchPolicy === "cache-and-network")) {
              options = tslib_es6_assign(tslib_es6_assign({}, options), { fetchPolicy: "cache-first" });
            }
            return this.queryManager.watchQuery(options);
          };
          ApolloClient2.prototype.query = function(options) {
            if (this.defaultOptions.query) {
              options = mergeOptions(this.defaultOptions.query, options);
            }
            __DEV__ ? invariant(options.fetchPolicy !== "cache-and-network", "The cache-and-network fetchPolicy does not work with client.query, because client.query can only return a single result. Please use client.watchQuery to receive multiple results from the cache and the network, or consider using a different fetchPolicy, such as cache-first or network-only.") : invariant(options.fetchPolicy !== "cache-and-network", 10);
            if (this.disableNetworkFetches && options.fetchPolicy === "network-only") {
              options = tslib_es6_assign(tslib_es6_assign({}, options), { fetchPolicy: "cache-first" });
            }
            return this.queryManager.query(options);
          };
          ApolloClient2.prototype.mutate = function(options) {
            if (this.defaultOptions.mutate) {
              options = mergeOptions(this.defaultOptions.mutate, options);
            }
            return this.queryManager.mutate(options);
          };
          ApolloClient2.prototype.subscribe = function(options) {
            return this.queryManager.startGraphQLSubscription(options);
          };
          ApolloClient2.prototype.readQuery = function(options, optimistic) {
            if (optimistic === void 0) {
              optimistic = false;
            }
            return this.cache.readQuery(options, optimistic);
          };
          ApolloClient2.prototype.readFragment = function(options, optimistic) {
            if (optimistic === void 0) {
              optimistic = false;
            }
            return this.cache.readFragment(options, optimistic);
          };
          ApolloClient2.prototype.writeQuery = function(options) {
            this.cache.writeQuery(options);
            this.queryManager.broadcastQueries();
          };
          ApolloClient2.prototype.writeFragment = function(options) {
            this.cache.writeFragment(options);
            this.queryManager.broadcastQueries();
          };
          ApolloClient2.prototype.__actionHookForDevTools = function(cb) {
            this.devToolsHookCb = cb;
          };
          ApolloClient2.prototype.__requestRaw = function(payload) {
            return execute(this.link, payload);
          };
          ApolloClient2.prototype.resetStore = function() {
            var _this = this;
            return Promise.resolve().then(function() {
              return _this.queryManager.clearStore({
                discardWatches: false
              });
            }).then(function() {
              return Promise.all(_this.resetStoreCallbacks.map(function(fn) {
                return fn();
              }));
            }).then(function() {
              return _this.reFetchObservableQueries();
            });
          };
          ApolloClient2.prototype.clearStore = function() {
            var _this = this;
            return Promise.resolve().then(function() {
              return _this.queryManager.clearStore({
                discardWatches: true
              });
            }).then(function() {
              return Promise.all(_this.clearStoreCallbacks.map(function(fn) {
                return fn();
              }));
            });
          };
          ApolloClient2.prototype.onResetStore = function(cb) {
            var _this = this;
            this.resetStoreCallbacks.push(cb);
            return function() {
              _this.resetStoreCallbacks = _this.resetStoreCallbacks.filter(function(c) {
                return c !== cb;
              });
            };
          };
          ApolloClient2.prototype.onClearStore = function(cb) {
            var _this = this;
            this.clearStoreCallbacks.push(cb);
            return function() {
              _this.clearStoreCallbacks = _this.clearStoreCallbacks.filter(function(c) {
                return c !== cb;
              });
            };
          };
          ApolloClient2.prototype.reFetchObservableQueries = function(includeStandby) {
            return this.queryManager.reFetchObservableQueries(includeStandby);
          };
          ApolloClient2.prototype.refetchQueries = function(options) {
            var map2 = this.queryManager.refetchQueries(options);
            var queries = [];
            var results = [];
            map2.forEach(function(result2, obsQuery) {
              queries.push(obsQuery);
              results.push(result2);
            });
            var result = Promise.all(results);
            result.queries = queries;
            result.results = results;
            result.catch(function(error) {
              __DEV__ && invariant.debug("In client.refetchQueries, Promise.all promise rejected with error ".concat(error));
            });
            return result;
          };
          ApolloClient2.prototype.getObservableQueries = function(include) {
            if (include === void 0) {
              include = "active";
            }
            return this.queryManager.getObservableQueries(include);
          };
          ApolloClient2.prototype.extract = function(optimistic) {
            return this.cache.extract(optimistic);
          };
          ApolloClient2.prototype.restore = function(serializedState) {
            return this.cache.restore(serializedState);
          };
          ApolloClient2.prototype.addResolvers = function(resolvers) {
            this.localState.addResolvers(resolvers);
          };
          ApolloClient2.prototype.setResolvers = function(resolvers) {
            this.localState.setResolvers(resolvers);
          };
          ApolloClient2.prototype.getResolvers = function() {
            return this.localState.getResolvers();
          };
          ApolloClient2.prototype.setLocalStateFragmentMatcher = function(fragmentMatcher) {
            this.localState.setFragmentMatcher(fragmentMatcher);
          };
          ApolloClient2.prototype.setLink = function(newLink) {
            this.link = this.queryManager.link = newLink;
          };
          return ApolloClient2;
        }();
        ;
        var ApolloCache = function() {
          function ApolloCache2() {
            this.getFragmentDoc = bundle_esm_wrap(getFragmentQueryDocument);
          }
          ApolloCache2.prototype.batch = function(options) {
            var _this = this;
            var optimisticId = typeof options.optimistic === "string" ? options.optimistic : options.optimistic === false ? null : void 0;
            var updateResult;
            this.performTransaction(function() {
              return updateResult = options.update(_this);
            }, optimisticId);
            return updateResult;
          };
          ApolloCache2.prototype.recordOptimisticTransaction = function(transaction, optimisticId) {
            this.performTransaction(transaction, optimisticId);
          };
          ApolloCache2.prototype.transformDocument = function(document2) {
            return document2;
          };
          ApolloCache2.prototype.transformForLink = function(document2) {
            return document2;
          };
          ApolloCache2.prototype.identify = function(object) {
            return;
          };
          ApolloCache2.prototype.gc = function() {
            return [];
          };
          ApolloCache2.prototype.modify = function(options) {
            return false;
          };
          ApolloCache2.prototype.readQuery = function(options, optimistic) {
            if (optimistic === void 0) {
              optimistic = !!options.optimistic;
            }
            return this.read(tslib_es6_assign(tslib_es6_assign({}, options), { rootId: options.id || "ROOT_QUERY", optimistic }));
          };
          ApolloCache2.prototype.readFragment = function(options, optimistic) {
            if (optimistic === void 0) {
              optimistic = !!options.optimistic;
            }
            return this.read(tslib_es6_assign(tslib_es6_assign({}, options), { query: this.getFragmentDoc(options.fragment, options.fragmentName), rootId: options.id, optimistic }));
          };
          ApolloCache2.prototype.writeQuery = function(_a2) {
            var id = _a2.id, data = _a2.data, options = __rest(_a2, ["id", "data"]);
            return this.write(Object.assign(options, {
              dataId: id || "ROOT_QUERY",
              result: data
            }));
          };
          ApolloCache2.prototype.writeFragment = function(_a2) {
            var id = _a2.id, data = _a2.data, fragment = _a2.fragment, fragmentName = _a2.fragmentName, options = __rest(_a2, ["id", "data", "fragment", "fragmentName"]);
            return this.write(Object.assign(options, {
              query: this.getFragmentDoc(fragment, fragmentName),
              dataId: id,
              result: data
            }));
          };
          ApolloCache2.prototype.updateQuery = function(options, update) {
            return this.batch({
              update: function(cache) {
                var value = cache.readQuery(options);
                var data = update(value);
                if (data === void 0 || data === null)
                  return value;
                cache.writeQuery(tslib_es6_assign(tslib_es6_assign({}, options), { data }));
                return data;
              }
            });
          };
          ApolloCache2.prototype.updateFragment = function(options, update) {
            return this.batch({
              update: function(cache) {
                var value = cache.readFragment(options);
                var data = update(value);
                if (data === void 0 || data === null)
                  return value;
                cache.writeFragment(tslib_es6_assign(tslib_es6_assign({}, options), { data }));
                return data;
              }
            });
          };
          return ApolloCache2;
        }();
        ;
        var MissingFieldError = function(_super) {
          __extends(MissingFieldError2, _super);
          function MissingFieldError2(message, path, query, variables) {
            var _a2;
            var _this = _super.call(this, message) || this;
            _this.message = message;
            _this.path = path;
            _this.query = query;
            _this.variables = variables;
            if (Array.isArray(_this.path)) {
              _this.missing = _this.message;
              for (var i2 = _this.path.length - 1; i2 >= 0; --i2) {
                _this.missing = (_a2 = {}, _a2[_this.path[i2]] = _this.missing, _a2);
              }
            } else {
              _this.missing = _this.path;
            }
            _this.__proto__ = MissingFieldError2.prototype;
            return _this;
          }
          return MissingFieldError2;
        }(Error);
        ;
        function deepFreeze(value) {
          var workSet = /* @__PURE__ */ new Set([value]);
          workSet.forEach(function(obj) {
            if (isNonNullObject(obj) && shallowFreeze(obj) === obj) {
              Object.getOwnPropertyNames(obj).forEach(function(name) {
                if (isNonNullObject(obj[name]))
                  workSet.add(obj[name]);
              });
            }
          });
          return value;
        }
        function shallowFreeze(obj) {
          if (__DEV__ && !Object.isFrozen(obj)) {
            try {
              Object.freeze(obj);
            } catch (e) {
              if (e instanceof TypeError)
                return null;
              throw e;
            }
          }
          return obj;
        }
        function maybeDeepFreeze(obj) {
          if (__DEV__) {
            deepFreeze(obj);
          }
          return obj;
        }
        ;
        var hasOwn = Object.prototype.hasOwnProperty;
        function isNullish(value) {
          return value === null || value === void 0;
        }
        function defaultDataIdFromObject(_a2, context2) {
          var __typename = _a2.__typename, id = _a2.id, _id = _a2._id;
          if (typeof __typename === "string") {
            if (context2) {
              context2.keyObject = !isNullish(id) ? { id } : !isNullish(_id) ? { _id } : void 0;
            }
            if (isNullish(id) && !isNullish(_id)) {
              id = _id;
            }
            if (!isNullish(id)) {
              return "".concat(__typename, ":").concat(typeof id === "number" || typeof id === "string" ? id : JSON.stringify(id));
            }
          }
        }
        var defaultConfig = {
          dataIdFromObject: defaultDataIdFromObject,
          addTypename: true,
          resultCaching: true,
          canonizeResults: false
        };
        function normalizeConfig(config2) {
          return compact(defaultConfig, config2);
        }
        function shouldCanonizeResults(config2) {
          var value = config2.canonizeResults;
          return value === void 0 ? defaultConfig.canonizeResults : value;
        }
        function getTypenameFromStoreObject(store, objectOrReference) {
          return isReference(objectOrReference) ? store.get(objectOrReference.__ref, "__typename") : objectOrReference && objectOrReference.__typename;
        }
        var TypeOrFieldNameRegExp = /^[_a-z][_0-9a-z]*/i;
        function fieldNameFromStoreName(storeFieldName) {
          var match = storeFieldName.match(TypeOrFieldNameRegExp);
          return match ? match[0] : storeFieldName;
        }
        function selectionSetMatchesResult(selectionSet, result, variables) {
          if (isNonNullObject(result)) {
            return arrays_isArray(result) ? result.every(function(item) {
              return selectionSetMatchesResult(selectionSet, item, variables);
            }) : selectionSet.selections.every(function(field) {
              if (storeUtils_isField(field) && shouldInclude(field, variables)) {
                var key = resultKeyNameFromField(field);
                return hasOwn.call(result, key) && (!field.selectionSet || selectionSetMatchesResult(field.selectionSet, result[key], variables));
              }
              return true;
            });
          }
          return false;
        }
        function storeValueIsStoreObject(value) {
          return isNonNullObject(value) && !isReference(value) && !arrays_isArray(value);
        }
        function makeProcessedFieldsMerger() {
          return new DeepMerger();
        }
        function extractFragmentContext(document2, fragments) {
          var fragmentMap = createFragmentMap(getFragmentDefinitions(document2));
          return {
            fragmentMap,
            lookupFragment: function(name) {
              var def = fragmentMap[name];
              if (!def && fragments) {
                def = fragments.lookup(name);
              }
              return def || null;
            }
          };
        }
        ;
        var DELETE = /* @__PURE__ */ Object.create(null);
        var delModifier = function() {
          return DELETE;
        };
        var INVALIDATE = /* @__PURE__ */ Object.create(null);
        var EntityStore = function() {
          function EntityStore2(policies, group) {
            var _this = this;
            this.policies = policies;
            this.group = group;
            this.data = /* @__PURE__ */ Object.create(null);
            this.rootIds = /* @__PURE__ */ Object.create(null);
            this.refs = /* @__PURE__ */ Object.create(null);
            this.getFieldValue = function(objectOrReference, storeFieldName) {
              return maybeDeepFreeze(isReference(objectOrReference) ? _this.get(objectOrReference.__ref, storeFieldName) : objectOrReference && objectOrReference[storeFieldName]);
            };
            this.canRead = function(objOrRef) {
              return isReference(objOrRef) ? _this.has(objOrRef.__ref) : typeof objOrRef === "object";
            };
            this.toReference = function(objOrIdOrRef, mergeIntoStore) {
              if (typeof objOrIdOrRef === "string") {
                return makeReference(objOrIdOrRef);
              }
              if (isReference(objOrIdOrRef)) {
                return objOrIdOrRef;
              }
              var id = _this.policies.identify(objOrIdOrRef)[0];
              if (id) {
                var ref = makeReference(id);
                if (mergeIntoStore) {
                  _this.merge(id, objOrIdOrRef);
                }
                return ref;
              }
            };
          }
          EntityStore2.prototype.toObject = function() {
            return tslib_es6_assign({}, this.data);
          };
          EntityStore2.prototype.has = function(dataId) {
            return this.lookup(dataId, true) !== void 0;
          };
          EntityStore2.prototype.get = function(dataId, fieldName) {
            this.group.depend(dataId, fieldName);
            if (hasOwn.call(this.data, dataId)) {
              var storeObject = this.data[dataId];
              if (storeObject && hasOwn.call(storeObject, fieldName)) {
                return storeObject[fieldName];
              }
            }
            if (fieldName === "__typename" && hasOwn.call(this.policies.rootTypenamesById, dataId)) {
              return this.policies.rootTypenamesById[dataId];
            }
            if (this instanceof Layer) {
              return this.parent.get(dataId, fieldName);
            }
          };
          EntityStore2.prototype.lookup = function(dataId, dependOnExistence) {
            if (dependOnExistence)
              this.group.depend(dataId, "__exists");
            if (hasOwn.call(this.data, dataId)) {
              return this.data[dataId];
            }
            if (this instanceof Layer) {
              return this.parent.lookup(dataId, dependOnExistence);
            }
            if (this.policies.rootTypenamesById[dataId]) {
              return /* @__PURE__ */ Object.create(null);
            }
          };
          EntityStore2.prototype.merge = function(older, newer) {
            var _this = this;
            var dataId;
            if (isReference(older))
              older = older.__ref;
            if (isReference(newer))
              newer = newer.__ref;
            var existing = typeof older === "string" ? this.lookup(dataId = older) : older;
            var incoming = typeof newer === "string" ? this.lookup(dataId = newer) : newer;
            if (!incoming)
              return;
            __DEV__ ? invariant(typeof dataId === "string", "store.merge expects a string ID") : invariant(typeof dataId === "string", 1);
            var merged = new DeepMerger(storeObjectReconciler).merge(existing, incoming);
            this.data[dataId] = merged;
            if (merged !== existing) {
              delete this.refs[dataId];
              if (this.group.caching) {
                var fieldsToDirty_1 = /* @__PURE__ */ Object.create(null);
                if (!existing)
                  fieldsToDirty_1.__exists = 1;
                Object.keys(incoming).forEach(function(storeFieldName) {
                  if (!existing || existing[storeFieldName] !== merged[storeFieldName]) {
                    fieldsToDirty_1[storeFieldName] = 1;
                    var fieldName = fieldNameFromStoreName(storeFieldName);
                    if (fieldName !== storeFieldName && !_this.policies.hasKeyArgs(merged.__typename, fieldName)) {
                      fieldsToDirty_1[fieldName] = 1;
                    }
                    if (merged[storeFieldName] === void 0 && !(_this instanceof Layer)) {
                      delete merged[storeFieldName];
                    }
                  }
                });
                if (fieldsToDirty_1.__typename && !(existing && existing.__typename) && this.policies.rootTypenamesById[dataId] === merged.__typename) {
                  delete fieldsToDirty_1.__typename;
                }
                Object.keys(fieldsToDirty_1).forEach(function(fieldName) {
                  return _this.group.dirty(dataId, fieldName);
                });
              }
            }
          };
          EntityStore2.prototype.modify = function(dataId, fields) {
            var _this = this;
            var storeObject = this.lookup(dataId);
            if (storeObject) {
              var changedFields_1 = /* @__PURE__ */ Object.create(null);
              var needToMerge_1 = false;
              var allDeleted_1 = true;
              var sharedDetails_1 = {
                DELETE,
                INVALIDATE,
                isReference,
                toReference: this.toReference,
                canRead: this.canRead,
                readField: function(fieldNameOrOptions, from) {
                  return _this.policies.readField(typeof fieldNameOrOptions === "string" ? {
                    fieldName: fieldNameOrOptions,
                    from: from || makeReference(dataId)
                  } : fieldNameOrOptions, { store: _this });
                }
              };
              Object.keys(storeObject).forEach(function(storeFieldName) {
                var fieldName = fieldNameFromStoreName(storeFieldName);
                var fieldValue = storeObject[storeFieldName];
                if (fieldValue === void 0)
                  return;
                var modify = typeof fields === "function" ? fields : fields[storeFieldName] || fields[fieldName];
                if (modify) {
                  var newValue = modify === delModifier ? DELETE : modify(maybeDeepFreeze(fieldValue), tslib_es6_assign(tslib_es6_assign({}, sharedDetails_1), { fieldName, storeFieldName, storage: _this.getStorage(dataId, storeFieldName) }));
                  if (newValue === INVALIDATE) {
                    _this.group.dirty(dataId, storeFieldName);
                  } else {
                    if (newValue === DELETE)
                      newValue = void 0;
                    if (newValue !== fieldValue) {
                      changedFields_1[storeFieldName] = newValue;
                      needToMerge_1 = true;
                      fieldValue = newValue;
                    }
                  }
                }
                if (fieldValue !== void 0) {
                  allDeleted_1 = false;
                }
              });
              if (needToMerge_1) {
                this.merge(dataId, changedFields_1);
                if (allDeleted_1) {
                  if (this instanceof Layer) {
                    this.data[dataId] = void 0;
                  } else {
                    delete this.data[dataId];
                  }
                  this.group.dirty(dataId, "__exists");
                }
                return true;
              }
            }
            return false;
          };
          EntityStore2.prototype.delete = function(dataId, fieldName, args) {
            var _a2;
            var storeObject = this.lookup(dataId);
            if (storeObject) {
              var typename = this.getFieldValue(storeObject, "__typename");
              var storeFieldName = fieldName && args ? this.policies.getStoreFieldName({ typename, fieldName, args }) : fieldName;
              return this.modify(dataId, storeFieldName ? (_a2 = {}, _a2[storeFieldName] = delModifier, _a2) : delModifier);
            }
            return false;
          };
          EntityStore2.prototype.evict = function(options, limit) {
            var evicted = false;
            if (options.id) {
              if (hasOwn.call(this.data, options.id)) {
                evicted = this.delete(options.id, options.fieldName, options.args);
              }
              if (this instanceof Layer && this !== limit) {
                evicted = this.parent.evict(options, limit) || evicted;
              }
              if (options.fieldName || evicted) {
                this.group.dirty(options.id, options.fieldName || "__exists");
              }
            }
            return evicted;
          };
          EntityStore2.prototype.clear = function() {
            this.replace(null);
          };
          EntityStore2.prototype.extract = function() {
            var _this = this;
            var obj = this.toObject();
            var extraRootIds = [];
            this.getRootIdSet().forEach(function(id) {
              if (!hasOwn.call(_this.policies.rootTypenamesById, id)) {
                extraRootIds.push(id);
              }
            });
            if (extraRootIds.length) {
              obj.__META = { extraRootIds: extraRootIds.sort() };
            }
            return obj;
          };
          EntityStore2.prototype.replace = function(newData) {
            var _this = this;
            Object.keys(this.data).forEach(function(dataId) {
              if (!(newData && hasOwn.call(newData, dataId))) {
                _this.delete(dataId);
              }
            });
            if (newData) {
              var __META = newData.__META, rest_1 = __rest(newData, ["__META"]);
              Object.keys(rest_1).forEach(function(dataId) {
                _this.merge(dataId, rest_1[dataId]);
              });
              if (__META) {
                __META.extraRootIds.forEach(this.retain, this);
              }
            }
          };
          EntityStore2.prototype.retain = function(rootId) {
            return this.rootIds[rootId] = (this.rootIds[rootId] || 0) + 1;
          };
          EntityStore2.prototype.release = function(rootId) {
            if (this.rootIds[rootId] > 0) {
              var count = --this.rootIds[rootId];
              if (!count)
                delete this.rootIds[rootId];
              return count;
            }
            return 0;
          };
          EntityStore2.prototype.getRootIdSet = function(ids) {
            if (ids === void 0) {
              ids = /* @__PURE__ */ new Set();
            }
            Object.keys(this.rootIds).forEach(ids.add, ids);
            if (this instanceof Layer) {
              this.parent.getRootIdSet(ids);
            } else {
              Object.keys(this.policies.rootTypenamesById).forEach(ids.add, ids);
            }
            return ids;
          };
          EntityStore2.prototype.gc = function() {
            var _this = this;
            var ids = this.getRootIdSet();
            var snapshot = this.toObject();
            ids.forEach(function(id) {
              if (hasOwn.call(snapshot, id)) {
                Object.keys(_this.findChildRefIds(id)).forEach(ids.add, ids);
                delete snapshot[id];
              }
            });
            var idsToRemove = Object.keys(snapshot);
            if (idsToRemove.length) {
              var root_1 = this;
              while (root_1 instanceof Layer)
                root_1 = root_1.parent;
              idsToRemove.forEach(function(id) {
                return root_1.delete(id);
              });
            }
            return idsToRemove;
          };
          EntityStore2.prototype.findChildRefIds = function(dataId) {
            if (!hasOwn.call(this.refs, dataId)) {
              var found_1 = this.refs[dataId] = /* @__PURE__ */ Object.create(null);
              var root = this.data[dataId];
              if (!root)
                return found_1;
              var workSet_1 = /* @__PURE__ */ new Set([root]);
              workSet_1.forEach(function(obj) {
                if (isReference(obj)) {
                  found_1[obj.__ref] = true;
                }
                if (isNonNullObject(obj)) {
                  Object.keys(obj).forEach(function(key) {
                    var child = obj[key];
                    if (isNonNullObject(child)) {
                      workSet_1.add(child);
                    }
                  });
                }
              });
            }
            return this.refs[dataId];
          };
          EntityStore2.prototype.makeCacheKey = function() {
            return this.group.keyMaker.lookupArray(arguments);
          };
          return EntityStore2;
        }();
        var CacheGroup = function() {
          function CacheGroup2(caching, parent) {
            if (parent === void 0) {
              parent = null;
            }
            this.caching = caching;
            this.parent = parent;
            this.d = null;
            this.resetCaching();
          }
          CacheGroup2.prototype.resetCaching = function() {
            this.d = this.caching ? dep() : null;
            this.keyMaker = new Trie(canUseWeakMap);
          };
          CacheGroup2.prototype.depend = function(dataId, storeFieldName) {
            if (this.d) {
              this.d(makeDepKey(dataId, storeFieldName));
              var fieldName = fieldNameFromStoreName(storeFieldName);
              if (fieldName !== storeFieldName) {
                this.d(makeDepKey(dataId, fieldName));
              }
              if (this.parent) {
                this.parent.depend(dataId, storeFieldName);
              }
            }
          };
          CacheGroup2.prototype.dirty = function(dataId, storeFieldName) {
            if (this.d) {
              this.d.dirty(makeDepKey(dataId, storeFieldName), storeFieldName === "__exists" ? "forget" : "setDirty");
            }
          };
          return CacheGroup2;
        }();
        function makeDepKey(dataId, storeFieldName) {
          return storeFieldName + "#" + dataId;
        }
        function maybeDependOnExistenceOfEntity(store, entityId) {
          if (supportsResultCaching(store)) {
            store.group.depend(entityId, "__exists");
          }
        }
        (function(EntityStore2) {
          var Root = function(_super) {
            __extends(Root2, _super);
            function Root2(_a2) {
              var policies = _a2.policies, _b = _a2.resultCaching, resultCaching = _b === void 0 ? true : _b, seed = _a2.seed;
              var _this = _super.call(this, policies, new CacheGroup(resultCaching)) || this;
              _this.stump = new Stump(_this);
              _this.storageTrie = new Trie(canUseWeakMap);
              if (seed)
                _this.replace(seed);
              return _this;
            }
            Root2.prototype.addLayer = function(layerId, replay) {
              return this.stump.addLayer(layerId, replay);
            };
            Root2.prototype.removeLayer = function() {
              return this;
            };
            Root2.prototype.getStorage = function() {
              return this.storageTrie.lookupArray(arguments);
            };
            return Root2;
          }(EntityStore2);
          EntityStore2.Root = Root;
        })(EntityStore || (EntityStore = {}));
        var Layer = function(_super) {
          __extends(Layer2, _super);
          function Layer2(id, parent, replay, group) {
            var _this = _super.call(this, parent.policies, group) || this;
            _this.id = id;
            _this.parent = parent;
            _this.replay = replay;
            _this.group = group;
            replay(_this);
            return _this;
          }
          Layer2.prototype.addLayer = function(layerId, replay) {
            return new Layer2(layerId, this, replay, this.group);
          };
          Layer2.prototype.removeLayer = function(layerId) {
            var _this = this;
            var parent = this.parent.removeLayer(layerId);
            if (layerId === this.id) {
              if (this.group.caching) {
                Object.keys(this.data).forEach(function(dataId) {
                  var ownStoreObject = _this.data[dataId];
                  var parentStoreObject = parent["lookup"](dataId);
                  if (!parentStoreObject) {
                    _this.delete(dataId);
                  } else if (!ownStoreObject) {
                    _this.group.dirty(dataId, "__exists");
                    Object.keys(parentStoreObject).forEach(function(storeFieldName) {
                      _this.group.dirty(dataId, storeFieldName);
                    });
                  } else if (ownStoreObject !== parentStoreObject) {
                    Object.keys(ownStoreObject).forEach(function(storeFieldName) {
                      if (!equal(ownStoreObject[storeFieldName], parentStoreObject[storeFieldName])) {
                        _this.group.dirty(dataId, storeFieldName);
                      }
                    });
                  }
                });
              }
              return parent;
            }
            if (parent === this.parent)
              return this;
            return parent.addLayer(this.id, this.replay);
          };
          Layer2.prototype.toObject = function() {
            return tslib_es6_assign(tslib_es6_assign({}, this.parent.toObject()), this.data);
          };
          Layer2.prototype.findChildRefIds = function(dataId) {
            var fromParent = this.parent.findChildRefIds(dataId);
            return hasOwn.call(this.data, dataId) ? tslib_es6_assign(tslib_es6_assign({}, fromParent), _super.prototype.findChildRefIds.call(this, dataId)) : fromParent;
          };
          Layer2.prototype.getStorage = function() {
            var p = this.parent;
            while (p.parent)
              p = p.parent;
            return p.getStorage.apply(p, arguments);
          };
          return Layer2;
        }(EntityStore);
        var Stump = function(_super) {
          __extends(Stump2, _super);
          function Stump2(root) {
            return _super.call(this, "EntityStore.Stump", root, function() {
            }, new CacheGroup(root.group.caching, root.group)) || this;
          }
          Stump2.prototype.removeLayer = function() {
            return this;
          };
          Stump2.prototype.merge = function() {
            return this.parent.merge.apply(this.parent, arguments);
          };
          return Stump2;
        }(Layer);
        function storeObjectReconciler(existingObject, incomingObject, property) {
          var existingValue = existingObject[property];
          var incomingValue = incomingObject[property];
          return equal(existingValue, incomingValue) ? existingValue : incomingValue;
        }
        function supportsResultCaching(store) {
          return !!(store instanceof EntityStore && store.group.caching);
        }
        ;
        ;
        function execSelectionSetKeyArgs(options) {
          return [
            options.selectionSet,
            options.objectOrReference,
            options.context,
            options.context.canonizeResults
          ];
        }
        var StoreReader = function() {
          function StoreReader2(config2) {
            var _this = this;
            this.knownResults = new (canUseWeakMap ? WeakMap : Map)();
            this.config = compact(config2, {
              addTypename: config2.addTypename !== false,
              canonizeResults: shouldCanonizeResults(config2)
            });
            this.canon = config2.canon || new ObjectCanon();
            this.executeSelectionSet = bundle_esm_wrap(function(options) {
              var _a2;
              var canonizeResults = options.context.canonizeResults;
              var peekArgs = execSelectionSetKeyArgs(options);
              peekArgs[3] = !canonizeResults;
              var other = (_a2 = _this.executeSelectionSet).peek.apply(_a2, peekArgs);
              if (other) {
                if (canonizeResults) {
                  return tslib_es6_assign(tslib_es6_assign({}, other), { result: _this.canon.admit(other.result) });
                }
                return other;
              }
              maybeDependOnExistenceOfEntity(options.context.store, options.enclosingRef.__ref);
              return _this.execSelectionSetImpl(options);
            }, {
              max: this.config.resultCacheMaxSize,
              keyArgs: execSelectionSetKeyArgs,
              makeCacheKey: function(selectionSet, parent, context2, canonizeResults) {
                if (supportsResultCaching(context2.store)) {
                  return context2.store.makeCacheKey(selectionSet, isReference(parent) ? parent.__ref : parent, context2.varString, canonizeResults);
                }
              }
            });
            this.executeSubSelectedArray = bundle_esm_wrap(function(options) {
              maybeDependOnExistenceOfEntity(options.context.store, options.enclosingRef.__ref);
              return _this.execSubSelectedArrayImpl(options);
            }, {
              max: this.config.resultCacheMaxSize,
              makeCacheKey: function(_a2) {
                var field = _a2.field, array = _a2.array, context2 = _a2.context;
                if (supportsResultCaching(context2.store)) {
                  return context2.store.makeCacheKey(field, array, context2.varString);
                }
              }
            });
          }
          StoreReader2.prototype.resetCanon = function() {
            this.canon = new ObjectCanon();
          };
          StoreReader2.prototype.diffQueryAgainstStore = function(_a2) {
            var store = _a2.store, query = _a2.query, _b = _a2.rootId, rootId = _b === void 0 ? "ROOT_QUERY" : _b, variables = _a2.variables, _c = _a2.returnPartialData, returnPartialData = _c === void 0 ? true : _c, _d = _a2.canonizeResults, canonizeResults = _d === void 0 ? this.config.canonizeResults : _d;
            var policies = this.config.cache.policies;
            variables = tslib_es6_assign(tslib_es6_assign({}, getDefaultValues(getQueryDefinition(query))), variables);
            var rootRef = makeReference(rootId);
            var execResult = this.executeSelectionSet({
              selectionSet: getMainDefinition(query).selectionSet,
              objectOrReference: rootRef,
              enclosingRef: rootRef,
              context: tslib_es6_assign({ store, query, policies, variables, varString: canonicalStringify(variables), canonizeResults }, extractFragmentContext(query, this.config.fragments))
            });
            var missing;
            if (execResult.missing) {
              missing = [new MissingFieldError(firstMissing(execResult.missing), execResult.missing, query, variables)];
              if (!returnPartialData) {
                throw missing[0];
              }
            }
            return {
              result: execResult.result,
              complete: !missing,
              missing
            };
          };
          StoreReader2.prototype.isFresh = function(result, parent, selectionSet, context2) {
            if (supportsResultCaching(context2.store) && this.knownResults.get(result) === selectionSet) {
              var latest = this.executeSelectionSet.peek(selectionSet, parent, context2, this.canon.isKnown(result));
              if (latest && result === latest.result) {
                return true;
              }
            }
            return false;
          };
          StoreReader2.prototype.execSelectionSetImpl = function(_a2) {
            var _this = this;
            var selectionSet = _a2.selectionSet, objectOrReference = _a2.objectOrReference, enclosingRef = _a2.enclosingRef, context2 = _a2.context;
            if (isReference(objectOrReference) && !context2.policies.rootTypenamesById[objectOrReference.__ref] && !context2.store.has(objectOrReference.__ref)) {
              return {
                result: this.canon.empty,
                missing: "Dangling reference to missing ".concat(objectOrReference.__ref, " object")
              };
            }
            var variables = context2.variables, policies = context2.policies, store = context2.store;
            var typename = store.getFieldValue(objectOrReference, "__typename");
            var objectsToMerge = [];
            var missing;
            var missingMerger = new DeepMerger();
            if (this.config.addTypename && typeof typename === "string" && !policies.rootIdsByTypename[typename]) {
              objectsToMerge.push({ __typename: typename });
            }
            function handleMissing(result2, resultName) {
              var _a3;
              if (result2.missing) {
                missing = missingMerger.merge(missing, (_a3 = {}, _a3[resultName] = result2.missing, _a3));
              }
              return result2.result;
            }
            var workSet = new Set(selectionSet.selections);
            workSet.forEach(function(selection) {
              var _a3, _b;
              if (!shouldInclude(selection, variables))
                return;
              if (storeUtils_isField(selection)) {
                var fieldValue = policies.readField({
                  fieldName: selection.name.value,
                  field: selection,
                  variables: context2.variables,
                  from: objectOrReference
                }, context2);
                var resultName = resultKeyNameFromField(selection);
                if (fieldValue === void 0) {
                  if (!addTypenameToDocument.added(selection)) {
                    missing = missingMerger.merge(missing, (_a3 = {}, _a3[resultName] = "Can't find field '".concat(selection.name.value, "' on ").concat(isReference(objectOrReference) ? objectOrReference.__ref + " object" : "object " + JSON.stringify(objectOrReference, null, 2)), _a3));
                  }
                } else if (arrays_isArray(fieldValue)) {
                  fieldValue = handleMissing(_this.executeSubSelectedArray({
                    field: selection,
                    array: fieldValue,
                    enclosingRef,
                    context: context2
                  }), resultName);
                } else if (!selection.selectionSet) {
                  if (context2.canonizeResults) {
                    fieldValue = _this.canon.pass(fieldValue);
                  }
                } else if (fieldValue != null) {
                  fieldValue = handleMissing(_this.executeSelectionSet({
                    selectionSet: selection.selectionSet,
                    objectOrReference: fieldValue,
                    enclosingRef: isReference(fieldValue) ? fieldValue : enclosingRef,
                    context: context2
                  }), resultName);
                }
                if (fieldValue !== void 0) {
                  objectsToMerge.push((_b = {}, _b[resultName] = fieldValue, _b));
                }
              } else {
                var fragment = getFragmentFromSelection(selection, context2.lookupFragment);
                if (!fragment && selection.kind === kinds_Kind.FRAGMENT_SPREAD) {
                  throw __DEV__ ? new InvariantError("No fragment named ".concat(selection.name.value)) : new InvariantError(5);
                }
                if (fragment && policies.fragmentMatches(fragment, typename)) {
                  fragment.selectionSet.selections.forEach(workSet.add, workSet);
                }
              }
            });
            var result = mergeDeepArray(objectsToMerge);
            var finalResult = { result, missing };
            var frozen = context2.canonizeResults ? this.canon.admit(finalResult) : maybeDeepFreeze(finalResult);
            if (frozen.result) {
              this.knownResults.set(frozen.result, selectionSet);
            }
            return frozen;
          };
          StoreReader2.prototype.execSubSelectedArrayImpl = function(_a2) {
            var _this = this;
            var field = _a2.field, array = _a2.array, enclosingRef = _a2.enclosingRef, context2 = _a2.context;
            var missing;
            var missingMerger = new DeepMerger();
            function handleMissing(childResult, i2) {
              var _a3;
              if (childResult.missing) {
                missing = missingMerger.merge(missing, (_a3 = {}, _a3[i2] = childResult.missing, _a3));
              }
              return childResult.result;
            }
            if (field.selectionSet) {
              array = array.filter(context2.store.canRead);
            }
            array = array.map(function(item, i2) {
              if (item === null) {
                return null;
              }
              if (arrays_isArray(item)) {
                return handleMissing(_this.executeSubSelectedArray({
                  field,
                  array: item,
                  enclosingRef,
                  context: context2
                }), i2);
              }
              if (field.selectionSet) {
                return handleMissing(_this.executeSelectionSet({
                  selectionSet: field.selectionSet,
                  objectOrReference: item,
                  enclosingRef: isReference(item) ? item : enclosingRef,
                  context: context2
                }), i2);
              }
              if (__DEV__) {
                assertSelectionSetForIdValue(context2.store, field, item);
              }
              return item;
            });
            return {
              result: context2.canonizeResults ? this.canon.admit(array) : array,
              missing
            };
          };
          return StoreReader2;
        }();
        function firstMissing(tree) {
          try {
            JSON.stringify(tree, function(_, value) {
              if (typeof value === "string")
                throw value;
              return value;
            });
          } catch (result) {
            return result;
          }
        }
        function assertSelectionSetForIdValue(store, field, fieldValue) {
          if (!field.selectionSet) {
            var workSet_1 = /* @__PURE__ */ new Set([fieldValue]);
            workSet_1.forEach(function(value) {
              if (isNonNullObject(value)) {
                __DEV__ ? invariant(!isReference(value), "Missing selection set for object of type ".concat(getTypenameFromStoreObject(store, value), " returned for query field ").concat(field.name.value)) : invariant(!isReference(value), 6);
                Object.values(value).forEach(workSet_1.add, workSet_1);
              }
            });
          }
        }
        ;
        function stringifyForDisplay(value) {
          var undefId = makeUniqueId("stringifyForDisplay");
          return JSON.stringify(value, function(key, value2) {
            return value2 === void 0 ? undefId : value2;
          }).split(JSON.stringify(undefId)).join("<undefined>");
        }
        ;
        var specifierInfoCache = /* @__PURE__ */ Object.create(null);
        function lookupSpecifierInfo(spec) {
          var cacheKey = JSON.stringify(spec);
          return specifierInfoCache[cacheKey] || (specifierInfoCache[cacheKey] = /* @__PURE__ */ Object.create(null));
        }
        function keyFieldsFnFromSpecifier(specifier) {
          var info = lookupSpecifierInfo(specifier);
          return info.keyFieldsFn || (info.keyFieldsFn = function(object, context2) {
            var extract = function(from, key) {
              return context2.readField(key, from);
            };
            var keyObject = context2.keyObject = collectSpecifierPaths(specifier, function(schemaKeyPath) {
              var extracted = extractKeyPath(context2.storeObject, schemaKeyPath, extract);
              if (extracted === void 0 && object !== context2.storeObject && hasOwn.call(object, schemaKeyPath[0])) {
                extracted = extractKeyPath(object, schemaKeyPath, extractKey);
              }
              __DEV__ ? invariant(extracted !== void 0, "Missing field '".concat(schemaKeyPath.join("."), "' while extracting keyFields from ").concat(JSON.stringify(object))) : invariant(extracted !== void 0, 2);
              return extracted;
            });
            return "".concat(context2.typename, ":").concat(JSON.stringify(keyObject));
          });
        }
        function keyArgsFnFromSpecifier(specifier) {
          var info = lookupSpecifierInfo(specifier);
          return info.keyArgsFn || (info.keyArgsFn = function(args, _a2) {
            var field = _a2.field, variables = _a2.variables, fieldName = _a2.fieldName;
            var collected = collectSpecifierPaths(specifier, function(keyPath) {
              var firstKey = keyPath[0];
              var firstChar = firstKey.charAt(0);
              if (firstChar === "@") {
                if (field && isNonEmptyArray(field.directives)) {
                  var directiveName_1 = firstKey.slice(1);
                  var d = field.directives.find(function(d2) {
                    return d2.name.value === directiveName_1;
                  });
                  var directiveArgs = d && argumentsObjectFromField(d, variables);
                  return directiveArgs && extractKeyPath(directiveArgs, keyPath.slice(1));
                }
                return;
              }
              if (firstChar === "$") {
                var variableName = firstKey.slice(1);
                if (variables && hasOwn.call(variables, variableName)) {
                  var varKeyPath = keyPath.slice(0);
                  varKeyPath[0] = variableName;
                  return extractKeyPath(variables, varKeyPath);
                }
                return;
              }
              if (args) {
                return extractKeyPath(args, keyPath);
              }
            });
            var suffix = JSON.stringify(collected);
            if (args || suffix !== "{}") {
              fieldName += ":" + suffix;
            }
            return fieldName;
          });
        }
        function collectSpecifierPaths(specifier, extractor) {
          var merger = new DeepMerger();
          return getSpecifierPaths(specifier).reduce(function(collected, path) {
            var _a2;
            var toMerge = extractor(path);
            if (toMerge !== void 0) {
              for (var i2 = path.length - 1; i2 >= 0; --i2) {
                toMerge = (_a2 = {}, _a2[path[i2]] = toMerge, _a2);
              }
              collected = merger.merge(collected, toMerge);
            }
            return collected;
          }, /* @__PURE__ */ Object.create(null));
        }
        function getSpecifierPaths(spec) {
          var info = lookupSpecifierInfo(spec);
          if (!info.paths) {
            var paths_1 = info.paths = [];
            var currentPath_1 = [];
            spec.forEach(function(s, i2) {
              if (arrays_isArray(s)) {
                getSpecifierPaths(s).forEach(function(p) {
                  return paths_1.push(currentPath_1.concat(p));
                });
                currentPath_1.length = 0;
              } else {
                currentPath_1.push(s);
                if (!arrays_isArray(spec[i2 + 1])) {
                  paths_1.push(currentPath_1.slice(0));
                  currentPath_1.length = 0;
                }
              }
            });
          }
          return info.paths;
        }
        function extractKey(object, key) {
          return object[key];
        }
        function extractKeyPath(object, path, extract) {
          extract = extract || extractKey;
          return normalize(path.reduce(function reducer(obj, key) {
            return arrays_isArray(obj) ? obj.map(function(child) {
              return reducer(child, key);
            }) : obj && extract(obj, key);
          }, object));
        }
        function normalize(value) {
          if (isNonNullObject(value)) {
            if (arrays_isArray(value)) {
              return value.map(normalize);
            }
            return collectSpecifierPaths(Object.keys(value).sort(), function(path) {
              return extractKeyPath(value, path);
            });
          }
          return value;
        }
        ;
        getStoreKeyName.setStringify(canonicalStringify);
        function argsFromFieldSpecifier(spec) {
          return spec.args !== void 0 ? spec.args : spec.field ? argumentsObjectFromField(spec.field, spec.variables) : null;
        }
        var nullKeyFieldsFn = function() {
          return void 0;
        };
        var simpleKeyArgsFn = function(_args, context2) {
          return context2.fieldName;
        };
        var mergeTrueFn = function(existing, incoming, _a2) {
          var mergeObjects = _a2.mergeObjects;
          return mergeObjects(existing, incoming);
        };
        var mergeFalseFn = function(_, incoming) {
          return incoming;
        };
        var Policies = function() {
          function Policies2(config2) {
            this.config = config2;
            this.typePolicies = /* @__PURE__ */ Object.create(null);
            this.toBeAdded = /* @__PURE__ */ Object.create(null);
            this.supertypeMap = /* @__PURE__ */ new Map();
            this.fuzzySubtypes = /* @__PURE__ */ new Map();
            this.rootIdsByTypename = /* @__PURE__ */ Object.create(null);
            this.rootTypenamesById = /* @__PURE__ */ Object.create(null);
            this.usingPossibleTypes = false;
            this.config = tslib_es6_assign({ dataIdFromObject: defaultDataIdFromObject }, config2);
            this.cache = this.config.cache;
            this.setRootTypename("Query");
            this.setRootTypename("Mutation");
            this.setRootTypename("Subscription");
            if (config2.possibleTypes) {
              this.addPossibleTypes(config2.possibleTypes);
            }
            if (config2.typePolicies) {
              this.addTypePolicies(config2.typePolicies);
            }
          }
          Policies2.prototype.identify = function(object, partialContext) {
            var _a2;
            var policies = this;
            var typename = partialContext && (partialContext.typename || ((_a2 = partialContext.storeObject) === null || _a2 === void 0 ? void 0 : _a2.__typename)) || object.__typename;
            if (typename === this.rootTypenamesById.ROOT_QUERY) {
              return ["ROOT_QUERY"];
            }
            var storeObject = partialContext && partialContext.storeObject || object;
            var context2 = tslib_es6_assign(tslib_es6_assign({}, partialContext), { typename, storeObject, readField: partialContext && partialContext.readField || function() {
              var options = normalizeReadFieldOptions(arguments, storeObject);
              return policies.readField(options, {
                store: policies.cache["data"],
                variables: options.variables
              });
            } });
            var id;
            var policy = typename && this.getTypePolicy(typename);
            var keyFn = policy && policy.keyFn || this.config.dataIdFromObject;
            while (keyFn) {
              var specifierOrId = keyFn(object, context2);
              if (arrays_isArray(specifierOrId)) {
                keyFn = keyFieldsFnFromSpecifier(specifierOrId);
              } else {
                id = specifierOrId;
                break;
              }
            }
            id = id ? String(id) : void 0;
            return context2.keyObject ? [id, context2.keyObject] : [id];
          };
          Policies2.prototype.addTypePolicies = function(typePolicies) {
            var _this = this;
            Object.keys(typePolicies).forEach(function(typename) {
              var _a2 = typePolicies[typename], queryType = _a2.queryType, mutationType = _a2.mutationType, subscriptionType = _a2.subscriptionType, incoming = __rest(_a2, ["queryType", "mutationType", "subscriptionType"]);
              if (queryType)
                _this.setRootTypename("Query", typename);
              if (mutationType)
                _this.setRootTypename("Mutation", typename);
              if (subscriptionType)
                _this.setRootTypename("Subscription", typename);
              if (hasOwn.call(_this.toBeAdded, typename)) {
                _this.toBeAdded[typename].push(incoming);
              } else {
                _this.toBeAdded[typename] = [incoming];
              }
            });
          };
          Policies2.prototype.updateTypePolicy = function(typename, incoming) {
            var _this = this;
            var existing = this.getTypePolicy(typename);
            var keyFields = incoming.keyFields, fields = incoming.fields;
            function setMerge(existing2, merge) {
              existing2.merge = typeof merge === "function" ? merge : merge === true ? mergeTrueFn : merge === false ? mergeFalseFn : existing2.merge;
            }
            setMerge(existing, incoming.merge);
            existing.keyFn = keyFields === false ? nullKeyFieldsFn : arrays_isArray(keyFields) ? keyFieldsFnFromSpecifier(keyFields) : typeof keyFields === "function" ? keyFields : existing.keyFn;
            if (fields) {
              Object.keys(fields).forEach(function(fieldName) {
                var existing2 = _this.getFieldPolicy(typename, fieldName, true);
                var incoming2 = fields[fieldName];
                if (typeof incoming2 === "function") {
                  existing2.read = incoming2;
                } else {
                  var keyArgs = incoming2.keyArgs, read = incoming2.read, merge = incoming2.merge;
                  existing2.keyFn = keyArgs === false ? simpleKeyArgsFn : arrays_isArray(keyArgs) ? keyArgsFnFromSpecifier(keyArgs) : typeof keyArgs === "function" ? keyArgs : existing2.keyFn;
                  if (typeof read === "function") {
                    existing2.read = read;
                  }
                  setMerge(existing2, merge);
                }
                if (existing2.read && existing2.merge) {
                  existing2.keyFn = existing2.keyFn || simpleKeyArgsFn;
                }
              });
            }
          };
          Policies2.prototype.setRootTypename = function(which, typename) {
            if (typename === void 0) {
              typename = which;
            }
            var rootId = "ROOT_" + which.toUpperCase();
            var old = this.rootTypenamesById[rootId];
            if (typename !== old) {
              __DEV__ ? invariant(!old || old === which, "Cannot change root ".concat(which, " __typename more than once")) : invariant(!old || old === which, 3);
              if (old)
                delete this.rootIdsByTypename[old];
              this.rootIdsByTypename[typename] = rootId;
              this.rootTypenamesById[rootId] = typename;
            }
          };
          Policies2.prototype.addPossibleTypes = function(possibleTypes) {
            var _this = this;
            this.usingPossibleTypes = true;
            Object.keys(possibleTypes).forEach(function(supertype) {
              _this.getSupertypeSet(supertype, true);
              possibleTypes[supertype].forEach(function(subtype) {
                _this.getSupertypeSet(subtype, true).add(supertype);
                var match = subtype.match(TypeOrFieldNameRegExp);
                if (!match || match[0] !== subtype) {
                  _this.fuzzySubtypes.set(subtype, new RegExp(subtype));
                }
              });
            });
          };
          Policies2.prototype.getTypePolicy = function(typename) {
            var _this = this;
            if (!hasOwn.call(this.typePolicies, typename)) {
              var policy_1 = this.typePolicies[typename] = /* @__PURE__ */ Object.create(null);
              policy_1.fields = /* @__PURE__ */ Object.create(null);
              var supertypes = this.supertypeMap.get(typename);
              if (supertypes && supertypes.size) {
                supertypes.forEach(function(supertype) {
                  var _a2 = _this.getTypePolicy(supertype), fields = _a2.fields, rest = __rest(_a2, ["fields"]);
                  Object.assign(policy_1, rest);
                  Object.assign(policy_1.fields, fields);
                });
              }
            }
            var inbox = this.toBeAdded[typename];
            if (inbox && inbox.length) {
              inbox.splice(0).forEach(function(policy) {
                _this.updateTypePolicy(typename, policy);
              });
            }
            return this.typePolicies[typename];
          };
          Policies2.prototype.getFieldPolicy = function(typename, fieldName, createIfMissing) {
            if (typename) {
              var fieldPolicies = this.getTypePolicy(typename).fields;
              return fieldPolicies[fieldName] || createIfMissing && (fieldPolicies[fieldName] = /* @__PURE__ */ Object.create(null));
            }
          };
          Policies2.prototype.getSupertypeSet = function(subtype, createIfMissing) {
            var supertypeSet = this.supertypeMap.get(subtype);
            if (!supertypeSet && createIfMissing) {
              this.supertypeMap.set(subtype, supertypeSet = /* @__PURE__ */ new Set());
            }
            return supertypeSet;
          };
          Policies2.prototype.fragmentMatches = function(fragment, typename, result, variables) {
            var _this = this;
            if (!fragment.typeCondition)
              return true;
            if (!typename)
              return false;
            var supertype = fragment.typeCondition.name.value;
            if (typename === supertype)
              return true;
            if (this.usingPossibleTypes && this.supertypeMap.has(supertype)) {
              var typenameSupertypeSet = this.getSupertypeSet(typename, true);
              var workQueue_1 = [typenameSupertypeSet];
              var maybeEnqueue_1 = function(subtype) {
                var supertypeSet2 = _this.getSupertypeSet(subtype, false);
                if (supertypeSet2 && supertypeSet2.size && workQueue_1.indexOf(supertypeSet2) < 0) {
                  workQueue_1.push(supertypeSet2);
                }
              };
              var needToCheckFuzzySubtypes = !!(result && this.fuzzySubtypes.size);
              var checkingFuzzySubtypes = false;
              for (var i2 = 0; i2 < workQueue_1.length; ++i2) {
                var supertypeSet = workQueue_1[i2];
                if (supertypeSet.has(supertype)) {
                  if (!typenameSupertypeSet.has(supertype)) {
                    if (checkingFuzzySubtypes) {
                      __DEV__ && invariant.warn("Inferring subtype ".concat(typename, " of supertype ").concat(supertype));
                    }
                    typenameSupertypeSet.add(supertype);
                  }
                  return true;
                }
                supertypeSet.forEach(maybeEnqueue_1);
                if (needToCheckFuzzySubtypes && i2 === workQueue_1.length - 1 && selectionSetMatchesResult(fragment.selectionSet, result, variables)) {
                  needToCheckFuzzySubtypes = false;
                  checkingFuzzySubtypes = true;
                  this.fuzzySubtypes.forEach(function(regExp, fuzzyString) {
                    var match = typename.match(regExp);
                    if (match && match[0] === typename) {
                      maybeEnqueue_1(fuzzyString);
                    }
                  });
                }
              }
            }
            return false;
          };
          Policies2.prototype.hasKeyArgs = function(typename, fieldName) {
            var policy = this.getFieldPolicy(typename, fieldName, false);
            return !!(policy && policy.keyFn);
          };
          Policies2.prototype.getStoreFieldName = function(fieldSpec) {
            var typename = fieldSpec.typename, fieldName = fieldSpec.fieldName;
            var policy = this.getFieldPolicy(typename, fieldName, false);
            var storeFieldName;
            var keyFn = policy && policy.keyFn;
            if (keyFn && typename) {
              var context2 = {
                typename,
                fieldName,
                field: fieldSpec.field || null,
                variables: fieldSpec.variables
              };
              var args = argsFromFieldSpecifier(fieldSpec);
              while (keyFn) {
                var specifierOrString = keyFn(args, context2);
                if (arrays_isArray(specifierOrString)) {
                  keyFn = keyArgsFnFromSpecifier(specifierOrString);
                } else {
                  storeFieldName = specifierOrString || fieldName;
                  break;
                }
              }
            }
            if (storeFieldName === void 0) {
              storeFieldName = fieldSpec.field ? storeKeyNameFromField(fieldSpec.field, fieldSpec.variables) : getStoreKeyName(fieldName, argsFromFieldSpecifier(fieldSpec));
            }
            if (storeFieldName === false) {
              return fieldName;
            }
            return fieldName === fieldNameFromStoreName(storeFieldName) ? storeFieldName : fieldName + ":" + storeFieldName;
          };
          Policies2.prototype.readField = function(options, context2) {
            var objectOrReference = options.from;
            if (!objectOrReference)
              return;
            var nameOrField = options.field || options.fieldName;
            if (!nameOrField)
              return;
            if (options.typename === void 0) {
              var typename = context2.store.getFieldValue(objectOrReference, "__typename");
              if (typename)
                options.typename = typename;
            }
            var storeFieldName = this.getStoreFieldName(options);
            var fieldName = fieldNameFromStoreName(storeFieldName);
            var existing = context2.store.getFieldValue(objectOrReference, storeFieldName);
            var policy = this.getFieldPolicy(options.typename, fieldName, false);
            var read = policy && policy.read;
            if (read) {
              var readOptions = makeFieldFunctionOptions(this, objectOrReference, options, context2, context2.store.getStorage(isReference(objectOrReference) ? objectOrReference.__ref : objectOrReference, storeFieldName));
              return cacheSlot.withValue(this.cache, read, [existing, readOptions]);
            }
            return existing;
          };
          Policies2.prototype.getReadFunction = function(typename, fieldName) {
            var policy = this.getFieldPolicy(typename, fieldName, false);
            return policy && policy.read;
          };
          Policies2.prototype.getMergeFunction = function(parentTypename, fieldName, childTypename) {
            var policy = this.getFieldPolicy(parentTypename, fieldName, false);
            var merge = policy && policy.merge;
            if (!merge && childTypename) {
              policy = this.getTypePolicy(childTypename);
              merge = policy && policy.merge;
            }
            return merge;
          };
          Policies2.prototype.runMergeFunction = function(existing, incoming, _a2, context2, storage) {
            var field = _a2.field, typename = _a2.typename, merge = _a2.merge;
            if (merge === mergeTrueFn) {
              return makeMergeObjectsFunction(context2.store)(existing, incoming);
            }
            if (merge === mergeFalseFn) {
              return incoming;
            }
            if (context2.overwrite) {
              existing = void 0;
            }
            return merge(existing, incoming, makeFieldFunctionOptions(this, void 0, { typename, fieldName: field.name.value, field, variables: context2.variables }, context2, storage || /* @__PURE__ */ Object.create(null)));
          };
          return Policies2;
        }();
        function makeFieldFunctionOptions(policies, objectOrReference, fieldSpec, context2, storage) {
          var storeFieldName = policies.getStoreFieldName(fieldSpec);
          var fieldName = fieldNameFromStoreName(storeFieldName);
          var variables = fieldSpec.variables || context2.variables;
          var _a2 = context2.store, toReference = _a2.toReference, canRead = _a2.canRead;
          return {
            args: argsFromFieldSpecifier(fieldSpec),
            field: fieldSpec.field || null,
            fieldName,
            storeFieldName,
            variables,
            isReference,
            toReference,
            storage,
            cache: policies.cache,
            canRead,
            readField: function() {
              return policies.readField(normalizeReadFieldOptions(arguments, objectOrReference, variables), context2);
            },
            mergeObjects: makeMergeObjectsFunction(context2.store)
          };
        }
        function normalizeReadFieldOptions(readFieldArgs, objectOrReference, variables) {
          var fieldNameOrOptions = readFieldArgs[0], from = readFieldArgs[1], argc = readFieldArgs.length;
          var options;
          if (typeof fieldNameOrOptions === "string") {
            options = {
              fieldName: fieldNameOrOptions,
              from: argc > 1 ? from : objectOrReference
            };
          } else {
            options = tslib_es6_assign({}, fieldNameOrOptions);
            if (!hasOwn.call(options, "from")) {
              options.from = objectOrReference;
            }
          }
          if (__DEV__ && options.from === void 0) {
            __DEV__ && invariant.warn("Undefined 'from' passed to readField with arguments ".concat(stringifyForDisplay(Array.from(readFieldArgs))));
          }
          if (void 0 === options.variables) {
            options.variables = variables;
          }
          return options;
        }
        function makeMergeObjectsFunction(store) {
          return function mergeObjects(existing, incoming) {
            if (arrays_isArray(existing) || arrays_isArray(incoming)) {
              throw __DEV__ ? new InvariantError("Cannot automatically merge arrays") : new InvariantError(4);
            }
            if (isNonNullObject(existing) && isNonNullObject(incoming)) {
              var eType = store.getFieldValue(existing, "__typename");
              var iType = store.getFieldValue(incoming, "__typename");
              var typesDiffer = eType && iType && eType !== iType;
              if (typesDiffer) {
                return incoming;
              }
              if (isReference(existing) && storeValueIsStoreObject(incoming)) {
                store.merge(existing.__ref, incoming);
                return existing;
              }
              if (storeValueIsStoreObject(existing) && isReference(incoming)) {
                store.merge(existing, incoming.__ref);
                return incoming;
              }
              if (storeValueIsStoreObject(existing) && storeValueIsStoreObject(incoming)) {
                return tslib_es6_assign(tslib_es6_assign({}, existing), incoming);
              }
            }
            return incoming;
          };
        }
        ;
        ;
        function getContextFlavor(context2, clientOnly, deferred) {
          var key = "".concat(clientOnly).concat(deferred);
          var flavored = context2.flavors.get(key);
          if (!flavored) {
            context2.flavors.set(key, flavored = context2.clientOnly === clientOnly && context2.deferred === deferred ? context2 : tslib_es6_assign(tslib_es6_assign({}, context2), { clientOnly, deferred }));
          }
          return flavored;
        }
        var StoreWriter = function() {
          function StoreWriter2(cache, reader, fragments) {
            this.cache = cache;
            this.reader = reader;
            this.fragments = fragments;
          }
          StoreWriter2.prototype.writeToStore = function(store, _a2) {
            var _this = this;
            var query = _a2.query, result = _a2.result, dataId = _a2.dataId, variables = _a2.variables, overwrite = _a2.overwrite;
            var operationDefinition = getOperationDefinition(query);
            var merger = makeProcessedFieldsMerger();
            variables = tslib_es6_assign(tslib_es6_assign({}, getDefaultValues(operationDefinition)), variables);
            var context2 = tslib_es6_assign(tslib_es6_assign({ store, written: /* @__PURE__ */ Object.create(null), merge: function(existing, incoming) {
              return merger.merge(existing, incoming);
            }, variables, varString: canonicalStringify(variables) }, extractFragmentContext(query, this.fragments)), { overwrite: !!overwrite, incomingById: /* @__PURE__ */ new Map(), clientOnly: false, deferred: false, flavors: /* @__PURE__ */ new Map() });
            var ref = this.processSelectionSet({
              result: result || /* @__PURE__ */ Object.create(null),
              dataId,
              selectionSet: operationDefinition.selectionSet,
              mergeTree: { map: /* @__PURE__ */ new Map() },
              context: context2
            });
            if (!isReference(ref)) {
              throw __DEV__ ? new InvariantError("Could not identify object ".concat(JSON.stringify(result))) : new InvariantError(7);
            }
            context2.incomingById.forEach(function(_a3, dataId2) {
              var storeObject = _a3.storeObject, mergeTree = _a3.mergeTree, fieldNodeSet = _a3.fieldNodeSet;
              var entityRef = makeReference(dataId2);
              if (mergeTree && mergeTree.map.size) {
                var applied = _this.applyMerges(mergeTree, entityRef, storeObject, context2);
                if (isReference(applied)) {
                  return;
                }
                storeObject = applied;
              }
              if (__DEV__ && !context2.overwrite) {
                var fieldsWithSelectionSets_1 = /* @__PURE__ */ Object.create(null);
                fieldNodeSet.forEach(function(field) {
                  if (field.selectionSet) {
                    fieldsWithSelectionSets_1[field.name.value] = true;
                  }
                });
                var hasSelectionSet_1 = function(storeFieldName) {
                  return fieldsWithSelectionSets_1[fieldNameFromStoreName(storeFieldName)] === true;
                };
                var hasMergeFunction_1 = function(storeFieldName) {
                  var childTree = mergeTree && mergeTree.map.get(storeFieldName);
                  return Boolean(childTree && childTree.info && childTree.info.merge);
                };
                Object.keys(storeObject).forEach(function(storeFieldName) {
                  if (hasSelectionSet_1(storeFieldName) && !hasMergeFunction_1(storeFieldName)) {
                    warnAboutDataLoss(entityRef, storeObject, storeFieldName, context2.store);
                  }
                });
              }
              store.merge(dataId2, storeObject);
            });
            store.retain(ref.__ref);
            return ref;
          };
          StoreWriter2.prototype.processSelectionSet = function(_a2) {
            var _this = this;
            var dataId = _a2.dataId, result = _a2.result, selectionSet = _a2.selectionSet, context2 = _a2.context, mergeTree = _a2.mergeTree;
            var policies = this.cache.policies;
            var incoming = /* @__PURE__ */ Object.create(null);
            var typename = dataId && policies.rootTypenamesById[dataId] || getTypenameFromResult(result, selectionSet, context2.fragmentMap) || dataId && context2.store.get(dataId, "__typename");
            if ("string" === typeof typename) {
              incoming.__typename = typename;
            }
            var readField = function() {
              var options = normalizeReadFieldOptions(arguments, incoming, context2.variables);
              if (isReference(options.from)) {
                var info = context2.incomingById.get(options.from.__ref);
                if (info) {
                  var result_1 = policies.readField(tslib_es6_assign(tslib_es6_assign({}, options), { from: info.storeObject }), context2);
                  if (result_1 !== void 0) {
                    return result_1;
                  }
                }
              }
              return policies.readField(options, context2);
            };
            var fieldNodeSet = /* @__PURE__ */ new Set();
            this.flattenFields(selectionSet, result, context2, typename).forEach(function(context3, field) {
              var _a3;
              var resultFieldKey = resultKeyNameFromField(field);
              var value = result[resultFieldKey];
              fieldNodeSet.add(field);
              if (value !== void 0) {
                var storeFieldName = policies.getStoreFieldName({
                  typename,
                  fieldName: field.name.value,
                  field,
                  variables: context3.variables
                });
                var childTree = getChildMergeTree(mergeTree, storeFieldName);
                var incomingValue = _this.processFieldValue(value, field, field.selectionSet ? getContextFlavor(context3, false, false) : context3, childTree);
                var childTypename = void 0;
                if (field.selectionSet && (isReference(incomingValue) || storeValueIsStoreObject(incomingValue))) {
                  childTypename = readField("__typename", incomingValue);
                }
                var merge = policies.getMergeFunction(typename, field.name.value, childTypename);
                if (merge) {
                  childTree.info = {
                    field,
                    typename,
                    merge
                  };
                } else {
                  maybeRecycleChildMergeTree(mergeTree, storeFieldName);
                }
                incoming = context3.merge(incoming, (_a3 = {}, _a3[storeFieldName] = incomingValue, _a3));
              } else if (__DEV__ && !context3.clientOnly && !context3.deferred && !addTypenameToDocument.added(field) && !policies.getReadFunction(typename, field.name.value)) {
                __DEV__ && invariant.error("Missing field '".concat(resultKeyNameFromField(field), "' while writing result ").concat(JSON.stringify(result, null, 2)).substring(0, 1e3));
              }
            });
            try {
              var _b = policies.identify(result, {
                typename,
                selectionSet,
                fragmentMap: context2.fragmentMap,
                storeObject: incoming,
                readField
              }), id = _b[0], keyObject = _b[1];
              dataId = dataId || id;
              if (keyObject) {
                incoming = context2.merge(incoming, keyObject);
              }
            } catch (e) {
              if (!dataId)
                throw e;
            }
            if ("string" === typeof dataId) {
              var dataRef = makeReference(dataId);
              var sets = context2.written[dataId] || (context2.written[dataId] = []);
              if (sets.indexOf(selectionSet) >= 0)
                return dataRef;
              sets.push(selectionSet);
              if (this.reader && this.reader.isFresh(result, dataRef, selectionSet, context2)) {
                return dataRef;
              }
              var previous_1 = context2.incomingById.get(dataId);
              if (previous_1) {
                previous_1.storeObject = context2.merge(previous_1.storeObject, incoming);
                previous_1.mergeTree = mergeMergeTrees(previous_1.mergeTree, mergeTree);
                fieldNodeSet.forEach(function(field) {
                  return previous_1.fieldNodeSet.add(field);
                });
              } else {
                context2.incomingById.set(dataId, {
                  storeObject: incoming,
                  mergeTree: mergeTreeIsEmpty(mergeTree) ? void 0 : mergeTree,
                  fieldNodeSet
                });
              }
              return dataRef;
            }
            return incoming;
          };
          StoreWriter2.prototype.processFieldValue = function(value, field, context2, mergeTree) {
            var _this = this;
            if (!field.selectionSet || value === null) {
              return __DEV__ ? cloneDeep(value) : value;
            }
            if (arrays_isArray(value)) {
              return value.map(function(item, i2) {
                var value2 = _this.processFieldValue(item, field, context2, getChildMergeTree(mergeTree, i2));
                maybeRecycleChildMergeTree(mergeTree, i2);
                return value2;
              });
            }
            return this.processSelectionSet({
              result: value,
              selectionSet: field.selectionSet,
              context: context2,
              mergeTree
            });
          };
          StoreWriter2.prototype.flattenFields = function(selectionSet, result, context2, typename) {
            if (typename === void 0) {
              typename = getTypenameFromResult(result, selectionSet, context2.fragmentMap);
            }
            var fieldMap = /* @__PURE__ */ new Map();
            var policies = this.cache.policies;
            var limitingTrie = new Trie(false);
            (function flatten(selectionSet2, inheritedContext) {
              var visitedNode = limitingTrie.lookup(selectionSet2, inheritedContext.clientOnly, inheritedContext.deferred);
              if (visitedNode.visited)
                return;
              visitedNode.visited = true;
              selectionSet2.selections.forEach(function(selection) {
                if (!shouldInclude(selection, context2.variables))
                  return;
                var clientOnly = inheritedContext.clientOnly, deferred = inheritedContext.deferred;
                if (!(clientOnly && deferred) && isNonEmptyArray(selection.directives)) {
                  selection.directives.forEach(function(dir) {
                    var name = dir.name.value;
                    if (name === "client")
                      clientOnly = true;
                    if (name === "defer") {
                      var args = argumentsObjectFromField(dir, context2.variables);
                      if (!args || args.if !== false) {
                        deferred = true;
                      }
                    }
                  });
                }
                if (storeUtils_isField(selection)) {
                  var existing = fieldMap.get(selection);
                  if (existing) {
                    clientOnly = clientOnly && existing.clientOnly;
                    deferred = deferred && existing.deferred;
                  }
                  fieldMap.set(selection, getContextFlavor(context2, clientOnly, deferred));
                } else {
                  var fragment = getFragmentFromSelection(selection, context2.lookupFragment);
                  if (!fragment && selection.kind === kinds_Kind.FRAGMENT_SPREAD) {
                    throw __DEV__ ? new InvariantError("No fragment named ".concat(selection.name.value)) : new InvariantError(8);
                  }
                  if (fragment && policies.fragmentMatches(fragment, typename, result, context2.variables)) {
                    flatten(fragment.selectionSet, getContextFlavor(context2, clientOnly, deferred));
                  }
                }
              });
            })(selectionSet, context2);
            return fieldMap;
          };
          StoreWriter2.prototype.applyMerges = function(mergeTree, existing, incoming, context2, getStorageArgs) {
            var _a2;
            var _this = this;
            if (mergeTree.map.size && !isReference(incoming)) {
              var e_1 = !arrays_isArray(incoming) && (isReference(existing) || storeValueIsStoreObject(existing)) ? existing : void 0;
              var i_1 = incoming;
              if (e_1 && !getStorageArgs) {
                getStorageArgs = [isReference(e_1) ? e_1.__ref : e_1];
              }
              var changedFields_1;
              var getValue_1 = function(from, name) {
                return arrays_isArray(from) ? typeof name === "number" ? from[name] : void 0 : context2.store.getFieldValue(from, String(name));
              };
              mergeTree.map.forEach(function(childTree, storeFieldName) {
                var eVal = getValue_1(e_1, storeFieldName);
                var iVal = getValue_1(i_1, storeFieldName);
                if (void 0 === iVal)
                  return;
                if (getStorageArgs) {
                  getStorageArgs.push(storeFieldName);
                }
                var aVal = _this.applyMerges(childTree, eVal, iVal, context2, getStorageArgs);
                if (aVal !== iVal) {
                  changedFields_1 = changedFields_1 || /* @__PURE__ */ new Map();
                  changedFields_1.set(storeFieldName, aVal);
                }
                if (getStorageArgs) {
                  invariant(getStorageArgs.pop() === storeFieldName);
                }
              });
              if (changedFields_1) {
                incoming = arrays_isArray(i_1) ? i_1.slice(0) : tslib_es6_assign({}, i_1);
                changedFields_1.forEach(function(value, name) {
                  incoming[name] = value;
                });
              }
            }
            if (mergeTree.info) {
              return this.cache.policies.runMergeFunction(existing, incoming, mergeTree.info, context2, getStorageArgs && (_a2 = context2.store).getStorage.apply(_a2, getStorageArgs));
            }
            return incoming;
          };
          return StoreWriter2;
        }();
        var emptyMergeTreePool = [];
        function getChildMergeTree(_a2, name) {
          var map2 = _a2.map;
          if (!map2.has(name)) {
            map2.set(name, emptyMergeTreePool.pop() || { map: /* @__PURE__ */ new Map() });
          }
          return map2.get(name);
        }
        function mergeMergeTrees(left, right) {
          if (left === right || !right || mergeTreeIsEmpty(right))
            return left;
          if (!left || mergeTreeIsEmpty(left))
            return right;
          var info = left.info && right.info ? tslib_es6_assign(tslib_es6_assign({}, left.info), right.info) : left.info || right.info;
          var needToMergeMaps = left.map.size && right.map.size;
          var map2 = needToMergeMaps ? /* @__PURE__ */ new Map() : left.map.size ? left.map : right.map;
          var merged = { info, map: map2 };
          if (needToMergeMaps) {
            var remainingRightKeys_1 = new Set(right.map.keys());
            left.map.forEach(function(leftTree, key) {
              merged.map.set(key, mergeMergeTrees(leftTree, right.map.get(key)));
              remainingRightKeys_1.delete(key);
            });
            remainingRightKeys_1.forEach(function(key) {
              merged.map.set(key, mergeMergeTrees(right.map.get(key), left.map.get(key)));
            });
          }
          return merged;
        }
        function mergeTreeIsEmpty(tree) {
          return !tree || !(tree.info || tree.map.size);
        }
        function maybeRecycleChildMergeTree(_a2, name) {
          var map2 = _a2.map;
          var childTree = map2.get(name);
          if (childTree && mergeTreeIsEmpty(childTree)) {
            emptyMergeTreePool.push(childTree);
            map2.delete(name);
          }
        }
        var warnings = /* @__PURE__ */ new Set();
        function warnAboutDataLoss(existingRef, incomingObj, storeFieldName, store) {
          var getChild = function(objOrRef) {
            var child = store.getFieldValue(objOrRef, storeFieldName);
            return typeof child === "object" && child;
          };
          var existing = getChild(existingRef);
          if (!existing)
            return;
          var incoming = getChild(incomingObj);
          if (!incoming)
            return;
          if (isReference(existing))
            return;
          if (equal(existing, incoming))
            return;
          if (Object.keys(existing).every(function(key) {
            return store.getFieldValue(incoming, key) !== void 0;
          })) {
            return;
          }
          var parentType = store.getFieldValue(existingRef, "__typename") || store.getFieldValue(incomingObj, "__typename");
          var fieldName = fieldNameFromStoreName(storeFieldName);
          var typeDotName = "".concat(parentType, ".").concat(fieldName);
          if (warnings.has(typeDotName))
            return;
          warnings.add(typeDotName);
          var childTypenames = [];
          if (!arrays_isArray(existing) && !arrays_isArray(incoming)) {
            [existing, incoming].forEach(function(child) {
              var typename = store.getFieldValue(child, "__typename");
              if (typeof typename === "string" && !childTypenames.includes(typename)) {
                childTypenames.push(typename);
              }
            });
          }
          __DEV__ && invariant.warn("Cache data may be lost when replacing the ".concat(fieldName, " field of a ").concat(parentType, " object.\n\nTo address this problem (which is not a bug in Apollo Client), ").concat(childTypenames.length ? "either ensure all objects of type " + childTypenames.join(" and ") + " have an ID or a custom merge function, or " : "", "define a custom merge function for the ").concat(typeDotName, " field, so InMemoryCache can safely merge these objects:\n\n  existing: ").concat(JSON.stringify(existing).slice(0, 1e3), "\n  incoming: ").concat(JSON.stringify(incoming).slice(0, 1e3), "\n\nFor more information about these options, please refer to the documentation:\n\n  * Ensuring entity objects have IDs: https://go.apollo.dev/c/generating-unique-identifiers\n  * Defining custom merge functions: https://go.apollo.dev/c/merging-non-normalized-objects\n"));
        }
        ;
        var InMemoryCache = function(_super) {
          __extends(InMemoryCache2, _super);
          function InMemoryCache2(config2) {
            if (config2 === void 0) {
              config2 = {};
            }
            var _this = _super.call(this) || this;
            _this.watches = /* @__PURE__ */ new Set();
            _this.typenameDocumentCache = /* @__PURE__ */ new Map();
            _this.makeVar = makeVar;
            _this.txCount = 0;
            _this.config = normalizeConfig(config2);
            _this.addTypename = !!_this.config.addTypename;
            _this.policies = new Policies({
              cache: _this,
              dataIdFromObject: _this.config.dataIdFromObject,
              possibleTypes: _this.config.possibleTypes,
              typePolicies: _this.config.typePolicies
            });
            _this.init();
            return _this;
          }
          InMemoryCache2.prototype.init = function() {
            var rootStore = this.data = new EntityStore.Root({
              policies: this.policies,
              resultCaching: this.config.resultCaching
            });
            this.optimisticData = rootStore.stump;
            this.resetResultCache();
          };
          InMemoryCache2.prototype.resetResultCache = function(resetResultIdentities) {
            var _this = this;
            var previousReader = this.storeReader;
            var fragments = this.config.fragments;
            this.storeWriter = new StoreWriter(this, this.storeReader = new StoreReader({
              cache: this,
              addTypename: this.addTypename,
              resultCacheMaxSize: this.config.resultCacheMaxSize,
              canonizeResults: shouldCanonizeResults(this.config),
              canon: resetResultIdentities ? void 0 : previousReader && previousReader.canon,
              fragments
            }), fragments);
            this.maybeBroadcastWatch = bundle_esm_wrap(function(c, options) {
              return _this.broadcastWatch(c, options);
            }, {
              max: this.config.resultCacheMaxSize,
              makeCacheKey: function(c) {
                var store = c.optimistic ? _this.optimisticData : _this.data;
                if (supportsResultCaching(store)) {
                  var optimistic = c.optimistic, id = c.id, variables = c.variables;
                  return store.makeCacheKey(c.query, c.callback, canonicalStringify({ optimistic, id, variables }));
                }
              }
            });
            (/* @__PURE__ */ new Set([
              this.data.group,
              this.optimisticData.group
            ])).forEach(function(group) {
              return group.resetCaching();
            });
          };
          InMemoryCache2.prototype.restore = function(data) {
            this.init();
            if (data)
              this.data.replace(data);
            return this;
          };
          InMemoryCache2.prototype.extract = function(optimistic) {
            if (optimistic === void 0) {
              optimistic = false;
            }
            return (optimistic ? this.optimisticData : this.data).extract();
          };
          InMemoryCache2.prototype.read = function(options) {
            var _a2 = options.returnPartialData, returnPartialData = _a2 === void 0 ? false : _a2;
            try {
              return this.storeReader.diffQueryAgainstStore(tslib_es6_assign(tslib_es6_assign({}, options), { store: options.optimistic ? this.optimisticData : this.data, config: this.config, returnPartialData })).result || null;
            } catch (e) {
              if (e instanceof MissingFieldError) {
                return null;
              }
              throw e;
            }
          };
          InMemoryCache2.prototype.write = function(options) {
            try {
              ++this.txCount;
              return this.storeWriter.writeToStore(this.data, options);
            } finally {
              if (!--this.txCount && options.broadcast !== false) {
                this.broadcastWatches();
              }
            }
          };
          InMemoryCache2.prototype.modify = function(options) {
            if (hasOwn.call(options, "id") && !options.id) {
              return false;
            }
            var store = options.optimistic ? this.optimisticData : this.data;
            try {
              ++this.txCount;
              return store.modify(options.id || "ROOT_QUERY", options.fields);
            } finally {
              if (!--this.txCount && options.broadcast !== false) {
                this.broadcastWatches();
              }
            }
          };
          InMemoryCache2.prototype.diff = function(options) {
            return this.storeReader.diffQueryAgainstStore(tslib_es6_assign(tslib_es6_assign({}, options), { store: options.optimistic ? this.optimisticData : this.data, rootId: options.id || "ROOT_QUERY", config: this.config }));
          };
          InMemoryCache2.prototype.watch = function(watch) {
            var _this = this;
            if (!this.watches.size) {
              recallCache(this);
            }
            this.watches.add(watch);
            if (watch.immediate) {
              this.maybeBroadcastWatch(watch);
            }
            return function() {
              if (_this.watches.delete(watch) && !_this.watches.size) {
                forgetCache(_this);
              }
              _this.maybeBroadcastWatch.forget(watch);
            };
          };
          InMemoryCache2.prototype.gc = function(options) {
            canonicalStringify.reset();
            var ids = this.optimisticData.gc();
            if (options && !this.txCount) {
              if (options.resetResultCache) {
                this.resetResultCache(options.resetResultIdentities);
              } else if (options.resetResultIdentities) {
                this.storeReader.resetCanon();
              }
            }
            return ids;
          };
          InMemoryCache2.prototype.retain = function(rootId, optimistic) {
            return (optimistic ? this.optimisticData : this.data).retain(rootId);
          };
          InMemoryCache2.prototype.release = function(rootId, optimistic) {
            return (optimistic ? this.optimisticData : this.data).release(rootId);
          };
          InMemoryCache2.prototype.identify = function(object) {
            if (isReference(object))
              return object.__ref;
            try {
              return this.policies.identify(object)[0];
            } catch (e) {
              __DEV__ && invariant.warn(e);
            }
          };
          InMemoryCache2.prototype.evict = function(options) {
            if (!options.id) {
              if (hasOwn.call(options, "id")) {
                return false;
              }
              options = tslib_es6_assign(tslib_es6_assign({}, options), { id: "ROOT_QUERY" });
            }
            try {
              ++this.txCount;
              return this.optimisticData.evict(options, this.data);
            } finally {
              if (!--this.txCount && options.broadcast !== false) {
                this.broadcastWatches();
              }
            }
          };
          InMemoryCache2.prototype.reset = function(options) {
            var _this = this;
            this.init();
            canonicalStringify.reset();
            if (options && options.discardWatches) {
              this.watches.forEach(function(watch) {
                return _this.maybeBroadcastWatch.forget(watch);
              });
              this.watches.clear();
              forgetCache(this);
            } else {
              this.broadcastWatches();
            }
            return Promise.resolve();
          };
          InMemoryCache2.prototype.removeOptimistic = function(idToRemove) {
            var newOptimisticData = this.optimisticData.removeLayer(idToRemove);
            if (newOptimisticData !== this.optimisticData) {
              this.optimisticData = newOptimisticData;
              this.broadcastWatches();
            }
          };
          InMemoryCache2.prototype.batch = function(options) {
            var _this = this;
            var update = options.update, _a2 = options.optimistic, optimistic = _a2 === void 0 ? true : _a2, removeOptimistic = options.removeOptimistic, onWatchUpdated = options.onWatchUpdated;
            var updateResult;
            var perform = function(layer) {
              var _a3 = _this, data = _a3.data, optimisticData = _a3.optimisticData;
              ++_this.txCount;
              if (layer) {
                _this.data = _this.optimisticData = layer;
              }
              try {
                return updateResult = update(_this);
              } finally {
                --_this.txCount;
                _this.data = data;
                _this.optimisticData = optimisticData;
              }
            };
            var alreadyDirty = /* @__PURE__ */ new Set();
            if (onWatchUpdated && !this.txCount) {
              this.broadcastWatches(tslib_es6_assign(tslib_es6_assign({}, options), { onWatchUpdated: function(watch) {
                alreadyDirty.add(watch);
                return false;
              } }));
            }
            if (typeof optimistic === "string") {
              this.optimisticData = this.optimisticData.addLayer(optimistic, perform);
            } else if (optimistic === false) {
              perform(this.data);
            } else {
              perform();
            }
            if (typeof removeOptimistic === "string") {
              this.optimisticData = this.optimisticData.removeLayer(removeOptimistic);
            }
            if (onWatchUpdated && alreadyDirty.size) {
              this.broadcastWatches(tslib_es6_assign(tslib_es6_assign({}, options), { onWatchUpdated: function(watch, diff) {
                var result = onWatchUpdated.call(this, watch, diff);
                if (result !== false) {
                  alreadyDirty.delete(watch);
                }
                return result;
              } }));
              if (alreadyDirty.size) {
                alreadyDirty.forEach(function(watch) {
                  return _this.maybeBroadcastWatch.dirty(watch);
                });
              }
            } else {
              this.broadcastWatches(options);
            }
            return updateResult;
          };
          InMemoryCache2.prototype.performTransaction = function(update, optimisticId) {
            return this.batch({
              update,
              optimistic: optimisticId || optimisticId !== null
            });
          };
          InMemoryCache2.prototype.transformDocument = function(document2) {
            if (this.addTypename) {
              var result = this.typenameDocumentCache.get(document2);
              if (!result) {
                result = addTypenameToDocument(document2);
                this.typenameDocumentCache.set(document2, result);
                this.typenameDocumentCache.set(result, result);
              }
              return result;
            }
            return document2;
          };
          InMemoryCache2.prototype.transformForLink = function(document2) {
            var fragments = this.config.fragments;
            return fragments ? fragments.transform(document2) : document2;
          };
          InMemoryCache2.prototype.broadcastWatches = function(options) {
            var _this = this;
            if (!this.txCount) {
              this.watches.forEach(function(c) {
                return _this.maybeBroadcastWatch(c, options);
              });
            }
          };
          InMemoryCache2.prototype.broadcastWatch = function(c, options) {
            var lastDiff = c.lastDiff;
            var diff = this.diff(c);
            if (options) {
              if (c.optimistic && typeof options.optimistic === "string") {
                diff.fromOptimisticTransaction = true;
              }
              if (options.onWatchUpdated && options.onWatchUpdated.call(this, c, diff, lastDiff) === false) {
                return;
              }
            }
            if (!lastDiff || !equal(lastDiff.result, diff.result)) {
              c.callback(c.lastDiff = diff, lastDiff);
            }
          };
          return InMemoryCache2;
        }(ApolloCache);
        ;
        function isObjectLike(value) {
          return typeof value == "object" && value !== null;
        }
        ;
        function invariant_invariant(condition, message) {
          const booleanCondition = Boolean(condition);
          if (!booleanCondition) {
            throw new Error(
              message != null ? message : "Unexpected invariant triggered."
            );
          }
        }
        ;
        const LineRegExp = /\r\n|[\n\r]/g;
        function getLocation(source, position) {
          let lastLineStart = 0;
          let line = 1;
          for (const match of source.body.matchAll(LineRegExp)) {
            typeof match.index === "number" || invariant_invariant(false);
            if (match.index >= position) {
              break;
            }
            lastLineStart = match.index + match[0].length;
            line += 1;
          }
          return {
            line,
            column: position + 1 - lastLineStart
          };
        }
        ;
        function printLocation(location) {
          return printSourceLocation(
            location.source,
            getLocation(location.source, location.start)
          );
        }
        function printSourceLocation(source, sourceLocation) {
          const firstLineColumnOffset = source.locationOffset.column - 1;
          const body = "".padStart(firstLineColumnOffset) + source.body;
          const lineIndex = sourceLocation.line - 1;
          const lineOffset = source.locationOffset.line - 1;
          const lineNum = sourceLocation.line + lineOffset;
          const columnOffset = sourceLocation.line === 1 ? firstLineColumnOffset : 0;
          const columnNum = sourceLocation.column + columnOffset;
          const locationStr = `${source.name}:${lineNum}:${columnNum}
`;
          const lines = body.split(/\r\n|[\n\r]/g);
          const locationLine = lines[lineIndex];
          if (locationLine.length > 120) {
            const subLineIndex = Math.floor(columnNum / 80);
            const subLineColumnNum = columnNum % 80;
            const subLines = [];
            for (let i2 = 0; i2 < locationLine.length; i2 += 80) {
              subLines.push(locationLine.slice(i2, i2 + 80));
            }
            return locationStr + printPrefixedLines([
              [`${lineNum} |`, subLines[0]],
              ...subLines.slice(1, subLineIndex + 1).map((subLine) => ["|", subLine]),
              ["|", "^".padStart(subLineColumnNum)],
              ["|", subLines[subLineIndex + 1]]
            ]);
          }
          return locationStr + printPrefixedLines([
            // Lines specified like this: ["prefix", "string"],
            [`${lineNum - 1} |`, lines[lineIndex - 1]],
            [`${lineNum} |`, locationLine],
            ["|", "^".padStart(columnNum)],
            [`${lineNum + 1} |`, lines[lineIndex + 1]]
          ]);
        }
        function printPrefixedLines(lines) {
          const existingLines = lines.filter(([_, line]) => line !== void 0);
          const padLen = Math.max(...existingLines.map(([prefix]) => prefix.length));
          return existingLines.map(([prefix, line]) => prefix.padStart(padLen) + (line ? " " + line : "")).join("\n");
        }
        ;
        function toNormalizedOptions(args) {
          const firstArg = args[0];
          if (firstArg == null || "kind" in firstArg || "length" in firstArg) {
            return {
              nodes: firstArg,
              source: args[1],
              positions: args[2],
              path: args[3],
              originalError: args[4],
              extensions: args[5]
            };
          }
          return firstArg;
        }
        class GraphQLError extends Error {
          /**
           * An array of `{ line, column }` locations within the source GraphQL document
           * which correspond to this error.
           *
           * Errors during validation often contain multiple locations, for example to
           * point out two things with the same name. Errors during execution include a
           * single location, the field which produced the error.
           *
           * Enumerable, and appears in the result of JSON.stringify().
           */
          /**
           * An array describing the JSON-path into the execution response which
           * corresponds to this error. Only included for errors during execution.
           *
           * Enumerable, and appears in the result of JSON.stringify().
           */
          /**
           * An array of GraphQL AST Nodes corresponding to this error.
           */
          /**
           * The source GraphQL document for the first location of this error.
           *
           * Note that if this Error represents more than one node, the source may not
           * represent nodes after the first node.
           */
          /**
           * An array of character offsets within the source GraphQL document
           * which correspond to this error.
           */
          /**
           * The original error thrown from a field resolver during execution.
           */
          /**
           * Extension fields to add to the formatted error.
           */
          /**
           * @deprecated Please use the `GraphQLErrorOptions` constructor overload instead.
           */
          constructor(message, ...rawArgs) {
            var _this$nodes, _nodeLocations$, _ref;
            const { nodes, source, positions, path, originalError, extensions } = toNormalizedOptions(rawArgs);
            super(message);
            this.name = "GraphQLError";
            this.path = path !== null && path !== void 0 ? path : void 0;
            this.originalError = originalError !== null && originalError !== void 0 ? originalError : void 0;
            this.nodes = undefinedIfEmpty(
              Array.isArray(nodes) ? nodes : nodes ? [nodes] : void 0
            );
            const nodeLocations = undefinedIfEmpty(
              (_this$nodes = this.nodes) === null || _this$nodes === void 0 ? void 0 : _this$nodes.map((node) => node.loc).filter((loc) => loc != null)
            );
            this.source = source !== null && source !== void 0 ? source : nodeLocations === null || nodeLocations === void 0 ? void 0 : (_nodeLocations$ = nodeLocations[0]) === null || _nodeLocations$ === void 0 ? void 0 : _nodeLocations$.source;
            this.positions = positions !== null && positions !== void 0 ? positions : nodeLocations === null || nodeLocations === void 0 ? void 0 : nodeLocations.map((loc) => loc.start);
            this.locations = positions && source ? positions.map((pos) => getLocation(source, pos)) : nodeLocations === null || nodeLocations === void 0 ? void 0 : nodeLocations.map((loc) => getLocation(loc.source, loc.start));
            const originalExtensions = isObjectLike(
              originalError === null || originalError === void 0 ? void 0 : originalError.extensions
            ) ? originalError === null || originalError === void 0 ? void 0 : originalError.extensions : void 0;
            this.extensions = (_ref = extensions !== null && extensions !== void 0 ? extensions : originalExtensions) !== null && _ref !== void 0 ? _ref : /* @__PURE__ */ Object.create(null);
            Object.defineProperties(this, {
              message: {
                writable: true,
                enumerable: true
              },
              name: {
                enumerable: false
              },
              nodes: {
                enumerable: false
              },
              source: {
                enumerable: false
              },
              positions: {
                enumerable: false
              },
              originalError: {
                enumerable: false
              }
            });
            if (originalError !== null && originalError !== void 0 && originalError.stack) {
              Object.defineProperty(this, "stack", {
                value: originalError.stack,
                writable: true,
                configurable: true
              });
            } else if (Error.captureStackTrace) {
              Error.captureStackTrace(this, GraphQLError);
            } else {
              Object.defineProperty(this, "stack", {
                value: Error().stack,
                writable: true,
                configurable: true
              });
            }
          }
          get [Symbol.toStringTag]() {
            return "GraphQLError";
          }
          toString() {
            let output = this.message;
            if (this.nodes) {
              for (const node of this.nodes) {
                if (node.loc) {
                  output += "\n\n" + printLocation(node.loc);
                }
              }
            } else if (this.source && this.locations) {
              for (const location of this.locations) {
                output += "\n\n" + printSourceLocation(this.source, location);
              }
            }
            return output;
          }
          toJSON() {
            const formattedError = {
              message: this.message
            };
            if (this.locations != null) {
              formattedError.locations = this.locations;
            }
            if (this.path != null) {
              formattedError.path = this.path;
            }
            if (this.extensions != null && Object.keys(this.extensions).length > 0) {
              formattedError.extensions = this.extensions;
            }
            return formattedError;
          }
        }
        function undefinedIfEmpty(array) {
          return array === void 0 || array.length === 0 ? void 0 : array;
        }
        function printError(error) {
          return error.toString();
        }
        function formatError(error) {
          return error.toJSON();
        }
        ;
        function syntaxError(source, position, description) {
          return new GraphQLError(`Syntax Error: ${description}`, {
            source,
            positions: [position]
          });
        }
        ;
        var DirectiveLocation;
        (function(DirectiveLocation2) {
          DirectiveLocation2["QUERY"] = "QUERY";
          DirectiveLocation2["MUTATION"] = "MUTATION";
          DirectiveLocation2["SUBSCRIPTION"] = "SUBSCRIPTION";
          DirectiveLocation2["FIELD"] = "FIELD";
          DirectiveLocation2["FRAGMENT_DEFINITION"] = "FRAGMENT_DEFINITION";
          DirectiveLocation2["FRAGMENT_SPREAD"] = "FRAGMENT_SPREAD";
          DirectiveLocation2["INLINE_FRAGMENT"] = "INLINE_FRAGMENT";
          DirectiveLocation2["VARIABLE_DEFINITION"] = "VARIABLE_DEFINITION";
          DirectiveLocation2["SCHEMA"] = "SCHEMA";
          DirectiveLocation2["SCALAR"] = "SCALAR";
          DirectiveLocation2["OBJECT"] = "OBJECT";
          DirectiveLocation2["FIELD_DEFINITION"] = "FIELD_DEFINITION";
          DirectiveLocation2["ARGUMENT_DEFINITION"] = "ARGUMENT_DEFINITION";
          DirectiveLocation2["INTERFACE"] = "INTERFACE";
          DirectiveLocation2["UNION"] = "UNION";
          DirectiveLocation2["ENUM"] = "ENUM";
          DirectiveLocation2["ENUM_VALUE"] = "ENUM_VALUE";
          DirectiveLocation2["INPUT_OBJECT"] = "INPUT_OBJECT";
          DirectiveLocation2["INPUT_FIELD_DEFINITION"] = "INPUT_FIELD_DEFINITION";
        })(DirectiveLocation || (DirectiveLocation = {}));
        ;
        var tokenKind_TokenKind;
        (function(TokenKind2) {
          TokenKind2["SOF"] = "<SOF>";
          TokenKind2["EOF"] = "<EOF>";
          TokenKind2["BANG"] = "!";
          TokenKind2["DOLLAR"] = "$";
          TokenKind2["AMP"] = "&";
          TokenKind2["PAREN_L"] = "(";
          TokenKind2["PAREN_R"] = ")";
          TokenKind2["SPREAD"] = "...";
          TokenKind2["COLON"] = ":";
          TokenKind2["EQUALS"] = "=";
          TokenKind2["AT"] = "@";
          TokenKind2["BRACKET_L"] = "[";
          TokenKind2["BRACKET_R"] = "]";
          TokenKind2["BRACE_L"] = "{";
          TokenKind2["PIPE"] = "|";
          TokenKind2["BRACE_R"] = "}";
          TokenKind2["NAME"] = "Name";
          TokenKind2["INT"] = "Int";
          TokenKind2["FLOAT"] = "Float";
          TokenKind2["STRING"] = "String";
          TokenKind2["BLOCK_STRING"] = "BlockString";
          TokenKind2["COMMENT"] = "Comment";
        })(tokenKind_TokenKind || (tokenKind_TokenKind = {}));
        ;
        class Lexer {
          /**
           * The previously focused non-ignored token.
           */
          /**
           * The currently focused non-ignored token.
           */
          /**
           * The (1-indexed) line containing the current token.
           */
          /**
           * The character offset at which the current line begins.
           */
          constructor(source) {
            const startOfFileToken = new Token(tokenKind_TokenKind.SOF, 0, 0, 0, 0);
            this.source = source;
            this.lastToken = startOfFileToken;
            this.token = startOfFileToken;
            this.line = 1;
            this.lineStart = 0;
          }
          get [Symbol.toStringTag]() {
            return "Lexer";
          }
          /**
           * Advances the token stream to the next non-ignored token.
           */
          advance() {
            this.lastToken = this.token;
            const token = this.token = this.lookahead();
            return token;
          }
          /**
           * Looks ahead and returns the next non-ignored token, but does not change
           * the state of Lexer.
           */
          lookahead() {
            let token = this.token;
            if (token.kind !== tokenKind_TokenKind.EOF) {
              do {
                if (token.next) {
                  token = token.next;
                } else {
                  const nextToken = readNextToken(this, token.end);
                  token.next = nextToken;
                  nextToken.prev = token;
                  token = nextToken;
                }
              } while (token.kind === tokenKind_TokenKind.COMMENT);
            }
            return token;
          }
        }
        function isPunctuatorTokenKind(kind) {
          return kind === tokenKind_TokenKind.BANG || kind === tokenKind_TokenKind.DOLLAR || kind === tokenKind_TokenKind.AMP || kind === tokenKind_TokenKind.PAREN_L || kind === tokenKind_TokenKind.PAREN_R || kind === tokenKind_TokenKind.SPREAD || kind === tokenKind_TokenKind.COLON || kind === tokenKind_TokenKind.EQUALS || kind === tokenKind_TokenKind.AT || kind === tokenKind_TokenKind.BRACKET_L || kind === tokenKind_TokenKind.BRACKET_R || kind === tokenKind_TokenKind.BRACE_L || kind === tokenKind_TokenKind.PIPE || kind === tokenKind_TokenKind.BRACE_R;
        }
        function isUnicodeScalarValue(code) {
          return code >= 0 && code <= 55295 || code >= 57344 && code <= 1114111;
        }
        function isSupplementaryCodePoint(body, location) {
          return isLeadingSurrogate(body.charCodeAt(location)) && isTrailingSurrogate(body.charCodeAt(location + 1));
        }
        function isLeadingSurrogate(code) {
          return code >= 55296 && code <= 56319;
        }
        function isTrailingSurrogate(code) {
          return code >= 56320 && code <= 57343;
        }
        function printCodePointAt(lexer, location) {
          const code = lexer.source.body.codePointAt(location);
          if (code === void 0) {
            return tokenKind_TokenKind.EOF;
          } else if (code >= 32 && code <= 126) {
            const char = String.fromCodePoint(code);
            return char === '"' ? `'"'` : `"${char}"`;
          }
          return "U+" + code.toString(16).toUpperCase().padStart(4, "0");
        }
        function createToken(lexer, kind, start, end, value) {
          const line = lexer.line;
          const col = 1 + start - lexer.lineStart;
          return new Token(kind, start, end, line, col, value);
        }
        function readNextToken(lexer, start) {
          const body = lexer.source.body;
          const bodyLength = body.length;
          let position = start;
          while (position < bodyLength) {
            const code = body.charCodeAt(position);
            switch (code) {
              case 65279:
              case 9:
              case 32:
              case 44:
                ++position;
                continue;
              case 10:
                ++position;
                ++lexer.line;
                lexer.lineStart = position;
                continue;
              case 13:
                if (body.charCodeAt(position + 1) === 10) {
                  position += 2;
                } else {
                  ++position;
                }
                ++lexer.line;
                lexer.lineStart = position;
                continue;
              case 35:
                return readComment(lexer, position);
              case 33:
                return createToken(lexer, tokenKind_TokenKind.BANG, position, position + 1);
              case 36:
                return createToken(lexer, tokenKind_TokenKind.DOLLAR, position, position + 1);
              case 38:
                return createToken(lexer, tokenKind_TokenKind.AMP, position, position + 1);
              case 40:
                return createToken(lexer, tokenKind_TokenKind.PAREN_L, position, position + 1);
              case 41:
                return createToken(lexer, tokenKind_TokenKind.PAREN_R, position, position + 1);
              case 46:
                if (body.charCodeAt(position + 1) === 46 && body.charCodeAt(position + 2) === 46) {
                  return createToken(lexer, tokenKind_TokenKind.SPREAD, position, position + 3);
                }
                break;
              case 58:
                return createToken(lexer, tokenKind_TokenKind.COLON, position, position + 1);
              case 61:
                return createToken(lexer, tokenKind_TokenKind.EQUALS, position, position + 1);
              case 64:
                return createToken(lexer, tokenKind_TokenKind.AT, position, position + 1);
              case 91:
                return createToken(lexer, tokenKind_TokenKind.BRACKET_L, position, position + 1);
              case 93:
                return createToken(lexer, tokenKind_TokenKind.BRACKET_R, position, position + 1);
              case 123:
                return createToken(lexer, tokenKind_TokenKind.BRACE_L, position, position + 1);
              case 124:
                return createToken(lexer, tokenKind_TokenKind.PIPE, position, position + 1);
              case 125:
                return createToken(lexer, tokenKind_TokenKind.BRACE_R, position, position + 1);
              case 34:
                if (body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34) {
                  return readBlockString(lexer, position);
                }
                return readString(lexer, position);
            }
            if (isDigit(code) || code === 45) {
              return readNumber(lexer, position, code);
            }
            if (isNameStart(code)) {
              return readName(lexer, position);
            }
            throw syntaxError(
              lexer.source,
              position,
              code === 39 ? `Unexpected single quote character ('), did you mean to use a double quote (")?` : isUnicodeScalarValue(code) || isSupplementaryCodePoint(body, position) ? `Unexpected character: ${printCodePointAt(lexer, position)}.` : `Invalid character: ${printCodePointAt(lexer, position)}.`
            );
          }
          return createToken(lexer, tokenKind_TokenKind.EOF, bodyLength, bodyLength);
        }
        function readComment(lexer, start) {
          const body = lexer.source.body;
          const bodyLength = body.length;
          let position = start + 1;
          while (position < bodyLength) {
            const code = body.charCodeAt(position);
            if (code === 10 || code === 13) {
              break;
            }
            if (isUnicodeScalarValue(code)) {
              ++position;
            } else if (isSupplementaryCodePoint(body, position)) {
              position += 2;
            } else {
              break;
            }
          }
          return createToken(
            lexer,
            tokenKind_TokenKind.COMMENT,
            start,
            position,
            body.slice(start + 1, position)
          );
        }
        function readNumber(lexer, start, firstCode) {
          const body = lexer.source.body;
          let position = start;
          let code = firstCode;
          let isFloat = false;
          if (code === 45) {
            code = body.charCodeAt(++position);
          }
          if (code === 48) {
            code = body.charCodeAt(++position);
            if (isDigit(code)) {
              throw syntaxError(
                lexer.source,
                position,
                `Invalid number, unexpected digit after 0: ${printCodePointAt(
                  lexer,
                  position
                )}.`
              );
            }
          } else {
            position = readDigits(lexer, position, code);
            code = body.charCodeAt(position);
          }
          if (code === 46) {
            isFloat = true;
            code = body.charCodeAt(++position);
            position = readDigits(lexer, position, code);
            code = body.charCodeAt(position);
          }
          if (code === 69 || code === 101) {
            isFloat = true;
            code = body.charCodeAt(++position);
            if (code === 43 || code === 45) {
              code = body.charCodeAt(++position);
            }
            position = readDigits(lexer, position, code);
            code = body.charCodeAt(position);
          }
          if (code === 46 || isNameStart(code)) {
            throw syntaxError(
              lexer.source,
              position,
              `Invalid number, expected digit but got: ${printCodePointAt(
                lexer,
                position
              )}.`
            );
          }
          return createToken(
            lexer,
            isFloat ? tokenKind_TokenKind.FLOAT : tokenKind_TokenKind.INT,
            start,
            position,
            body.slice(start, position)
          );
        }
        function readDigits(lexer, start, firstCode) {
          if (!isDigit(firstCode)) {
            throw syntaxError(
              lexer.source,
              start,
              `Invalid number, expected digit but got: ${printCodePointAt(
                lexer,
                start
              )}.`
            );
          }
          const body = lexer.source.body;
          let position = start + 1;
          while (isDigit(body.charCodeAt(position))) {
            ++position;
          }
          return position;
        }
        function readString(lexer, start) {
          const body = lexer.source.body;
          const bodyLength = body.length;
          let position = start + 1;
          let chunkStart = position;
          let value = "";
          while (position < bodyLength) {
            const code = body.charCodeAt(position);
            if (code === 34) {
              value += body.slice(chunkStart, position);
              return createToken(lexer, tokenKind_TokenKind.STRING, start, position + 1, value);
            }
            if (code === 92) {
              value += body.slice(chunkStart, position);
              const escape = body.charCodeAt(position + 1) === 117 ? body.charCodeAt(position + 2) === 123 ? readEscapedUnicodeVariableWidth(lexer, position) : readEscapedUnicodeFixedWidth(lexer, position) : readEscapedCharacter(lexer, position);
              value += escape.value;
              position += escape.size;
              chunkStart = position;
              continue;
            }
            if (code === 10 || code === 13) {
              break;
            }
            if (isUnicodeScalarValue(code)) {
              ++position;
            } else if (isSupplementaryCodePoint(body, position)) {
              position += 2;
            } else {
              throw syntaxError(
                lexer.source,
                position,
                `Invalid character within String: ${printCodePointAt(
                  lexer,
                  position
                )}.`
              );
            }
          }
          throw syntaxError(lexer.source, position, "Unterminated string.");
        }
        function readEscapedUnicodeVariableWidth(lexer, position) {
          const body = lexer.source.body;
          let point = 0;
          let size = 3;
          while (size < 12) {
            const code = body.charCodeAt(position + size++);
            if (code === 125) {
              if (size < 5 || !isUnicodeScalarValue(point)) {
                break;
              }
              return {
                value: String.fromCodePoint(point),
                size
              };
            }
            point = point << 4 | readHexDigit(code);
            if (point < 0) {
              break;
            }
          }
          throw syntaxError(
            lexer.source,
            position,
            `Invalid Unicode escape sequence: "${body.slice(
              position,
              position + size
            )}".`
          );
        }
        function readEscapedUnicodeFixedWidth(lexer, position) {
          const body = lexer.source.body;
          const code = read16BitHexCode(body, position + 2);
          if (isUnicodeScalarValue(code)) {
            return {
              value: String.fromCodePoint(code),
              size: 6
            };
          }
          if (isLeadingSurrogate(code)) {
            if (body.charCodeAt(position + 6) === 92 && body.charCodeAt(position + 7) === 117) {
              const trailingCode = read16BitHexCode(body, position + 8);
              if (isTrailingSurrogate(trailingCode)) {
                return {
                  value: String.fromCodePoint(code, trailingCode),
                  size: 12
                };
              }
            }
          }
          throw syntaxError(
            lexer.source,
            position,
            `Invalid Unicode escape sequence: "${body.slice(position, position + 6)}".`
          );
        }
        function read16BitHexCode(body, position) {
          return readHexDigit(body.charCodeAt(position)) << 12 | readHexDigit(body.charCodeAt(position + 1)) << 8 | readHexDigit(body.charCodeAt(position + 2)) << 4 | readHexDigit(body.charCodeAt(position + 3));
        }
        function readHexDigit(code) {
          return code >= 48 && code <= 57 ? code - 48 : code >= 65 && code <= 70 ? code - 55 : code >= 97 && code <= 102 ? code - 87 : -1;
        }
        function readEscapedCharacter(lexer, position) {
          const body = lexer.source.body;
          const code = body.charCodeAt(position + 1);
          switch (code) {
            case 34:
              return {
                value: '"',
                size: 2
              };
            case 92:
              return {
                value: "\\",
                size: 2
              };
            case 47:
              return {
                value: "/",
                size: 2
              };
            case 98:
              return {
                value: "\b",
                size: 2
              };
            case 102:
              return {
                value: "\f",
                size: 2
              };
            case 110:
              return {
                value: "\n",
                size: 2
              };
            case 114:
              return {
                value: "\r",
                size: 2
              };
            case 116:
              return {
                value: "	",
                size: 2
              };
          }
          throw syntaxError(
            lexer.source,
            position,
            `Invalid character escape sequence: "${body.slice(
              position,
              position + 2
            )}".`
          );
        }
        function readBlockString(lexer, start) {
          const body = lexer.source.body;
          const bodyLength = body.length;
          let lineStart = lexer.lineStart;
          let position = start + 3;
          let chunkStart = position;
          let currentLine = "";
          const blockLines = [];
          while (position < bodyLength) {
            const code = body.charCodeAt(position);
            if (code === 34 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34) {
              currentLine += body.slice(chunkStart, position);
              blockLines.push(currentLine);
              const token = createToken(
                lexer,
                tokenKind_TokenKind.BLOCK_STRING,
                start,
                position + 3,
                // Return a string of the lines joined with U+000A.
                dedentBlockStringLines(blockLines).join("\n")
              );
              lexer.line += blockLines.length - 1;
              lexer.lineStart = lineStart;
              return token;
            }
            if (code === 92 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34 && body.charCodeAt(position + 3) === 34) {
              currentLine += body.slice(chunkStart, position);
              chunkStart = position + 1;
              position += 4;
              continue;
            }
            if (code === 10 || code === 13) {
              currentLine += body.slice(chunkStart, position);
              blockLines.push(currentLine);
              if (code === 13 && body.charCodeAt(position + 1) === 10) {
                position += 2;
              } else {
                ++position;
              }
              currentLine = "";
              chunkStart = position;
              lineStart = position;
              continue;
            }
            if (isUnicodeScalarValue(code)) {
              ++position;
            } else if (isSupplementaryCodePoint(body, position)) {
              position += 2;
            } else {
              throw syntaxError(
                lexer.source,
                position,
                `Invalid character within String: ${printCodePointAt(
                  lexer,
                  position
                )}.`
              );
            }
          }
          throw syntaxError(lexer.source, position, "Unterminated string.");
        }
        function readName(lexer, start) {
          const body = lexer.source.body;
          const bodyLength = body.length;
          let position = start + 1;
          while (position < bodyLength) {
            const code = body.charCodeAt(position);
            if (isNameContinue(code)) {
              ++position;
            } else {
              break;
            }
          }
          return createToken(
            lexer,
            tokenKind_TokenKind.NAME,
            start,
            position,
            body.slice(start, position)
          );
        }
        ;
        function parse(source, options) {
          const parser = new Parser(source, options);
          return parser.parseDocument();
        }
        function parseValue(source, options) {
          const parser = new Parser(source, options);
          parser.expectToken(TokenKind.SOF);
          const value = parser.parseValueLiteral(false);
          parser.expectToken(TokenKind.EOF);
          return value;
        }
        function parseConstValue(source, options) {
          const parser = new Parser(source, options);
          parser.expectToken(TokenKind.SOF);
          const value = parser.parseConstValueLiteral();
          parser.expectToken(TokenKind.EOF);
          return value;
        }
        function parseType(source, options) {
          const parser = new Parser(source, options);
          parser.expectToken(TokenKind.SOF);
          const type = parser.parseTypeReference();
          parser.expectToken(TokenKind.EOF);
          return type;
        }
        class Parser {
          constructor(source, options = {}) {
            const sourceObj = isSource(source) ? source : new Source(source);
            this._lexer = new Lexer(sourceObj);
            this._options = options;
            this._tokenCounter = 0;
          }
          /**
           * Converts a name lex token into a name parse node.
           */
          parseName() {
            const token = this.expectToken(tokenKind_TokenKind.NAME);
            return this.node(token, {
              kind: kinds_Kind.NAME,
              value: token.value
            });
          }
          // Implements the parsing rules in the Document section.
          /**
           * Document : Definition+
           */
          parseDocument() {
            return this.node(this._lexer.token, {
              kind: kinds_Kind.DOCUMENT,
              definitions: this.many(
                tokenKind_TokenKind.SOF,
                this.parseDefinition,
                tokenKind_TokenKind.EOF
              )
            });
          }
          /**
           * Definition :
           *   - ExecutableDefinition
           *   - TypeSystemDefinition
           *   - TypeSystemExtension
           *
           * ExecutableDefinition :
           *   - OperationDefinition
           *   - FragmentDefinition
           *
           * TypeSystemDefinition :
           *   - SchemaDefinition
           *   - TypeDefinition
           *   - DirectiveDefinition
           *
           * TypeDefinition :
           *   - ScalarTypeDefinition
           *   - ObjectTypeDefinition
           *   - InterfaceTypeDefinition
           *   - UnionTypeDefinition
           *   - EnumTypeDefinition
           *   - InputObjectTypeDefinition
           */
          parseDefinition() {
            if (this.peek(tokenKind_TokenKind.BRACE_L)) {
              return this.parseOperationDefinition();
            }
            const hasDescription = this.peekDescription();
            const keywordToken = hasDescription ? this._lexer.lookahead() : this._lexer.token;
            if (keywordToken.kind === tokenKind_TokenKind.NAME) {
              switch (keywordToken.value) {
                case "schema":
                  return this.parseSchemaDefinition();
                case "scalar":
                  return this.parseScalarTypeDefinition();
                case "type":
                  return this.parseObjectTypeDefinition();
                case "interface":
                  return this.parseInterfaceTypeDefinition();
                case "union":
                  return this.parseUnionTypeDefinition();
                case "enum":
                  return this.parseEnumTypeDefinition();
                case "input":
                  return this.parseInputObjectTypeDefinition();
                case "directive":
                  return this.parseDirectiveDefinition();
              }
              if (hasDescription) {
                throw syntaxError(
                  this._lexer.source,
                  this._lexer.token.start,
                  "Unexpected description, descriptions are supported only on type definitions."
                );
              }
              switch (keywordToken.value) {
                case "query":
                case "mutation":
                case "subscription":
                  return this.parseOperationDefinition();
                case "fragment":
                  return this.parseFragmentDefinition();
                case "extend":
                  return this.parseTypeSystemExtension();
              }
            }
            throw this.unexpected(keywordToken);
          }
          // Implements the parsing rules in the Operations section.
          /**
           * OperationDefinition :
           *  - SelectionSet
           *  - OperationType Name? VariableDefinitions? Directives? SelectionSet
           */
          parseOperationDefinition() {
            const start = this._lexer.token;
            if (this.peek(tokenKind_TokenKind.BRACE_L)) {
              return this.node(start, {
                kind: kinds_Kind.OPERATION_DEFINITION,
                operation: OperationTypeNode.QUERY,
                name: void 0,
                variableDefinitions: [],
                directives: [],
                selectionSet: this.parseSelectionSet()
              });
            }
            const operation = this.parseOperationType();
            let name;
            if (this.peek(tokenKind_TokenKind.NAME)) {
              name = this.parseName();
            }
            return this.node(start, {
              kind: kinds_Kind.OPERATION_DEFINITION,
              operation,
              name,
              variableDefinitions: this.parseVariableDefinitions(),
              directives: this.parseDirectives(false),
              selectionSet: this.parseSelectionSet()
            });
          }
          /**
           * OperationType : one of query mutation subscription
           */
          parseOperationType() {
            const operationToken = this.expectToken(tokenKind_TokenKind.NAME);
            switch (operationToken.value) {
              case "query":
                return OperationTypeNode.QUERY;
              case "mutation":
                return OperationTypeNode.MUTATION;
              case "subscription":
                return OperationTypeNode.SUBSCRIPTION;
            }
            throw this.unexpected(operationToken);
          }
          /**
           * VariableDefinitions : ( VariableDefinition+ )
           */
          parseVariableDefinitions() {
            return this.optionalMany(
              tokenKind_TokenKind.PAREN_L,
              this.parseVariableDefinition,
              tokenKind_TokenKind.PAREN_R
            );
          }
          /**
           * VariableDefinition : Variable : Type DefaultValue? Directives[Const]?
           */
          parseVariableDefinition() {
            return this.node(this._lexer.token, {
              kind: kinds_Kind.VARIABLE_DEFINITION,
              variable: this.parseVariable(),
              type: (this.expectToken(tokenKind_TokenKind.COLON), this.parseTypeReference()),
              defaultValue: this.expectOptionalToken(tokenKind_TokenKind.EQUALS) ? this.parseConstValueLiteral() : void 0,
              directives: this.parseConstDirectives()
            });
          }
          /**
           * Variable : $ Name
           */
          parseVariable() {
            const start = this._lexer.token;
            this.expectToken(tokenKind_TokenKind.DOLLAR);
            return this.node(start, {
              kind: kinds_Kind.VARIABLE,
              name: this.parseName()
            });
          }
          /**
           * ```
           * SelectionSet : { Selection+ }
           * ```
           */
          parseSelectionSet() {
            return this.node(this._lexer.token, {
              kind: kinds_Kind.SELECTION_SET,
              selections: this.many(
                tokenKind_TokenKind.BRACE_L,
                this.parseSelection,
                tokenKind_TokenKind.BRACE_R
              )
            });
          }
          /**
           * Selection :
           *   - Field
           *   - FragmentSpread
           *   - InlineFragment
           */
          parseSelection() {
            return this.peek(tokenKind_TokenKind.SPREAD) ? this.parseFragment() : this.parseField();
          }
          /**
           * Field : Alias? Name Arguments? Directives? SelectionSet?
           *
           * Alias : Name :
           */
          parseField() {
            const start = this._lexer.token;
            const nameOrAlias = this.parseName();
            let alias;
            let name;
            if (this.expectOptionalToken(tokenKind_TokenKind.COLON)) {
              alias = nameOrAlias;
              name = this.parseName();
            } else {
              name = nameOrAlias;
            }
            return this.node(start, {
              kind: kinds_Kind.FIELD,
              alias,
              name,
              arguments: this.parseArguments(false),
              directives: this.parseDirectives(false),
              selectionSet: this.peek(tokenKind_TokenKind.BRACE_L) ? this.parseSelectionSet() : void 0
            });
          }
          /**
           * Arguments[Const] : ( Argument[?Const]+ )
           */
          parseArguments(isConst) {
            const item = isConst ? this.parseConstArgument : this.parseArgument;
            return this.optionalMany(tokenKind_TokenKind.PAREN_L, item, tokenKind_TokenKind.PAREN_R);
          }
          /**
           * Argument[Const] : Name : Value[?Const]
           */
          parseArgument(isConst = false) {
            const start = this._lexer.token;
            const name = this.parseName();
            this.expectToken(tokenKind_TokenKind.COLON);
            return this.node(start, {
              kind: kinds_Kind.ARGUMENT,
              name,
              value: this.parseValueLiteral(isConst)
            });
          }
          parseConstArgument() {
            return this.parseArgument(true);
          }
          // Implements the parsing rules in the Fragments section.
          /**
           * Corresponds to both FragmentSpread and InlineFragment in the spec.
           *
           * FragmentSpread : ... FragmentName Directives?
           *
           * InlineFragment : ... TypeCondition? Directives? SelectionSet
           */
          parseFragment() {
            const start = this._lexer.token;
            this.expectToken(tokenKind_TokenKind.SPREAD);
            const hasTypeCondition = this.expectOptionalKeyword("on");
            if (!hasTypeCondition && this.peek(tokenKind_TokenKind.NAME)) {
              return this.node(start, {
                kind: kinds_Kind.FRAGMENT_SPREAD,
                name: this.parseFragmentName(),
                directives: this.parseDirectives(false)
              });
            }
            return this.node(start, {
              kind: kinds_Kind.INLINE_FRAGMENT,
              typeCondition: hasTypeCondition ? this.parseNamedType() : void 0,
              directives: this.parseDirectives(false),
              selectionSet: this.parseSelectionSet()
            });
          }
          /**
           * FragmentDefinition :
           *   - fragment FragmentName on TypeCondition Directives? SelectionSet
           *
           * TypeCondition : NamedType
           */
          parseFragmentDefinition() {
            const start = this._lexer.token;
            this.expectKeyword("fragment");
            if (this._options.allowLegacyFragmentVariables === true) {
              return this.node(start, {
                kind: kinds_Kind.FRAGMENT_DEFINITION,
                name: this.parseFragmentName(),
                variableDefinitions: this.parseVariableDefinitions(),
                typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
                directives: this.parseDirectives(false),
                selectionSet: this.parseSelectionSet()
              });
            }
            return this.node(start, {
              kind: kinds_Kind.FRAGMENT_DEFINITION,
              name: this.parseFragmentName(),
              typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
              directives: this.parseDirectives(false),
              selectionSet: this.parseSelectionSet()
            });
          }
          /**
           * FragmentName : Name but not `on`
           */
          parseFragmentName() {
            if (this._lexer.token.value === "on") {
              throw this.unexpected();
            }
            return this.parseName();
          }
          // Implements the parsing rules in the Values section.
          /**
           * Value[Const] :
           *   - [~Const] Variable
           *   - IntValue
           *   - FloatValue
           *   - StringValue
           *   - BooleanValue
           *   - NullValue
           *   - EnumValue
           *   - ListValue[?Const]
           *   - ObjectValue[?Const]
           *
           * BooleanValue : one of `true` `false`
           *
           * NullValue : `null`
           *
           * EnumValue : Name but not `true`, `false` or `null`
           */
          parseValueLiteral(isConst) {
            const token = this._lexer.token;
            switch (token.kind) {
              case tokenKind_TokenKind.BRACKET_L:
                return this.parseList(isConst);
              case tokenKind_TokenKind.BRACE_L:
                return this.parseObject(isConst);
              case tokenKind_TokenKind.INT:
                this.advanceLexer();
                return this.node(token, {
                  kind: kinds_Kind.INT,
                  value: token.value
                });
              case tokenKind_TokenKind.FLOAT:
                this.advanceLexer();
                return this.node(token, {
                  kind: kinds_Kind.FLOAT,
                  value: token.value
                });
              case tokenKind_TokenKind.STRING:
              case tokenKind_TokenKind.BLOCK_STRING:
                return this.parseStringLiteral();
              case tokenKind_TokenKind.NAME:
                this.advanceLexer();
                switch (token.value) {
                  case "true":
                    return this.node(token, {
                      kind: kinds_Kind.BOOLEAN,
                      value: true
                    });
                  case "false":
                    return this.node(token, {
                      kind: kinds_Kind.BOOLEAN,
                      value: false
                    });
                  case "null":
                    return this.node(token, {
                      kind: kinds_Kind.NULL
                    });
                  default:
                    return this.node(token, {
                      kind: kinds_Kind.ENUM,
                      value: token.value
                    });
                }
              case tokenKind_TokenKind.DOLLAR:
                if (isConst) {
                  this.expectToken(tokenKind_TokenKind.DOLLAR);
                  if (this._lexer.token.kind === tokenKind_TokenKind.NAME) {
                    const varName = this._lexer.token.value;
                    throw syntaxError(
                      this._lexer.source,
                      token.start,
                      `Unexpected variable "$${varName}" in constant value.`
                    );
                  } else {
                    throw this.unexpected(token);
                  }
                }
                return this.parseVariable();
              default:
                throw this.unexpected();
            }
          }
          parseConstValueLiteral() {
            return this.parseValueLiteral(true);
          }
          parseStringLiteral() {
            const token = this._lexer.token;
            this.advanceLexer();
            return this.node(token, {
              kind: kinds_Kind.STRING,
              value: token.value,
              block: token.kind === tokenKind_TokenKind.BLOCK_STRING
            });
          }
          /**
           * ListValue[Const] :
           *   - [ ]
           *   - [ Value[?Const]+ ]
           */
          parseList(isConst) {
            const item = () => this.parseValueLiteral(isConst);
            return this.node(this._lexer.token, {
              kind: kinds_Kind.LIST,
              values: this.any(tokenKind_TokenKind.BRACKET_L, item, tokenKind_TokenKind.BRACKET_R)
            });
          }
          /**
           * ```
           * ObjectValue[Const] :
           *   - { }
           *   - { ObjectField[?Const]+ }
           * ```
           */
          parseObject(isConst) {
            const item = () => this.parseObjectField(isConst);
            return this.node(this._lexer.token, {
              kind: kinds_Kind.OBJECT,
              fields: this.any(tokenKind_TokenKind.BRACE_L, item, tokenKind_TokenKind.BRACE_R)
            });
          }
          /**
           * ObjectField[Const] : Name : Value[?Const]
           */
          parseObjectField(isConst) {
            const start = this._lexer.token;
            const name = this.parseName();
            this.expectToken(tokenKind_TokenKind.COLON);
            return this.node(start, {
              kind: kinds_Kind.OBJECT_FIELD,
              name,
              value: this.parseValueLiteral(isConst)
            });
          }
          // Implements the parsing rules in the Directives section.
          /**
           * Directives[Const] : Directive[?Const]+
           */
          parseDirectives(isConst) {
            const directives = [];
            while (this.peek(tokenKind_TokenKind.AT)) {
              directives.push(this.parseDirective(isConst));
            }
            return directives;
          }
          parseConstDirectives() {
            return this.parseDirectives(true);
          }
          /**
           * ```
           * Directive[Const] : @ Name Arguments[?Const]?
           * ```
           */
          parseDirective(isConst) {
            const start = this._lexer.token;
            this.expectToken(tokenKind_TokenKind.AT);
            return this.node(start, {
              kind: kinds_Kind.DIRECTIVE,
              name: this.parseName(),
              arguments: this.parseArguments(isConst)
            });
          }
          // Implements the parsing rules in the Types section.
          /**
           * Type :
           *   - NamedType
           *   - ListType
           *   - NonNullType
           */
          parseTypeReference() {
            const start = this._lexer.token;
            let type;
            if (this.expectOptionalToken(tokenKind_TokenKind.BRACKET_L)) {
              const innerType = this.parseTypeReference();
              this.expectToken(tokenKind_TokenKind.BRACKET_R);
              type = this.node(start, {
                kind: kinds_Kind.LIST_TYPE,
                type: innerType
              });
            } else {
              type = this.parseNamedType();
            }
            if (this.expectOptionalToken(tokenKind_TokenKind.BANG)) {
              return this.node(start, {
                kind: kinds_Kind.NON_NULL_TYPE,
                type
              });
            }
            return type;
          }
          /**
           * NamedType : Name
           */
          parseNamedType() {
            return this.node(this._lexer.token, {
              kind: kinds_Kind.NAMED_TYPE,
              name: this.parseName()
            });
          }
          // Implements the parsing rules in the Type Definition section.
          peekDescription() {
            return this.peek(tokenKind_TokenKind.STRING) || this.peek(tokenKind_TokenKind.BLOCK_STRING);
          }
          /**
           * Description : StringValue
           */
          parseDescription() {
            if (this.peekDescription()) {
              return this.parseStringLiteral();
            }
          }
          /**
           * ```
           * SchemaDefinition : Description? schema Directives[Const]? { OperationTypeDefinition+ }
           * ```
           */
          parseSchemaDefinition() {
            const start = this._lexer.token;
            const description = this.parseDescription();
            this.expectKeyword("schema");
            const directives = this.parseConstDirectives();
            const operationTypes = this.many(
              tokenKind_TokenKind.BRACE_L,
              this.parseOperationTypeDefinition,
              tokenKind_TokenKind.BRACE_R
            );
            return this.node(start, {
              kind: kinds_Kind.SCHEMA_DEFINITION,
              description,
              directives,
              operationTypes
            });
          }
          /**
           * OperationTypeDefinition : OperationType : NamedType
           */
          parseOperationTypeDefinition() {
            const start = this._lexer.token;
            const operation = this.parseOperationType();
            this.expectToken(tokenKind_TokenKind.COLON);
            const type = this.parseNamedType();
            return this.node(start, {
              kind: kinds_Kind.OPERATION_TYPE_DEFINITION,
              operation,
              type
            });
          }
          /**
           * ScalarTypeDefinition : Description? scalar Name Directives[Const]?
           */
          parseScalarTypeDefinition() {
            const start = this._lexer.token;
            const description = this.parseDescription();
            this.expectKeyword("scalar");
            const name = this.parseName();
            const directives = this.parseConstDirectives();
            return this.node(start, {
              kind: kinds_Kind.SCALAR_TYPE_DEFINITION,
              description,
              name,
              directives
            });
          }
          /**
           * ObjectTypeDefinition :
           *   Description?
           *   type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition?
           */
          parseObjectTypeDefinition() {
            const start = this._lexer.token;
            const description = this.parseDescription();
            this.expectKeyword("type");
            const name = this.parseName();
            const interfaces = this.parseImplementsInterfaces();
            const directives = this.parseConstDirectives();
            const fields = this.parseFieldsDefinition();
            return this.node(start, {
              kind: kinds_Kind.OBJECT_TYPE_DEFINITION,
              description,
              name,
              interfaces,
              directives,
              fields
            });
          }
          /**
           * ImplementsInterfaces :
           *   - implements `&`? NamedType
           *   - ImplementsInterfaces & NamedType
           */
          parseImplementsInterfaces() {
            return this.expectOptionalKeyword("implements") ? this.delimitedMany(tokenKind_TokenKind.AMP, this.parseNamedType) : [];
          }
          /**
           * ```
           * FieldsDefinition : { FieldDefinition+ }
           * ```
           */
          parseFieldsDefinition() {
            return this.optionalMany(
              tokenKind_TokenKind.BRACE_L,
              this.parseFieldDefinition,
              tokenKind_TokenKind.BRACE_R
            );
          }
          /**
           * FieldDefinition :
           *   - Description? Name ArgumentsDefinition? : Type Directives[Const]?
           */
          parseFieldDefinition() {
            const start = this._lexer.token;
            const description = this.parseDescription();
            const name = this.parseName();
            const args = this.parseArgumentDefs();
            this.expectToken(tokenKind_TokenKind.COLON);
            const type = this.parseTypeReference();
            const directives = this.parseConstDirectives();
            return this.node(start, {
              kind: kinds_Kind.FIELD_DEFINITION,
              description,
              name,
              arguments: args,
              type,
              directives
            });
          }
          /**
           * ArgumentsDefinition : ( InputValueDefinition+ )
           */
          parseArgumentDefs() {
            return this.optionalMany(
              tokenKind_TokenKind.PAREN_L,
              this.parseInputValueDef,
              tokenKind_TokenKind.PAREN_R
            );
          }
          /**
           * InputValueDefinition :
           *   - Description? Name : Type DefaultValue? Directives[Const]?
           */
          parseInputValueDef() {
            const start = this._lexer.token;
            const description = this.parseDescription();
            const name = this.parseName();
            this.expectToken(tokenKind_TokenKind.COLON);
            const type = this.parseTypeReference();
            let defaultValue;
            if (this.expectOptionalToken(tokenKind_TokenKind.EQUALS)) {
              defaultValue = this.parseConstValueLiteral();
            }
            const directives = this.parseConstDirectives();
            return this.node(start, {
              kind: kinds_Kind.INPUT_VALUE_DEFINITION,
              description,
              name,
              type,
              defaultValue,
              directives
            });
          }
          /**
           * InterfaceTypeDefinition :
           *   - Description? interface Name Directives[Const]? FieldsDefinition?
           */
          parseInterfaceTypeDefinition() {
            const start = this._lexer.token;
            const description = this.parseDescription();
            this.expectKeyword("interface");
            const name = this.parseName();
            const interfaces = this.parseImplementsInterfaces();
            const directives = this.parseConstDirectives();
            const fields = this.parseFieldsDefinition();
            return this.node(start, {
              kind: kinds_Kind.INTERFACE_TYPE_DEFINITION,
              description,
              name,
              interfaces,
              directives,
              fields
            });
          }
          /**
           * UnionTypeDefinition :
           *   - Description? union Name Directives[Const]? UnionMemberTypes?
           */
          parseUnionTypeDefinition() {
            const start = this._lexer.token;
            const description = this.parseDescription();
            this.expectKeyword("union");
            const name = this.parseName();
            const directives = this.parseConstDirectives();
            const types = this.parseUnionMemberTypes();
            return this.node(start, {
              kind: kinds_Kind.UNION_TYPE_DEFINITION,
              description,
              name,
              directives,
              types
            });
          }
          /**
           * UnionMemberTypes :
           *   - = `|`? NamedType
           *   - UnionMemberTypes | NamedType
           */
          parseUnionMemberTypes() {
            return this.expectOptionalToken(tokenKind_TokenKind.EQUALS) ? this.delimitedMany(tokenKind_TokenKind.PIPE, this.parseNamedType) : [];
          }
          /**
           * EnumTypeDefinition :
           *   - Description? enum Name Directives[Const]? EnumValuesDefinition?
           */
          parseEnumTypeDefinition() {
            const start = this._lexer.token;
            const description = this.parseDescription();
            this.expectKeyword("enum");
            const name = this.parseName();
            const directives = this.parseConstDirectives();
            const values = this.parseEnumValuesDefinition();
            return this.node(start, {
              kind: kinds_Kind.ENUM_TYPE_DEFINITION,
              description,
              name,
              directives,
              values
            });
          }
          /**
           * ```
           * EnumValuesDefinition : { EnumValueDefinition+ }
           * ```
           */
          parseEnumValuesDefinition() {
            return this.optionalMany(
              tokenKind_TokenKind.BRACE_L,
              this.parseEnumValueDefinition,
              tokenKind_TokenKind.BRACE_R
            );
          }
          /**
           * EnumValueDefinition : Description? EnumValue Directives[Const]?
           */
          parseEnumValueDefinition() {
            const start = this._lexer.token;
            const description = this.parseDescription();
            const name = this.parseEnumValueName();
            const directives = this.parseConstDirectives();
            return this.node(start, {
              kind: kinds_Kind.ENUM_VALUE_DEFINITION,
              description,
              name,
              directives
            });
          }
          /**
           * EnumValue : Name but not `true`, `false` or `null`
           */
          parseEnumValueName() {
            if (this._lexer.token.value === "true" || this._lexer.token.value === "false" || this._lexer.token.value === "null") {
              throw syntaxError(
                this._lexer.source,
                this._lexer.token.start,
                `${getTokenDesc(
                  this._lexer.token
                )} is reserved and cannot be used for an enum value.`
              );
            }
            return this.parseName();
          }
          /**
           * InputObjectTypeDefinition :
           *   - Description? input Name Directives[Const]? InputFieldsDefinition?
           */
          parseInputObjectTypeDefinition() {
            const start = this._lexer.token;
            const description = this.parseDescription();
            this.expectKeyword("input");
            const name = this.parseName();
            const directives = this.parseConstDirectives();
            const fields = this.parseInputFieldsDefinition();
            return this.node(start, {
              kind: kinds_Kind.INPUT_OBJECT_TYPE_DEFINITION,
              description,
              name,
              directives,
              fields
            });
          }
          /**
           * ```
           * InputFieldsDefinition : { InputValueDefinition+ }
           * ```
           */
          parseInputFieldsDefinition() {
            return this.optionalMany(
              tokenKind_TokenKind.BRACE_L,
              this.parseInputValueDef,
              tokenKind_TokenKind.BRACE_R
            );
          }
          /**
           * TypeSystemExtension :
           *   - SchemaExtension
           *   - TypeExtension
           *
           * TypeExtension :
           *   - ScalarTypeExtension
           *   - ObjectTypeExtension
           *   - InterfaceTypeExtension
           *   - UnionTypeExtension
           *   - EnumTypeExtension
           *   - InputObjectTypeDefinition
           */
          parseTypeSystemExtension() {
            const keywordToken = this._lexer.lookahead();
            if (keywordToken.kind === tokenKind_TokenKind.NAME) {
              switch (keywordToken.value) {
                case "schema":
                  return this.parseSchemaExtension();
                case "scalar":
                  return this.parseScalarTypeExtension();
                case "type":
                  return this.parseObjectTypeExtension();
                case "interface":
                  return this.parseInterfaceTypeExtension();
                case "union":
                  return this.parseUnionTypeExtension();
                case "enum":
                  return this.parseEnumTypeExtension();
                case "input":
                  return this.parseInputObjectTypeExtension();
              }
            }
            throw this.unexpected(keywordToken);
          }
          /**
           * ```
           * SchemaExtension :
           *  - extend schema Directives[Const]? { OperationTypeDefinition+ }
           *  - extend schema Directives[Const]
           * ```
           */
          parseSchemaExtension() {
            const start = this._lexer.token;
            this.expectKeyword("extend");
            this.expectKeyword("schema");
            const directives = this.parseConstDirectives();
            const operationTypes = this.optionalMany(
              tokenKind_TokenKind.BRACE_L,
              this.parseOperationTypeDefinition,
              tokenKind_TokenKind.BRACE_R
            );
            if (directives.length === 0 && operationTypes.length === 0) {
              throw this.unexpected();
            }
            return this.node(start, {
              kind: kinds_Kind.SCHEMA_EXTENSION,
              directives,
              operationTypes
            });
          }
          /**
           * ScalarTypeExtension :
           *   - extend scalar Name Directives[Const]
           */
          parseScalarTypeExtension() {
            const start = this._lexer.token;
            this.expectKeyword("extend");
            this.expectKeyword("scalar");
            const name = this.parseName();
            const directives = this.parseConstDirectives();
            if (directives.length === 0) {
              throw this.unexpected();
            }
            return this.node(start, {
              kind: kinds_Kind.SCALAR_TYPE_EXTENSION,
              name,
              directives
            });
          }
          /**
           * ObjectTypeExtension :
           *  - extend type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition
           *  - extend type Name ImplementsInterfaces? Directives[Const]
           *  - extend type Name ImplementsInterfaces
           */
          parseObjectTypeExtension() {
            const start = this._lexer.token;
            this.expectKeyword("extend");
            this.expectKeyword("type");
            const name = this.parseName();
            const interfaces = this.parseImplementsInterfaces();
            const directives = this.parseConstDirectives();
            const fields = this.parseFieldsDefinition();
            if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {
              throw this.unexpected();
            }
            return this.node(start, {
              kind: kinds_Kind.OBJECT_TYPE_EXTENSION,
              name,
              interfaces,
              directives,
              fields
            });
          }
          /**
           * InterfaceTypeExtension :
           *  - extend interface Name ImplementsInterfaces? Directives[Const]? FieldsDefinition
           *  - extend interface Name ImplementsInterfaces? Directives[Const]
           *  - extend interface Name ImplementsInterfaces
           */
          parseInterfaceTypeExtension() {
            const start = this._lexer.token;
            this.expectKeyword("extend");
            this.expectKeyword("interface");
            const name = this.parseName();
            const interfaces = this.parseImplementsInterfaces();
            const directives = this.parseConstDirectives();
            const fields = this.parseFieldsDefinition();
            if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {
              throw this.unexpected();
            }
            return this.node(start, {
              kind: kinds_Kind.INTERFACE_TYPE_EXTENSION,
              name,
              interfaces,
              directives,
              fields
            });
          }
          /**
           * UnionTypeExtension :
           *   - extend union Name Directives[Const]? UnionMemberTypes
           *   - extend union Name Directives[Const]
           */
          parseUnionTypeExtension() {
            const start = this._lexer.token;
            this.expectKeyword("extend");
            this.expectKeyword("union");
            const name = this.parseName();
            const directives = this.parseConstDirectives();
            const types = this.parseUnionMemberTypes();
            if (directives.length === 0 && types.length === 0) {
              throw this.unexpected();
            }
            return this.node(start, {
              kind: kinds_Kind.UNION_TYPE_EXTENSION,
              name,
              directives,
              types
            });
          }
          /**
           * EnumTypeExtension :
           *   - extend enum Name Directives[Const]? EnumValuesDefinition
           *   - extend enum Name Directives[Const]
           */
          parseEnumTypeExtension() {
            const start = this._lexer.token;
            this.expectKeyword("extend");
            this.expectKeyword("enum");
            const name = this.parseName();
            const directives = this.parseConstDirectives();
            const values = this.parseEnumValuesDefinition();
            if (directives.length === 0 && values.length === 0) {
              throw this.unexpected();
            }
            return this.node(start, {
              kind: kinds_Kind.ENUM_TYPE_EXTENSION,
              name,
              directives,
              values
            });
          }
          /**
           * InputObjectTypeExtension :
           *   - extend input Name Directives[Const]? InputFieldsDefinition
           *   - extend input Name Directives[Const]
           */
          parseInputObjectTypeExtension() {
            const start = this._lexer.token;
            this.expectKeyword("extend");
            this.expectKeyword("input");
            const name = this.parseName();
            const directives = this.parseConstDirectives();
            const fields = this.parseInputFieldsDefinition();
            if (directives.length === 0 && fields.length === 0) {
              throw this.unexpected();
            }
            return this.node(start, {
              kind: kinds_Kind.INPUT_OBJECT_TYPE_EXTENSION,
              name,
              directives,
              fields
            });
          }
          /**
           * ```
           * DirectiveDefinition :
           *   - Description? directive @ Name ArgumentsDefinition? `repeatable`? on DirectiveLocations
           * ```
           */
          parseDirectiveDefinition() {
            const start = this._lexer.token;
            const description = this.parseDescription();
            this.expectKeyword("directive");
            this.expectToken(tokenKind_TokenKind.AT);
            const name = this.parseName();
            const args = this.parseArgumentDefs();
            const repeatable = this.expectOptionalKeyword("repeatable");
            this.expectKeyword("on");
            const locations = this.parseDirectiveLocations();
            return this.node(start, {
              kind: kinds_Kind.DIRECTIVE_DEFINITION,
              description,
              name,
              arguments: args,
              repeatable,
              locations
            });
          }
          /**
           * DirectiveLocations :
           *   - `|`? DirectiveLocation
           *   - DirectiveLocations | DirectiveLocation
           */
          parseDirectiveLocations() {
            return this.delimitedMany(tokenKind_TokenKind.PIPE, this.parseDirectiveLocation);
          }
          /*
           * DirectiveLocation :
           *   - ExecutableDirectiveLocation
           *   - TypeSystemDirectiveLocation
           *
           * ExecutableDirectiveLocation : one of
           *   `QUERY`
           *   `MUTATION`
           *   `SUBSCRIPTION`
           *   `FIELD`
           *   `FRAGMENT_DEFINITION`
           *   `FRAGMENT_SPREAD`
           *   `INLINE_FRAGMENT`
           *
           * TypeSystemDirectiveLocation : one of
           *   `SCHEMA`
           *   `SCALAR`
           *   `OBJECT`
           *   `FIELD_DEFINITION`
           *   `ARGUMENT_DEFINITION`
           *   `INTERFACE`
           *   `UNION`
           *   `ENUM`
           *   `ENUM_VALUE`
           *   `INPUT_OBJECT`
           *   `INPUT_FIELD_DEFINITION`
           */
          parseDirectiveLocation() {
            const start = this._lexer.token;
            const name = this.parseName();
            if (Object.prototype.hasOwnProperty.call(DirectiveLocation, name.value)) {
              return name;
            }
            throw this.unexpected(start);
          }
          // Core parsing utility functions
          /**
           * Returns a node that, if configured to do so, sets a "loc" field as a
           * location object, used to identify the place in the source that created a
           * given parsed object.
           */
          node(startToken, node) {
            if (this._options.noLocation !== true) {
              node.loc = new Location(
                startToken,
                this._lexer.lastToken,
                this._lexer.source
              );
            }
            return node;
          }
          /**
           * Determines if the next token is of a given kind
           */
          peek(kind) {
            return this._lexer.token.kind === kind;
          }
          /**
           * If the next token is of the given kind, return that token after advancing the lexer.
           * Otherwise, do not change the parser state and throw an error.
           */
          expectToken(kind) {
            const token = this._lexer.token;
            if (token.kind === kind) {
              this.advanceLexer();
              return token;
            }
            throw syntaxError(
              this._lexer.source,
              token.start,
              `Expected ${getTokenKindDesc(kind)}, found ${getTokenDesc(token)}.`
            );
          }
          /**
           * If the next token is of the given kind, return "true" after advancing the lexer.
           * Otherwise, do not change the parser state and return "false".
           */
          expectOptionalToken(kind) {
            const token = this._lexer.token;
            if (token.kind === kind) {
              this.advanceLexer();
              return true;
            }
            return false;
          }
          /**
           * If the next token is a given keyword, advance the lexer.
           * Otherwise, do not change the parser state and throw an error.
           */
          expectKeyword(value) {
            const token = this._lexer.token;
            if (token.kind === tokenKind_TokenKind.NAME && token.value === value) {
              this.advanceLexer();
            } else {
              throw syntaxError(
                this._lexer.source,
                token.start,
                `Expected "${value}", found ${getTokenDesc(token)}.`
              );
            }
          }
          /**
           * If the next token is a given keyword, return "true" after advancing the lexer.
           * Otherwise, do not change the parser state and return "false".
           */
          expectOptionalKeyword(value) {
            const token = this._lexer.token;
            if (token.kind === tokenKind_TokenKind.NAME && token.value === value) {
              this.advanceLexer();
              return true;
            }
            return false;
          }
          /**
           * Helper function for creating an error when an unexpected lexed token is encountered.
           */
          unexpected(atToken) {
            const token = atToken !== null && atToken !== void 0 ? atToken : this._lexer.token;
            return syntaxError(
              this._lexer.source,
              token.start,
              `Unexpected ${getTokenDesc(token)}.`
            );
          }
          /**
           * Returns a possibly empty list of parse nodes, determined by the parseFn.
           * This list begins with a lex token of openKind and ends with a lex token of closeKind.
           * Advances the parser to the next lex token after the closing token.
           */
          any(openKind, parseFn, closeKind) {
            this.expectToken(openKind);
            const nodes = [];
            while (!this.expectOptionalToken(closeKind)) {
              nodes.push(parseFn.call(this));
            }
            return nodes;
          }
          /**
           * Returns a list of parse nodes, determined by the parseFn.
           * It can be empty only if open token is missing otherwise it will always return non-empty list
           * that begins with a lex token of openKind and ends with a lex token of closeKind.
           * Advances the parser to the next lex token after the closing token.
           */
          optionalMany(openKind, parseFn, closeKind) {
            if (this.expectOptionalToken(openKind)) {
              const nodes = [];
              do {
                nodes.push(parseFn.call(this));
              } while (!this.expectOptionalToken(closeKind));
              return nodes;
            }
            return [];
          }
          /**
           * Returns a non-empty list of parse nodes, determined by the parseFn.
           * This list begins with a lex token of openKind and ends with a lex token of closeKind.
           * Advances the parser to the next lex token after the closing token.
           */
          many(openKind, parseFn, closeKind) {
            this.expectToken(openKind);
            const nodes = [];
            do {
              nodes.push(parseFn.call(this));
            } while (!this.expectOptionalToken(closeKind));
            return nodes;
          }
          /**
           * Returns a non-empty list of parse nodes, determined by the parseFn.
           * This list may begin with a lex token of delimiterKind followed by items separated by lex tokens of tokenKind.
           * Advances the parser to the next lex token after last item in the list.
           */
          delimitedMany(delimiterKind, parseFn) {
            this.expectOptionalToken(delimiterKind);
            const nodes = [];
            do {
              nodes.push(parseFn.call(this));
            } while (this.expectOptionalToken(delimiterKind));
            return nodes;
          }
          advanceLexer() {
            const { maxTokens } = this._options;
            const token = this._lexer.advance();
            if (maxTokens !== void 0 && token.kind !== tokenKind_TokenKind.EOF) {
              ++this._tokenCounter;
              if (this._tokenCounter > maxTokens) {
                throw syntaxError(
                  this._lexer.source,
                  token.start,
                  `Document contains more that ${maxTokens} tokens. Parsing aborted.`
                );
              }
            }
          }
        }
        function getTokenDesc(token) {
          const value = token.value;
          return getTokenKindDesc(token.kind) + (value != null ? ` "${value}"` : "");
        }
        function getTokenKindDesc(kind) {
          return isPunctuatorTokenKind(kind) ? `"${kind}"` : kind;
        }
        ;
        var docCache = /* @__PURE__ */ new Map();
        var fragmentSourceMap = /* @__PURE__ */ new Map();
        var printFragmentWarnings = true;
        var experimentalFragmentVariables = false;
        function lib_normalize(string) {
          return string.replace(/[\s,]+/g, " ").trim();
        }
        function cacheKeyFromLoc(loc) {
          return lib_normalize(loc.source.body.substring(loc.start, loc.end));
        }
        function processFragments(ast) {
          var seenKeys = /* @__PURE__ */ new Set();
          var definitions = [];
          ast.definitions.forEach(function(fragmentDefinition) {
            if (fragmentDefinition.kind === "FragmentDefinition") {
              var fragmentName = fragmentDefinition.name.value;
              var sourceKey = cacheKeyFromLoc(fragmentDefinition.loc);
              var sourceKeySet = fragmentSourceMap.get(fragmentName);
              if (sourceKeySet && !sourceKeySet.has(sourceKey)) {
                if (printFragmentWarnings) {
                  console.warn("Warning: fragment with name " + fragmentName + " already exists.\ngraphql-tag enforces all fragment names across your application to be unique; read more about\nthis in the docs: http://dev.apollodata.com/core/fragments.html#unique-names");
                }
              } else if (!sourceKeySet) {
                fragmentSourceMap.set(fragmentName, sourceKeySet = /* @__PURE__ */ new Set());
              }
              sourceKeySet.add(sourceKey);
              if (!seenKeys.has(sourceKey)) {
                seenKeys.add(sourceKey);
                definitions.push(fragmentDefinition);
              }
            } else {
              definitions.push(fragmentDefinition);
            }
          });
          return tslib_es6_assign(tslib_es6_assign({}, ast), { definitions });
        }
        function stripLoc(doc) {
          var workSet = new Set(doc.definitions);
          workSet.forEach(function(node) {
            if (node.loc)
              delete node.loc;
            Object.keys(node).forEach(function(key) {
              var value = node[key];
              if (value && typeof value === "object") {
                workSet.add(value);
              }
            });
          });
          var loc = doc.loc;
          if (loc) {
            delete loc.startToken;
            delete loc.endToken;
          }
          return doc;
        }
        function parseDocument(source) {
          var cacheKey = lib_normalize(source);
          if (!docCache.has(cacheKey)) {
            var parsed = parse(source, {
              experimentalFragmentVariables,
              allowLegacyFragmentVariables: experimentalFragmentVariables
            });
            if (!parsed || parsed.kind !== "Document") {
              throw new Error("Not a valid GraphQL document.");
            }
            docCache.set(cacheKey, stripLoc(processFragments(parsed)));
          }
          return docCache.get(cacheKey);
        }
        function gql(literals) {
          var args = [];
          for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
          }
          if (typeof literals === "string") {
            literals = [literals];
          }
          var result = literals[0];
          args.forEach(function(arg, i2) {
            if (arg && arg.kind === "Document") {
              result += arg.loc.source.body;
            } else {
              result += arg;
            }
            result += literals[i2 + 1];
          });
          return parseDocument(result);
        }
        function resetCaches() {
          docCache.clear();
          fragmentSourceMap.clear();
        }
        function disableFragmentWarnings() {
          printFragmentWarnings = false;
        }
        function enableExperimentalFragmentVariables() {
          experimentalFragmentVariables = true;
        }
        function disableExperimentalFragmentVariables() {
          experimentalFragmentVariables = false;
        }
        var extras = {
          gql,
          resetCaches,
          disableFragmentWarnings,
          enableExperimentalFragmentVariables,
          disableExperimentalFragmentVariables
        };
        (function(gql_1) {
          gql_1.gql = extras.gql, gql_1.resetCaches = extras.resetCaches, gql_1.disableFragmentWarnings = extras.disableFragmentWarnings, gql_1.enableExperimentalFragmentVariables = extras.enableExperimentalFragmentVariables, gql_1.disableExperimentalFragmentVariables = extras.disableExperimentalFragmentVariables;
        })(gql || (gql = {}));
        gql["default"] = gql;
        const lib = (
          /* unused pure expression or super */
          null
        );
        var browser_ponyfill = __webpack_require__(9372);
        var browser_ponyfill_default = __webpack_require__.n(browser_ponyfill);
        ;
        const kotlinControllers = [
          "query",
          "aiData",
          "api",
          "backend-function",
          "webhooks",
          "ws",
          "quota",
          "named-query",
          "native-query",
          "application-kotlin",
          "openapi",
          "secret",
          "queue"
        ];
        function getApplicationUrl(regionPrefix, appId, path) {
          const baseUrl = "https://squid.cloud";
          const parsedBaseUrl = new URL(baseUrl);
          parsedBaseUrl.host = `${appId}.${regionPrefix}.${parsedBaseUrl.host}`;
          const controller = path.replace(/^\//g, "").split("/")[0] || "";
          if (isLocal(regionPrefix)) {
            parsedBaseUrl.protocol = "http";
            parsedBaseUrl.port = kotlinControllers.includes(controller) ? "8001" : "8000";
            if (isAndroid(regionPrefix)) {
              parsedBaseUrl.host = "10.0.2.2";
            } else if (isIOS(regionPrefix)) {
              parsedBaseUrl.host = "localhost";
            }
          }
          const url = parsedBaseUrl.toString();
          path = path.startsWith("/") ? path.slice(1) : path;
          return (url.endsWith("/") ? url : url + "/") + path;
        }
        function getApplicationHttpHeaders(regionPrefix, appId) {
          const headers = {};
          if (isLocal(regionPrefix)) {
            headers["x-squid-appid"] = appId;
          }
          return headers;
        }
        function isLocal(regionPrefix) {
          return /^local/.test(regionPrefix);
        }
        function isAndroid(regionPrefix) {
          return /android$/.test(regionPrefix);
        }
        function isIOS(regionPrefix) {
          return /ios$/.test(regionPrefix);
        }
        ;
        class GraphQLClient {
          constructor(rpcManager, integrationId, region, appId) {
            this.rpcManager = rpcManager;
            this.region = region;
            this.appId = appId;
            const url = getApplicationUrl(this.region, this.appId, `${integrationId}/graphql`);
            this.client = new ApolloClient({
              link: new HttpLink({
                uri: url,
                headers: this.rpcManager.getStaticHeaders(),
                fetch: browser_ponyfill_default()
              }),
              cache: new InMemoryCache()
            });
          }
          /** Executes a GraphQL query and returns a promise with the result. */
          async query(request) {
            const result = await this.client.query({
              query: gql`
        ${request.query}
      `,
              variables: request.variables
            });
            return result.data;
          }
          /** Executes a GraphQL mutation and returns a promise with the result. */
          async mutate(request) {
            const result = await this.client.mutate({
              mutation: gql`
        ${request.query}
      `
            });
            return result.data;
          }
        }
        ;
        class AiChatbotClientFactory {
          constructor(rpcManager, socketManager) {
            this.rpcManager = rpcManager;
            this.socketManager = socketManager;
            this.chatbotsMap = /* @__PURE__ */ new Map();
          }
          /** @internal */
          getChatbot(aiIntegrationId) {
            let client = this.chatbotsMap.get(aiIntegrationId);
            if (client)
              return client;
            client = new AiChatbotClient(this.rpcManager, this.socketManager, aiIntegrationId);
            this.chatbotsMap.set(aiIntegrationId, client);
            return client;
          }
        }
        ;
        class ApiManager {
          constructor(clientIdService, rpcManager, apiServerUrlOverrideMapping = {}) {
            this.clientIdService = clientIdService;
            this.rpcManager = rpcManager;
            this.apiServerUrlOverrideMapping = apiServerUrlOverrideMapping;
          }
          callApiAndSubscribe(integrationId, endpointId, request) {
            const callApiRequest = {
              integrationId,
              endpointId,
              request,
              serverUrlOverride: this.apiServerUrlOverrideMapping[integrationId]
            };
            return (0, external_rxjs_.race)((0, external_rxjs_.from)(this.rpcManager.post("api/call", callApiRequest)).pipe(map((response) => {
              const parsedPayload = response.payload ? deserializeObj(response.payload) : void 0;
              if (response.success) {
                return parsedPayload;
              } else {
                throw new Error(`Got error while calling API (HTTP Status ${response.httpStatus}). Message: ${parsedPayload === null || parsedPayload === void 0 ? void 0 : parsedPayload["message"]}`);
              }
            })), this.clientIdService.observeClientTooOld().pipe(map(() => {
              throw new Error("CLIENT_NOT_CONNECTED");
            })));
          }
        }
        ;
        class AuthManager {
          constructor(apiKey, authProvider) {
            this.apiKey = apiKey;
            this.authProvider = authProvider;
          }
          /**
           * Sets a new auth-token provider to Squid.
           * All future squid backend requests will use this token provider.
           * Exising in-flight requests won't be affected.
           */
          setAuthProvider(authProvider) {
            this.authProvider = authProvider;
          }
          async getAuthData() {
            var _a2;
            return {
              token: await this.getTokenFromAuthProvider(),
              integrationId: (_a2 = this.authProvider) === null || _a2 === void 0 ? void 0 : _a2.integrationId
            };
          }
          async getTokenFromAuthProvider() {
            var _a2;
            const promiseOrPrimitive = (_a2 = this.authProvider) === null || _a2 === void 0 ? void 0 : _a2.getToken();
            return typeof promiseOrPrimitive === "object" ? await promiseOrPrimitive : promiseOrPrimitive;
          }
          getApiKey() {
            return this.apiKey;
          }
          /**
           * Returns a valid AuthToken.
           * Tries to use `apiKey` first if set up.
           * Falls back to `await authTokenProvider()` result.
           */
          async getToken() {
            var _a2;
            if (this.apiKey) {
              return { type: "ApiKey", token: this.apiKey };
            }
            const token = await this.getTokenFromAuthProvider();
            if (!token)
              return void 0;
            return { type: "Bearer", token, integrationId: (_a2 = this.authProvider) === null || _a2 === void 0 ? void 0 : _a2.integrationId };
          }
        }
        ;
        class BackendFunctionManager {
          constructor(clientIdService, rpcManager) {
            this.clientIdService = clientIdService;
            this.rpcManager = rpcManager;
          }
          executeFunctionAndSubscribe(functionName, ...params) {
            const request = {
              functionName,
              paramsArrayStr: serializeObj(params)
            };
            const postUrl = `backend-function/execute?${encodeURIComponent(functionName)}`;
            return (0, external_rxjs_.race)((0, external_rxjs_.from)(this.rpcManager.post(postUrl, request)).pipe(map((response) => {
              if (!response.success) {
                throw new Error(response.payload);
              }
              return deserializeObj(response.payload);
            })), this.clientIdService.observeClientTooOld().pipe(map(() => {
              throw new Error("CLIENT_NOT_CONNECTED");
            })));
          }
        }
        ;
        function getGlobal() {
          if (typeof window !== "undefined") {
            return window;
          }
          if (typeof __webpack_require__.g !== "undefined") {
            return __webpack_require__.g;
          }
          if (typeof self !== "undefined") {
            return self;
          }
          throw new Error("Unable to locate global object");
        }
        function isDebugEnabled() {
          const globalObj2 = getGlobal();
          return globalObj2 && globalObj2["SQUID_DEBUG_ENABLED"];
        }
        function enableDebugLogs() {
          const globalObj2 = getGlobal();
          globalObj2["SQUID_DEBUG_ENABLED"] = true;
        }
        class DebugLogger {
          static log(...args) {
            DebugLogger.info(...args);
          }
          static info(...args) {
            console.log(`%c[${DebugLogger.getTimestampString()}] INFO`, "color:green", ...args);
          }
          static warn(...args) {
            console.warn(`%c[${DebugLogger.getTimestampString()}] WARN`, "color:yellow", ...args);
          }
          static error(...args) {
            console.error(`%c[${DebugLogger.getTimestampString()}] ERROR`, "color:red", ...args);
          }
          static debug(...args) {
            if (!isDebugEnabled())
              return;
            console.log(`%c[${DebugLogger.getTimestampString()}] DEBUG`, "color:cyan", ...args);
          }
          static getTimestampString() {
            const date = /* @__PURE__ */ new Date();
            return `${date.toLocaleTimeString()}.${date.getMilliseconds()}`;
          }
        }
        ;
        class ClientIdService {
          constructor(destructManager) {
            this.destructManager = destructManager;
            this.clientTooOldSubject = new external_rxjs_.BehaviorSubject(false);
            this.isTenant = getGlobal()["squidTenant"] === true;
            this.clientIdSubject = new external_rxjs_.BehaviorSubject(this.generateClientId());
            this.destructManager.onDestruct(() => {
              this.clientTooOldSubject.complete();
              this.clientIdSubject.complete();
            });
          }
          observeClientId() {
            return this.clientIdSubject;
          }
          observeClientTooOld() {
            return this.clientTooOldSubject.pipe((0, external_rxjs_.filter)((v) => v), (0, external_rxjs_.map)(() => void 0));
          }
          /**  there was a long-term disconnection of the socket */
          notifyClientTooOld() {
            this.clientTooOldSubject.next(true);
            this.clientIdSubject.next(this.generateClientId());
          }
          notifyClientReadyToBeRegenerated() {
            this.clientTooOldSubject.next(false);
          }
          observeClientReadyToBeRegenerated() {
            return this.clientTooOldSubject.pipe(
              // skip the initial connection
              (0, external_rxjs_.skip)(1),
              (0, external_rxjs_.filter)((v) => !v),
              (0, external_rxjs_.map)(() => void 0)
            );
          }
          getClientId() {
            return this.clientIdSubject.value;
          }
          isClientTooOld() {
            return this.clientTooOldSubject.value;
          }
          generateClientId() {
            return `${this.isTenant ? "tenant-" : ""}${generateId()}`;
          }
        }
        ;
        class CollectionReferenceFactory {
          constructor(documentReferenceFactory, queryBuilderFactory, querySubscriptionManager) {
            this.documentReferenceFactory = documentReferenceFactory;
            this.queryBuilderFactory = queryBuilderFactory;
            this.querySubscriptionManager = querySubscriptionManager;
            this.collections = /* @__PURE__ */ new Map();
          }
          get(collectionName, integrationId) {
            let integrationCollectionMap = this.collections.get(integrationId);
            if (!integrationCollectionMap) {
              integrationCollectionMap = /* @__PURE__ */ new Map();
              this.collections.set(integrationId, integrationCollectionMap);
            }
            let collectionRef = integrationCollectionMap.get(collectionName);
            if (collectionRef)
              return collectionRef;
            collectionRef = new CollectionReference(collectionName, integrationId, this.documentReferenceFactory, this.queryBuilderFactory, this.querySubscriptionManager);
            integrationCollectionMap.set(collectionName, collectionRef);
            return collectionRef;
          }
        }
        ;
        class ConnectionDetails {
          /** @internal */
          constructor(clientIdService, socketManager) {
            this.clientIdService = clientIdService;
            this.socketManager = socketManager;
            this.isConnected = false;
            this.socketManager.observeConnectionReady().subscribe((isConnected) => {
              this.isConnected = isConnected;
            });
          }
          /** Whether the Squid Client SDK is currently connected to the Squid Server. */
          get connected() {
            return this.isConnected;
          }
          /**
           * A unique client ID that is assigned to the client. This client ID is also available to the different backend
           * function in the context object.
           * Note: The client ID may change after a long disconnect.
           */
          get clientId() {
            return this.clientIdService.getClientId();
          }
          /**
           * Returns an observable that emits true when the client is connected to the server and false when the client is
           * disconnected from the server.
           */
          observeConnected() {
            return this.socketManager.observeConnectionReady();
          }
        }
        var promise_pool_dist = __webpack_require__(3910);
        ;
        const RUN_IN_TRANSACTION_MUTEX = "dataManager_runInTransaction";
        class DataManager {
          constructor(documentStore, mutationSender, socketManager, querySubscriptionManager, queryBuilderFactory, lockManager, destructManager, documentIdentityService, querySender) {
            this.documentStore = documentStore;
            this.mutationSender = mutationSender;
            this.socketManager = socketManager;
            this.querySubscriptionManager = querySubscriptionManager;
            this.queryBuilderFactory = queryBuilderFactory;
            this.lockManager = lockManager;
            this.destructManager = destructManager;
            this.documentIdentityService = documentIdentityService;
            this.querySender = querySender;
            this.docIdToLocalTimestamp = /* @__PURE__ */ new Map();
            this.batchClientRequestIds = /* @__PURE__ */ new Set();
            this.docIdToServerTimestamp = /* @__PURE__ */ new Map();
            this.pendingIncomingUpdates = /* @__PURE__ */ new Map();
            this.pendingOutgoingMutations = /* @__PURE__ */ new Map();
            this.pendingOutgoingMutationsChanged = new external_rxjs_.Subject();
            this.outgoingMutationsEmpty = new external_rxjs_.BehaviorSubject(true);
            this.knownDirtyDocs = /* @__PURE__ */ new Set();
            this.failedDocsToResync = [];
            this.refreshDocIdToTimestamp = /* @__PURE__ */ new Map();
            this.handleIncomingMessagesForTests = true;
            this.destructManager.onDestruct(() => {
              this.destruct();
            });
            this.documentIdentityService.observeChanges().subscribe(this.migrateDocIds.bind(this));
            this.handleNotifications();
            this.startDeleteExpiredTimestampsJob();
            this.handleOrphanDocs();
            this.outgoingMutationsEmpty.subscribe((isEmpty2) => {
              this.querySender.safeToSendQueriesToServer.next(isEmpty2);
            });
          }
          getProperties(squidDocId) {
            return this.documentStore.getDocumentOrUndefined(squidDocId);
          }
          /** Whether a document has changes that are out of sync with the server. */
          isDirty(squidDocId) {
            var _a2;
            if (this.knownDirtyDocs.has(squidDocId))
              return true;
            const hasOutgoingChanges = !!((_a2 = this.pendingOutgoingMutations.get(squidDocId)) === null || _a2 === void 0 ? void 0 : _a2.length);
            if (hasOutgoingChanges)
              return true;
            const docTimestamp = this.docIdToServerTimestamp.get(squidDocId);
            const serverTimestamp = docTimestamp && !docTimestamp.expireTimestamp ? docTimestamp.timestamp : void 0;
            const localDocTimestamp = this.docIdToLocalTimestamp.get(squidDocId);
            if (localDocTimestamp && !serverTimestamp) {
              return true;
            }
            if (this.isForgotten(squidDocId) || this.isLocalOnly(squidDocId)) {
              return true;
            }
            return localDocTimestamp !== serverTimestamp;
          }
          /**
           * Runs the provided function without sending mutations to the server while collecting the updates to the different
           * queries. Local updates will still be applied. Once the batch finishes, all the updates will be sent to the server
           * and the different queries will be notified. runInTransaction may be invoked inside another runInTransaction, only
           * the top level batch will trigger updates to the server.
           */
          async runInTransaction(fn, transactionId) {
            if (transactionId) {
              (0, dist.assertTruthy)(transactionId === this.currentTransactionId, "Transaction already ended.");
              return fn(transactionId).then((r) => Promise.resolve(r));
            }
            if (this.lockManager.canGetLock(RUN_IN_TRANSACTION_MUTEX)) {
              this.lockManager.lockSync(RUN_IN_TRANSACTION_MUTEX);
            } else {
              await this.lockManager.lock(RUN_IN_TRANSACTION_MUTEX);
            }
            let error = UNSET_VALUE;
            const hasError = () => error !== UNSET_VALUE;
            return new Promise(async (resolve, reject) => {
              try {
                this.currentTransactionId = generateId();
                let res = void 0;
                try {
                  res = await fn(this.currentTransactionId);
                } catch (e1) {
                  error = e1;
                } finally {
                  this.finishTransaction(hasError() ? void 0 : { resolve: () => resolve(res), reject });
                }
              } catch (e2) {
                error = hasError() ? error : e2;
              } finally {
                try {
                  this.lockManager.release(RUN_IN_TRANSACTION_MUTEX);
                } catch (e3) {
                  error = hasError() ? error : e3;
                }
              }
              if (hasError()) {
                reject(error);
              }
            });
          }
          /** Applies a mutation done from the client (from DocumentReference) and sends it to the server. */
          async applyOutgoingMutation(mutation, transactionId) {
            var _a2;
            const squidDocIdObj = mutation.squidDocIdObj;
            const squidDocId = getSquidDocId(squidDocIdObj);
            this.knownDirtyDocs.add(squidDocId);
            if (!transactionId && !this.lockManager.canGetLock(RUN_IN_TRANSACTION_MUTEX)) {
              await this.lockManager.lock(RUN_IN_TRANSACTION_MUTEX);
              this.lockManager.release(RUN_IN_TRANSACTION_MUTEX);
            }
            this.knownDirtyDocs.delete(squidDocId);
            const lastOutgoingMutation = (_a2 = this.pendingOutgoingMutations.get(squidDocId)) === null || _a2 === void 0 ? void 0 : _a2.slice(-1)[0];
            if (lastOutgoingMutation && !lastOutgoingMutation.sentToServer) {
              lastOutgoingMutation.mutation = reduceMutations([lastOutgoingMutation.mutation, mutation])[0];
              this.outgoingMutationsEmpty.next(false);
            } else {
              const outgoingMutation = {
                mutation: this.removeInternalProperties(mutation),
                sentToServer: false
              };
              const ar = this.pendingOutgoingMutations.get(squidDocId) || [];
              ar.push(outgoingMutation);
              this.pendingOutgoingMutations.set(squidDocId, ar);
              this.outgoingMutationsEmpty.next(false);
              this.pendingOutgoingMutationsChanged.next();
            }
            return this.runInTransaction(async () => {
              const docBefore = this.documentStore.getDocumentOrUndefined(squidDocId);
              const docAfter = mutation.type === "delete" ? void 0 : mutation.type === "update" ? applyUpdateMutation(docBefore, mutation) : Object.assign({}, mutation.properties);
              const updated = this.updateDocumentFromSnapshot(squidDocId, docAfter);
              if (!updated)
                return;
              if (mutation.type === "insert") {
                this.docIdToLocalTimestamp.set(squidDocId, (/* @__PURE__ */ new Date()).getTime());
              }
              const allClientRequestIds = this.querySubscriptionManager.setClientRequestIdsForLocalDoc(squidDocId, docAfter);
              allClientRequestIds.forEach((clientRequestId) => this.batchClientRequestIds.add(clientRequestId));
            }, transactionId);
          }
          /** Same as runInTransaction with the exception that the passed function runs synchronously. */
          async runInTransactionSync(fn, transactionId) {
            if (transactionId) {
              (0, dist.assertTruthy)(transactionId === this.currentTransactionId, "Transaction already ended.");
              fn(transactionId);
              return;
            }
            await this.lockManager.lock(RUN_IN_TRANSACTION_MUTEX);
            try {
              this.currentTransactionId = generateId();
              try {
                return fn(this.currentTransactionId);
              } catch (e1) {
                console.error("error while executing callback function in transaction", e1);
              } finally {
                this.finishTransaction();
              }
            } catch (e2) {
              console.error("error while executing transaction", e2);
            } finally {
              this.lockManager.release(RUN_IN_TRANSACTION_MUTEX);
            }
          }
          /** Remove properties from the document record that should not be sent to the server. */
          removeInternalProperties(mutation) {
            if (mutation.type === "delete")
              return mutation;
            const result = Object.assign(Object.assign({}, mutation), { properties: Object.assign({}, mutation.properties) });
            delete result.properties["__docId__"];
            delete result.properties["__ts__"];
            return result;
          }
          /** Listens and handles mutations and snapshots notifications from the socketManager. */
          handleNotifications() {
            this.socketManager.observeNotifications().pipe((0, external_rxjs_.filter)((notification) => notification.type === "mutations"), map((n) => n)).subscribe((notification) => {
              this.outgoingMutationsEmpty.pipe((0, external_rxjs_.filter)(Boolean), (0, external_rxjs_.take)(1)).subscribe(() => {
                this.handleIncomingMutations(notification.payload);
              });
            });
            this.querySubscriptionManager.observeQueryResults().subscribe((queryResult) => {
              this.outgoingMutationsEmpty.pipe((0, external_rxjs_.filter)(Boolean), (0, external_rxjs_.take)(1)).subscribe(() => {
                this.handleIncomingQuerySnapshots(queryResult);
              });
            });
          }
          handleIncomingMutations(payload) {
            if (!this.handleIncomingMessagesForTests) {
              return;
            }
            const squidDocIdToNewData = payload.reduce((prev, item) => {
              if (!this.querySubscriptionManager.hasOngoingQuery(item.clientRequestId)) {
                return prev;
              }
              prev[item.squidDocId] = {
                properties: item.doc,
                timestamp: item.mutationTimestamp
              };
              return prev;
            }, {});
            this.applyIncomingUpdates(squidDocIdToNewData);
          }
          handleIncomingQuerySnapshots(queryResult) {
            if (!this.handleIncomingMessagesForTests) {
              return;
            }
            if (!this.querySubscriptionManager.hasOngoingQuery(queryResult.clientRequestId)) {
              return;
            }
            const query = this.querySubscriptionManager.getQuery(queryResult.clientRequestId);
            const squidDocIdToNewData = {};
            for (const doc of queryResult.docs) {
              const squidDocId = getSquidDocId(doc.__docId__, query.collectionName, query.integrationId);
              squidDocIdToNewData[squidDocId] = { properties: doc, timestamp: doc.__ts__ };
            }
            this.runInTransactionSync((transactionId) => {
              this.querySubscriptionManager.setGotInitialResult(queryResult.clientRequestId);
              this.batchClientRequestIds.add(queryResult.clientRequestId);
              const someDocumentsWereOutdated = this.applyIncomingUpdates(squidDocIdToNewData, transactionId);
              if (someDocumentsWereOutdated && this.querySubscriptionManager.hasSubscription(queryResult.clientRequestId)) {
                this.batchClientRequestIds.delete(queryResult.clientRequestId);
              }
            }).then();
          }
          /**
           * Returns a boolean for whether some updates were ignored because the client knows of a later timestamp for those
           * documents.
           */
          applyIncomingUpdates(squidDocIdToNewData, transactionId) {
            let someDocumentsWereOutdated = false;
            const updatedDocIds = /* @__PURE__ */ new Set();
            const staleDocIds = /* @__PURE__ */ new Set();
            for (const [squidDocId, incomingUpdateItem] of Object.entries(squidDocIdToNewData)) {
              const existingPendingIncomingUpdate = this.pendingIncomingUpdates.get(squidDocId);
              const timestampMetadata = this.docIdToServerTimestamp.get(squidDocId);
              if (existingPendingIncomingUpdate && existingPendingIncomingUpdate.timestamp > incomingUpdateItem.timestamp) {
                someDocumentsWereOutdated = true;
                continue;
              }
              if (!(timestampMetadata && timestampMetadata.timestamp > incomingUpdateItem.timestamp)) {
                this.pendingIncomingUpdates.set(squidDocId, incomingUpdateItem);
                updatedDocIds.add(squidDocId);
              } else {
                staleDocIds.add(squidDocId);
              }
            }
            this.runInTransactionSync(() => {
              for (const squidDocId of updatedDocIds) {
                this.maybeApplyIncomingUpdate(squidDocId);
              }
              for (const squidDocId of staleDocIds) {
                this.refreshQueryMapping(squidDocId);
              }
            }, transactionId).then();
            return someDocumentsWereOutdated;
          }
          maybeApplyIncomingUpdate(squidDocId) {
            const incomingUpdate = this.pendingIncomingUpdates.get(squidDocId);
            if (!incomingUpdate)
              return;
            const outgoingMutations = this.pendingOutgoingMutations.get(squidDocId);
            if (outgoingMutations && outgoingMutations.length) {
              return;
            }
            this.updateDocumentFromSnapshot(squidDocId, incomingUpdate.properties);
            this.acknowledgeDocument(squidDocId, incomingUpdate.timestamp, !incomingUpdate.properties);
            this.docIdToLocalTimestamp.set(squidDocId, incomingUpdate.timestamp);
            this.pendingIncomingUpdates.delete(squidDocId);
            this.refreshQueryMapping(squidDocId);
          }
          refreshQueryMapping(squidDocId) {
            const doc = this.documentStore.getDocumentOrUndefined(squidDocId);
            const allClientRequestIds = this.querySubscriptionManager.setClientRequestIdsForLocalDoc(squidDocId, doc);
            allClientRequestIds.forEach((clientRequestId) => {
              this.batchClientRequestIds.add(clientRequestId);
            });
            if (doc) {
              if (!this.querySubscriptionManager.findQueriesForDocument(doc, squidDocId).length) {
                this.forgetDocument(squidDocId);
              }
            }
          }
          destruct() {
            this.stopDeleteExpiredTimestampsJob();
          }
          stopDeleteExpiredTimestampsJob() {
            if (this.deleteExpiredTimestampsInterval === void 0)
              return;
            clearInterval(this.deleteExpiredTimestampsInterval);
            this.deleteExpiredTimestampsInterval = void 0;
          }
          /**
           * Removes entries from the docToTimestamp map for all the documents that are no longer relevant for this client.
           * If a document is currently tracked, we forget it.
           * Cases a document is considered not relevant anymore:
           * 1 - There are no outgoing or incoming updates for this document AND:
           *   a - The document was deleted on the server and this client already received a notification about it OR
           *   b - The document no longer has a query that will keep it up-to-date
           */
          startDeleteExpiredTimestampsJob() {
            this.deleteExpiredTimestampsInterval = setInterval(() => {
              const entriesToRemove = [...this.docIdToServerTimestamp.entries()].filter(([squidDocId, timestampMetadata]) => {
                if (!timestampMetadata.expireTimestamp || timestampMetadata.expireTimestamp > Date.now()) {
                  return false;
                }
                return !this.isTracked(squidDocId);
              });
              for (const [squidDocId] of entriesToRemove) {
                this.docIdToServerTimestamp.delete(squidDocId);
                this.forgetDocument(squidDocId);
              }
            }, 1e4);
          }
          /**
           * Whether the document is tracked by any pending mutations or ongoing queries.
           */
          isTracked(squidDocId) {
            const hasPendingIncomingUpdate = !!this.pendingIncomingUpdates.get(squidDocId);
            if (hasPendingIncomingUpdate) {
              return true;
            }
            const outgoingUpdates = this.pendingOutgoingMutations.get(squidDocId);
            const hasPendingOutgoing = outgoingUpdates && outgoingUpdates.length;
            if (hasPendingOutgoing) {
              return true;
            }
            return this.querySubscriptionManager.hasOngoingQueryForDocId(squidDocId);
          }
          /**
           * Whether a document exists locally, but is no longer tracked by any mutations or queries. This is often the case
           * for in-memory DocumentReferences that are not part of any query.
           */
          isForgotten(squidDocId) {
            return this.documentStore.hasData(squidDocId) && !this.isTracked(squidDocId);
          }
          /**
           * Whether a document only exists locally. This means that the document has never by sent to or received from the
           * server.
           */
          isLocalOnly(squidDocId) {
            return !this.hasBeenAcknowledged(squidDocId) && this.documentStore.hasData(squidDocId);
          }
          /**
           * Whether the document has even been acknowledged by the server. Acknowledgements occur when an incoming query or
           * mutation is received, and when an outgoing mutation is acknowledged.
           */
          hasBeenAcknowledged(squidDocId) {
            return this.docIdToServerTimestamp.has(squidDocId);
          }
          /**
           * Updates the document with the new properties, returns true if an update was done or false in case the doc did not
           * change.
           */
          updateDocumentFromSnapshot(squidDocId, doc) {
            const existingDoc = this.documentStore.getDocumentOrUndefined(squidDocId);
            if (!existingDoc && !doc || existingDoc === doc)
              return false;
            if (existingDoc && doc) {
              const serializedDoc = normalizeJsonAsString(Object.assign(Object.assign({}, doc), { __ts__: void 0 }));
              const serializedExistingDoc = normalizeJsonAsString(existingDoc);
              if (serializedDoc === serializedExistingDoc)
                return false;
            }
            this.documentStore.saveDocument(squidDocId, doc);
            return true;
          }
          finishTransaction(promiseResolver) {
            this.currentTransactionId = void 0;
            const batchClientRequestIds = [...this.batchClientRequestIds.values()];
            this.batchClientRequestIds.clear();
            this.querySubscriptionManager.notifyAllSubscriptions(batchClientRequestIds);
            this.sendAllUnsentOutgoingMutations(promiseResolver).then();
          }
          async sendAllUnsentOutgoingMutations(promiseResolver) {
            const outgoingMutationsByIntegrationId = this.groupOutgoingMutationsByIntegrationId();
            try {
              await promise_pool_dist.PromisePool.for(outgoingMutationsByIntegrationId).withConcurrency(outgoingMutationsByIntegrationId.length || 1).handleError((e) => {
                throw e;
              }).process(async ([integrationId, outgoingMutations]) => {
                await this.sendMutationsForIntegration([...outgoingMutations], integrationId);
              });
              if (!this.pendingOutgoingMutations.size) {
                this.outgoingMutationsEmpty.next(true);
              }
              await this.refreshUpdatedDocuments();
              const hasPendingSentMutations = this.hasPendingSentMutations();
              if (!hasPendingSentMutations) {
                promiseResolver === null || promiseResolver === void 0 ? void 0 : promiseResolver.resolve();
              } else {
                await (0, external_rxjs_.firstValueFrom)(this.pendingOutgoingMutationsChanged.pipe((0, external_rxjs_.filter)(() => !this.hasPendingSentMutations())));
                promiseResolver === null || promiseResolver === void 0 ? void 0 : promiseResolver.resolve();
              }
            } catch (e) {
              if (!this.pendingOutgoingMutations.size) {
                this.outgoingMutationsEmpty.next(true);
                await this.resyncFailedUpdates();
              }
              promiseResolver === null || promiseResolver === void 0 ? void 0 : promiseResolver.reject(e);
            }
          }
          async sendMutationsForIntegration(outgoingMutations, integrationId) {
            try {
              const { timestamp, idResolutionMap = {}, refreshList = [] } = await this.mutationSender.sendMutations(outgoingMutations.map((outgoingMutation) => outgoingMutation.mutation), integrationId);
              this.documentIdentityService.migrate(idResolutionMap);
              refreshList.forEach((docId) => {
                this.refreshDocIdToTimestamp.set(idResolutionMap[docId] || docId, timestamp);
              });
              for (const outgoingMutation of outgoingMutations) {
                let squidDocId = this.removeOutgoingMutation(outgoingMutation);
                if (idResolutionMap[squidDocId])
                  squidDocId = idResolutionMap[squidDocId];
                this.acknowledgeDocument(squidDocId, timestamp);
                if (!this.isTracked(squidDocId)) {
                  this.setExpiration(squidDocId, true);
                  this.forgetDocument(squidDocId);
                }
              }
            } catch (e) {
              for (const outgoingMutation of outgoingMutations) {
                const squidDocId = this.removeOutgoingMutation(outgoingMutation);
                this.forgetDocument(squidDocId);
                if (this.hasBeenAcknowledged(squidDocId) || outgoingMutation.mutation.type === "insert") {
                  this.failedDocsToResync.push(squidDocId);
                }
              }
              throw e;
            }
          }
          removeOutgoingMutation(outgoingMutation) {
            const squidDocId = getSquidDocId(outgoingMutation.mutation.squidDocIdObj);
            const outgoingMutationsForDoc = (0, dist.truthy)(this.pendingOutgoingMutations.get(squidDocId));
            outgoingMutationsForDoc.splice(outgoingMutationsForDoc.indexOf(outgoingMutation), 1);
            if (!outgoingMutationsForDoc.length) {
              this.pendingOutgoingMutations.delete(squidDocId);
            }
            this.pendingOutgoingMutationsChanged.next();
            return squidDocId;
          }
          async resyncFailedUpdates() {
            const failedDocsToResync = [...this.failedDocsToResync];
            this.failedDocsToResync.splice(0);
            for (const squidDocId of failedDocsToResync) {
              this.setExpiration(squidDocId, true);
              try {
                const results = await this.queryBuilderFactory.getForDocument(squidDocId).setForceFetchFromServer().snapshot();
                (0, dist.truthy)(results.length <= 1, "Got more than one doc for the same id:" + squidDocId);
                if (!results.length) {
                  this.forgetDocument(squidDocId);
                  const queriesToNotify = this.querySubscriptionManager.setClientRequestIdsForLocalDoc(squidDocId, void 0);
                  this.querySubscriptionManager.notifyAllSubscriptions(queriesToNotify);
                }
              } catch (e) {
                this.querySubscriptionManager.errorOutAllQueries(squidDocId, e);
              }
            }
          }
          async refreshUpdatedDocuments() {
            var _a2;
            const docsToRefresh = [];
            for (const [docId, timestamp] of this.refreshDocIdToTimestamp.entries()) {
              const serverTimestamp = (_a2 = this.docIdToServerTimestamp.get(docId)) === null || _a2 === void 0 ? void 0 : _a2.timestamp;
              if (serverTimestamp && serverTimestamp > timestamp)
                continue;
              docsToRefresh.push(docId);
            }
            this.refreshDocIdToTimestamp.clear();
            for (const squidDocId of docsToRefresh) {
              try {
                await this.queryBuilderFactory.getForDocument(squidDocId).snapshot();
              } catch (_b) {
              }
            }
          }
          groupOutgoingMutationsByIntegrationId() {
            const outgoingMutationsByIntegrationId = {};
            for (const [, outgoingMutations] of [...this.pendingOutgoingMutations.entries()]) {
              const latestOutgoingMutation = outgoingMutations[outgoingMutations.length - 1];
              if (latestOutgoingMutation && !latestOutgoingMutation.sentToServer) {
                const integrationId = latestOutgoingMutation.mutation.squidDocIdObj.integrationId;
                (outgoingMutationsByIntegrationId[integrationId] || (outgoingMutationsByIntegrationId[integrationId] = [])).push(latestOutgoingMutation);
                latestOutgoingMutation.sentToServer = true;
              }
            }
            return Object.entries(outgoingMutationsByIntegrationId);
          }
          /**
           * Handles the case that due to some change (an incoming or outgoing change to a document), a document becomes orphan.
           * That is, there are no ongoing queries that will keep it up-to-date.
           * An orphan document should not stay locally since it may be stale after some time.
           */
          handleOrphanDocs() {
            this.querySubscriptionManager.onOrphanDocuments.subscribe((orphanDocs) => {
              for (const squidDocId of orphanDocs) {
                if (!this.isTracked(squidDocId)) {
                  this.forgetDocument(squidDocId);
                }
              }
            });
          }
          acknowledgeDocument(squidDocId, timestamp, expires = false) {
            this.docIdToServerTimestamp.set(squidDocId, { timestamp });
            this.setExpiration(squidDocId, expires);
          }
          setExpiration(squidDocId, expires) {
            const docTimestamp = this.docIdToServerTimestamp.get(squidDocId);
            if (docTimestamp) {
              docTimestamp.expireTimestamp = expires ? Date.now() + 2e4 : void 0;
            }
          }
          forgetDocument(squidDocId) {
            this.docIdToLocalTimestamp.delete(squidDocId);
            this.setExpiration(squidDocId, true);
          }
          migrateDocIds(idResolutionMap) {
            this.pendingOutgoingMutations.forEach((outgoingMutations) => {
              outgoingMutations.forEach((outgoingMutation) => {
                const squidDocId = getSquidDocId(outgoingMutation.mutation.squidDocIdObj);
                const resolvedId = idResolutionMap[squidDocId];
                if (resolvedId) {
                  outgoingMutation.mutation.squidDocIdObj = parseSquidDocId(resolvedId);
                }
              });
            });
            Object.entries(idResolutionMap).forEach(([squidDocId, newSquidDocId]) => {
              replaceKeyInMap(this.pendingOutgoingMutations, squidDocId, newSquidDocId);
              replaceKeyInMap(this.docIdToLocalTimestamp, squidDocId, newSquidDocId);
              replaceKeyInMap(this.docIdToServerTimestamp, squidDocId, newSquidDocId);
            });
          }
          hasPendingSentMutations() {
            for (const outgoingMutationsForDoc of this.pendingOutgoingMutations.values()) {
              for (const outgoingMutation of outgoingMutationsForDoc) {
                if (outgoingMutation.sentToServer) {
                  return true;
                }
              }
            }
            return false;
          }
        }
        const UNSET_VALUE = Symbol("undefined");
        ;
        class DestructManager {
          constructor() {
            this.preDestructors = [];
            this.destructors = [];
            this.isDestructedSubject = new external_rxjs_.BehaviorSubject(false);
          }
          get isDestructing() {
            return this.isDestructedSubject.value;
          }
          observeIsDestructing() {
            return this.isDestructedSubject.asObservable().pipe((0, external_rxjs_.filter)(Boolean), map(() => void 0));
          }
          onPreDestruct(fn) {
            this.preDestructors.push(fn);
          }
          onDestruct(fn) {
            this.destructors.push(fn);
          }
          async destruct() {
            this.reportDestructed();
            const fns = this.preDestructors.concat(this.destructors);
            let fn = fns.shift();
            while (fn) {
              try {
                await fn();
              } catch (e) {
                console.error("Error while destructing Squid", e);
              }
              fn = fns.shift();
            }
          }
          reportDestructed() {
            if (this.isDestructing) {
              return;
            }
            this.isDestructedSubject.next(true);
          }
        }
        ;
        class DistributedLockManager {
          constructor(socketManager, destructManager) {
            this.socketManager = socketManager;
            this.destructManager = destructManager;
            this.ongoingLocks = {};
            this.acquireLockMessagesFromServer = this.socketManager.observeNotifications().pipe((0, external_rxjs_.filter)((message) => message.type === "lockAcquired"));
            this.releaseLockMessagesFromServer = this.socketManager.observeNotifications().pipe((0, external_rxjs_.filter)((message) => message.type === "lockReleased"));
            this.lockWaitForConnectionThreshold = 2e3;
            destructManager.onPreDestruct(() => {
              this.releaseAllLocks();
            });
            this.socketManager.observeConnectionReady().subscribe((ready) => {
              if (ready)
                return;
              this.releaseAllLocks();
            });
            this.releaseLockMessagesFromServer.subscribe((message) => {
              const lock = this.ongoingLocks[message.payload.clientRequestId];
              if (lock === void 0)
                return;
              lock.release();
            });
          }
          async lock(mutex) {
            const isConnected = await (0, external_rxjs_.firstValueFrom)((0, external_rxjs_.race)((0, external_rxjs_.timer)(this.lockWaitForConnectionThreshold).pipe(map(() => false)), this.socketManager.observeConnectionReady().pipe((0, external_rxjs_.filter)(Boolean)), this.destructManager.observeIsDestructing()));
            if (!isConnected) {
              return Promise.reject("CLIENT_NOT_CONNECTED");
            }
            const clientRequestId = generateId();
            const acquireLockMessage = {
              type: "acquireLock",
              payload: {
                mutex,
                clientRequestId
              }
            };
            this.socketManager.sendMessage(acquireLockMessage);
            const result = await (0, external_rxjs_.firstValueFrom)((0, external_rxjs_.race)((0, external_rxjs_.timer)(5e3).pipe((0, external_rxjs_.take)(1), map(() => {
              return {
                payload: {
                  error: "TIMEOUT_GETTING_LOCK",
                  lockId: void 0
                }
              };
            })), this.acquireLockMessagesFromServer.pipe((0, external_rxjs_.filter)((message) => message.payload.clientRequestId === clientRequestId))));
            if (!result.payload.lockId) {
              throw new Error(`Failed to acquire lock: ${result.payload.error}`);
            }
            const lockId = result.payload.lockId;
            const lock = new DistributedLockImpl(lockId, clientRequestId, this.ongoingLocks, this.socketManager);
            this.ongoingLocks[lockId] = lock;
            return lock;
          }
          releaseAllLocks() {
            for (const [lockId, lock] of Object.entries(this.ongoingLocks)) {
              lock.release();
              delete this.ongoingLocks[lockId];
            }
          }
        }
        class DistributedLockImpl {
          constructor(lockId, clientRequestId, ongoingLocks, socketManager) {
            this.lockId = lockId;
            this.clientRequestId = clientRequestId;
            this.ongoingLocks = ongoingLocks;
            this.socketManager = socketManager;
            this.released = false;
            this.onReleaseSubject = new external_rxjs_.Subject();
          }
          release() {
            if (this.released)
              return;
            this.released = true;
            delete this.ongoingLocks[this.lockId];
            const releaseLockMessage = {
              type: "releaseLock",
              payload: {
                lockId: this.lockId,
                clientRequestId: this.clientRequestId
              }
            };
            this.socketManager.sendMessage(releaseLockMessage);
            this.onReleaseSubject.next();
          }
          observeRelease() {
            return this.onReleaseSubject.asObservable();
          }
          isReleased() {
            return this.released;
          }
        }
        ;
        class DocumentIdentityService {
          constructor(documentStore, destructManager) {
            this.documentStore = documentStore;
            this.destructManager = destructManager;
            this.changeNotifier = new external_rxjs_.BehaviorSubject({});
            this.destructManager.onDestruct(() => {
              this.changeNotifier.complete();
            });
          }
          migrate(idResolutionMap) {
            Object.entries(idResolutionMap).forEach(([squidDocId, newSquidDocId]) => {
              this.documentStore.migrateDocId(squidDocId, newSquidDocId);
            });
            this.changeNotifier.next(idResolutionMap);
          }
          observeChanges() {
            return this.changeNotifier.asObservable();
          }
        }
        ;
        class DocumentReferenceFactory {
          constructor(documentIdentityService) {
            this.documentIdentityService = documentIdentityService;
            this.documents = /* @__PURE__ */ new Map();
            this.documentsForCollection = /* @__PURE__ */ new Map();
            this.documentIdentityService.observeChanges().subscribe(this.migrateDocIds.bind(this));
          }
          create(squidDocId, queryBuilderFactory) {
            let reference = this.documents.get(squidDocId);
            if (reference)
              return reference;
            reference = new DocumentReference(squidDocId, (0, dist.truthy)(this.dataManager, "dataManager not found"), queryBuilderFactory);
            const { integrationId, collectionName } = parseSquidDocId(squidDocId);
            this.documents.set(squidDocId, reference);
            const collectionKey = this.getCollectionKey(integrationId, collectionName);
            const docsForCollection = this.documentsForCollection.get(collectionKey) || [];
            this.documentsForCollection.set(collectionKey, docsForCollection.concat(reference));
            return reference;
          }
          setDataManager(dataManager) {
            this.dataManager = dataManager;
          }
          /**
           * @internal
           */
          getDocumentsForCollection(integrationId, collectionName) {
            const collectionKey = this.getCollectionKey(integrationId, collectionName);
            return (this.documentsForCollection.get(collectionKey) || []).filter((d) => d.hasData);
          }
          /**
           * @internal
           */
          migrateDocIds(idResolutionMap) {
            for (const [, reference] of this.documents) {
              reference.migrateDocIds(idResolutionMap);
            }
            Object.entries(idResolutionMap).forEach(([squidDocId, newSquidDocId]) => {
              const squidDocIdObj = parseSquidDocId(squidDocId);
              const newSquidDocIdObj = parseSquidDocId(newSquidDocId);
              replaceKeyInMap(this.documents, squidDocIdObj.docId, newSquidDocIdObj.docId);
            });
          }
          getCollectionKey(integrationId, collectionName) {
            return `${integrationId}_${collectionName}`;
          }
        }
        ;
        class DocumentStore {
          constructor() {
            this.squidDocIdToDoc = /* @__PURE__ */ new Map();
          }
          saveDocument(squidDocId, properties) {
            const doc = this.squidDocIdToDoc.get(squidDocId);
            if (doc === void 0 && !properties)
              return void 0;
            if (doc !== void 0) {
              if (properties) {
                const updateDoc = (0, lodash.cloneDeep)(properties);
                const data2 = this.removeInternalProperties(updateDoc);
                this.squidDocIdToDoc.set(squidDocId, data2);
                return data2;
              }
              this.squidDocIdToDoc.delete(squidDocId);
              return void 0;
            }
            const data = this.removeInternalProperties(properties);
            this.squidDocIdToDoc.set(squidDocId, data);
            return properties;
          }
          hasData(squidDocId) {
            const doc = this.squidDocIdToDoc.get(squidDocId);
            return doc !== void 0;
          }
          getDocument(squidDocId) {
            return (0, dist.truthy)(this.getDocumentOrUndefined(squidDocId));
          }
          getDocumentOrUndefined(squidDocId) {
            return this.squidDocIdToDoc.get(squidDocId);
          }
          compareValues(a, b) {
            if (lodash_default().isNil(a)) {
              return lodash_default().isNil(b) ? 0 : -1;
            }
            if (lodash_default().isNil(b))
              return 1;
            if (a === b)
              return 0;
            return a > b ? 1 : -1;
          }
          compareSquidDocs(a, b, sortFieldNames, sortOrders) {
            for (const [i2, fieldName] of sortFieldNames.entries()) {
              const compare = this.compareValues(lodash_default().get(a, fieldName), lodash_default().get(b, fieldName));
              if (compare !== 0) {
                return sortOrders[i2] === "asc" ? compare : -1 * compare;
              }
            }
            return 0;
          }
          group(sortedDocs, sortFieldNames) {
            return Object.values(lodash_default().groupBy(sortedDocs, (doc) => {
              return normalizeJsonAsString(sortFieldNames.map((fieldName) => getInPath(doc, fieldName)));
            }));
          }
          sortAndLimitDocs(docIdSet, query) {
            if (docIdSet.size === 0) {
              return [];
            }
            const docs = [...docIdSet].map((id) => this.squidDocIdToDoc.get(id)).filter(dist.isNonNullable);
            const { sortOrder, limitBy } = query;
            const sortFieldNames = sortOrder.map((s) => s.fieldName);
            const sortOrders = sortOrder.map((s) => s.asc ? "asc" : "desc");
            const sortedDocs = docs.sort((a, b) => {
              return this.compareSquidDocs(a, b, sortFieldNames, sortOrders);
            });
            const mainLimit = query.limit < 0 ? 2e3 : query.limit;
            if (!limitBy) {
              return sortedDocs.slice(0, mainLimit);
            }
            const { limit: internalLimit, fields, reverseSort } = limitBy;
            const sortedGroups = this.group(sortedDocs, fields);
            let limitedGroups;
            if (reverseSort) {
              limitedGroups = sortedGroups.map((group) => group.slice(-internalLimit));
            } else {
              limitedGroups = sortedGroups.map((group) => group.slice(0, internalLimit));
            }
            return limitedGroups.flat().slice(0, mainLimit);
          }
          removeInternalProperties(doc) {
            if (!doc)
              return void 0;
            const data = Object.assign({}, doc);
            delete data["__ts__"];
            return data;
          }
          migrateDocId(squidDocId, newSquidDocId) {
            const doc = this.getDocumentOrUndefined(squidDocId);
            if (!doc)
              return;
            replaceKeyInMap(this.squidDocIdToDoc, squidDocId, newSquidDocId);
            const newSquidDocIdObj = parseSquidDocId(newSquidDocId);
            const docIdObj = deserializeObj(newSquidDocIdObj.docId);
            this.saveDocument(newSquidDocId, Object.assign(Object.assign(Object.assign({}, doc), docIdObj), { __docId__: newSquidDocIdObj.docId }));
          }
        }
        ;
        class GraphQLClientFactory {
          constructor(rpcManager, region, appId) {
            this.rpcManager = rpcManager;
            this.region = region;
            this.appId = appId;
            this.clientsMap = /* @__PURE__ */ new Map();
          }
          get(integrationId) {
            let client = this.clientsMap.get(integrationId);
            if (client)
              return client;
            client = new GraphQLClient(this.rpcManager, integrationId, this.region, this.appId);
            this.clientsMap.set(integrationId, client);
            return client;
          }
        }
        ;
        class MutationSender {
          constructor(rpcManager, lockManager, querySender) {
            this.rpcManager = rpcManager;
            this.lockManager = lockManager;
            this.querySender = querySender;
          }
          async sendMutations(mutations, integrationId) {
            const reducedMutations = reduceMutations(mutations);
            const mutexes = reducedMutations.map((mutation) => `sendMutation_${getSquidDocId(mutation.squidDocIdObj)}`);
            await this.lockManager.lock(...mutexes);
            await this.querySender.waitForAllQueriesToFinish();
            try {
              const request = {
                mutations: reducedMutations,
                integrationId
              };
              return await this.rpcManager.post("mutation/mutate", request);
            } catch (e) {
              DebugLogger.debug("Error while sending mutations", {
                error: e,
                mutations: JSON.stringify(reducedMutations, null, 2)
              });
              throw e;
            } finally {
              this.lockManager.release(...mutexes);
            }
          }
        }
        ;
        class LocalQueryManager {
          constructor(documentStore, documentReferenceFactory, querySubscriptionManager) {
            this.documentStore = documentStore;
            this.documentReferenceFactory = documentReferenceFactory;
            this.querySubscriptionManager = querySubscriptionManager;
          }
          /** @internal */
          peek(query) {
            if (!this.querySubscriptionManager.findValidParentOfQuery(query))
              return [];
            const { integrationId, collectionName } = query;
            const queryContext = new QueryContext(query);
            const references = this.documentReferenceFactory.getDocumentsForCollection(integrationId, collectionName).filter((doc) => queryContext.documentMatchesQuery(doc.data));
            const refMap = {};
            references.forEach((reference) => {
              refMap[reference.squidDocId] = reference;
            });
            const documents = this.documentStore.sortAndLimitDocs(new Set(Object.keys(refMap)), query);
            return documents.map((doc) => refMap[getSquidDocId(doc.__docId__, collectionName, integrationId)]);
          }
        }
        ;
        function filter(predicate, thisArg) {
          return operate(function(source, subscriber) {
            var index = 0;
            source.subscribe(createOperatorSubscriber(subscriber, function(value) {
              return predicate.call(thisArg, value, index++) && subscriber.next(value);
            }));
          });
        }
        var otrie_dist = __webpack_require__(511);
        ;
        var LimitUnderflowState;
        (function(LimitUnderflowState2) {
          LimitUnderflowState2[LimitUnderflowState2["UNKNOWN"] = 0] = "UNKNOWN";
          LimitUnderflowState2[LimitUnderflowState2["DISABLED"] = 1] = "DISABLED";
          LimitUnderflowState2[LimitUnderflowState2["ENABLED"] = 2] = "ENABLED";
        })(LimitUnderflowState || (LimitUnderflowState = {}));
        ;
        function binarySearch(arr, key, comparator = (a, b) => a > b ? 1 : a < b ? -1 : 0, low = 0, high = arr.length - 1) {
          if (high < low)
            return -1;
          const mid = Math.trunc((low + high) / 2);
          if (comparator(key, arr[mid]) === 0)
            return mid;
          if (comparator(key, arr[mid]) > 0)
            return binarySearch(arr, key, comparator, mid + 1, high);
          return binarySearch(arr, key, comparator, low, mid - 1);
        }
        function insertSorted(arr, key, comparator = (a, b) => a > b ? 1 : a < b ? -1 : 0) {
          if (binarySearch(arr, key, comparator) !== -1) {
            return;
          }
          const len = arr.length;
          let i2;
          for (i2 = len - 1; i2 >= 0 && comparator(arr[i2], key) > 0; i2--)
            arr[i2 + 1] = arr[i2];
          arr[i2 + 1] = key;
        }
        function removeSorted(arr, key, comparator = (a, b) => a > b ? 1 : a < b ? -1 : 0) {
          const index = binarySearch(arr, key, comparator);
          if (index > -1) {
            arr.splice(index, 1);
          }
        }
        async function asyncGroupBy(arr, groupNamer) {
          const groups = {};
          for (const element of arr) {
            const key = await groupNamer(element);
            if (!groups[key]) {
              groups[key] = [];
            }
            groups[key].push(element);
          }
          return groups;
        }
        const arrayMergeCustomizer = (a, b) => {
          if (isArray(a)) {
            return a.concat(b);
          } else {
            return void 0;
          }
        };
        ;
        const FETCH_BEYOND_LIMIT = 100;
        const LIMIT_UNDERFLOW_TRIGGER = 20;
        class QuerySubscriptionManager {
          constructor(rpcManager, clientIdService, documentStore, destructManager, documentIdentityService, querySender) {
            this.rpcManager = rpcManager;
            this.clientIdService = clientIdService;
            this.documentStore = documentStore;
            this.destructManager = destructManager;
            this.documentIdentityService = documentIdentityService;
            this.querySender = querySender;
            this.onOrphanDocuments = new external_rxjs_.Subject();
            this.ongoingQueries = /* @__PURE__ */ new Map();
            this.clientRequestIdToLocalDocuments = /* @__PURE__ */ new Map();
            this.localDocumentToClientRequestIds = /* @__PURE__ */ new Map();
            this.queryMappingManager = new ClientQueryMappingManager();
            this.queryResultsSubject = new external_rxjs_.Subject();
            this.documentIdentityService.observeChanges().subscribe(this.migrateDocIds.bind(this));
            this.clientIdService.observeClientReadyToBeRegenerated().subscribe(() => {
              this.refreshOngoingQueries();
            });
            this.destructManager.onPreDestruct(() => {
              this.preDestruct();
            });
          }
          observeQueryResults() {
            return this.queryResultsSubject.asObservable();
          }
          /**
           * Returns true if the client knows about this clientRequestId. It may happen that it will return false in the case
           * that the client unsubscribed from a query but the server sent a mutation update for this clientRequestId.
           */
          hasOngoingQuery(clientRequestId) {
            return this.ongoingQueries.has(clientRequestId);
          }
          /**
           * Returns the query associated with the given clientRequestId. Throws error if the clientRequestId is not known.
           */
          getQuery(clientRequestId) {
            return (0, dist.truthy)(this.ongoingQueries.get(clientRequestId), "UNKNOWN_QUERY").query;
          }
          /**
           * A query receives updates from three different sources:
           * 1 - An initial snapshot from the server or from a parent query
           * 2 - Incremental updates from the server (or from a parent query before the query is registered)
           * 3 - A new snapshot if the query is refreshed after connection has been lost.
           *
           * If an incremental update is received before the snapshot was received, we cannot process it for this query.
           * This boolean indicates whether the initial snapshot was received.
           */
          setGotInitialResult(clientRequestId) {
            const ongoingQuery = this.ongoingQueries.get(clientRequestId);
            this.removeClientRequestIdMapping(clientRequestId);
            if (ongoingQuery) {
              ongoingQuery.gotInitialResponse = true;
              ongoingQuery.isInFlight = false;
            }
          }
          /** Given a document, returns all the queries that should be notified with the new document properties. */
          findQueriesForDocument(doc, squidDocId) {
            const { collectionName, integrationId } = parseSquidDocId(squidDocId);
            const mapping = this.queryMappingManager.getMapping(collectionName, integrationId);
            if (!mapping)
              return [];
            return findQueriesForDocumentSync(mapping, doc);
          }
          /**
           * Given the new document's properties, finds all the queries that should be notified with the new properties and
           * updates the internal mappings (squidDocId --> client request Ids and, clientRequestId --> squidDocIds).
           * Returns an array with all the previous and current client request ids (basically all the client request ids that
           * will need to be notified due to the change of properties).
           */
          setClientRequestIdsForLocalDoc(squidDocId, properties) {
            const clientRequestIdsBefore = this.localDocumentToClientRequestIds.get(squidDocId) || /* @__PURE__ */ new Set();
            const clientRequestIdsAfter = new Set(properties ? this.findQueriesForDocument(properties, squidDocId).map((querySubscriptionId) => parseQuerySubscriptionId(querySubscriptionId).clientRequestId) : []);
            const allClientRequestIds = /* @__PURE__ */ new Set([...clientRequestIdsBefore, ...clientRequestIdsAfter]);
            for (const clientRequestIdBefore of [...clientRequestIdsBefore]) {
              if (clientRequestIdsAfter.has(clientRequestIdBefore))
                continue;
              clientRequestIdsBefore.delete(clientRequestIdBefore);
              const localDocsBefore = this.clientRequestIdToLocalDocuments.get(clientRequestIdBefore);
              if (localDocsBefore) {
                localDocsBefore.delete(squidDocId);
                if (!localDocsBefore.size) {
                  this.clientRequestIdToLocalDocuments.delete(clientRequestIdBefore);
                }
              }
              if (!clientRequestIdsBefore.size) {
                this.localDocumentToClientRequestIds.delete(squidDocId);
              }
            }
            for (const clientRequestIdAfter of clientRequestIdsAfter) {
              let clientRequestIds = this.localDocumentToClientRequestIds.get(squidDocId);
              if (!clientRequestIds) {
                clientRequestIds = /* @__PURE__ */ new Set();
                this.localDocumentToClientRequestIds.set(squidDocId, clientRequestIds);
              }
              clientRequestIds.add(clientRequestIdAfter);
              let localDocuments = this.clientRequestIdToLocalDocuments.get(clientRequestIdAfter);
              if (!localDocuments) {
                localDocuments = /* @__PURE__ */ new Set();
                this.clientRequestIdToLocalDocuments.set(clientRequestIdAfter, localDocuments);
              }
              localDocuments.add(squidDocId);
            }
            return [...allClientRequestIds];
          }
          /**
           * Due to an error when syncing a document, all the queries that are subscribed to this document should be notified
           * and error out.
           */
          errorOutAllQueries(squidDocId, err) {
            const clientRequestIds = this.localDocumentToClientRequestIds.get(squidDocId) || /* @__PURE__ */ new Set();
            for (const clientRequestId of clientRequestIds) {
              const ongoingQuery = this.ongoingQueries.get(clientRequestId);
              if (!ongoingQuery)
                continue;
              if (!this.destructManager.isDestructing) {
                ongoingQuery.dataSubject.error(err);
              } else {
                ongoingQuery.dataSubject.complete();
              }
              ongoingQuery.done = true;
            }
          }
          /** Notifies to all the given queries (identified by their clientRequestId) with the updated query result. */
          notifyAllSubscriptions(clientRequestIds) {
            const rootOngoingQueries = /* @__PURE__ */ new Set();
            for (const clientRequestId of clientRequestIds) {
              const ongoingQuery = this.ongoingQueries.get(clientRequestId);
              if (!ongoingQuery)
                continue;
              if (!ongoingQuery.gotInitialResponse || !ongoingQuery.activated || ongoingQuery.isInFlight)
                continue;
              const docIdSet = this.clientRequestIdToLocalDocuments.get(clientRequestId) || /* @__PURE__ */ new Set();
              const result = this.documentStore.sortAndLimitDocs(docIdSet, ongoingQuery.query);
              const observablesUpdated = ongoingQuery.supportedQueries.map((supportedOngoingQuery) => this.updateOngoingQueryWithNewDataFromSupportingQuery(result, supportedOngoingQuery)).some(Boolean);
              let rootOngoingQuery = ongoingQuery;
              while (!rootOngoingQuery.allObservables) {
                rootOngoingQuery = (0, dist.truthy)(rootOngoingQuery === null || rootOngoingQuery === void 0 ? void 0 : rootOngoingQuery.supportingOngoingQuery);
              }
              if (observablesUpdated) {
                rootOngoingQueries.add(rootOngoingQuery);
              }
              if (ongoingQuery.query.limit > 0) {
                switch (ongoingQuery.limitUnderflowState) {
                  case LimitUnderflowState.UNKNOWN:
                    ongoingQuery.limitUnderflowState = docIdSet.size === ongoingQuery.query.limit + FETCH_BEYOND_LIMIT ? LimitUnderflowState.ENABLED : LimitUnderflowState.DISABLED;
                    break;
                  case LimitUnderflowState.DISABLED:
                    break;
                  case LimitUnderflowState.ENABLED:
                    if (docIdSet.size < ongoingQuery.query.limit + LIMIT_UNDERFLOW_TRIGGER) {
                      ongoingQuery.limitUnderflowState = LimitUnderflowState.UNKNOWN;
                      this.sendQueryToServerOrUseParentQuery(ongoingQuery);
                      continue;
                    }
                }
              }
              ongoingQuery.dataSubject.next(result);
            }
            for (const rootOngoingQuery of rootOngoingQueries) {
              const allObservables = this.collectAllObservables(rootOngoingQuery);
              (0, dist.truthy)(rootOngoingQuery.allObservables).next(allObservables);
            }
          }
          isValidParent(candidateParentQuery) {
            if (!candidateParentQuery.activated || candidateParentQuery.isInFlight || candidateParentQuery.isEmptyForJoin || candidateParentQuery.done || !candidateParentQuery.subscribe || !candidateParentQuery.gotInitialResponse || !candidateParentQuery.dataSubject.value) {
              return false;
            }
            const limit = candidateParentQuery.query.limit === -1 ? 1e3 : candidateParentQuery.query.limit;
            return candidateParentQuery.dataSubject.value.length < limit;
          }
          /**
           * Given an ongoing query, search for candidate ongoing queries that can serve as a parent.
           * If there is a parent query, the result of that query can be used for serving the current query.
           * We will still register the current query on the server, but we do not need to run the query, apply security rules,
           * etc.
           */
          findValidParentOfOngoingQuery(ongoingQuery) {
            if (ongoingQuery.forceFetchFromServer)
              return void 0;
            const qc = new QueryContext(ongoingQuery.query);
            for (const candidateParentQuery of this.ongoingQueries.values()) {
              if (ongoingQuery === candidateParentQuery) {
                return void 0;
              } else if (!this.isValidParent(candidateParentQuery)) {
                continue;
              } else if (qc.isSubqueryOfQuery(candidateParentQuery.query)) {
                return candidateParentQuery;
              }
            }
            return void 0;
          }
          findValidParentOfQuery(query) {
            const qc = new QueryContext(query);
            for (const candidateParentQuery of this.ongoingQueries.values()) {
              if (!this.isValidParent(candidateParentQuery)) {
                continue;
              }
              if (qc.isSubqueryOfQuery(candidateParentQuery.query)) {
                return candidateParentQuery;
              }
            }
            return void 0;
          }
          processQuery(query, rootAlias, joins, joinConditions, subscribe, forceFetchFromServer) {
            return (0, external_rxjs_.defer)(() => {
              const rootOngoingQuery = this.createOngoingQueryGraph(query, rootAlias, joins, joinConditions, subscribe, true);
              if (forceFetchFromServer) {
                rootOngoingQuery.forceFetchFromServer = true;
              }
              this.sendQueryToServerOrUseParentQuery(rootOngoingQuery);
              rootOngoingQuery.allObservables = new external_rxjs_.ReplaySubject(1);
              const result = rootOngoingQuery.allObservables.pipe(
                (0, external_rxjs_.switchMap)((allObservables2) => {
                  return (0, external_rxjs_.combineLatest)(allObservables2).pipe(map((allResults) => {
                    return this.joinResults(allResults, joinConditions, rootOngoingQuery);
                  }));
                }),
                filter(() => {
                  return this.allOngoingQueriesGotInitialResult(rootOngoingQuery);
                }),
                (0, external_rxjs_.startWith)(void 0),
                (0, external_rxjs_.pairwise)(),
                filter(([before, after]) => {
                  return !lodash.isEqual(before, after);
                }),
                map(([, after]) => after),
                // This handles 'subscribe = false'
                subscribe ? (0, external_rxjs_.tap)() : (0, external_rxjs_.take)(1),
                (0, external_rxjs_.finalize)(() => {
                  var _a2;
                  rootOngoingQuery.dataSubject.complete();
                  rootOngoingQuery.done = true;
                  this.completeAllSupportedQueries(rootOngoingQuery).then();
                  (_a2 = rootOngoingQuery.allObservables) === null || _a2 === void 0 ? void 0 : _a2.complete();
                })
              );
              const allObservables = this.collectAllObservables(rootOngoingQuery);
              rootOngoingQuery.allObservables.next(allObservables);
              return result;
            }).pipe((0, external_rxjs_.share)());
          }
          /**
           * Returns whether the given document ID has a query that has this document ID as a result.
           * A document without a query is considered "un-tracked".
           */
          hasOngoingQueryForDocId(squidDocId) {
            const clientRequestIds = this.localDocumentToClientRequestIds.get(squidDocId);
            return !!clientRequestIds && !!clientRequestIds.size;
          }
          /**
           * Removes a query from the mapping and updates the orphan documents as needed.
           */
          removeClientRequestIdMapping(clientRequestId) {
            const docs = this.clientRequestIdToLocalDocuments.get(clientRequestId);
            if (!docs)
              return;
            this.clientRequestIdToLocalDocuments.delete(clientRequestId);
            const orphanDocument = [];
            for (const doc of docs) {
              const clientRequestIds = (0, dist.truthy)(this.localDocumentToClientRequestIds.get(doc));
              clientRequestIds.delete(clientRequestId);
              if (!clientRequestIds.size) {
                this.localDocumentToClientRequestIds.delete(doc);
                orphanDocument.push(doc);
              }
            }
            if (orphanDocument.length) {
              this.onOrphanDocuments.next(orphanDocument);
            }
          }
          /** Register logic for cleaning up the query when it is unsubscribed. */
          registerQueryFinalizer(ongoingQuery) {
            const clientRequestId = ongoingQuery.clientRequestId;
            const querySubscriptionId = getQuerySubscriptionId(this.clientIdService.getClientId(), clientRequestId);
            ongoingQuery.dataSubject.pipe((0, external_rxjs_.finalize)(async () => {
              if (ongoingQuery.unsubscribeBlockerCount.value > 0) {
                await (0, external_rxjs_.firstValueFrom)((0, external_rxjs_.race)(this.destructManager.observeIsDestructing(), ongoingQuery.unsubscribeBlockerCount.pipe(filter((count) => count === 0))));
              }
              this.queryMappingManager.removeQuery(querySubscriptionId).then();
              this.ongoingQueries.delete(clientRequestId);
              if (ongoingQuery.subscribe) {
                if (!ongoingQuery.isEmptyForJoin && ongoingQuery.activated) {
                  const unsubscribeRequest = {
                    clientRequestId
                  };
                  this.rpcManager.post("query/unsubscribe", unsubscribeRequest).catch((e) => {
                    if (this.destructManager.isDestructing)
                      return;
                    console.error("Got error while unsubscribing from query", ongoingQuery.query, e);
                  });
                }
              }
              this.removeClientRequestIdMapping(clientRequestId);
              this.ongoingQueries.delete(clientRequestId);
            }), filter(Boolean)).subscribe({
              error: () => {
              }
            });
          }
          /** Creates a graph of ongoing queries and returns the root of the graph. */
          createOngoingQueryGraph(query, alias, joins, joinConditionsMap, subscribe, isRoot, createdOngoingQueries = {}) {
            if (createdOngoingQueries[alias])
              return createdOngoingQueries[alias];
            const clientRequestId = generateId();
            const supportedQueries = [];
            const result = {
              clientRequestId,
              activated: isRoot,
              alias,
              query,
              subscribe,
              dataSubject: new external_rxjs_.BehaviorSubject(null),
              supportedQueries,
              supportingOngoingQuery: void 0,
              joinCondition: void 0,
              gotInitialResponse: false,
              isEmptyForJoin: false,
              unsubscribeBlockerCount: new external_rxjs_.BehaviorSubject(0),
              queryRegistered: new external_rxjs_.BehaviorSubject(false),
              done: false,
              isInFlight: false,
              forceFetchFromServer: false,
              limitUnderflowState: subscribe ? LimitUnderflowState.UNKNOWN : LimitUnderflowState.DISABLED
            };
            this.registerQueryFinalizer(result);
            this.ongoingQueries.set(clientRequestId, result);
            createdOngoingQueries[alias] = result;
            for (const [rightAlias, joinCondition] of Object.entries(joinConditionsMap)) {
              const leftAlias = joinCondition.leftAlias;
              if (leftAlias !== alias && rightAlias !== alias)
                continue;
              const chosenAlias = leftAlias === alias ? rightAlias : leftAlias;
              if (leftAlias === alias) {
                const supportedQuery = this.createOngoingQueryGraph(joins[chosenAlias], chosenAlias, joins, joinConditionsMap, subscribe, false, createdOngoingQueries);
                supportedQuery.joinCondition = joinCondition;
                supportedQueries.push(supportedQuery);
              } else {
                result.supportingOngoingQuery = this.createOngoingQueryGraph(joins[chosenAlias], chosenAlias, joins, joinConditionsMap, subscribe, false, createdOngoingQueries);
              }
            }
            return result;
          }
          collectAllObservables(ongoingQuery, result = []) {
            if (ongoingQuery.isEmptyForJoin) {
              return result;
            }
            const alias = ongoingQuery.alias;
            result.push(ongoingQuery.dataSubject.pipe(filter(Boolean), map((docs) => {
              return { docs, alias };
            })));
            for (const supportedQuery of ongoingQuery.supportedQueries) {
              this.collectAllObservables(supportedQuery, result);
            }
            return result;
          }
          joinResults(allResults, joinConditions, rootOngoingQuery) {
            const aliasToDocs = allResults.reduce((accum, docsAndAlias) => {
              if (accum[docsAndAlias.alias]) {
                accum[docsAndAlias.alias].push(...docsAndAlias.docs);
              } else {
                accum[docsAndAlias.alias] = [...docsAndAlias.docs];
              }
              return accum;
            }, {});
            let result = aliasToDocs[rootOngoingQuery.alias].map((doc) => ({
              [rootOngoingQuery.alias]: doc
            }));
            const ongoingQueriesInOrder = this.getOngoingQueriesBfs(rootOngoingQuery);
            const visitedAliases = /* @__PURE__ */ new Set();
            for (let i2 = 1; i2 < ongoingQueriesInOrder.length; i2++) {
              const ongoingQuery = ongoingQueriesInOrder[i2];
              const rightAlias = ongoingQuery.alias;
              if (visitedAliases.has(rightAlias))
                continue;
              visitedAliases.add(rightAlias);
              result = this.join(result, rightAlias, aliasToDocs[rightAlias], joinConditions[rightAlias]);
            }
            return result;
          }
          join(left, rightAlias, rightDocs, joinCondition) {
            if (!left.length)
              return left;
            const availableLeftAliases = Object.keys(left[0]);
            if (!(joinCondition && availableLeftAliases.includes(joinCondition.leftAlias))) {
              throw new Error("No join condition found for alias " + rightAlias);
            }
            const rightAsMap = /* @__PURE__ */ new Map();
            (rightDocs || []).forEach((doc) => {
              const val = doc[joinCondition.right];
              if (!rightAsMap.has(val))
                rightAsMap.set(val, []);
              (0, dist.truthy)(rightAsMap.get(val)).push(doc);
            });
            return left.flatMap((leftElement) => {
              var _a2;
              const rightDocsWithSameValue = rightAsMap.get((_a2 = leftElement[joinCondition.leftAlias]) === null || _a2 === void 0 ? void 0 : _a2[joinCondition.left]) || [];
              if (rightDocsWithSameValue.length) {
                return rightDocsWithSameValue.map((rightDoc) => Object.assign(Object.assign({}, leftElement), { [rightAlias]: rightDoc }));
              } else if (joinCondition.isInner) {
                return [];
              } else {
                return [Object.assign(Object.assign({}, leftElement), { [rightAlias]: void 0 })];
              }
            });
          }
          getOngoingQueriesBfs(rootOngoingQuery) {
            const result = [];
            const queue = [rootOngoingQuery];
            while (queue.length) {
              const current = (0, dist.truthy)(queue.shift());
              if (current.isEmptyForJoin)
                continue;
              result.push(current);
              queue.push(...current.supportedQueries);
            }
            return result;
          }
          updateOngoingQueryWithNewDataFromSupportingQuery(supportingQueryResult, supportedOngoingQuery) {
            var _a2;
            const joinCondition = (0, dist.truthy)(supportedOngoingQuery.joinCondition);
            const query = supportedOngoingQuery.query;
            if (!supportedOngoingQuery.activated) {
              const newConditions = supportingQueryResult.map((supportingDoc) => {
                var _a3;
                return {
                  fieldName: joinCondition.right,
                  operator: "==",
                  value: (_a3 = supportingDoc[joinCondition.left]) !== null && _a3 !== void 0 ? _a3 : null
                };
              });
              supportedOngoingQuery.activated = true;
              if (newConditions.length) {
                query.conditions.push(...newConditions);
                this.sendQueryToServerOrUseParentQuery(supportedOngoingQuery);
              } else {
                supportedOngoingQuery.isEmptyForJoin = true;
              }
              return true;
            } else {
              const supportedQueriesWithSameAlias = (0, dist.truthy)((_a2 = supportedOngoingQuery.supportingOngoingQuery) === null || _a2 === void 0 ? void 0 : _a2.supportedQueries).filter((q) => q.alias === supportedOngoingQuery.alias);
              const allNeededValues = new Set(supportingQueryResult.map((resultDoc) => {
                var _a3;
                return (_a3 = resultDoc[joinCondition.left]) !== null && _a3 !== void 0 ? _a3 : null;
              }));
              for (const supportedQuery of supportedQueriesWithSameAlias) {
                supportedQuery.query.conditions.filter(isSimpleCondition).filter((cond) => cond.fieldName === joinCondition.right).forEach((cond) => {
                  allNeededValues.delete(cond.value);
                });
              }
              if (allNeededValues.size === 0) {
                return false;
              }
              const newQuery = lodash.cloneDeep(query);
              newQuery.conditions = newQuery.conditions.filter((cond) => !isSimpleCondition(cond) || cond.fieldName !== joinCondition.right);
              [...allNeededValues].forEach((value) => {
                newQuery.conditions.push({
                  fieldName: joinCondition.right,
                  operator: "==",
                  value
                });
              });
              const ongoingQuery = Object.assign(Object.assign({}, supportedOngoingQuery), { query: newQuery, activated: true, gotInitialResponse: false, dataSubject: new external_rxjs_.BehaviorSubject(null), clientRequestId: generateId(), isEmptyForJoin: false });
              this.registerQueryFinalizer(ongoingQuery);
              this.ongoingQueries.set(ongoingQuery.clientRequestId, ongoingQuery);
              (0, dist.truthy)(supportedOngoingQuery.supportingOngoingQuery).supportedQueries.push(ongoingQuery);
              this.sendQueryToServerOrUseParentQuery(ongoingQuery);
              return true;
            }
          }
          allOngoingQueriesGotInitialResult(rootOngoingQuery) {
            if (rootOngoingQuery.isEmptyForJoin)
              return true;
            if (!rootOngoingQuery.gotInitialResponse)
              return false;
            if (!rootOngoingQuery.supportedQueries.length)
              return true;
            return rootOngoingQuery.supportedQueries.every((ongoingQuery) => this.allOngoingQueriesGotInitialResult(ongoingQuery));
          }
          async completeAllSupportedQueries(rootOngoingQuery) {
            const supportedQueries = [...rootOngoingQuery.supportedQueries || []];
            while (supportedQueries.length) {
              const supportedQuery = (0, dist.truthy)(supportedQueries.shift());
              supportedQueries.push(...supportedQuery.supportedQueries || []);
              await (0, external_rxjs_.firstValueFrom)(supportedQuery.unsubscribeBlockerCount.pipe(filter((count) => count === 0)));
              supportedQuery.dataSubject.complete();
            }
          }
          preDestruct() {
            this.unsubscribe();
          }
          unsubscribe() {
            var _a2;
            const ongoingQueries = [...this.ongoingQueries.values()];
            for (const ongoingQuery of ongoingQueries) {
              ongoingQuery.dataSubject.complete();
              (_a2 = ongoingQuery.allObservables) === null || _a2 === void 0 ? void 0 : _a2.complete();
            }
          }
          hasSubscription(clientRequestId) {
            var _a2;
            return !!((_a2 = this.ongoingQueries.get(clientRequestId)) === null || _a2 === void 0 ? void 0 : _a2.subscribe);
          }
          /** Sends the query request to the server and makes sure to unsubscribe once the subject completes. */
          sendQueryToServerOrUseParentQuery(ongoingQuery) {
            if (this.destructManager.isDestructing)
              return;
            const query = ongoingQuery.query;
            const clientRequestId = ongoingQuery.clientRequestId;
            const querySubscriptionId = getQuerySubscriptionId(this.clientIdService.getClientId(), clientRequestId);
            this.queryMappingManager.addQuery(query, querySubscriptionId);
            const parentOngoingQuery = this.findValidParentOfOngoingQuery(ongoingQuery);
            this.ongoingQueries.set(clientRequestId, ongoingQuery);
            if (parentOngoingQuery) {
              this.useParentOngoingQuery(ongoingQuery, parentOngoingQuery).then();
            } else {
              this.sendQueryToServer(ongoingQuery);
            }
          }
          /**
           * Uses the parent query as the source of data for the given ongoing query until the ongoing query is registered on
           * the server. It prevents the parent query from being unsubscribed until the query is registered on the server and
           * the first snapshot is received from the parent query.
           * 1 - Prevents the parent query from being unsubscribed
           * 2 - Connects the results of the parent query to the result of the current ongoing query
           * 3 - Registers the query on the server
           */
          async useParentOngoingQuery(ongoingQuery, parentOngoingQuery) {
            const queryRegisterRequest = {
              clientRequestId: ongoingQuery.clientRequestId,
              query: ongoingQuery.query,
              parentClientRequestId: parentOngoingQuery.clientRequestId
            };
            const queryContext = new QueryContext(ongoingQuery.query);
            parentOngoingQuery.unsubscribeBlockerCount.next(parentOngoingQuery.unsubscribeBlockerCount.value + 1);
            try {
              await (0, external_rxjs_.firstValueFrom)(parentOngoingQuery.queryRegistered.pipe(filter(Boolean)));
            } catch (e) {
              if (!this.destructManager.isDestructing) {
                ongoingQuery.dataSubject.error(e);
                ongoingQuery.queryRegistered.error(e);
              } else {
                ongoingQuery.dataSubject.complete();
                ongoingQuery.queryRegistered.complete();
              }
              ongoingQuery.done = true;
              return;
            }
            if (this.destructManager.isDestructing)
              return;
            if (ongoingQuery.done) {
              return;
            }
            this.rpcManager.post("query/register", queryRegisterRequest).then(() => {
              ongoingQuery.isInFlight = false;
              ongoingQuery.queryRegistered.next(true);
            }).catch((e) => {
              ongoingQuery.isInFlight = false;
              if (!this.destructManager.isDestructing) {
                console.error("Query error", ongoingQuery.query, parentOngoingQuery.query, e);
                ongoingQuery.dataSubject.error(e);
              } else {
                ongoingQuery.dataSubject.complete();
              }
              ongoingQuery.done = true;
            }).finally(() => {
              parentOngoingQuery.unsubscribeBlockerCount.next(parentOngoingQuery.unsubscribeBlockerCount.value - 1);
            });
            const takeUntilNotifier = (0, external_rxjs_.race)(
              /**
               * There may be some race condition between the time the query is registered and when the last mutation was sent
               * from the server. Adding a delay of 2 seconds here to make sure any update that the server sent will be
               * reflected in the query.
               */
              ongoingQuery.queryRegistered.pipe(filter(Boolean), (0, external_rxjs_.delay)(2e3), (0, external_rxjs_.take)(1)),
              this.destructManager.observeIsDestructing().pipe((0, external_rxjs_.take)(1))
            );
            parentOngoingQuery.dataSubject.pipe((0, external_rxjs_.takeWhile)(() => {
              return !ongoingQuery.done;
            }), (0, external_rxjs_.takeUntil)(takeUntilNotifier), filter(Boolean), (0, external_rxjs_.tap)(() => {
              if (ongoingQuery.gotInitialResponse)
                return;
              this.setGotInitialResult(ongoingQuery.clientRequestId);
            }), map((documents) => documents.filter((doc) => queryContext.documentMatchesQuery(doc)))).subscribe({
              next: (results) => {
                for (const result of results) {
                  this.setClientRequestIdsForLocalDoc(getSquidDocId(result.__docId__, ongoingQuery.query.collectionName, ongoingQuery.query.integrationId), result);
                }
                this.notifyAllSubscriptions([ongoingQuery.clientRequestId]);
              },
              error: (e) => {
                if (!this.destructManager.isDestructing) {
                  ongoingQuery.dataSubject.error(e);
                } else {
                  ongoingQuery.dataSubject.complete();
                }
              }
            });
          }
          /**
           * Sends the /query request to the server. It:
           * 1 - Waits for when it is safe to send a query to the server (no in-flight mutations)
           * 2 - Increments the number of inflightQueriesCount to prevent parallel mutations
           * 3 - Handles errors
           * 4 - Marks the query as registered
           */
          sendQueryToServer(ongoingQuery) {
            const oldLimit = ongoingQuery.query.limit;
            const newLimit = oldLimit > 0 && ongoingQuery.subscribe ? oldLimit + FETCH_BEYOND_LIMIT : oldLimit;
            const queryRequest = {
              query: Object.assign(Object.assign({}, ongoingQuery.query), { limit: newLimit }),
              clientRequestId: ongoingQuery.clientRequestId,
              subscribe: ongoingQuery.subscribe
            };
            ongoingQuery.isInFlight = true;
            this.querySender.sendQuery(queryRequest).then((queryResult) => {
              ongoingQuery.isInFlight = false;
              ongoingQuery.queryRegistered.next(true);
              this.queryResultsSubject.next(queryResult);
            }).catch((e) => {
              ongoingQuery.isInFlight = false;
              if (!this.destructManager.isDestructing) {
                DebugLogger.debug("Query error", ongoingQuery.query, e);
                ongoingQuery.dataSubject.error(e);
                ongoingQuery.queryRegistered.error("query failed");
              } else {
                ongoingQuery.dataSubject.complete();
                ongoingQuery.queryRegistered.complete();
              }
              ongoingQuery.done = true;
            });
          }
          /** naive way to refresh queries/subscriptions when we have a new client id */
          refreshOngoingQueries() {
            for (const query of this.ongoingQueries.values()) {
              this.sendQueryToServerOrUseParentQuery(query);
            }
            return;
          }
          migrateDocIds(idResolutionMap) {
            const squidDocIds = Object.keys(idResolutionMap);
            for (const set of this.clientRequestIdToLocalDocuments.values()) {
              squidDocIds.forEach((key) => {
                if (set.has(key)) {
                  set.delete(key);
                  set.add(idResolutionMap[key]);
                }
              });
            }
            squidDocIds.forEach((key) => {
              replaceKeyInMap(this.localDocumentToClientRequestIds, key, idResolutionMap[key]);
            });
          }
        }
        function matchesCompositeCondition(condition, doc) {
          var _a2;
          for (const subCondition of condition.fields) {
            const valueInDocument = (_a2 = getInPath(doc, subCondition.fieldName)) !== null && _a2 !== void 0 ? _a2 : null;
            if (compareOperator(subCondition.value, valueInDocument, subCondition.operator)) {
              return true;
            }
            if (compareOperator(subCondition.value, valueInDocument, "!=")) {
              return false;
            }
          }
          return false;
        }
        function findQueriesForDocumentSync(mapping, doc) {
          var _a2;
          const result = [...mapping.unconditional || []];
          const mappedIdFoundMap = /* @__PURE__ */ new Map();
          for (const [encodedCondition, queryIds] of Object.entries(mapping.conditional || {})) {
            const condition = deserializeObj(encodedCondition);
            let matchesCondition;
            if (isSimpleCondition(condition)) {
              const valueInDocument = (_a2 = getInPath(doc, condition.fieldName)) !== null && _a2 !== void 0 ? _a2 : null;
              matchesCondition = compareOperator(condition.value, valueInDocument, condition.operator);
            } else {
              matchesCondition = matchesCompositeCondition(condition, doc);
            }
            if (matchesCondition) {
              for (const mappedId of queryIds) {
                mappedIdFoundMap.set(mappedId, (mappedIdFoundMap.get(mappedId) || 0) + 1);
              }
            }
          }
          for (const [mappedId, matchCount] of mappedIdFoundMap.entries()) {
            if (matchCount >= mapping.queriesMetadata[mappedId].condCount) {
              result.push(mappedId);
            }
          }
          return result;
        }
        class ClientQueryMappingManager {
          constructor() {
            this.stateService = new otrie_dist.TrieStore({});
            this.querySubscriptionIdToQuery = {};
          }
          addQuery(query, querySubscriptionId) {
            this.stateService.runInBatch(() => {
              let condCount = 0;
              const visitedEqualityFields = /* @__PURE__ */ new Set();
              for (const condition of query.conditions) {
                if (isSimpleCondition(condition) && ["=="].includes(condition.operator)) {
                  const fieldName = encodeValueForMapping(condition.fieldName);
                  if (!visitedEqualityFields.has(fieldName)) {
                    condCount++;
                    visitedEqualityFields.add(fieldName);
                  }
                } else {
                  condCount++;
                }
                const conditionPath = this.getConditionStatePath(query, condition);
                const clientRequestIdsForCondition = [...this.stateService.get(conditionPath) || []];
                insertSorted(clientRequestIdsForCondition, querySubscriptionId);
                this.stateService.set(conditionPath, clientRequestIdsForCondition);
              }
              if (!query.conditions.length) {
                const path = ["queryMapping", query.collectionName, query.integrationId, "mapping", "unconditional"];
                const currentArray = [...this.stateService.get(path) || []];
                insertSorted(currentArray, querySubscriptionId);
                this.stateService.set(path, currentArray);
              }
              this.stateService.set([...this.getQueryMetadataStatePath(query, querySubscriptionId), "condCount"], condCount);
            });
            this.querySubscriptionIdToQuery[querySubscriptionId] = query;
          }
          async removeQuery(querySubscriptionId) {
            const query = this.querySubscriptionIdToQuery[querySubscriptionId];
            if (!query)
              return;
            this.stateService.runInBatch(() => {
              for (const cond of query.conditions) {
                const path = this.getConditionStatePath(query, cond);
                const currentArray = [...this.stateService.get(path) || []];
                removeSorted(currentArray, querySubscriptionId);
                if (currentArray.length) {
                  this.stateService.set(path, currentArray);
                } else {
                  this.stateService.delete(path);
                }
              }
              if (!query.conditions.length) {
                const path = ["queryMapping", query.collectionName, query.integrationId, "mapping", "unconditional"];
                const currentArray = [...this.stateService.get(path) || []];
                removeSorted(currentArray, querySubscriptionId);
                this.stateService.set(path, currentArray);
              }
              this.stateService.delete(this.getQueryMetadataStatePath(query, querySubscriptionId));
            });
            return query;
          }
          getMapping(collectionName, integrationId) {
            return this.stateService.get([
              "queryMapping",
              collectionName,
              integrationId,
              "mapping"
            ]);
          }
          getQueryMetadataStatePath(query, clientRequestId) {
            return [
              "queryMapping",
              query.collectionName,
              query.integrationId,
              "mapping",
              "queriesMetadata",
              `${clientRequestId}`
            ];
          }
          getConditionStatePath(query, cond) {
            return ["queryMapping", query.collectionName, query.integrationId, "mapping", "conditional", encodeCondition(cond)];
          }
        }
        ;
        class RateLimiter {
          /**
           * Creates a new rate limiter. It limits the number of requests using two parameters:
           * - capacity: the maximum number of tokens (actions) that can be stored at any given time
           * - seconds: the number of seconds it takes to refill the bucket to its maximum capacity
           *
           * We then can calculate the refillRatePerMs: the number of tokens (actions) that are added to the bucket every
           * millisecond
           *
           * Example:
           * Say we want to allow maximum 60 requests in a period of 5 seconds. We can create a rate limiter with:
           * - capacity: 60
           * - seconds: 5
           * And we will get refillRatePerMs: 60 / (5 * 1000) = 0.012
           *
           * To use:
           * const rateLimiter = new RateLimiter(60, 5);
           * await rateLimiter.consume();
           *
           * @param capacity
           * @param refillRatePerMs
           */
          constructor(capacity, seconds) {
            this.capacity = capacity;
            this.seconds = seconds;
            this.tokens = capacity;
            this.refillRatePerMs = capacity / (seconds * 1e3);
            this.lastRefillTimestamp = Date.now();
          }
          async consume() {
            if (this.attemptConsume())
              return;
            await (0, external_rxjs_.firstValueFrom)((0, external_rxjs_.interval)(10).pipe((0, external_rxjs_.filter)(() => this.attemptConsume()), (0, external_rxjs_.first)()));
          }
          attemptConsume() {
            this.refill();
            if (this.tokens >= 1) {
              this.tokens -= 1;
              return true;
            }
            return false;
          }
          refill() {
            const now = Date.now();
            const elapsedTime = now - this.lastRefillTimestamp;
            const tokensToAdd = elapsedTime * this.refillRatePerMs;
            this.tokens = Math.min(this.tokens + tokensToAdd, this.capacity);
            this.lastRefillTimestamp = now;
          }
        }
        ;
        const external_axios_namespaceObject = require_axios();
        var external_axios_default = __webpack_require__.n(external_axios_namespaceObject);
        ;
        class RpcManager {
          constructor(region, appId, destructManager, headers = {}, authManager, clientIdService) {
            this.region = region;
            this.appId = appId;
            this.authManager = authManager;
            this.clientIdService = clientIdService;
            this.staticHeaders = {};
            this.onGoingRpcCounter = new external_rxjs_.BehaviorSubject(0);
            for (const [key, value] of Object.entries(headers)) {
              this.setStaticHeader(key, value);
            }
            this.clientIdService.observeClientId().subscribe((clientId) => {
              if (clientId) {
                this.setStaticHeader("x-squid-clientid", clientId);
              } else {
                this.deleteStaticHeader("x-squid-clientid");
              }
            });
            destructManager.onDestruct(async () => {
              await this.awaitAllSettled();
            });
            const apiKey = this.authManager.getApiKey();
            const rateLimiterMultiplier = apiKey ? 5 : 1;
            this.rateLimiters = {
              default: new RateLimiter(60 * rateLimiterMultiplier, 5),
              ai: new RateLimiter(20 * rateLimiterMultiplier, 5),
              secret: new RateLimiter(20 * rateLimiterMultiplier, 5)
            };
          }
          async getAuthHeaders() {
            const apiKey = this.authManager.getApiKey();
            if (apiKey) {
              return { Authorization: `ApiKey ${apiKey}` };
            }
            const { token, integrationId } = await this.authManager.getAuthData();
            if (!token)
              return {};
            let header = `Bearer ${token}`;
            if (integrationId) {
              header += `; IntegrationId ${integrationId}`;
            }
            return { Authorization: header };
          }
          async awaitAllSettled() {
            await (0, external_rxjs_.firstValueFrom)(this.onGoingRpcCounter.pipe((0, external_rxjs_.filter)((value) => value === 0)));
          }
          setStaticHeader(key, value) {
            this.staticHeaders[key] = value;
          }
          deleteStaticHeader(key) {
            delete this.staticHeaders[key];
          }
          getStaticHeaders() {
            return this.staticHeaders;
          }
          async post(path, message, files = [], filesFieldName = "files") {
            this.onGoingRpcCounter.next(this.onGoingRpcCounter.value + 1);
            try {
              await this.getRateLimiterBucket(path).consume();
              let headers = {};
              if (Object.keys(this.staticHeaders)) {
                headers = Object.assign(Object.assign({}, headers), this.staticHeaders);
              }
              const authHeaders = await this.getAuthHeaders();
              headers = Object.assign(Object.assign({}, headers), authHeaders);
              DebugLogger.debug(`sending request: path: ${path} message: ${JSON.stringify(message)}`);
              const url = getApplicationUrl(this.region, this.appId, path);
              let axiosResponse;
              try {
                if (files.length) {
                  const formData = new FormData();
                  files.forEach((file) => {
                    const blob = file instanceof Blob ? file : file.blob;
                    const filename = file instanceof Blob ? void 0 : file.name;
                    formData.append(filesFieldName, blob, filename);
                  });
                  formData.append("body", serializeObj(message));
                  axiosResponse = await external_axios_default().post(url, formData, {
                    headers: Object.assign({}, headers),
                    responseType: "text"
                  });
                } else {
                  axiosResponse = await external_axios_default().post(url, serializeObj(message), {
                    headers: Object.assign(Object.assign({}, headers), { "Content-Type": "application/json" }),
                    responseType: "text"
                  });
                }
              } catch (e) {
                if (e === null || e === void 0 ? void 0 : e.isAxiosError) {
                  const response = e.response;
                  if (!response)
                    throw e;
                  let message2;
                  try {
                    const errorResponse = this.tryDeserializing(response.data);
                    message2 = typeof errorResponse === "string" ? errorResponse : errorResponse["message"];
                  } catch (_a2) {
                  }
                  if (!message2)
                    message2 = response.statusText;
                  throw new RpcError(response.status, response.statusText, response.headers, url, message2);
                } else {
                  throw e;
                }
              }
              const parsedResponse = this.tryDeserializing(axiosResponse.data);
              DebugLogger.debug(`received response: ${JSON.stringify(parsedResponse)}`);
              return parsedResponse;
            } finally {
              this.onGoingRpcCounter.next(this.onGoingRpcCounter.value - 1);
            }
          }
          tryDeserializing(text) {
            if (!text)
              return void 0;
            try {
              return deserializeObj(text);
            } catch (_a2) {
            }
            return text;
          }
          getRateLimiterBucket(path) {
            if (path.startsWith("ai/chatbot")) {
              return (0, dist.truthy)(this.rateLimiters["ai"], "MISSING_RATE_LIMITER_AI");
            }
            if (path.startsWith("secret/")) {
              return (0, dist.truthy)(this.rateLimiters["secret"], "MISSING_RATE_LIMITER_SECRETS");
            }
            return (0, dist.truthy)(this.rateLimiters["default"], "MISSING_RATE_LIMITER_DEFAULT");
          }
        }
        class RpcError extends Error {
          constructor(statusCode, statusText, headers, url, message) {
            super(message || `RPC error ${statusCode} ${statusText} calling ${url}`);
            this.statusCode = statusCode;
            this.statusText = statusText;
            this.headers = headers;
            this.url = url;
          }
        }
        ;
        class SecretClient {
          constructor(rpcManager) {
            this.rpcManager = rpcManager;
          }
          async get(key) {
            const request = { key };
            return await this.rpcManager.post("secret/get", request) || void 0;
          }
          getAll() {
            return this.rpcManager.post("secret/getAll", {});
          }
          upsert(key, value) {
            return this.upsertMany([{ key, value }]).then((entries) => entries[0]);
          }
          upsertMany(entries) {
            const request = { entries };
            return this.rpcManager.post("secret/upsert", request);
          }
          delete(key) {
            const request = { keys: [key] };
            return this.rpcManager.post("secret/delete", request);
          }
          deleteMany(keys) {
            const request = { keys };
            return this.rpcManager.post("secret/delete", request);
          }
          get apiKeys() {
            return new ApiKeysSecretClient(this.rpcManager);
          }
        }
        class ApiKeysSecretClient {
          constructor(rpcManager) {
            this.rpcManager = rpcManager;
          }
          get(key) {
            const request = { key };
            return this.rpcManager.post("secret/api-key/get", request);
          }
          getAll() {
            return this.rpcManager.post("secret/api-key/getAll", {});
          }
          upsert(key) {
            const request = { key };
            return this.rpcManager.post("secret/api-key/upsert", request);
          }
          delete(key) {
            const request = { key };
            return this.rpcManager.post("secret/api-key/delete", request);
          }
        }
        ;
        const NOOP_FN = (fn) => {
          return fn();
        };
        ;
        var websocket_impl_a;
        function websocket_impl_noop() {
          return;
        }
        const globalObj = getGlobal();
        const WebSocketClass = (websocket_impl_a = globalObj["WebSocket"]) !== null && websocket_impl_a !== void 0 ? websocket_impl_a : __webpack_require__(5352);
        function createWebSocketWrapper(url, opts = {}) {
          let ws;
          let num = 0;
          let timer = 1;
          const $ = {
            connected: false,
            open() {
              var _a2;
              const wsConstructor = (_a2 = WebSocketClass === null || WebSocketClass === void 0 ? void 0 : WebSocketClass["WebSocket"]) !== null && _a2 !== void 0 ? _a2 : WebSocketClass;
              ws = new wsConstructor(url, opts.protocols || []);
              ws.onmessage = opts.onmessage || websocket_impl_noop;
              ws.onopen = function(e) {
                $.connected = true;
                (opts.onopen || websocket_impl_noop)(e);
                num = 0;
              };
              ws.onclose = function(e) {
                $.connected = false;
                if (e.code !== 4999 && e.code !== 4001) {
                  DebugLogger.debug("WebSocket closed. Reconnecting. Close code: ", e.code);
                  (opts.onclose || websocket_impl_noop)(e);
                  $.reconnect(e);
                  return;
                }
                (opts.onclose || websocket_impl_noop)(e);
              };
              ws.onerror = function(e) {
                $.connected = false;
                if (e && "ECONNREFUSED" === e.code) {
                  $.reconnect(e);
                } else {
                  (opts.onerror || websocket_impl_noop)(e);
                }
              };
            },
            reconnect(e) {
              const maxAttempts = opts.maxAttempts !== void 0 ? opts.maxAttempts : Infinity;
              if (timer && num++ < maxAttempts) {
                timer = setTimeout(function() {
                  (opts.onreconnect || websocket_impl_noop)(e);
                  DebugLogger.debug("WebSocket trying to reconnect...");
                  $.open();
                }, opts.timeout || 1e3);
              } else {
                (opts.onmaximum || websocket_impl_noop)(e);
              }
            },
            json(x) {
              ws.send(JSON.stringify(x));
            },
            send(x) {
              ws.send(x);
            },
            close(code = 4999, message) {
              try {
                $.connected = false;
                clearTimeout(timer);
                timer = void 0;
                ws.close(code, message);
              } catch (e) {
              }
            }
          };
          $.open();
          return $;
        }
        ;
        class SocketManager {
          constructor(clientIdService, region, appId, messageNotificationWrapper = NOOP_FN, destructManager, authManager) {
            this.clientIdService = clientIdService;
            this.region = region;
            this.appId = appId;
            this.messageNotificationWrapper = messageNotificationWrapper;
            this.destructManager = destructManager;
            this.authManager = authManager;
            this.webSocketObserver = new external_rxjs_.Subject();
            this.allMessagesObserver = new external_rxjs_.Subject();
            this.connectionReady = new external_rxjs_.BehaviorSubject(false);
            this.seenMessageIds = /* @__PURE__ */ new Set();
            this.destructSubject = new external_rxjs_.Subject();
            this.clientTooOldThreshold = 3e4;
            this.destructManager.onDestruct(async () => {
              await this.destruct();
            });
            this.setupMessageAcknowledgments();
            this.connect();
            this.lastTick = /* @__PURE__ */ new Date();
            this.tickInterval = setInterval(() => this.tick(), 5e3);
            this.observeConnectionReady().pipe((0, external_rxjs_.skip)(1), (0, external_rxjs_.filter)((v) => !v), (0, external_rxjs_.switchMap)(() => {
              return (0, external_rxjs_.race)((0, external_rxjs_.timer)(this.clientTooOldThreshold), this.connectionReady.pipe((0, external_rxjs_.filter)(Boolean)), this.destructManager.observeIsDestructing());
            })).subscribe(() => {
              if (this.connectionReady.value) {
                DebugLogger.debug("Client reconnected before becoming too old. Ignoring...");
                return;
              }
              this.refreshClient();
            });
            this.observeConnectionReady().pipe((0, external_rxjs_.filter)(Boolean)).subscribe(() => {
              if (this.clientIdService.isClientTooOld()) {
                this.clientIdService.notifyClientReadyToBeRegenerated();
              }
            });
          }
          refreshClient() {
            if (this.destructManager.isDestructing) {
              DebugLogger.debug("Client too old but is destructed. Ignoring...");
              return;
            } else if (this.clientIdService.isClientTooOld()) {
              DebugLogger.debug("Client is already marked as too old. Ignoring...");
              return;
            }
            this.clientIdService.notifyClientTooOld();
            DebugLogger.debug("Client too old. Reconnecting...");
            this.connect();
          }
          tick() {
            const diff = Math.abs(Date.now() - this.lastTick.getTime());
            if (diff > this.clientTooOldThreshold) {
              this.refreshClient();
            }
            this.lastTick = /* @__PURE__ */ new Date();
          }
          observeNotifications() {
            return this.webSocketObserver.asObservable();
          }
          observeConnectionReady() {
            return this.connectionReady.asObservable().pipe((0, external_rxjs_.distinctUntilChanged)());
          }
          sendMessage(message) {
            this.sendMessageAsync(message).then();
          }
          async sendMessageAsync(message) {
            var _a2;
            await (0, external_rxjs_.firstValueFrom)(this.connectionReady.pipe((0, external_rxjs_.filter)(Boolean)));
            const authToken = await this.authManager.getToken();
            if (!this.connectionReady.value) {
              await this.sendMessageAsync(message);
              return;
            }
            try {
              (0, dist.assertTruthy)(this.socket, "Socket is undefined in sendMessageAsync");
              this.socket.send(serializeObj({ message, authToken }));
            } catch (e) {
              if (!((_a2 = this.socket) === null || _a2 === void 0 ? void 0 : _a2.connected)) {
                this.connectionReady.next(false);
                await this.sendMessageAsync(message);
              } else {
                console.error("Websocket message is ignored due to a non-recoverable error", e);
              }
            }
          }
          /**  Sends 'kill' message ignoring 'connectionReady' observable. */
          sendKillMessage() {
            var _a2;
            if (!((_a2 = this.socket) === null || _a2 === void 0 ? void 0 : _a2.connected))
              return;
            const message = { type: "kill" };
            this.socket.send(serializeObj({ message }));
          }
          connect() {
            var _a2;
            (_a2 = this.socket) === null || _a2 === void 0 ? void 0 : _a2.close();
            const endpoint = getApplicationUrl(this.region, this.appId, "ws/general").replace("https", "wss").replace("http", "ws");
            DebugLogger.debug("Connecting to socket at:", endpoint);
            const socketUri = `${endpoint}?clientId=${this.clientIdService.getClientId()}`;
            this.socket = createWebSocketWrapper(socketUri, {
              timeout: 5e3,
              onmessage: (e) => this.onMessage(e.data),
              onopen: () => {
                DebugLogger.debug(`Connection to socket established. Endpoint: ${endpoint}`);
              },
              onreconnect: () => {
                DebugLogger.debug(`WebSocket reconnect event triggered`);
                this.connectionReady.next(false);
              },
              onclose: () => {
                DebugLogger.debug(`WebSocket onclose event triggered`);
                this.connectionReady.next(false);
              },
              onerror: (e) => console.error("WebSocket error:", e)
            });
          }
          disconnect() {
            var _a2;
            this.connectionReady.next(false);
            (_a2 = this.socket) === null || _a2 === void 0 ? void 0 : _a2.close(4998);
          }
          onConnectionReady() {
            this.connectionReady.next(true);
            this.sendMessage({ type: "catchup" });
          }
          onMessage(messagesStr) {
            if (messagesStr === "connectionReady") {
              DebugLogger.debug("Got socket message: connectionReady");
              this.onConnectionReady();
              return;
            }
            const messages = deserializeObj(messagesStr);
            for (const message of messages) {
              this.allMessagesObserver.next(message);
              if (this.seenMessageIds.has(message.messageId)) {
                continue;
              }
              this.seenMessageIds.add(message.messageId);
              DebugLogger.debug(/* @__PURE__ */ new Date(), "Got socket message: ", JSON.stringify(message, null, 2));
              this.messageNotificationWrapper(() => {
                this.webSocketObserver.next(message);
              });
            }
          }
          setupMessageAcknowledgments() {
            const ackSubject = new external_rxjs_.Subject();
            this.allMessagesObserver.subscribe((message) => {
              if (!(message === null || message === void 0 ? void 0 : message.messageId))
                return;
              ackSubject.next(message.messageId);
            });
            const collectedMessageIds = [];
            ackSubject.pipe((0, external_rxjs_.tap)((messageId) => collectedMessageIds.push(messageId)), (0, external_rxjs_.debounceTime)(100)).subscribe(async () => {
              const messageIds = [...collectedMessageIds.splice(0)];
              this.sendMessage({ type: "acknowledge", payload: messageIds });
            });
          }
          async destruct() {
            var _a2;
            this.sendKillMessage();
            await (0, external_rxjs_.firstValueFrom)((0, external_rxjs_.timer)(0));
            this.connectionReady.next(false);
            await (0, external_rxjs_.firstValueFrom)((0, external_rxjs_.timer)(0));
            clearInterval(this.tickInterval);
            (_a2 = this.socket) === null || _a2 === void 0 ? void 0 : _a2.close();
            this.webSocketObserver.complete();
            this.allMessagesObserver.complete();
            this.destructSubject.next();
          }
        }
        ;
        class QuerySender {
          constructor(rpcManager, destructManager) {
            this.rpcManager = rpcManager;
            this.destructManager = destructManager;
            this.pendingQueryRequests = [];
            this.safeToSendQueriesToServer = new external_rxjs_.BehaviorSubject(true);
            this.inflightQueriesCount = new external_rxjs_.BehaviorSubject(0);
            this.destructManager.onPreDestruct(() => {
              this.preDestruct();
            });
          }
          async sendQuery(queryRequest) {
            const responseSubject = new external_rxjs_.Subject();
            const responsePromise = (0, external_rxjs_.firstValueFrom)(responseSubject);
            this.pendingQueryRequests.push({ queryRequest, responseSubject });
            if (this.pendingQueryBatchTimeout) {
              clearTimeout(this.pendingQueryBatchTimeout);
              this.pendingQueryBatchTimeout = void 0;
            }
            if (this.pendingQueryRequests.length >= 10) {
              void this.processQueryBatch();
              return responsePromise;
            }
            this.pendingQueryBatchTimeout = setTimeout(() => {
              this.safeToSendQueriesToServer.pipe(filter(Boolean), (0, external_rxjs_.take)(1)).subscribe(() => {
                this.processQueryBatch();
              });
            }, 0);
            return responsePromise;
          }
          async processQueryBatch() {
            const queryRequestAndSubjects = this.pendingQueryRequests.splice(0);
            if (!queryRequestAndSubjects.length)
              return;
            const pendingQueryRequests = queryRequestAndSubjects.map(({ queryRequest }) => queryRequest);
            const responseSubjects = queryRequestAndSubjects.map(({ responseSubject }) => responseSubject);
            this.inflightQueriesCount.next(this.inflightQueriesCount.value + pendingQueryRequests.length);
            try {
              const batchResponse = await this.rpcManager.post("query/batchQueries", pendingQueryRequests);
              for (const { queryRequest, responseSubject } of queryRequestAndSubjects) {
                const clientRequestId = queryRequest.clientRequestId;
                const error = batchResponse.errors[clientRequestId];
                const result = batchResponse.results[clientRequestId];
                if (error) {
                  responseSubject.error(error);
                } else {
                  responseSubject.next(result);
                }
              }
            } catch (e) {
              responseSubjects.forEach((responseSubject) => responseSubject.error(e));
            } finally {
              this.inflightQueriesCount.next(this.inflightQueriesCount.value - pendingQueryRequests.length);
            }
          }
          /** Will resolve once all the in-flight queries are done. */
          async waitForAllQueriesToFinish() {
            return (0, external_rxjs_.firstValueFrom)(this.inflightQueriesCount.pipe(filter((count) => count === 0))).then(() => {
              return void 0;
            });
          }
          preDestruct() {
            this.safeToSendQueriesToServer.next(false);
            this.safeToSendQueriesToServer.complete();
          }
        }
        ;
        class NativeQueryManager {
          constructor(rpcManager) {
            this.rpcManager = rpcManager;
          }
          async executeNativeQuery(integrationId, request) {
            const executeRequest = Object.assign({ integrationId }, request);
            return this.rpcManager.post("native-query/execute", executeRequest);
          }
        }
        ;
        class AiAssistantClient {
          constructor(rpcManager) {
            this.rpcManager = rpcManager;
          }
          /**
           * Creates a new AI assistant with specified characteristics.
           * @param name - The name of the assistant.
           * @param instructions - Instructions for the assistant.
           * @param functions - Array of function names annotated with "@aiFunction" in your Squid backend that will be
           *   available tol the assistant.
           * @param toolTypes - Optional array of tool types. If you want to use files for retrieval, you must add them using
           *   the addFileToAssistant method.
           * @returns A promise that resolves to the created assistant's ID.
           */
          async createAssistant(name, instructions, functions, toolTypes) {
            const request = {
              name,
              instructions,
              functions,
              toolTypes
            };
            const response = await this.rpcManager.post("ai/assistant/createAssistant", request);
            return response.assistantId;
          }
          /**
           * Deletes an AI assistant.
           * @param assistantId - The ID of the assistant to be deleted.
           * @returns A promise that resolves when the assistant is deleted.
           */
          async deleteAssistant(assistantId) {
            const request = {
              assistantId
            };
            await this.rpcManager.post("ai/assistant/deleteAssistant", request);
          }
          /**
           * Creates a new thread for an AI assistant. A thread is a long-lived conversation with the assistant that you can
           * always send questions to.
           * @param assistantId - The ID of the assistant for which the thread is created.
           * @returns A promise that resolves to the created thread's ID.
           */
          async createThread(assistantId) {
            const request = {
              assistantId
            };
            const response = await this.rpcManager.post("ai/assistant/createThread", request);
            return response.threadId;
          }
          /**
           * Deletes a thread of an AI assistant.
           * @param threadId - The ID of the thread to be deleted.
           * @returns A promise that resolves when the thread is deleted.
           */
          async deleteThread(threadId) {
            const request = {
              threadId
            };
            await this.rpcManager.post("ai/assistant/deleteThread", request);
          }
          /**
           * Queries an AI assistant within a specific thread.
           * @param assistantId - The ID of the assistant.
           * @param threadId - The ID of the thread.
           * @param prompt - The query prompt.
           * @param fileIds - Optional array of file IDs to include in the query. These file IDs need to be added using the
           *   addFileToThread method.
           * @returns A promise that resolves to the assistant's response.
           */
          async queryAssistant(assistantId, threadId, prompt, fileIds) {
            const request = {
              assistantId,
              threadId,
              prompt,
              fileIds
            };
            const response = await this.rpcManager.post("ai/assistant/queryAssistant", request);
            return response.answer;
          }
          /**
           * Adds a file to an AI assistant that can be available for retrieval or code analyzer.
           * @param assistantId - The ID of the assistant.
           * @param file - The file or blob and filename to be added.
           * @returns A promise that resolves to the ID of the added file.
           */
          async addFileToAssistant(assistantId, file) {
            const request = { assistantId };
            const response = await this.rpcManager.post(`ai/assistant/addFileToAssistant`, request, [file], "file");
            return response.fileId;
          }
          /**
           * Removes a file from an AI assistant.
           * @param assistantId - The ID of the assistant.
           * @param fileId - The ID of the file to be removed.
           * @returns A promise that resolves when the file is removed.
           */
          async removeFileFromAssistant(assistantId, fileId) {
            const request = {
              assistantId,
              fileId
            };
            await this.rpcManager.post("ai/assistant/removeFileFromAssistant", request);
          }
          /**
           * Adds a file to a specific thread of an AI assistant. These files can be used when asking a question in the thread.
           * @param threadId - The ID of the thread.
           * @param file - The file or blob and filename to be added.
           * @returns A promise that resolves to the ID of the added file.
           */
          async addFileToThread(threadId, file) {
            const request = { threadId };
            const response = await this.rpcManager.post(`ai/assistant/addFileToThread`, request, [file], "file");
            return response.fileId;
          }
        }
        ;
        class AiClient {
          constructor(aiChatbotClientFactory, rpcManager) {
            this.aiChatbotClientFactory = aiChatbotClientFactory;
            this.rpcManager = rpcManager;
            this.aiAssistantClient = new AiAssistantClient(this.rpcManager);
          }
          /**
           * Retrieves an AI chatbot client for a specific AI integration.
           * @param aiIntegrationId - The identifier for the AI integration.
           * @returns An instance of AiChatbotClient associated with the given AI integration ID.
           */
          chatbot(aiIntegrationId) {
            return this.aiChatbotClientFactory.getChatbot(aiIntegrationId);
          }
          /**
           * Retrieves the AI assistant client.
           * @returns An instance of AiAssistantClient.
           */
          assistant() {
            return this.aiAssistantClient;
          }
          /**
           * Executes an AI query using a specific DB integration, sending a prompt to the AI and returning its response.
           * This function allows for direct interaction with the AI's capabilities by sending text prompts and receiving
           * the AI's responses, which can be used for various applications such as automating tasks, generating content,
           * or obtaining information.
           *
           * @param integrationId The identifier for the DB integration which is used to direct the query to the
           *                      appropriate DB.
           * @param prompt        The text prompt to send to the AI. This should be formulated in a way that the AI can
           *                      understand and respond to, taking into account the nature of the task or the information
           *                      sought.
           * @returns             A promise that resolves to an `ExecuteAiQueryResponse`. This response includes the AI's
           *                      reply to the provided prompt, along with any other relevant information that is part of
           *                      the AI's response. The promise can be awaited to handle the response asynchronously.
           *
           * @example
           * ```
           * const response = await ai().executeAiQuery(myDbIntegrationId, "How many transactions ran yesterday?");
           * console.log(response);
           * ```
           *
           * For more details on the usage and capabilities of the AI Assistant, refer to the documentation provided at
           * {@link https://docs.squid.cloud/docs/ai}.
           */
          executeAiQuery(integrationId, prompt) {
            const req = { integrationId, prompt };
            return this.rpcManager.post("aiData/executeAiQuery", req);
          }
        }
        ;
        class LockManager {
          constructor() {
            this.locks = {};
          }
          async lock(...mutexes) {
            if (this.canGetLock(...mutexes)) {
              this.lockSync(...mutexes);
              return;
            }
            const relevantLocks = Object.entries(this.locks).filter(([mutex]) => mutexes.includes(mutex)).map(([, isLockedSubject]) => isLockedSubject);
            await (0, external_rxjs_.lastValueFrom)((0, external_rxjs_.combineLatest)(relevantLocks).pipe((0, external_rxjs_.filter)((isLockedArray) => !isLockedArray.includes(true)), (0, external_rxjs_.take)(1)));
            await this.lock(...mutexes);
          }
          release(...mutexes) {
            for (const mutex of mutexes) {
              const isLockedSubject = (0, dist.truthy)(this.locks[mutex]);
              isLockedSubject.next(false);
              isLockedSubject.complete();
              delete this.locks[mutex];
            }
          }
          canGetLock(...mutexes) {
            return !mutexes.some((mutex) => {
              var _a2;
              return (_a2 = this.locks[mutex]) === null || _a2 === void 0 ? void 0 : _a2.value;
            });
          }
          lockSync(...mutexes) {
            (0, dist.assertTruthy)(this.canGetLock(...mutexes), "Cannot acquire lock sync");
            for (const mutex of mutexes) {
              this.locks[mutex] = new external_rxjs_.BehaviorSubject(true);
            }
          }
        }
        ;
        class QueueManagerFactory {
          constructor(rpcManager, socketManager, destructManager) {
            this.rpcManager = rpcManager;
            this.socketManager = socketManager;
            this.queueManagers = /* @__PURE__ */ new Map();
            this.socketManager.observeNotifications().subscribe((message) => {
              const queueManager = this.getOrUndefined(message.integrationId, message.topicName);
              if (!queueManager) {
                return;
              }
              queueManager.onMessages(message.payload);
            });
            destructManager.onPreDestruct(() => {
              for (const queueManagersForIntegration of this.queueManagers.values()) {
                for (const queueManager of queueManagersForIntegration.values()) {
                  queueManager.destruct();
                }
              }
            });
          }
          get(integrationId, topicName) {
            let integrationQueueManagers = this.queueManagers.get(integrationId);
            if (!integrationQueueManagers) {
              integrationQueueManagers = /* @__PURE__ */ new Map();
              this.queueManagers.set(integrationId, integrationQueueManagers);
            }
            let queueManager = integrationQueueManagers.get(topicName);
            if (!queueManager) {
              queueManager = new QueueManagerImpl(integrationId, topicName, this.rpcManager);
              integrationQueueManagers.set(topicName, queueManager);
            }
            return queueManager;
          }
          getOrUndefined(integrationId, topicName) {
            var _a2;
            return (_a2 = this.queueManagers.get(integrationId)) === null || _a2 === void 0 ? void 0 : _a2.get(topicName);
          }
        }
        class QueueManagerImpl {
          constructor(integrationId, topicName, rpcManager) {
            this.integrationId = integrationId;
            this.topicName = topicName;
            this.rpcManager = rpcManager;
            this.messagesSubject = new external_rxjs_.Subject();
            this.subscriberCount = 0;
          }
          async produce(messages) {
            await this.rpcManager.post("queue/produceMessages", {
              integrationId: this.integrationId,
              topicName: this.topicName,
              messages
            });
          }
          consume() {
            return (0, external_rxjs_.defer)(() => {
              this.subscriberCount++;
              if (this.subscriberCount === 1) {
                this.rpcManager.post("queue/subscribe", {
                  integrationId: this.integrationId,
                  topicName: this.topicName
                }).catch((e) => {
                  this.messagesSubject.error(e);
                  this.messagesSubject.complete();
                  this.subscriberCount = 0;
                  this.messagesSubject = new external_rxjs_.Subject();
                });
              }
              return this.messagesSubject.asObservable().pipe((0, external_rxjs_.finalize)(() => {
                this.subscriberCount--;
                if (this.subscriberCount === 0) {
                  this.rpcManager.post("queue/unsubscribe", {
                    integrationId: this.integrationId,
                    topicName: this.topicName
                  });
                }
              }));
            });
          }
          onMessages(payload) {
            for (const message of payload) {
              this.messagesSubject.next(message);
            }
          }
          destruct() {
            this.messagesSubject.complete();
          }
        }
        ;
        class Squid {
          /**
           * Creates a new instance of Squid with the given options.
           *
           * @param options The options for initializing the Squid instance.
           */
          constructor(options) {
            this.options = options;
            this.destructManager = new DestructManager();
            (0, dist.assertTruthy)(options.appId, "APP_ID_MUST_BE_PROVIDED");
            for (const methodName of Object.getOwnPropertyNames(Object.getPrototypeOf(this))) {
              const method = this[methodName];
              if (typeof method === "function" && methodName !== "constructor" && !methodName.startsWith("_")) {
                this[methodName] = method.bind(this);
              }
            }
            const shouldAddDeveloperId = options.environmentId !== "prod" && options.squidDeveloperId;
            const appId = appIdWithEnvironmentIdAndDevId(options.appId, options.environmentId, shouldAddDeveloperId ? options.squidDeveloperId : void 0);
            const httpHeaders = getApplicationHttpHeaders(options.region, appId);
            this.clientIdService = new ClientIdService(this.destructManager);
            this.authManager = new AuthManager(options.apiKey, options.authProvider);
            this.socketManager = new SocketManager(this.clientIdService, options.region, appId, options.messageNotificationWrapper, this.destructManager, this.authManager);
            this.rpcManager = new RpcManager(options.region, appId, this.destructManager, httpHeaders, this.authManager, this.clientIdService);
            this.aiClientFactory = new AiChatbotClientFactory(this.rpcManager, this.socketManager);
            this.aiClient = new AiClient(this.aiClientFactory, this.rpcManager);
            this.documentStore = new DocumentStore();
            this.lockManager = new LockManager();
            this.distributedLockManager = new DistributedLockManager(this.socketManager, this.destructManager);
            this.documentIdentityService = new DocumentIdentityService(this.documentStore, this.destructManager);
            this.documentReferenceFactory = new DocumentReferenceFactory(this.documentIdentityService);
            this.querySender = new QuerySender(this.rpcManager, this.destructManager);
            this.querySubscriptionManager = new QuerySubscriptionManager(this.rpcManager, this.clientIdService, this.documentStore, this.destructManager, this.documentIdentityService, this.querySender);
            this.localQueryManager = new LocalQueryManager(this.documentStore, this.documentReferenceFactory, this.querySubscriptionManager);
            const mutationSender = new MutationSender(this.rpcManager, this.lockManager, this.querySender);
            this.queryBuilderFactory = new QueryBuilderFactory(this.querySubscriptionManager, this.localQueryManager, this.documentReferenceFactory, this.documentIdentityService);
            this.collectionReferenceFactory = new CollectionReferenceFactory(this.documentReferenceFactory, this.queryBuilderFactory, this.querySubscriptionManager);
            this.dataManager = new DataManager(this.documentStore, mutationSender, this.socketManager, this.querySubscriptionManager, this.queryBuilderFactory, this.lockManager, this.destructManager, this.documentIdentityService, this.querySender);
            this.documentReferenceFactory.setDataManager(this.dataManager);
            this.backendFunctionManager = new BackendFunctionManager(this.clientIdService, this.rpcManager);
            this.nativeQueryManager = new NativeQueryManager(this.rpcManager);
            this.apiManager = new ApiManager(this.clientIdService, this.rpcManager, options.apiServerUrlOverrideMapping);
            this.graphqlClientFactory = new GraphQLClientFactory(this.rpcManager, options.region, appId);
            this.secretClient = new SecretClient(this.rpcManager);
            this._connectionDetails = new ConnectionDetails(this.clientIdService, this.socketManager);
            this.queueManagerFactory = new QueueManagerFactory(this.rpcManager, this.socketManager, this.destructManager);
          }
          /**
           * Returns the global Squid instance with the given options, creating a new instance if one with the same options
           * does not exist.
           *
           * @param options The options for initializing the Squid instance.
           * @returns A global Squid instance with the given options.
           */
          static getInstance(options) {
            const optionsStr = normalizeJsonAsString(options);
            let instance = Squid.squidInstancesMap[optionsStr];
            if (instance)
              return instance;
            instance = new Squid(options);
            Squid.squidInstancesMap[optionsStr] = instance;
            return instance;
          }
          /**
           * Returns all the global Squid instances.
           *
           * @returns An array of all the global Squid instances.
           */
          static getInstances() {
            return Object.values(Squid.squidInstancesMap);
          }
          /**
           * Sets the authorization access token (OAuth2.0) provider that will be sent to the server and will be used for
           * providing the `auth` object to the security rules.
           *
           * @param authProvider The OAuth2.0 access token provider invoked for every backend request by Squid.
           *    When the provider returns undefined, no authorization information is sent.
           *    When a new provider is set, all future Squid backend requests will use the new token provider, and exising
           *    in-flight requests won't be affected.
           * @returns void.
           */
          setAuthProvider(authProvider) {
            this.authManager.setAuthProvider(authProvider);
          }
          /**
           * Returns a reference to the collection in the provided integration.
           *
           * If the integrationId is not provided, the `built_in_db` integration id will be used.
           *
           * For more information on the CollectionReference object, please refer to the
           * {@link https://docs.squid.cloud/docs/development-tools/client-sdk/collection-reference documentation}.
           *
           * @param collectionName The name of the collection.
           * @param integrationId The id of the integration, default to `built_in_db`.
           * @returns A reference to the collection in the provided integration.
           * @typeParam T The type of the documents in the collection.
           */
          collection(collectionName, integrationId = IntegrationType.built_in_db) {
            this._validateNotDestructed();
            return this.collectionReferenceFactory.get(collectionName, integrationId);
          }
          /**
           * Runs the given callback as an atomic change. All the mutations that are executed using the provided transactionId
           * will be atomic. Note that mutations for different integrations will not be atomic.
           *
           * For more information about transactions in Squid, please refer to the
           * {@link https://docs.squid.cloud/docs/development-tools/client-sdk/transactions documentation}.
           *
           * @param fn The callback to run as an atomic change. The function receives a transactionId that should be used for
           * all the mutations that should be atomic. The function should return a promise.
           *
           * @returns A promise that resolves when the transactions are committed on the server.
           */
          runInTransaction(fn) {
            this._validateNotDestructed();
            return this.dataManager.runInTransaction(fn);
          }
          /**
           * Executes the given backend function with the given parameters and returns a promise with the result.
           *
           * For more information about backend functions in Squid, please refer to the
           * {@link https://docs.squid.cloud/docs/development-tools/backend/executables documentation}.
           *
           * @param functionName The name of the function to execute on the server.
           * @param params The parameters to pass to the function.
           * @returns A promise that resolves with the result of the function.
           * @typeParam T The type of the result of the function.
           */
          executeFunction(functionName, ...params) {
            this._validateNotDestructed();
            return (0, external_rxjs_.firstValueFrom)(this.backendFunctionManager.executeFunctionAndSubscribe(functionName, ...params));
          }
          /**
           * Executes a native relational query with the given parameters and returns a promise with the result.
           *
           * Native queries allow you to execute raw SQL or other database-specific queries directly against the database.
           * This can be useful when you need to perform operations that are not easily accomplished with other high-level
           * abstractions.
           *
           * @param integrationId The id of the integration that the query is associated with.
           * @param query The raw SQL or other database-specific query to execute.
           * @param params (Optional) The parameters to pass to the query. Defaults to an empty object.
           * @returns A promise that resolves with the result of the query.
           * @type {Promise<Array<SquidDocument>>}
           */
          executeNativeRelationalQuery(integrationId, query, params = {}) {
            return this.nativeQueryManager.executeNativeQuery(integrationId, { type: "relational", query, params });
          }
          /**
           * Invokes the given HTTP API (defined by the integration ID and the endpoint ID) with the given request parameters
           * and returns a promise with the response. The structure of the request and the response is defined in the
           * integration's schema page.
           *
           * For more information about API integrations in Squid, please refer to the
           * {@link https://docs.squid.cloud/docs/integrations/api/httpapi documentation}.
           *
           * @param integrationId The id of the integration that the API is defined with.
           * @param endpointId The id of the endpoint in the API integration.
           * @param request The request parameters to pass to the API.
           * @returns A promise that resolves with the response of the API.
           * @typeParam T The type of the response of the API.
           */
          callApi(integrationId, endpointId, request = {}) {
            this._validateNotDestructed();
            return (0, external_rxjs_.firstValueFrom)(this.apiManager.callApiAndSubscribe(integrationId, endpointId, request));
          }
          /**
           * Returns a GraphQL client for the given integration. The GraphQL client can be used to execute GraphQL queries and
           * mutations. For more information about GraphQL in Squid, please refer to the
           * {@link https://docs.squid.cloud/docs/integrations/api/graphql documentation}.
           *
           * @param integrationId The id of the integration that the GraphQL API is defined with.
           * @returns A GraphQL client for the given integration.
           */
          graphql(integrationId) {
            this._validateNotDestructed();
            return this.graphqlClientFactory.get(integrationId);
          }
          /**
           * Returns a set of AI specific clients.
           *
           * @returns A set of AI specific clients.
           */
          ai() {
            this._validateNotDestructed();
            return this.aiClient;
          }
          get secrets() {
            return this.secretClient;
          }
          /**
           * Returns a distributed lock for the given mutex. The lock can be used to synchronize access to a shared resource.
           * The lock will be released when the release method on the returned object is invoked or whenever the connection
           * with the server is lost.
           * @param mutex A string that uniquely identifies the lock.
           * @returns A promise that resolves with the lock object. The promise will reject if failed to acquire the lock.
           */
          acquireLock(mutex) {
            this._validateNotDestructed();
            return this.distributedLockManager.lock(mutex);
          }
          /**
           * Returns a queue manager for the given topic name and integration id. Using the queue manager you can consume and
           * produce messages
           */
          queue(topicName, integrationId = IntegrationType.built_in_queue) {
            this._validateNotDestructed();
            return this.queueManagerFactory.get(integrationId, topicName);
          }
          /**
           * Destructs the Squid Client. Unsubscribes from all ongoing queries or requests, and clears the local data.
           * After invoking this method, the Squid client will not be usable.
           *
           * @returns A promise that resolves when the destruct process is complete.
           */
          async destruct() {
            return this.destructManager.destruct().finally(() => {
              const entry = Object.entries(Squid.squidInstancesMap).find(([, value]) => value === this);
              if (entry)
                delete Squid.squidInstancesMap[entry[0]];
            });
          }
          /** Provides information about the connection to the Squid Server. */
          connectionDetails() {
            this._validateNotDestructed();
            return this._connectionDetails;
          }
          /**
           * @internal
           */
          async _unsubscribe() {
            this.querySubscriptionManager.unsubscribe();
            await this.rpcManager.awaitAllSettled();
          }
          _validateNotDestructed() {
            (0, dist.assertTruthy)(!this.destructManager.isDestructing, "The client was already destructed.");
          }
        }
        Squid.squidInstancesMap = {};
        ;
        function deserializeQuery(squid, serializedQuery) {
          switch (serializedQuery.type) {
            case "simple":
              return deserializeSimpleQuery(squid, serializedQuery);
            case "join":
              return deserializeJoinQuery(squid, serializedQuery);
            case "merged":
              return deserializeMergedQuery(squid, serializedQuery);
          }
        }
        function deserializeSimpleQuery(squid, serializedQuery) {
          const { query, dereference } = serializedQuery;
          const { collectionName, integrationId } = query;
          let builder = squid.collection(collectionName, integrationId).query();
          builder = appendFromQuery(builder, query);
          if (dereference)
            return builder.dereference();
          return builder;
        }
        function deserializeMergedQuery(squid, serializedQuery) {
          const { queries } = serializedQuery;
          const { collectionName, integrationId } = getCollection(queries[0]);
          const builders = queries.map((q) => deserializeQuery(squid, q));
          return squid.collection(collectionName, integrationId).or(...builders);
        }
        function deserializeJoinQuery(squid, serializedQuery) {
          const { root, joins, joinConditions, dereference, grouped } = serializedQuery;
          const { collectionName, integrationId } = root.query;
          let builder = squid.collection(collectionName, integrationId).joinQuery(root.alias);
          builder = appendFromQuery(builder, root.query);
          Object.entries(joins).map(([alias, query]) => {
            const { collectionName: collectionName2, integrationId: integrationId2 } = query;
            const { left, right, leftAlias } = joinConditions[alias];
            let queryBuilder = squid.collection(collectionName2, integrationId2).query();
            queryBuilder = appendFromQuery(queryBuilder, query);
            builder = builder.join(queryBuilder, alias, { left, right }, { leftAlias });
          });
          if (dereference && grouped)
            return builder.grouped().dereference();
          if (dereference)
            return builder.dereference();
          if (grouped)
            return builder.grouped();
          return builder;
        }
        function appendFromQuery(builder, query) {
          const { conditions, limit, sortOrder } = query;
          for (const condition of conditions) {
            if (!("operator" in condition))
              throw new Error("Composite conditions are not support in query serialization.");
            const { fieldName, operator, value } = condition;
            builder.where(fieldName, operator, value);
          }
          builder.limit(limit);
          for (const { fieldName, asc } of sortOrder) {
            builder.sortBy(fieldName, asc);
          }
          return builder;
        }
        function getCollection(serialized) {
          switch (serialized.type) {
            case "simple": {
              const { collectionName, integrationId } = serialized.query;
              return { collectionName, integrationId };
            }
            case "join": {
              const { collectionName, integrationId } = serialized.root.query;
              return { collectionName, integrationId };
            }
            case "merged": {
              return getCollection(serialized.queries[0]);
            }
          }
        }
        ;
      })();
      var __webpack_export_target__ = exports;
      for (var i in __webpack_exports__)
        __webpack_export_target__[i] = __webpack_exports__[i];
      if (__webpack_exports__.__esModule)
        Object.defineProperty(__webpack_export_target__, "__esModule", { value: true });
    })();
  }
});

// node_modules/@squidcloud/react/dist/cjs/context/SquidContext.js
var require_SquidContext = __commonJS({
  "node_modules/@squidcloud/react/dist/cjs/context/SquidContext.js"(exports) {
    "use client";
    "use strict";
    var e = require_jsx_runtime();
    var r = require_cjs2();
    var t = require_react();
    var i = t.createContext({ squid: null });
    exports.SquidContext = i, exports.SquidContextProvider = ({ children: u, options: n }) => {
      const s = t.useRef(r.Squid.getInstance(n));
      return e.jsx(i.Provider, { value: { squid: s.current }, children: u });
    };
  }
});

// node_modules/@squidcloud/react/dist/cjs/index-82c10f9e.js
var require_index_82c10f9e = __commonJS({
  "node_modules/@squidcloud/react/dist/cjs/index-82c10f9e.js"(exports) {
    "use strict";
    var u = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {};
    var e = {};
    var t = {};
    var F = {};
    var r = {};
    function n(u2) {
      return "string" == typeof u2;
    }
    Object.defineProperty(r, "__esModule", { value: true }), r.isNonNullable = r.isHexString = r.isUuid = r.isEmail = r.checkArrayHasUniqueElements = r.isNumber = r.isString = r.isBoolean = void 0, r.isBoolean = function(u2) {
      return "boolean" == typeof u2;
    }, r.isString = n, r.isNumber = function(u2) {
      return "number" == typeof u2;
    }, r.checkArrayHasUniqueElements = function(u2, e2) {
      if (u2.length <= 1)
        return true;
      const t2 = /* @__PURE__ */ new Set();
      for (const F2 of u2) {
        const u3 = e2(F2);
        if (t2.has(u3))
          return false;
        t2.add(u3);
      }
      return true;
    };
    var o = /^[-!#$%&'*+/\d=?A-Z^_a-z{|}~](\.?[-!#$%&'*+/\d=?A-Z^_a-z`{|}~])*@[a-zA-Z0-9](-*\.?[a-zA-Z\d])*\.[a-zA-Z](-?[a-zA-Z\d])+$/;
    var s = /^(?!\.)((?!.*\.{2})[a-zA-Z0-9\u0080-\u00FF\u0100-\u017F\u0180-\u024F\u0250-\u02AF\u0300-\u036F\u0370-\u03FF\u0400-\u04FF\u0500-\u052F\u0530-\u058F\u0590-\u05FF\u0600-\u06FF\u0700-\u074F\u0750-\u077F\u0780-\u07BF\u07C0-\u07FF\u0900-\u097F\u0980-\u09FF\u0A00-\u0A7F\u0A80-\u0AFF\u0B00-\u0B7F\u0B80-\u0BFF\u0C00-\u0C7F\u0C80-\u0CFF\u0D00-\u0D7F\u0D80-\u0DFF\u0E00-\u0E7F\u0E80-\u0EFF\u0F00-\u0FFF\u1000-\u109F\u10A0-\u10FF\u1100-\u11FF\u1200-\u137F\u1380-\u139F\u13A0-\u13FF\u1400-\u167F\u1680-\u169F\u16A0-\u16FF\u1700-\u171F\u1720-\u173F\u1740-\u175F\u1760-\u177F\u1780-\u17FF\u1800-\u18AF\u1900-\u194F\u1950-\u197F\u1980-\u19DF\u19E0-\u19FF\u1A00-\u1A1F\u1B00-\u1B7F\u1D00-\u1D7F\u1D80-\u1DBF\u1DC0-\u1DFF\u1E00-\u1EFF\u1F00-\u1FFF\u20D0-\u20FF\u2100-\u214F\u2C00-\u2C5F\u2C60-\u2C7F\u2C80-\u2CFF\u2D00-\u2D2F\u2D30-\u2D7F\u2D80-\u2DDF\u2F00-\u2FDF\u2FF0-\u2FFF\u3040-\u309F\u30A0-\u30FF\u3100-\u312F\u3130-\u318F\u3190-\u319F\u31C0-\u31EF\u31F0-\u31FF\u3200-\u32FF\u3300-\u33FF\u3400-\u4DBF\u4DC0-\u4DFF\u4E00-\u9FFF\uA000-\uA48F\uA490-\uA4CF\uA700-\uA71F\uA800-\uA82F\uA840-\uA87F\uAC00-\uD7AF\uF900-\uFAFF.!#$%&'*+-/=?^_`{|}~\-\d]+)@(?!\.)([a-zA-Z0-9\u0080-\u00FF\u0100-\u017F\u0180-\u024F\u0250-\u02AF\u0300-\u036F\u0370-\u03FF\u0400-\u04FF\u0500-\u052F\u0530-\u058F\u0590-\u05FF\u0600-\u06FF\u0700-\u074F\u0750-\u077F\u0780-\u07BF\u07C0-\u07FF\u0900-\u097F\u0980-\u09FF\u0A00-\u0A7F\u0A80-\u0AFF\u0B00-\u0B7F\u0B80-\u0BFF\u0C00-\u0C7F\u0C80-\u0CFF\u0D00-\u0D7F\u0D80-\u0DFF\u0E00-\u0E7F\u0E80-\u0EFF\u0F00-\u0FFF\u1000-\u109F\u10A0-\u10FF\u1100-\u11FF\u1200-\u137F\u1380-\u139F\u13A0-\u13FF\u1400-\u167F\u1680-\u169F\u16A0-\u16FF\u1700-\u171F\u1720-\u173F\u1740-\u175F\u1760-\u177F\u1780-\u17FF\u1800-\u18AF\u1900-\u194F\u1950-\u197F\u1980-\u19DF\u19E0-\u19FF\u1A00-\u1A1F\u1B00-\u1B7F\u1D00-\u1D7F\u1D80-\u1DBF\u1DC0-\u1DFF\u1E00-\u1EFF\u1F00-\u1FFF\u20D0-\u20FF\u2100-\u214F\u2C00-\u2C5F\u2C60-\u2C7F\u2C80-\u2CFF\u2D00-\u2D2F\u2D30-\u2D7F\u2D80-\u2DDF\u2F00-\u2FDF\u2FF0-\u2FFF\u3040-\u309F\u30A0-\u30FF\u3100-\u312F\u3130-\u318F\u3190-\u319F\u31C0-\u31EF\u31F0-\u31FF\u3200-\u32FF\u3300-\u33FF\u3400-\u4DBF\u4DC0-\u4DFF\u4E00-\u9FFF\uA000-\uA48F\uA490-\uA4CF\uA700-\uA71F\uA800-\uA82F\uA840-\uA87F\uAC00-\uD7AF\uF900-\uFAFF\-.\d]+)((\.([a-zA-Z\u0080-\u00FF\u0100-\u017F\u0180-\u024F\u0250-\u02AF\u0300-\u036F\u0370-\u03FF\u0400-\u04FF\u0500-\u052F\u0530-\u058F\u0590-\u05FF\u0600-\u06FF\u0700-\u074F\u0750-\u077F\u0780-\u07BF\u07C0-\u07FF\u0900-\u097F\u0980-\u09FF\u0A00-\u0A7F\u0A80-\u0AFF\u0B00-\u0B7F\u0B80-\u0BFF\u0C00-\u0C7F\u0C80-\u0CFF\u0D00-\u0D7F\u0D80-\u0DFF\u0E00-\u0E7F\u0E80-\u0EFF\u0F00-\u0FFF\u1000-\u109F\u10A0-\u10FF\u1100-\u11FF\u1200-\u137F\u1380-\u139F\u13A0-\u13FF\u1400-\u167F\u1680-\u169F\u16A0-\u16FF\u1700-\u171F\u1720-\u173F\u1740-\u175F\u1760-\u177F\u1780-\u17FF\u1800-\u18AF\u1900-\u194F\u1950-\u197F\u1980-\u19DF\u19E0-\u19FF\u1A00-\u1A1F\u1B00-\u1B7F\u1D00-\u1D7F\u1D80-\u1DBF\u1DC0-\u1DFF\u1E00-\u1EFF\u1F00-\u1FFF\u20D0-\u20FF\u2100-\u214F\u2C00-\u2C5F\u2C60-\u2C7F\u2C80-\u2CFF\u2D00-\u2D2F\u2D30-\u2D7F\u2D80-\u2DDF\u2F00-\u2FDF\u2FF0-\u2FFF\u3040-\u309F\u30A0-\u30FF\u3100-\u312F\u3130-\u318F\u3190-\u319F\u31C0-\u31EF\u31F0-\u31FF\u3200-\u32FF\u3300-\u33FF\u3400-\u4DBF\u4DC0-\u4DFF\u4E00-\u9FFF\uA000-\uA48F\uA490-\uA4CF\uA700-\uA71F\uA800-\uA82F\uA840-\uA87F\uAC00-\uD7AF\uF900-\uFAFF]){2,63})+)$/i;
    r.isEmail = function(u2, e2 = { allowInternationalDomains: false }) {
      if (!n(u2) || 0 === u2.length || u2.length > 254)
        return false;
      if (!(e2.allowInternationalDomains ? s : o).test(u2))
        return false;
      const t2 = u2.split("@");
      return !(t2[0].length > 64) && !t2[1].split(".").some((u3) => u3.length > 63);
    };
    var i = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
    r.isUuid = function(u2) {
      return n(u2) && i.test(u2);
    };
    var a = /^[0-9a-fA-F]*$/;
    r.isHexString = function(u2) {
      return n(u2) && a.test(u2);
    }, r.isNonNullable = function(u2) {
      return null != u2;
    }, Object.defineProperty(F, "__esModule", { value: true }), F.callValueAssertion = F.assertArray = F.assertObject = F.getErrorMessage = F.getAssertionErrorFromProvider = F.fail = F.truthy = F.assertTruthy = void 0;
    var l = r;
    function c(u2, e2) {
      u2 || A(e2);
    }
    function A(u2) {
      const e2 = f(u2);
      if ("object" == typeof e2)
        throw e2;
      throw new Error(e2 || "Assertion error");
    }
    function f(u2) {
      return void 0 === u2 ? "" : "string" == typeof u2 ? u2 : u2();
    }
    function d(u2) {
      const e2 = f(u2);
      return "string" == typeof e2 ? e2 : e2.message || "<no error message>";
    }
    function g(u2, e2, t2 = void 0, F2 = {}) {
      const r2 = () => d(t2), n2 = (u3) => {
        const e3 = r2();
        return 0 === e3.length ? u3 : `${e3} ${u3}`;
      };
      c("object" == typeof u2, () => n2("is not an object: " + typeof u2)), c(void 0 !== u2, () => n2("is not defined")), c(null !== u2, () => n2("is null")), c(!Array.isArray(u2), () => n2("is an array."));
      const o2 = Object.entries(e2);
      if (F2.failOnUnknownFields)
        for (const e3 in u2)
          c(o2.some(([u3]) => e3 === u3), n2(`property can't be checked: ${e3}`));
      let s2;
      for (const [e3, t3] of o2) {
        c("function" == typeof t3 || "object" == typeof t3 && null !== t3, () => `${r2()}.${e3} assertion is not an object or a function: ${typeof t3}`);
        const F3 = u2[e3], n3 = () => `${r2()}.${e3}`;
        if ("object" == typeof t3)
          c(!Array.isArray(F3), () => `${r2()}.${n3()} use arrayAssertion() to create a ValueAssertion for an array`), g(F3, t3, n3);
        else if (c("function" == typeof t3, () => `${r2()}.${n3()} assertion is not a function`), "$o" === e3)
          s2 = t3;
        else {
          const u3 = t3(F3, n3);
          c(void 0 === u3, `Assertion function must assert (void) but it returns a value: ${u3}. Wrap with $v()?`);
        }
      }
      s2 && s2(u2, t2);
    }
    function y(u2, e2, t2) {
      e2(u2, t2);
    }
    F.assertTruthy = c, F.truthy = function(u2, e2) {
      return c(u2, e2), u2;
    }, F.fail = A, F.getAssertionErrorFromProvider = f, F.getErrorMessage = d, F.assertObject = g, F.assertArray = function(u2, e2, t2 = {}, F2 = void 0) {
      var r2, n2;
      const o2 = (u3 = "with-space-separator") => {
        const e3 = d(F2);
        return e3 ? `${e3}${"with-space-separator" === u3 ? " " : ""}` : "";
      };
      c(Array.isArray(u2), () => `${o2()}value is not an array: ${u2}`);
      const s2 = null !== (r2 = t2.minLength) && void 0 !== r2 ? r2 : 0, i2 = null !== (n2 = t2.maxLength) && void 0 !== n2 ? n2 : 1 / 0;
      c(u2.length >= s2, () => `${o2()}array length < minLength. Array length: ${u2.length}, minLength: ${s2}`), c(u2.length <= i2, () => `${o2()}array length > maxLength. Array length: ${u2.length}, maxLength: ${i2}`), t2.uniqueByIdentity && c((0, l.checkArrayHasUniqueElements)(u2, t2.uniqueByIdentity), () => `${o2()}array contains non-unique elements`);
      let a2 = 0;
      const A2 = () => `${o2("no-space-separator")}[${a2}]`;
      for (; a2 < u2.length; a2++) {
        const t3 = u2[a2];
        "object" == typeof e2 ? (c(!Array.isArray(t3), () => `${A2}: use arrayAssertion() to create a ValueAssertion for an array`), g(t3, e2, A2)) : y(t3, e2, A2);
      }
    }, F.callValueAssertion = y;
    var h = {};
    var D = {};
    Object.defineProperty(D, "__esModule", { value: true }), D.assertNonNullable = D.assertEmail = D.assertHexString = D.assertUuid = D.assertBoolean = D.assertNumber = D.assertString = D.formatError = void 0;
    var b = F;
    var v = r;
    function $(u2, e2, t2) {
      const F2 = (0, b.getAssertionErrorFromProvider)(u2);
      if ("object" == typeof F2)
        throw F2;
      return `${F2 ? `${F2}: ` : ""}${e2} ${void 0 === t2 ? "<undefined>" : null === t2 ? "<null>" : `<${typeof t2}:${t2}>`}`;
    }
    D.formatError = $;
    D.assertString = (u2, e2 = void 0) => {
      (0, b.assertTruthy)((0, v.isString)(u2), () => $(e2, "Not a string", u2));
    };
    D.assertNumber = (u2, e2 = void 0) => {
      (0, b.assertTruthy)((0, v.isNumber)(u2), () => $(e2, "Not a number", u2));
    };
    D.assertBoolean = (u2, e2 = void 0) => {
      (0, b.assertTruthy)((0, v.isBoolean)(u2), () => $(e2, "Not a boolean", u2));
    };
    D.assertUuid = (u2, e2 = void 0) => {
      (0, b.assertTruthy)((0, v.isUuid)(u2), () => $(e2, "Invalid uuid", u2));
    };
    D.assertHexString = (u2, e2 = void 0) => {
      (0, b.assertTruthy)((0, v.isHexString)(u2), () => $(e2, "Invalid hex string", u2));
    };
    D.assertEmail = (u2, e2 = void 0) => {
      (0, b.assertTruthy)((0, v.isEmail)(u2), () => $(e2, "Invalid email", u2));
    }, D.assertNonNullable = function(u2, e2) {
      (0, b.assertTruthy)((0, v.isNonNullable)(u2), () => $(e2, "Value is " + (void 0 === u2 ? "undefined" : "null"), u2));
    }, Object.defineProperty(h, "__esModule", { value: true }), h.stringAssertion = h.nullOr = h.undefinedOr = h.valueOr = h.$a = h.arrayAssertion = h.objectAssertion = void 0;
    var p = F;
    var m = D;
    function C(u2, e2) {
      return (t2, F2 = void 0) => {
        t2 !== u2 && ("object" == typeof e2 ? (0, p.assertObject)(t2, e2, F2) : (0, p.callValueAssertion)(t2, e2, F2));
      };
    }
    h.objectAssertion = function(u2, e2 = void 0) {
      return (t2) => (0, p.assertObject)(t2, u2, e2);
    }, h.arrayAssertion = function(u2, e2 = {}) {
      const { minLength: t2, maxLength: F2 } = e2;
      return (0, p.assertTruthy)((null != t2 ? t2 : 0) <= (null != F2 ? F2 : 1 / 0), `minLength must be < maxLength! minLength ${t2}, maxLength: ${F2}`), (0, p.assertTruthy)((null != t2 ? t2 : 0) >= 0, `minLength must be a positive number: ${t2}`), (0, p.assertTruthy)((null != F2 ? F2 : 0) >= 0, `maxLength must be a positive number: ${F2}`), (t3, F3 = void 0) => {
        (0, p.assertArray)(t3, u2, e2, F3);
      };
    }, h.$a = function(u2, e2) {
      return (0, p.assertTruthy)("function" == typeof u2, `"check" is not a function: ${u2}`), (t2, F2 = void 0) => (0, p.assertTruthy)(u2(t2), () => {
        let u3 = (0, p.getErrorMessage)(F2) || "Check is failed";
        u3.endsWith(":") || (u3 += ":");
        return `${u3} ${(0, p.getErrorMessage)(e2) || ("object" == typeof t2 ? "[object]" : `'${t2}'`)}`;
      });
    }, h.valueOr = C, h.undefinedOr = function(u2) {
      return C(void 0, u2);
    }, h.nullOr = function(u2) {
      return C(null, u2);
    };
    h.stringAssertion = (u2) => (e2, t2 = void 0) => {
      var F2, r2;
      (0, m.assertString)(e2, t2), (0, p.assertTruthy)(e2.length >= (null !== (F2 = u2.minLength) && void 0 !== F2 ? F2 : 0), `${(0, p.getErrorMessage)(t2)} length is too small: ${e2.length} < ${u2.minLength}`), (0, p.assertTruthy)(e2.length <= (null !== (r2 = u2.maxLength) && void 0 !== r2 ? r2 : 1 / 0), `${(0, p.getErrorMessage)(t2)} length is too large ${e2.length} > ${u2.maxLength}`);
    }, function(e2) {
      var t2 = u && u.__createBinding || (Object.create ? function(u2, e3, t3, F2) {
        void 0 === F2 && (F2 = t3);
        var r2 = Object.getOwnPropertyDescriptor(e3, t3);
        r2 && !("get" in r2 ? !e3.__esModule : r2.writable || r2.configurable) || (r2 = { enumerable: true, get: function() {
          return e3[t3];
        } }), Object.defineProperty(u2, F2, r2);
      } : function(u2, e3, t3, F2) {
        void 0 === F2 && (F2 = t3), u2[F2] = e3[t3];
      }), n2 = u && u.__exportStar || function(u2, e3) {
        for (var F2 in u2)
          "default" === F2 || Object.prototype.hasOwnProperty.call(e3, F2) || t2(e3, u2, F2);
      };
      Object.defineProperty(e2, "__esModule", { value: true }), n2(F, e2), n2(h, e2), n2(D, e2), n2(r, e2);
    }(t), function(e2) {
      var F2 = u && u.__createBinding || (Object.create ? function(u2, e3, t2, F3) {
        void 0 === F3 && (F3 = t2);
        var r3 = Object.getOwnPropertyDescriptor(e3, t2);
        r3 && !("get" in r3 ? !e3.__esModule : r3.writable || r3.configurable) || (r3 = { enumerable: true, get: function() {
          return e3[t2];
        } }), Object.defineProperty(u2, F3, r3);
      } : function(u2, e3, t2, F3) {
        void 0 === F3 && (F3 = t2), u2[F3] = e3[t2];
      }), r2 = u && u.__exportStar || function(u2, e3) {
        for (var t2 in u2)
          "default" === t2 || Object.prototype.hasOwnProperty.call(e3, t2) || F2(e3, u2, t2);
      };
      Object.defineProperty(e2, "__esModule", { value: true }), r2(t, e2);
    }(e), exports.dist = e;
  }
});

// node_modules/@squidcloud/react/dist/cjs/hooks/useSquid.js
var require_useSquid = __commonJS({
  "node_modules/@squidcloud/react/dist/cjs/hooks/useSquid.js"(exports) {
    "use client";
    "use strict";
    var e = require_react();
    var t = require_SquidContext();
    require_jsx_runtime(), require_cjs2(), exports.useSquid = function() {
      const r = e.useContext(t.SquidContext);
      if (void 0 === r)
        throw new Error("useSquid must be used within a SquidContext.Provider");
      return r.squid;
    };
  }
});

// node_modules/@squidcloud/react/dist/cjs/hooks/useObservable.js
var require_useObservable = __commonJS({
  "node_modules/@squidcloud/react/dist/cjs/hooks/useObservable.js"(exports) {
    "use client";
    "use strict";
    var e = require_react();
    var t = { enabled: true, initialData: null };
    exports.useObservable = function(n, s = {}, a = []) {
      const i = Object.assign(Object.assign({}, t), s), [r, c] = e.useState({ loading: true, data: i.initialData, error: null, complete: false }), l = e.useMemo(n, [JSON.stringify(a), i.enabled]);
      return e.useEffect(() => {
        r.loading || c((e3) => Object.assign(Object.assign({}, e3), { loading: true, complete: false }));
        const { enabled: e2 } = i;
        if (!e2)
          return;
        const t2 = l.subscribe({ next: (e3) => c({ loading: false, data: e3, error: null, complete: false }), error: (e3) => c((t3) => Object.assign(Object.assign({}, t3), { loading: false, error: e3, complete: false })), complete: () => c((e3) => Object.assign(Object.assign({}, e3), { loading: false, complete: true })) });
        return () => {
          setTimeout(() => t2.unsubscribe(), 0);
        };
      }, [l]), r;
    };
  }
});

// node_modules/@squidcloud/react/dist/cjs/hooks/useQuery.js
var require_useQuery = __commonJS({
  "node_modules/@squidcloud/react/dist/cjs/hooks/useQuery.js"(exports) {
    "use client";
    "use strict";
    var e = require_cjs();
    var r = require_useObservable();
    require_react();
    var a = { enabled: true, subscribe: true, initialData: [] };
    exports.useQuery = function(s, i = {}, t = []) {
      const n = Object.assign(Object.assign({}, a), i), { enabled: u, subscribe: b, initialData: c } = n, { loading: l, error: o, data: d } = r.useObservable(() => b ? s.snapshots() : e.from(s.snapshot()), { enabled: u, initialData: c || (() => {
        try {
          return s.peek();
        } catch (e2) {
          return [];
        }
      })() }, [JSON.stringify(s.serialize()), b, JSON.stringify(t)]);
      return { loading: l, error: o, data: d };
    };
  }
});

// node_modules/@squidcloud/react/dist/cjs/hoc/withServerQuery/WithQueryClient.js
var require_WithQueryClient = __commonJS({
  "node_modules/@squidcloud/react/dist/cjs/hoc/withServerQuery/WithQueryClient.js"(exports, module) {
    "use client";
    "use strict";
    var e = require_jsx_runtime();
    var r = require_cjs2();
    require_index_82c10f9e(), require_react(), require_cjs();
    var s = require_useSquid();
    require_SquidContext();
    var i = require_useQuery();
    require_useObservable();
    module.exports = ({ Component: u, props: t, serializedQuery: a, data: o }) => {
      const n = s.useSquid(), { data: q } = i.useQuery(r.deserializeQuery(n, a), { subscribe: true, initialData: o }), d = Object.assign(Object.assign({}, t), { data: q });
      return e.jsx(u, Object.assign({}, d));
    };
  }
});

// node_modules/@squidcloud/react/dist/cjs/index-2b00d0d6.js
var require_index_2b00d0d6 = __commonJS({
  "node_modules/@squidcloud/react/dist/cjs/index-2b00d0d6.js"(exports) {
    "use strict";
    var e = require_jsx_runtime();
    var s = require_WithQueryClient();
    var r = async ({ Component: r2, props: i, query: n, options: o }) => {
      const a = await n.snapshot(), p = Object.assign(Object.assign({}, t), o), u = Object.assign(Object.assign({}, i), { data: a });
      return p.subscribe ? e.jsx(s, { serializedQuery: n.serialize(), props: i, data: a, Component: r2 }) : e.jsx(r2, Object.assign({}, u));
    };
    var t = { subscribe: true };
    exports.DEFAULT_WITH_QUERY_OPTIONS = t, exports.WithQueryServer = r, exports.withServerQuery = (s2, t2, i) => (n) => e.jsx(r, { props: n, Component: s2, query: t2, options: i });
  }
});

// node_modules/@squidcloud/react/dist/cjs/hooks/useAiChatbot.js
var require_useAiChatbot = __commonJS({
  "node_modules/@squidcloud/react/dist/cjs/hooks/useAiChatbot.js"(exports) {
    "use client";
    "use strict";
    var e = require_cjs2();
    var t = require_index_82c10f9e();
    var r = require_react();
    var u = require_cjs();
    var n = require_useObservable();
    var s = require_useSquid();
    function i(i2, a, o) {
      const c = s.useSquid();
      t.dist.assertTruthy(!a || c.options.apiKey, "apiKey must be defined for AI queries");
      const [d, l] = r.useState(""), [p, q] = r.useState(void 0), [y, x] = r.useState([]), { data: f, error: h, loading: g, complete: m } = n.useObservable(() => d ? a ? u.from(c.ai().executeAiQuery(i2, d)).pipe(u.map((e2) => {
        let t2 = `### Result

${e2.answer}`;
        return e2.executedQuery && (t2 += `

### Executed Query

\`\`\`${e2.queryMarkdownType || "sql"}
${e2.executedQuery}
\`\`\``), e2.explanation && (t2 += `

### Walkthrough

${e2.explanation}`), t2;
      })) : (t.dist.assertTruthy(o, "profileId must be defined"), c.ai().chatbot(i2).profile(o).chat(d, p)) : u.of(""), { initialData: "" }, [d]);
      r.useEffect(() => {
        const t2 = y[y.length - 1];
        t2 && f && !g && (m && l(""), "user" === t2.type ? x((t3) => t3.concat({ id: e.generateId(), type: "ai", message: f })) : x((e2) => {
          const t3 = [...e2];
          return t3[t3.length - 1].message = f, t3;
        }));
      }, [f, m, g]);
      return { chat: (t2, r2) => {
        x((r3) => r3.concat({ id: e.generateId(), type: "user", message: t2 })), q(r2), l(t2);
      }, history: y, data: f, loading: g, error: h, complete: m };
    }
    require_SquidContext(), require_jsx_runtime(), exports.useAiChatbot = function(e2, t2) {
      return i(e2, false, t2);
    }, exports.useAiQuery = function(e2) {
      return i(e2, true);
    };
  }
});

// node_modules/@squidcloud/react/dist/cjs/hooks/useCollection.js
var require_useCollection = __commonJS({
  "node_modules/@squidcloud/react/dist/cjs/hooks/useCollection.js"(exports) {
    "use client";
    "use strict";
    var e = require_react();
    var r = require_SquidContext();
    var t = require_useSquid();
    require_jsx_runtime(), require_cjs2(), exports.useCollection = function(u, i) {
      if (void 0 === e.useContext(r.SquidContext))
        throw new Error("useSquid must be used within a SquidContext.Provider");
      return t.useSquid().collection(u, i);
    };
  }
});

// node_modules/@squidcloud/react/dist/cjs/hooks/useDoc.js
var require_useDoc = __commonJS({
  "node_modules/@squidcloud/react/dist/cjs/hooks/useDoc.js"(exports) {
    "use client";
    "use strict";
    var e = require_cjs();
    var r = require_useObservable();
    require_react();
    var s = { enabled: true, subscribe: true };
    exports.DEFAULT_DOC_OPTIONS = s, exports.useDoc = function(a, t = {}) {
      const n = Object.assign(Object.assign({}, s), t), { enabled: i, subscribe: b } = n, { loading: o, error: u, data: c } = r.useObservable(() => b ? a.snapshots() : e.from(a.snapshot()), { enabled: i, initialData: a.peek() }, [a.refId, b]);
      return { loading: o, error: u, data: c };
    };
  }
});

// node_modules/@squidcloud/react/dist/cjs/hooks/useDocs.js
var require_useDocs = __commonJS({
  "node_modules/@squidcloud/react/dist/cjs/hooks/useDocs.js"(exports) {
    "use client";
    "use strict";
    var e = require_react();
    var s = require_cjs();
    var r = require_useDoc();
    require_useObservable(), exports.useDocs = function(t, n) {
      const [u, i] = e.useState(!!t.length), [a, c] = e.useState(t.map((e2) => e2.peek())), [o, b] = e.useState(null), O = Object.assign(Object.assign({}, r.DEFAULT_DOC_OPTIONS), n);
      return e.useEffect(() => {
        i(!!t.length);
        const { enabled: e2, subscribe: r2 } = O;
        if (!e2)
          return;
        const n2 = t.map((e3) => r2 ? e3.snapshots() : e3.snapshot()), u2 = s.combineLatest(n2).subscribe({ next: (e3) => {
          c(e3), i(false);
        }, error: (e3) => {
          b(e3), i(false);
        } });
        return () => {
          setTimeout(() => u2.unsubscribe(), 0);
        };
      }, [JSON.stringify(t.map((e2) => e2.refId)), JSON.stringify(O)]), { loading: u, error: o, data: a };
    };
  }
});

// node_modules/@squidcloud/react/dist/cjs/hooks/usePagination.js
var require_usePagination = __commonJS({
  "node_modules/@squidcloud/react/dist/cjs/hooks/usePagination.js"(exports) {
    "use client";
    "use strict";
    var e = require_react();
    var t = { enabled: true };
    exports.usePagination = function(n, s, r = []) {
      const a = Object.assign(Object.assign({}, t), s), u = e.useRef(null), [i, c] = e.useState({ loading: true, data: [], hasNext: false, hasPrev: false, next: () => {
      }, prev: () => {
      } });
      function o() {
        c((e2) => Object.assign(Object.assign({}, e2), { loading: true, hasNext: false, hasPrev: false }));
      }
      return e.useEffect(() => {
        o();
        const { enabled: e2 } = a;
        if (!e2)
          return;
        u.current = n.paginate(a);
        const t2 = u.current.observeState().subscribe((e3) => {
          c({ loading: false, data: e3.data, hasNext: e3.hasNext, hasPrev: e3.hasPrev, next: () => {
            var e4;
            o(), null === (e4 = u.current) || void 0 === e4 || e4.next();
          }, prev: () => {
            var e4;
            o(), null === (e4 = u.current) || void 0 === e4 || e4.prev();
          } });
        });
        return () => {
          const e3 = u.current;
          setTimeout(() => {
            null == e3 || e3.unsubscribe(), t2.unsubscribe();
          }, 0);
        };
      }, [JSON.stringify(r), JSON.stringify(a)]), i;
    };
  }
});

// node_modules/@squidcloud/react/dist/cjs/hooks/usePromise.js
var require_usePromise = __commonJS({
  "node_modules/@squidcloud/react/dist/cjs/hooks/usePromise.js"(exports) {
    "use client";
    "use strict";
    var e = require_react();
    var t = { enabled: true, initialData: null };
    exports.usePromise = function(n, a = {}, i = []) {
      const s = Object.assign(Object.assign({}, t), a), [r, l] = e.useState({ loading: true, data: s.initialData, error: null }), c = e.useMemo(() => n, [JSON.stringify(i), s.enabled]);
      return e.useEffect(() => {
        r.loading || l((e3) => Object.assign(Object.assign({}, e3), { loading: true }));
        const { enabled: e2 } = s;
        if (!e2)
          return;
        let t2 = true;
        return c().then((e3) => {
          t2 && l({ loading: false, data: e3, error: null });
        }).catch((e3) => {
          t2 && l((t3) => Object.assign(Object.assign({}, t3), { loading: false, error: e3 }));
        }), () => {
          t2 = false;
        };
      }, [c]), r;
    };
  }
});

// node_modules/@squidcloud/react/dist/cjs/index.js
var require_cjs3 = __commonJS({
  "node_modules/@squidcloud/react/dist/cjs/index.js"(exports) {
    var e = require_SquidContext();
    var r = require_index_2b00d0d6();
    var s = require_useAiChatbot();
    var u = require_useCollection();
    var o = require_useDoc();
    var i = require_useDocs();
    var t = require_useObservable();
    var q = require_usePagination();
    var x = require_usePromise();
    var n = require_useQuery();
    var h = require_useSquid();
    require_jsx_runtime(), require_cjs2(), require_react(), require_WithQueryClient(), require_index_82c10f9e(), require_cjs(), exports.SquidContext = e.SquidContext, exports.SquidContextProvider = e.SquidContextProvider, exports.DEFAULT_WITH_QUERY_OPTIONS = r.DEFAULT_WITH_QUERY_OPTIONS, exports.withServerQuery = r.withServerQuery, exports.useAiChatbot = s.useAiChatbot, exports.useAiQuery = s.useAiQuery, exports.useCollection = u.useCollection, exports.DEFAULT_DOC_OPTIONS = o.DEFAULT_DOC_OPTIONS, exports.useDoc = o.useDoc, exports.useDocs = i.useDocs, exports.useObservable = t.useObservable, exports.usePagination = q.usePagination, exports.usePromise = x.usePromise, exports.useQuery = n.useQuery, exports.useSquid = h.useSquid;
  }
});
export default require_cjs3();
/*! Bundled license information:

@squidcloud/client/dist/cjs/index.js:
  (**
  * @license
  * Lodash <https://lodash.com/>
  * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
  * Released under MIT license <https://lodash.com/license>
  * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
  * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
  *)
*/
//# sourceMappingURL=@squidcloud_react.js.map
